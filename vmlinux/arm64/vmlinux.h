#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef signed char __s8;

typedef unsigned char __u8;

typedef short int __s16;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __s8 s8;

typedef __u8 u8;

typedef __s16 s16;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef __u16 __be16;

typedef __u32 __le32;

typedef __u32 __be32;

typedef __u32 __wsum;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef s32 int32_t;

typedef u32 uint32_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u64 phys_addr_t;

typedef long unsigned int irq_hw_number_t;

typedef struct {
	int counter;
} atomic_t;

typedef struct {
	s64 counter;
} atomic64_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

typedef atomic64_t atomic_long_t;

typedef int (*initcall_t)();

typedef int initcall_entry_t;

struct lock_class_key {};

struct fs_context;

struct fs_parameter_spec;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key invalidate_lock_key;
	struct lock_class_key i_mutex_dir_key;
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

struct lockdep_map {};

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

typedef struct raw_spinlock raw_spinlock_t;

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, bool);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
};

struct static_call_key {
	void *func;
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_RUNNING = 2,
	SYSTEM_HALT = 3,
	SYSTEM_POWER_OFF = 4,
	SYSTEM_RESTART = 5,
	SYSTEM_SUSPEND = 6,
};

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	short unsigned int line;
	short unsigned int flags;
};

struct jump_entry {
	s32 code;
	s32 target;
	long int key;
};

struct static_key_mod;

struct static_key {
	atomic_t enabled;
	union {
		long unsigned int type;
		struct jump_entry *entries;
		struct static_key_mod *next;
	};
};

struct static_key_false {
	struct static_key key;
};

struct cpumask {
	long unsigned int bits[1];
};

typedef struct cpumask cpumask_t;

typedef struct cpumask cpumask_var_t[1];

struct llist_node;

struct llist_head {
	struct llist_node *first;
};

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct restart_block {
	long unsigned int arch_data;
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct thread_info {
	long unsigned int flags;
	u64 ttbr0;
	union {
		u64 preempt_count;
		struct {
			u32 count;
			u32 need_resched;
		} preempt;
	};
};

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	struct util_est util_est;
};

struct cfs_rq;

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	long unsigned int runnable_weight;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
};

struct rt_rq;

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
	struct sched_rt_entity *parent;
	struct rt_rq *rt_rq;
	struct rt_rq *my_q;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct sched_dl_entity *pi_se;
};

struct sched_statistics {};

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct vmacache {
	u64 seqnum;
	struct vm_area_struct *vmas[4];
};

struct task_rss_stat {
	int events;
	int count[4];
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[1];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct syscall_user_dispatch {};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {};

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	raw_spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct tlbflush_unmap_batch {};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct kmap_ctrl {};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct cpu_context {
	long unsigned int x19;
	long unsigned int x20;
	long unsigned int x21;
	long unsigned int x22;
	long unsigned int x23;
	long unsigned int x24;
	long unsigned int x25;
	long unsigned int x26;
	long unsigned int x27;
	long unsigned int x28;
	long unsigned int fp;
	long unsigned int sp;
	long unsigned int pc;
};

struct user_fpsimd_state {
	__int128 unsigned vregs[32];
	__u32 fpsr;
	__u32 fpcr;
	__u32 __reserved[2];
};

struct perf_event;

struct debug_info {
	int suspended_step;
	int bps_disabled;
	int wps_disabled;
	struct perf_event *hbp_break[16];
	struct perf_event *hbp_watch[16];
};

struct ptrauth_key {
	long unsigned int lo;
	long unsigned int hi;
};

struct ptrauth_keys_user {
	struct ptrauth_key apia;
	struct ptrauth_key apib;
	struct ptrauth_key apda;
	struct ptrauth_key apdb;
	struct ptrauth_key apga;
};

struct ptrauth_keys_kernel {
	struct ptrauth_key apia;
};

struct thread_struct {
	struct cpu_context cpu_context;
	long: 64;
	struct {
		long unsigned int tp_value;
		long unsigned int tp2_value;
		struct user_fpsimd_state fpsimd_state;
	} uw;
	unsigned int fpsimd_cpu;
	void *sve_state;
	unsigned int sve_vl;
	unsigned int sve_vl_onexec;
	long unsigned int fault_address;
	long unsigned int fault_code;
	struct debug_info debug;
	struct ptrauth_keys_user keys_user;
	struct ptrauth_keys_kernel keys_kernel;
	u64 sctlr_user;
};

struct sched_class;

struct task_group;

struct rcu_node;

struct mm_struct;

struct pid;

struct completion;

struct cred;

struct key;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct futex_pi_state;

struct perf_event_context;

struct mempolicy;

struct numa_group;

struct mem_cgroup;

struct request_queue;

struct vm_struct;

struct bpf_local_storage;

struct bpf_run_ctx;

struct task_struct {
	struct thread_info thread_info;
	unsigned int __state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int cpu;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct sched_dl_entity dl;
	struct task_group *sched_task_group;
	long: 64;
	long: 64;
	struct sched_statistics stats;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t *user_cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	short unsigned int migration_disabled;
	short unsigned int migration_flags;
	int rcu_read_lock_nesting;
	union rcu_special rcu_read_unlock_special;
	struct list_head rcu_node_entry;
	struct rcu_node *rcu_blocked_node;
	long unsigned int rcu_tasks_nvcsw;
	u8 rcu_tasks_holdout;
	u8 rcu_tasks_idx;
	int rcu_tasks_idle_cpu;
	struct list_head rcu_tasks_holdout_list;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	bool trc_reader_checked;
	struct list_head trc_holdout_list;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct vmacache vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	long: 29;
	unsigned int sched_remote_wakeup: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int in_user_fault: 1;
	unsigned int in_lru_fault: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	unsigned int in_eventfd: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	void *pf_io_worker;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	nodemask_t mems_allowed;
	seqcount_spinlock_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	int cpuset_slab_spread_rotor;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short int il_prev;
	short int pref_node_fork;
	int numa_scan_seq;
	unsigned int numa_scan_period;
	unsigned int numa_scan_period_max;
	int numa_preferred_nid;
	long unsigned int numa_migrate_retry;
	u64 node_stamp;
	u64 last_task_numa_placement;
	u64 last_sum_exec_runtime;
	struct callback_head numa_work;
	struct numa_group *numa_group;
	long unsigned int *numa_faults;
	long unsigned int total_numa_faults;
	long unsigned int numa_faults_locality[3];
	long unsigned int numa_pages_migrated;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct request_queue *throttle_queue;
	struct kmap_ctrl kmap_ctrl;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct timer_list oom_reaper_timer;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	struct bpf_local_storage *bpf_storage;
	struct bpf_run_ctx *bpf_ctx;
	struct llist_head kretprobe_instances;
	struct thread_struct thread;
	long: 64;
	long: 64;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

typedef struct {
	uid_t val;
} kuid_t;

typedef struct {
	gid_t val;
} kgid_t;

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct ctl_table;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct ucounts;

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	long int ucount_max[16];
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
};

typedef u64 pteval_t;

typedef u64 pmdval_t;

typedef u64 pudval_t;

typedef u64 pgdval_t;

typedef struct {
	pteval_t pte;
} pte_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

typedef struct {
	pteval_t pgprot;
} pgprot_t;

typedef struct page *pgtable_t;

struct address_space;

struct page_pool;

struct kmem_cache;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			long unsigned int pp_magic;
			struct page_pool *pp;
			long unsigned int _pp_mapping_pad;
			long unsigned int dma_addr;
			union {
				long unsigned int dma_addr_upper;
				atomic_long_t pp_frag_count;
			};
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page *next;
					int pages;
					int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
			unsigned int compound_nr;
		};
		struct {
			long unsigned int _compound_pad_1;
			atomic_t hpage_pinned_refcount;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
	long unsigned int memcg_data;
};

struct vm_userfaultfd_ctx {};

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct *vm_next;
	struct vm_area_struct *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct user_pt_regs {
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
};

struct pt_regs {
	union {
		struct user_pt_regs user_regs;
		struct {
			u64 regs[31];
			u64 sp;
			u64 pc;
			u64 pstate;
		};
	};
	u64 orig_x0;
	s32 syscallno;
	u32 unused2;
	u64 sdei_ttbr1;
	u64 pmr_save;
	u64 stackframe[2];
	u64 lockdep_hardirqs;
	u64 exit_rcu;
};

struct arch_hw_breakpoint_ctrl {
	u32 __reserved: 19;
	u32 len: 8;
	u32 type: 2;
	u32 privilege: 2;
	u32 enabled: 1;
};

struct arch_hw_breakpoint {
	u64 address;
	u64 trigger;
	struct arch_hw_breakpoint_ctrl ctrl;
};

typedef struct {
	u64 key[2];
} siphash_key_t;

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 build_id: 1;
	__u64 inherit_thread: 1;
	__u64 remove_on_exec: 1;
	__u64 sigtrap: 1;
	__u64 __reserved_1: 26;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
	__u64 sig_data;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct list_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct pmu;

struct perf_buffer;

struct fasync_struct;

struct perf_addr_filter_range;

struct pid_namespace;

struct bpf_prog;

struct trace_event_call;

struct event_filter;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	unsigned int pending_wakeup;
	unsigned int pending_kill;
	unsigned int pending_disable;
	unsigned int pending_sigtrap;
	long unsigned int pending_addr;
	struct irq_work pending_irq;
	struct callback_head pending_task;
	unsigned int pending_work;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	u64 bpf_cookie;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct list_head sb_list;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

typedef struct {
	atomic64_t id;
	refcount_t pinned;
	void *vdso;
	long unsigned int flags;
} mm_context_t;

struct uprobes_state {};

struct linux_binfmt;

struct core_state;

struct kioctx_table;

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct vm_area_struct *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[46];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		struct core_state *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct *owner;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		long unsigned int numa_next_scan;
		long unsigned int numa_scan_offset;
		int numa_scan_seq;
		atomic_t tlb_flush_pending;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		u32 pasid;
		struct {
			struct list_head list;
			long unsigned int bitmap;
			struct mem_cgroup *memcg;
		} lru_gen;
	};
	long unsigned int cpu_bitmap[0];
};

struct workqueue_struct;

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	struct rw_semaphore invalidate_lock;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct device;

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct pp_alloc_cache {
	u32 count;
	struct page *cache[128];
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	unsigned int frag_offset;
	struct page *frag_page;
	long int frag_users;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct vmem_altmap {
	long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_FS_DAX = 2,
	MEMORY_DEVICE_GENERIC = 3,
	MEMORY_DEVICE_PCI_P2PDMA = 4,
};

struct range {
	u64 start;
	u64 end;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct range ranges[0];
	};
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	struct file_ra_state f_ra;
	u64 f_version;
	void *private_data;
	struct hlist_head *f_ep;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	long unsigned int num_children;
	long unsigned int num_active_vmas;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct mempolicy {
	atomic_t refcnt;
	short unsigned int mode;
	short unsigned int flags;
	nodemask_t nodes;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct cgroup;

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct page_counter {
	atomic_long_t usage;
	long unsigned int min;
	long unsigned int low;
	long unsigned int high;
	long unsigned int max;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int failcnt;
	struct page_counter *parent;
};

struct vmpressure {
	long unsigned int scanned;
	long unsigned int reclaimed;
	long unsigned int tree_scanned;
	long unsigned int tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct kernfs_node;

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct mem_cgroup_threshold_ary;

struct mem_cgroup_thresholds {
	struct mem_cgroup_threshold_ary *primary;
	struct mem_cgroup_threshold_ary *spare;
};

struct memcg_padding {
	char x[0];
};

struct memcg_vmstats {
	long int state[42];
	long unsigned int events[99];
	long int state_pending[42];
	long unsigned int events_pending[99];
};

enum memcg_kmem_state {
	KMEM_NONE = 0,
	KMEM_ALLOCATED = 1,
	KMEM_ONLINE = 2,
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct memcg_cgwb_frn {
	u64 bdi_id;
	int memcg_id;
	u64 at;
	struct wb_completion done;
};

struct deferred_split {
	spinlock_t split_queue_lock;
	struct list_head split_queue;
	long unsigned int split_queue_len;
};

struct lru_gen_mm_list {
	struct list_head fifo;
	spinlock_t lock;
};

struct obj_cgroup;

struct memcg_vmstats_percpu;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	struct page_counter memory;
	union {
		struct page_counter swap;
		struct page_counter memsw;
	};
	struct page_counter kmem;
	struct page_counter tcpmem;
	struct work_struct high_work;
	long unsigned int soft_limit;
	struct vmpressure vmpressure;
	bool oom_group;
	bool oom_lock;
	int under_oom;
	int swappiness;
	int oom_kill_disable;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct mutex thresholds_lock;
	struct mem_cgroup_thresholds thresholds;
	struct mem_cgroup_thresholds memsw_thresholds;
	struct list_head oom_notify;
	long unsigned int move_charge_at_immigrate;
	spinlock_t move_lock;
	long unsigned int move_lock_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct memcg_padding _pad1_;
	struct memcg_vmstats vmstats;
	atomic_long_t memory_events[8];
	atomic_long_t memory_events_local[8];
	long unsigned int socket_pressure;
	bool tcpmem_active;
	int tcpmem_pressure;
	int kmemcg_id;
	enum memcg_kmem_state kmem_state;
	struct obj_cgroup *objcg;
	struct list_head objcg_list;
	struct memcg_padding _pad2_;
	atomic_t moving_account;
	struct task_struct *move_lock_task;
	struct memcg_vmstats_percpu *vmstats_percpu;
	struct list_head cgwb_list;
	struct wb_domain cgwb_domain;
	struct memcg_cgwb_frn cgwb_frn[4];
	struct list_head event_list;
	spinlock_t event_list_lock;
	struct deferred_split deferred_split_queue;
	struct lru_gen_mm_list mm_list;
	struct mem_cgroup_per_node *nodeinfo[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

enum fault_flag {
	FAULT_FLAG_WRITE = 1,
	FAULT_FLAG_MKWRITE = 2,
	FAULT_FLAG_ALLOW_RETRY = 4,
	FAULT_FLAG_RETRY_NOWAIT = 8,
	FAULT_FLAG_KILLABLE = 16,
	FAULT_FLAG_TRIED = 32,
	FAULT_FLAG_USER = 64,
	FAULT_FLAG_REMOTE = 128,
	FAULT_FLAG_INSTRUCTION = 256,
	FAULT_FLAG_INTERRUPTIBLE = 512,
};

struct vm_fault {
	const struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		long unsigned int pgoff;
		long unsigned int address;
	};
	enum fault_flag flags;
	pmd_t *pmd;
	pud_t *pud;
	union {
		pte_t orig_pte;
		pmd_t orig_pmd;
	};
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

struct hlist_nulls_node;

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

struct free_area {
	struct list_head free_list[6];
	long unsigned int nr_free;
};

struct zone_padding {
	char x[0];
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_KERNEL_MISC_RECLAIMABLE = 33,
	NR_FOLL_PIN_ACQUIRED = 34,
	NR_FOLL_PIN_RELEASED = 35,
	NR_KERNEL_STACK_KB = 36,
	NR_PAGETABLE = 37,
	NR_SWAPCACHE = 38,
	NR_VM_NODE_STAT_ITEMS = 39,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

struct lru_gen_page {
	long unsigned int max_seq;
	long unsigned int min_seq[2];
	long unsigned int timestamps[4];
	struct list_head pages[32];
	long int nr_pages[32];
	long unsigned int avg_refaulted[8];
	long unsigned int avg_total[8];
	long unsigned int protected[6];
	atomic_long_t evicted[8];
	atomic_long_t refaulted[8];
	bool enabled;
	u8 gen;
	u8 seg;
	struct hlist_nulls_node list;
};

struct lru_gen_mm_state {
	long unsigned int seq;
	struct list_head *head;
	struct list_head *tail;
	struct wait_queue_head wait;
	long unsigned int *filters[2];
	long unsigned int stats[6];
	int nr_walkers;
};

struct lruvec;

struct lru_gen_mm_walk {
	struct lruvec *lruvec;
	long unsigned int max_seq;
	long unsigned int next_addr;
	int nr_pages[32];
	int mm_stats[6];
	int batched;
	bool can_swap;
	bool force_scan;
};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
	struct lru_gen_page lrugen;
	struct lru_gen_mm_state mm_state;
	struct pglist_data *pgdat;
};

struct lru_gen_memcg {
	long unsigned int seq;
	long unsigned int nr_memcgs[2];
	struct hlist_nulls_head fifo[16];
	spinlock_t lock;
};

struct per_cpu_pages;

struct per_cpu_zonestat;

struct zone {
	long unsigned int _watermark[3];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[4];
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pages *per_cpu_pageset;
	struct per_cpu_zonestat *per_cpu_zonestats;
	int pageset_high;
	int pageset_batch;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	long unsigned int cma_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	int initialized;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	struct free_area free_area[11];
	long unsigned int flags;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	long: 0;
	struct zone_padding _pad3_;
	atomic_long_t vm_stat[10];
	atomic_long_t vm_numa_event[6];
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[17];
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	__MAX_NR_ZONES = 4,
};

struct per_cpu_nodestat;

struct pglist_data {
	struct zone node_zones[4];
	struct zonelist node_zonelists[2];
	int nr_zones;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
	long unsigned int totalreserve_pages;
	long unsigned int min_unmapped_pages;
	long unsigned int min_slab_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	struct deferred_split deferred_split_queue;
	struct lruvec __lruvec;
	long unsigned int flags;
	struct lru_gen_mm_walk mm_walk;
	struct lru_gen_memcg memcg_lru;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[39];
};

typedef unsigned int isolate_mode_t;

struct per_cpu_pages {
	int count;
	int high;
	int batch;
	short int free_factor;
	short int expire;
	struct list_head lists[15];
};

struct per_cpu_zonestat {
	s8 vm_stat_diff[10];
	s8 stat_threshold;
	long unsigned int vm_numa_event[6];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[39];
};

typedef struct pglist_data pg_data_t;

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	long int seglen[4];
	u8 flags;
};

struct srcu_node;

struct srcu_struct;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node node[5];
	struct srcu_node *level[3];
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_last_gp_end;
	struct srcu_data *sda;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	struct delayed_work work;
	struct lockdep_map dep_map;
};

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct user_struct;

struct group_info;

struct cred {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

typedef struct elf64_sym Elf64_Sym;

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct posix_acl;

struct inode_operations;

struct bdi_writeback;

struct file_lock_context;

struct cdev;

struct fsnotify_mark_connector;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	long: 64;
	long: 64;
	long: 64;
};

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct shrink_control;

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct block_device;

struct mtd_info;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	const struct xattr_handler **s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_connectors;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
	struct user_namespace *mnt_userns;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one *lru[0];
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	struct list_lru_memcg *memcg_lrus;
	long int nr_items;
	long: 64;
	long: 64;
};

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct fs_pin;

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t *__sigrestore_t;

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			int _trapno;
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
			struct {
				long unsigned int _data;
				__u32 _type;
				__u32 _flags;
			} _perf;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	atomic_t count;
	atomic_long_t ucount[16];
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct rhash_head {
	struct rhash_head *next;
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct pacct_struct {
	int ac_flag;
	long int ac_exitcode;
	long unsigned int ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	long unsigned int ac_minflt;
	long unsigned int ac_majflt;
};

struct tty_struct;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct rq;

struct rq_flags;

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int);
	struct task_struct * (*pick_task)(struct rq *);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *, u32);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *, int);
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct blk_plug {
	struct list_head mq_list;
	struct list_head cb_list;
	short unsigned int rq_count;
	bool multiple_queues;
	bool nowait;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
	struct lru_gen_mm_walk *mm_walk;
};

struct kref {
	refcount_t refcount;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	atomic_t writeback_inodes;
	struct percpu_counter stat[4];
	long unsigned int congested;
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	struct delayed_work bw_dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
	struct percpu_ref refcnt;
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css;
	struct cgroup_subsys_state *blkcg_css;
	struct list_head memcg_node;
	struct list_head blkcg_node;
	struct list_head b_attached;
	struct list_head offline_node;
	union {
		struct work_struct release_work;
		struct callback_head rcu;
	};
};

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	struct bdi_writeback wb;
	struct list_head wb_list;
	struct xarray cgwb_tree;
	struct mutex cgwb_release_mutex;
	struct rw_semaphore wb_switch_rwsem;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	atomic_t nr_tasks;
	spinlock_t lock;
	short unsigned int ioprio;
	struct xarray icq_tree;
	struct io_cq *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

struct css_set {
	struct cgroup_subsys_state *subsys[7];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[7];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_src_preload_node;
	struct list_head mg_dst_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	void *task_ctx_data;
	struct callback_head callback_head;
	local_t nr_pending;
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	bool poll_usage;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct kset;

struct kobj_type;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

enum rpm_status {
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	bool round_robin;
	struct sbitmap_word *map;
	unsigned int *alloc_hint;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	unsigned int min_shallow_depth;
};

enum blk_bounce {
	BLK_BOUNCE_NONE = 0,
	BLK_BOUNCE_HIGH = 1,
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	enum blk_bounce bounce;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_write_same_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int zone_write_granularity;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_alloc_cache;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	struct bio_alloc_cache *cache;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	mempool_t bio_integrity_pool;
	mempool_t bvec_integrity_pool;
	unsigned int back_pad;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
	struct hlist_node cpuhp_dead;
};

struct request;

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct gendisk;

struct blk_stat_callback;

struct blkcg_gq;

struct blk_flush_queue;

struct throtl_data;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int queue_depth;
	struct blk_mq_hw_ctx **queue_hw_ctx;
	unsigned int nr_hw_queues;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	spinlock_t queue_lock;
	struct gendisk *disk;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct blk_integrity integrity;
	struct device *dev;
	enum rpm_status rpm_status;
	long unsigned int nr_requests;
	unsigned int dma_pad_mask;
	unsigned int dma_alignment;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	struct blk_rq_stat poll_stat[16];
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_sbitmap;
	struct sbitmap_queue sched_bitmap_tags;
	struct sbitmap_queue sched_breserved_tags;
	struct list_head icq_list;
	long unsigned int blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	int node;
	struct mutex debugfs_mutex;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct throtl_data *td;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct bio_set bio_split;
	struct dentry *debugfs_dir;
	bool mq_sysfs_init_done;
	size_t cmd_size;
	u64 write_hints[5];
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct bpf_run_ctx {};

struct exception_table_entry {
	int insn;
	int fixup;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct psi_group {};

struct bpf_prog_array;

struct cgroup_bpf {
	struct bpf_prog_array *effective[23];
	struct list_head progs[23];
	u32 flags[23];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[7];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[7];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	u64 ancestor_ids[0];
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct user_struct {
	refcount_t __count;
	struct percpu_counter epoll_watches;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	union {
		unsigned int ki_cookie;
		struct wait_page_queue *ki_waitq;
	};
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct mod_plt_sec {
	int plt_shndx;
	int plt_num_entries;
	int plt_max_entries;
};

struct plt_entry;

struct mod_arch_specific {
	struct mod_plt_sec core;
	struct mod_plt_sec init;
	struct plt_entry *ftrace_trampolines;
};

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

typedef const int tracepoint_ptr_t;

struct module_attribute;

struct kernel_param;

struct module_sect_attrs;

struct module_notes_attrs;

struct bpf_raw_event_map;

struct trace_eval_map;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool async_probe_requested;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	void *btf_data;
	struct jump_entry *jump_entries;
	unsigned int num_jump_entries;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct wait_page_queue {
	struct page *page;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct writeback_control;

struct readahead_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*readpage)(struct file *, struct page *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	int (*set_page_dirty)(struct page *);
	int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidatepage)(struct page *, unsigned int, unsigned int);
	int (*releasepage)(struct page *, gfp_t);
	void (*freepage)(struct page *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
	bool (*isolate_page)(struct page *, isolate_mode_t);
	void (*putback_page)(struct page *);
	int (*launder_page)(struct page *);
	int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
	struct bdi_writeback *wb;
	struct inode *inode;
	int wb_id;
	int wb_lcand_id;
	int wb_tcand_id;
	size_t wb_bytes;
	size_t wb_lcand_bytes;
	size_t wb_tcand_bytes;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	struct file_ra_state *ra;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
};

struct iovec;

struct kvec;

struct bio_vec;

struct iov_iter {
	u8 iter_type;
	bool nofault;
	bool data_source;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct xarray *xarray;
		struct pipe_inode_info *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
		loff_t xarray_start;
	};
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	struct percpu_ref users;
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int *cluster_next_cpu;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	struct completion comp;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct fiemap_extent_info;

struct fileattr;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct user_namespace *, struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int, bool);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct user_namespace *, struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct user_namespace *, struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct user_namespace *, struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct user_namespace *, struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct user_namespace *, struct dentry *, struct iattr *);
	int (*getattr)(struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct user_namespace *, struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int);
	int (*fileattr_set)(struct user_namespace *, struct dentry *, struct fileattr *);
	int (*fileattr_get)(struct dentry *, struct fileattr *);
	long: 64;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
};

struct lock_manager_operations {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
};

struct fid;

struct iomap;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	u64 (*fetch_iversion)(struct inode *);
	long unsigned int flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct user_namespace *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int needs_force_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct dev_archdata {};

enum device_removable {
	DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
	DEVICE_REMOVABLE_UNKNOWN = 1,
	DEVICE_FIXED = 2,
	DEVICE_REMOVABLE = 3,
};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct irq_domain;

struct dma_map_ops;

struct bus_dma_region;

struct device_dma_parameters;

struct dma_coherent_mem;

struct cma;

struct io_tlb_mem;

struct device_node;

struct fwnode_handle;

struct class;

struct attribute_group;

struct iommu_group;

struct dev_iommu;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct irq_domain *msi_domain;
	raw_spinlock_t msi_lock;
	struct list_head msi_list;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dma_coherent_mem *dma_mem;
	struct cma *cma_area;
	struct io_tlb_mem *dma_io_tlb_mem;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	enum device_removable removable;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool can_match: 1;
	bool dma_coherent: 1;
};

struct disk_stats;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	struct disk_stats *bd_stats;
	long unsigned int bd_stamp;
	bool bd_read_only;
	dev_t bd_dev;
	int bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	void *bd_claiming;
	struct device bd_device;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct kobject *bd_holder_dir;
	u8 bd_partno;
	spinlock_t bd_size_lock;
	struct gendisk *bd_disk;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct super_block *bd_fsfreeze_sb;
	struct partition_meta_info *bd_meta_info;
};

typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

struct seq_operations;

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
};

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
};

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bio_integrity_payload;

struct bio {
	struct bio *bi_next;
	struct block_device *bi_bdev;
	unsigned int bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	short unsigned int bi_write_hint;
	blk_status_t bi_status;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	union {
		struct bio_integrity_payload *bi_integrity;
	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
	long unsigned int rev;
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	u64 id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	struct address_space * (*f_mapping)();
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kset *, struct kobject *);
	const char * (* const name)(struct kset *, struct kobject *);
	int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct plt_entry {
	__le32 adrp;
	__le32 add;
	__le32 br;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	union {
		void *module;
		atomic_t refcnt;
	};
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct core_vma_metadata;

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	loff_t written;
	loff_t pos;
	loff_t to_skip;
	int vma_count;
	size_t vma_data_size;
	struct core_vma_metadata *vma_meta;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	unsigned int clock_op_might_sleep;
	struct mutex clock_mutex;
	struct list_head clock_list;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	void (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_INTR_REMAP = 1,
	IOMMU_CAP_NOEXEC = 2,
};

typedef u64 dma_addr_t;

enum iommu_dev_features {
	IOMMU_DEV_FEAT_AUX = 0,
	IOMMU_DEV_FEAT_SVA = 1,
	IOMMU_DEV_FEAT_IOPF = 2,
};

struct iommu_domain;

struct iommu_iotlb_gather;

struct iommu_device;

struct iommu_resv_region;

struct of_phandle_args;

struct iommu_sva;

struct iommu_fault_event;

struct iommu_page_response;

struct iommu_cache_invalidate_info;

struct iommu_gpasid_bind_data;

struct iommu_ops {
	bool (*capable)(enum iommu_cap);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	void (*domain_free)(struct iommu_domain *);
	int (*attach_dev)(struct iommu_domain *, struct device *);
	void (*detach_dev)(struct iommu_domain *, struct device *);
	int (*map)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	int (*map_pages)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap)(struct iommu_domain *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	size_t (*unmap_pages)(struct iommu_domain *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	void (*iotlb_sync_map)(struct iommu_domain *, long unsigned int, size_t);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	int (*enable_nesting)(struct iommu_domain *);
	int (*set_pgtable_quirks)(struct iommu_domain *, long unsigned int);
	void (*get_resv_regions)(struct device *, struct list_head *);
	void (*put_resv_regions)(struct device *, struct list_head *);
	void (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *);
	int (*of_xlate)(struct device *, struct of_phandle_args *);
	bool (*is_attach_deferred)(struct iommu_domain *, struct device *);
	bool (*dev_has_feat)(struct device *, enum iommu_dev_features);
	bool (*dev_feat_enabled)(struct device *, enum iommu_dev_features);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	int (*aux_attach_dev)(struct iommu_domain *, struct device *);
	void (*aux_detach_dev)(struct iommu_domain *, struct device *);
	int (*aux_get_pasid)(struct iommu_domain *, struct device *);
	struct iommu_sva * (*sva_bind)(struct device *, struct mm_struct *, void *);
	void (*sva_unbind)(struct iommu_sva *);
	u32 (*sva_get_pasid)(struct iommu_sva *);
	int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);
	int (*cache_invalidate)(struct iommu_domain *, struct device *, struct iommu_cache_invalidate_info *);
	int (*sva_bind_gpasid)(struct iommu_domain *, struct device *, struct iommu_gpasid_bind_data *);
	int (*sva_unbind_gpasid)(struct device *, u32);
	int (*def_domain_type)(struct device *);
	long unsigned int pgsize_bitmap;
	struct module *owner;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[9];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	long unsigned int segment_boundary_mask;
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
};

struct irq_domain_ops;

struct irq_domain_chip_generic;

struct irq_data;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_mutex;
	struct irq_data *revmap[0];
};

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	struct sg_table * (*alloc_noncontiguous)(struct device *, size_t, enum dma_data_direction, gfp_t, long unsigned int);
	void (*free_noncontiguous)(struct device *, size_t, struct sg_table *, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	struct kobject kobj;
	long unsigned int _flags;
	void *data;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_DEMOTION_DEAD = 14,
	CPUHP_MM_VMSTAT_DEAD = 15,
	CPUHP_SOFTIRQ_DEAD = 16,
	CPUHP_NET_MVNETA_DEAD = 17,
	CPUHP_CPUIDLE_DEAD = 18,
	CPUHP_ARM64_FPSIMD_DEAD = 19,
	CPUHP_ARM_OMAP_WAKE_DEAD = 20,
	CPUHP_IRQ_POLL_DEAD = 21,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 22,
	CPUHP_BIO_DEAD = 23,
	CPUHP_ACPI_CPUDRV_DEAD = 24,
	CPUHP_S390_PFAULT_DEAD = 25,
	CPUHP_BLK_MQ_DEAD = 26,
	CPUHP_FS_BUFF_DEAD = 27,
	CPUHP_PRINTK_DEAD = 28,
	CPUHP_MM_MEMCQ_DEAD = 29,
	CPUHP_XFS_DEAD = 30,
	CPUHP_PERCPU_CNT_DEAD = 31,
	CPUHP_RADIX_DEAD = 32,
	CPUHP_PAGE_ALLOC = 33,
	CPUHP_NET_DEV_DEAD = 34,
	CPUHP_PCI_XGENE_DEAD = 35,
	CPUHP_IOMMU_IOVA_DEAD = 36,
	CPUHP_LUSTRE_CFS_DEAD = 37,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 38,
	CPUHP_PADATA_DEAD = 39,
	CPUHP_RANDOM_PREPARE = 40,
	CPUHP_WORKQUEUE_PREP = 41,
	CPUHP_POWER_NUMA_PREPARE = 42,
	CPUHP_HRTIMERS_PREPARE = 43,
	CPUHP_PROFILE_PREPARE = 44,
	CPUHP_X2APIC_PREPARE = 45,
	CPUHP_SMPCFD_PREPARE = 46,
	CPUHP_RELAY_PREPARE = 47,
	CPUHP_SLAB_PREPARE = 48,
	CPUHP_MD_RAID5_PREPARE = 49,
	CPUHP_RCUTREE_PREP = 50,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 51,
	CPUHP_POWERPC_PMAC_PREPARE = 52,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 53,
	CPUHP_XEN_PREPARE = 54,
	CPUHP_XEN_EVTCHN_PREPARE = 55,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 56,
	CPUHP_SH_SH3X_PREPARE = 57,
	CPUHP_NET_FLOW_PREPARE = 58,
	CPUHP_TOPOLOGY_PREPARE = 59,
	CPUHP_NET_IUCV_PREPARE = 60,
	CPUHP_ARM_BL_PREPARE = 61,
	CPUHP_TRACE_RB_PREPARE = 62,
	CPUHP_MM_ZS_PREPARE = 63,
	CPUHP_MM_ZSWP_MEM_PREPARE = 64,
	CPUHP_MM_ZSWP_POOL_PREPARE = 65,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 66,
	CPUHP_ZCOMP_PREPARE = 67,
	CPUHP_TIMERS_PREPARE = 68,
	CPUHP_MIPS_SOC_PREPARE = 69,
	CPUHP_BP_PREPARE_DYN = 70,
	CPUHP_BP_PREPARE_DYN_END = 90,
	CPUHP_BRINGUP_CPU = 91,
	CPUHP_AP_IDLE_DEAD = 92,
	CPUHP_AP_OFFLINE = 93,
	CPUHP_AP_SCHED_STARTING = 94,
	CPUHP_AP_RCUTREE_DYING = 95,
	CPUHP_AP_CPU_PM_STARTING = 96,
	CPUHP_AP_IRQ_GIC_STARTING = 97,
	CPUHP_AP_IRQ_HIP04_STARTING = 98,
	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 99,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 100,
	CPUHP_AP_IRQ_BCM2836_STARTING = 101,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 102,
	CPUHP_AP_IRQ_RISCV_STARTING = 103,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 104,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 105,
	CPUHP_AP_MICROCODE_LOADER = 106,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 107,
	CPUHP_AP_PERF_X86_STARTING = 108,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 109,
	CPUHP_AP_PERF_X86_CQM_STARTING = 110,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 111,
	CPUHP_AP_PERF_XTENSA_STARTING = 112,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 113,
	CPUHP_AP_ARM_VFP_STARTING = 114,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 115,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 116,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 117,
	CPUHP_AP_PERF_ARM_STARTING = 118,
	CPUHP_AP_ARM_L2X0_STARTING = 119,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 120,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 121,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 122,
	CPUHP_AP_JCORE_TIMER_STARTING = 123,
	CPUHP_AP_ARM_TWD_STARTING = 124,
	CPUHP_AP_QCOM_TIMER_STARTING = 125,
	CPUHP_AP_TEGRA_TIMER_STARTING = 126,
	CPUHP_AP_ARMADA_TIMER_STARTING = 127,
	CPUHP_AP_MARCO_TIMER_STARTING = 128,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 129,
	CPUHP_AP_ARC_TIMER_STARTING = 130,
	CPUHP_AP_RISCV_TIMER_STARTING = 131,
	CPUHP_AP_CLINT_TIMER_STARTING = 132,
	CPUHP_AP_CSKY_TIMER_STARTING = 133,
	CPUHP_AP_TI_GP_TIMER_STARTING = 134,
	CPUHP_AP_HYPERV_TIMER_STARTING = 135,
	CPUHP_AP_KVM_STARTING = 136,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 137,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 138,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 139,
	CPUHP_AP_DUMMY_TIMER_STARTING = 140,
	CPUHP_AP_ARM_XEN_STARTING = 141,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 142,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 143,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 144,
	CPUHP_AP_SMPCFD_DYING = 145,
	CPUHP_AP_X86_TBOOT_DYING = 146,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 147,
	CPUHP_AP_ONLINE = 148,
	CPUHP_TEARDOWN_CPU = 149,
	CPUHP_AP_ONLINE_IDLE = 150,
	CPUHP_AP_SCHED_WAIT_EMPTY = 151,
	CPUHP_AP_SMPBOOT_THREADS = 152,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 153,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 154,
	CPUHP_AP_BLK_MQ_ONLINE = 155,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 156,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 157,
	CPUHP_AP_PERF_ONLINE = 158,
	CPUHP_AP_PERF_X86_ONLINE = 159,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 160,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 161,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 162,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 163,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 164,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 165,
	CPUHP_AP_PERF_X86_IDXD_ONLINE = 166,
	CPUHP_AP_PERF_S390_CF_ONLINE = 167,
	CPUHP_AP_PERF_S390_SF_ONLINE = 168,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 169,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 170,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 171,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 172,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 173,
	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 174,
	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 175,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 176,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 177,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 178,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 179,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 180,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 181,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 182,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 183,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 184,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 185,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 186,
	CPUHP_AP_PERF_CSKY_ONLINE = 187,
	CPUHP_AP_WATCHDOG_ONLINE = 188,
	CPUHP_AP_WORKQUEUE_ONLINE = 189,
	CPUHP_AP_RANDOM_ONLINE = 190,
	CPUHP_AP_RCUTREE_ONLINE = 191,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 192,
	CPUHP_AP_ONLINE_DYN = 193,
	CPUHP_AP_ONLINE_DYN_END = 223,
	CPUHP_AP_MM_DEMOTION_ONLINE = 224,
	CPUHP_AP_X86_HPET_ONLINE = 225,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 226,
	CPUHP_AP_DTPM_CPU_ONLINE = 227,
	CPUHP_AP_ACTIVE = 228,
	CPUHP_ONLINE = 229,
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGDEMOTE_KSWAPD = 27,
	PGDEMOTE_DIRECT = 28,
	PGSCAN_KSWAPD = 29,
	PGSCAN_DIRECT = 30,
	PGSCAN_DIRECT_THROTTLE = 31,
	PGSCAN_ANON = 32,
	PGSCAN_FILE = 33,
	PGSTEAL_ANON = 34,
	PGSTEAL_FILE = 35,
	PGSCAN_ZONE_RECLAIM_FAILED = 36,
	PGINODESTEAL = 37,
	SLABS_SCANNED = 38,
	KSWAPD_INODESTEAL = 39,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 40,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 41,
	PAGEOUTRUN = 42,
	PGROTATED = 43,
	DROP_PAGECACHE = 44,
	DROP_SLAB = 45,
	OOM_KILL = 46,
	NUMA_PTE_UPDATES = 47,
	NUMA_HUGE_PTE_UPDATES = 48,
	NUMA_HINT_FAULTS = 49,
	NUMA_HINT_FAULTS_LOCAL = 50,
	NUMA_PAGE_MIGRATE = 51,
	PGMIGRATE_SUCCESS = 52,
	PGMIGRATE_FAIL = 53,
	THP_MIGRATION_SUCCESS = 54,
	THP_MIGRATION_FAIL = 55,
	THP_MIGRATION_SPLIT = 56,
	COMPACTMIGRATE_SCANNED = 57,
	COMPACTFREE_SCANNED = 58,
	COMPACTISOLATED = 59,
	COMPACTSTALL = 60,
	COMPACTFAIL = 61,
	COMPACTSUCCESS = 62,
	KCOMPACTD_WAKE = 63,
	KCOMPACTD_MIGRATE_SCANNED = 64,
	KCOMPACTD_FREE_SCANNED = 65,
	HTLB_BUDDY_PGALLOC = 66,
	HTLB_BUDDY_PGALLOC_FAIL = 67,
	CMA_ALLOC_SUCCESS = 68,
	CMA_ALLOC_FAIL = 69,
	UNEVICTABLE_PGCULLED = 70,
	UNEVICTABLE_PGSCANNED = 71,
	UNEVICTABLE_PGRESCUED = 72,
	UNEVICTABLE_PGMLOCKED = 73,
	UNEVICTABLE_PGMUNLOCKED = 74,
	UNEVICTABLE_PGCLEARED = 75,
	UNEVICTABLE_PGSTRANDED = 76,
	THP_FAULT_ALLOC = 77,
	THP_FAULT_FALLBACK = 78,
	THP_FAULT_FALLBACK_CHARGE = 79,
	THP_COLLAPSE_ALLOC = 80,
	THP_COLLAPSE_ALLOC_FAILED = 81,
	THP_FILE_ALLOC = 82,
	THP_FILE_FALLBACK = 83,
	THP_FILE_FALLBACK_CHARGE = 84,
	THP_FILE_MAPPED = 85,
	THP_SPLIT_PAGE = 86,
	THP_SPLIT_PAGE_FAILED = 87,
	THP_DEFERRED_SPLIT_PAGE = 88,
	THP_SPLIT_PMD = 89,
	THP_ZERO_PAGE_ALLOC = 90,
	THP_ZERO_PAGE_ALLOC_FAILED = 91,
	THP_SWPOUT = 92,
	THP_SWPOUT_FALLBACK = 93,
	BALLOON_INFLATE = 94,
	BALLOON_DEFLATE = 95,
	BALLOON_MIGRATE = 96,
	SWAP_RA = 97,
	SWAP_RA_HIT = 98,
	NR_VM_EVENT_ITEMS = 99,
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	loff_t readpos;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	int full;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
	unsigned int ipi_offset;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqaction;

struct irq_affinity_notify;

struct proc_dir_entry;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_CGROUP = 1,
	KMALLOC_RECLAIM = 2,
	KMALLOC_DMA = 3,
	NR_KMALLOC_TYPES = 4,
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct msi_msg;

struct irq_chip {
	struct device *parent_device;
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_cpu_online)(struct irq_data *);
	void (*irq_cpu_offline)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
	PERF_COUNT_SW_MAX = 12,
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_blk: 3;
		__u64 mem_rsvd: 21;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 reserved: 40;
};

union perf_sample_weight {
	__u64 full;
	struct {
		__u32 var1_dw;
		__u16 var2_w;
		__u16 var3_w;
	};
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int *sock_inuse;
	struct prot_inuse *prot_inuse;
};

struct ipstats_mib;

struct tcp_mib;

struct linux_mib;

struct udp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct netns_mib {
	struct ipstats_mib *ip_statistics;
	struct ipstats_mib *ipv6_statistics;
	struct tcp_mib *tcp_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udp_stats_in6;
	struct udp_mib *udplite_statistics;
	struct udp_mib *udplite_stats_in6;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_unix {
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	atomic_t tw_count;
	char tw_pad[60];
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

struct ipv4_devconf;

struct ip_ra_chain;

struct fib_rules_ops;

struct fib_table;

struct inet_peer_base;

struct fqdir;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct inet_timewait_death_row tcp_death_row;
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	unsigned int fib_rules_require_fldissect;
	bool fib_has_custom_rules;
	bool fib_has_custom_local_routes;
	bool fib_offload_disabled;
	atomic_t fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	u8 sysctl_icmp_echo_ignore_all;
	u8 sysctl_icmp_echo_enable_probe;
	u8 sysctl_icmp_echo_ignore_broadcasts;
	u8 sysctl_icmp_ignore_bogus_error_responses;
	u8 sysctl_icmp_errors_use_inbound_ifaddr;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	struct local_ports ip_local_ports;
	u8 sysctl_tcp_ecn;
	u8 sysctl_tcp_ecn_fallback;
	u8 sysctl_ip_default_ttl;
	u8 sysctl_ip_no_pmtu_disc;
	u8 sysctl_ip_fwd_use_pmtu;
	u8 sysctl_ip_fwd_update_priority;
	u8 sysctl_ip_nonlocal_bind;
	u8 sysctl_ip_autobind_reuse;
	u8 sysctl_ip_dynaddr;
	u8 sysctl_ip_early_demux;
	u8 sysctl_raw_l3mdev_accept;
	u8 sysctl_tcp_early_demux;
	u8 sysctl_udp_early_demux;
	u8 sysctl_nexthop_compat_mode;
	u8 sysctl_fwmark_reflect;
	u8 sysctl_tcp_fwmark_accept;
	u8 sysctl_tcp_l3mdev_accept;
	u8 sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_intvl;
	u8 sysctl_tcp_keepalive_probes;
	u8 sysctl_tcp_syn_retries;
	u8 sysctl_tcp_synack_retries;
	u8 sysctl_tcp_syncookies;
	u8 sysctl_tcp_migrate_req;
	int sysctl_tcp_reordering;
	u8 sysctl_tcp_retries1;
	u8 sysctl_tcp_retries2;
	u8 sysctl_tcp_orphan_retries;
	u8 sysctl_tcp_tw_reuse;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	u8 sysctl_tcp_sack;
	u8 sysctl_tcp_window_scaling;
	u8 sysctl_tcp_timestamps;
	u8 sysctl_tcp_early_retrans;
	u8 sysctl_tcp_recovery;
	u8 sysctl_tcp_thin_linear_timeouts;
	u8 sysctl_tcp_slow_start_after_idle;
	u8 sysctl_tcp_retrans_collapse;
	u8 sysctl_tcp_stdurg;
	u8 sysctl_tcp_rfc1337;
	u8 sysctl_tcp_abort_on_overflow;
	u8 sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_adv_win_scale;
	u8 sysctl_tcp_dsack;
	u8 sysctl_tcp_app_win;
	u8 sysctl_tcp_frto;
	u8 sysctl_tcp_nometrics_save;
	u8 sysctl_tcp_no_ssthresh_metrics_save;
	u8 sysctl_tcp_moderate_rcvbuf;
	u8 sysctl_tcp_tso_win_divisor;
	u8 sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_rtt_wlen;
	u8 sysctl_tcp_min_tso_segs;
	u8 sysctl_tcp_autocorking;
	u8 sysctl_tcp_reflect_tos;
	u8 sysctl_tcp_comp_sack_nr;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	u8 sysctl_fib_notify_on_flag_change;
	u8 sysctl_udp_l3mdev_accept;
	u8 sysctl_igmp_llm_reports;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct list_head mr_tables;
	struct fib_rules_ops *mr_rules_ops;
	u32 sysctl_fib_multipath_hash_fields;
	u8 sysctl_fib_multipath_use_neigh;
	u8 sysctl_fib_multipath_hash_policy;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dst_entry;

struct net_device;

struct sk_buff;

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	u32 multipath_hash_fields;
	u8 multipath_hash_policy;
	u8 bindv6only;
	u8 flowlabel_consistency;
	u8 auto_flowlabels;
	int icmpv6_time;
	u8 icmpv6_echo_ignore_all;
	u8 icmpv6_echo_ignore_multicast;
	u8 icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	u8 anycast_src_echo_reply;
	u8 ip_nonlocal_bind;
	u8 fwmark_reflect;
	u8 flowlabel_state_ranges;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	u32 ioam6_id;
	u64 ioam6_id_wide;
	int skip_notify_on_dev_down;
	u8 fib_notify_on_flag_change;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct seg6_pernet_data;

struct ioam6_pernet_data;

struct netns_ipv6 {
	struct dst_ops ip6_dst_ops;
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	atomic_t ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned char flowlabel_has_excl;
	bool fib6_has_custom_rules;
	unsigned int fib6_rules_require_fldissect;
	unsigned int fib6_routes_require_src;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_policy_failed_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct list_head mr6_tables;
	struct fib_rules_ops *mr6_rules_ops;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	struct ioam6_pernet_data *ioam6_data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_logger *nf_loggers[13];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	struct nf_hook_entries *hooks_arp[3];
	struct nf_hook_entries *hooks_bridge[5];
	unsigned int defrag_ipv4_users;
	unsigned int defrag_ipv6_users;
};

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	u8 tcp_loose;
	u8 tcp_be_liberal;
	u8 tcp_max_retrans;
	u8 tcp_ignore_invalid_rst;
	unsigned int offload_timeout;
};

struct nf_udp_net {
	unsigned int timeouts[2];
	unsigned int offload_timeout;
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_gre_net {
	struct list_head keymap_list;
	unsigned int timeouts[2];
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
	struct nf_gre_net gre;
};

struct ct_pcpu;

struct ip_conntrack_stat;

struct nf_ct_event_notifier;

struct netns_ct {
	bool ecache_dwork_pending;
	u8 sysctl_log_invalid;
	u8 sysctl_events;
	u8 sysctl_acct;
	u8 sysctl_auto_assign_helper;
	u8 sysctl_tstamp;
	u8 sysctl_checksum;
	struct ct_pcpu *pcpu_lists;
	struct ip_conntrack_stat *stat;
	struct nf_ct_event_notifier *nf_conntrack_event_cb;
	struct nf_ip_net nf_ct_proto;
};

struct netns_nftables {
	u8 gencursor;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct netns_ipvs;

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_nf nf;
	struct netns_ct ct;
	struct netns_nftables nft;
	struct net_generic *gen;
	struct netns_bpf bpf;
	u64 net_cookie;
	struct netns_ipvs *ipvs;
	struct sock *diag_nlsk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct u64_stats_sync {};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
};

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	union {
		struct bpf_cgroup_storage *cgroup_storage[2];
		u64 bpf_cookie;
	};
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

typedef unsigned int sk_buff_data_t;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
		long unsigned int _sk_redir;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 pp_recycle: 1;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 gro_skip: 1;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	__u8 offload_fwd_mark: 1;
	__u8 offload_l3_fwd_mark: 1;
	__u8 tc_skip_classify: 1;
	__u8 tc_at_ingress: 1;
	__u8 redirected: 1;
	__u8 from_ingress: 1;
	__u8 slow_gro: 1;
	__u8 scm_io_uring: 1;
	__u16 tc_index;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup cgrp;
	u64 cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int online;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 addr;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 period;
	union perf_sample_weight weight;
	u64 txn;
	union perf_mem_data_src data_src;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	u64 aux_size;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	u64 cgroup;
	u64 data_page_size;
	u64 code_page_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	char *fmt;
	unsigned int fmt_size;
	long int wait_index;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_buffer;

struct trace_event_file;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	unsigned int trace_ctx;
	struct pt_regs *regs;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_DYNAMIC_BIT = 5,
	TRACE_EVENT_FL_KPROBE_BIT = 6,
	TRACE_EVENT_FL_UPROBE_BIT = 7,
	TRACE_EVENT_FL_EPROBE_BIT = 8,
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_DYNAMIC = 32,
	TRACE_EVENT_FL_KPROBE = 64,
	TRACE_EVENT_FL_UPROBE = 128,
	TRACE_EVENT_FL_EPROBE = 256,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
	ETT_EVENT_EPROBE = 64,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_PTR_STRING = 3,
	FILTER_TRACE_FN = 4,
	FILTER_COMM = 5,
	FILTER_CPU = 6,
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
	struct bin_attribute attr;
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct badblocks;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct xarray part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	int flags;
	long unsigned int state;
	struct mutex open_mutex;
	unsigned int open_partitions;
	struct backing_dev_info *bdi;
	struct kobject *slave_dir;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	struct kobject integrity_kobj;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
	u64 diskseq;
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	short unsigned int bip_vcnt;
	short unsigned int bip_max_vcnt;
	short unsigned int bip_flags;
	struct bvec_iter bio_iter;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	struct bio_vec bip_inline_vecs[0];
};

struct blkg_iostat {
	u64 bytes[3];
	u64 ios[3];
};

struct blkg_iostat_set {
	struct u64_stats_sync sync;
	struct blkg_iostat cur;
	struct blkg_iostat last;
};

struct blkcg;

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_iostat_set *iostat_cpu;
	struct blkg_iostat_set iostat;
	struct blkg_policy_data *pd[6];
	spinlock_t async_bio_lock;
	struct bio_list async_bios;
	struct work_struct async_bio_work;
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

typedef __u32 blk_mq_req_flags_t;

typedef unsigned int blk_qc_t;

struct blk_integrity_iter;

typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);

typedef void integrity_prepare_fn(struct request *);

typedef void integrity_complete_fn(struct request *, unsigned int);

struct blk_integrity_profile {
	integrity_processing_fn *generate_fn;
	integrity_processing_fn *verify_fn;
	integrity_prepare_fn *prepare_fn;
	integrity_complete_fn *complete_fn;
	const char *name;
};

struct blk_zone;

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	blk_qc_t (*submit_bio)(struct bio *);
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	struct module *owner;
	const struct pr_ops *pr_ops;
	int (*alternative_gpt_sector)(struct gendisk *, sector_t *);
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

struct sbitmap_word {
	long unsigned int depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef void rq_end_io_fn(struct request *, blk_status_t);

typedef __u32 req_flags_t;

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	unsigned int cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	struct list_head queuelist;
	union {
		struct hlist_node hash;
		struct llist_node ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
		int error_count;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	struct gendisk *rq_disk;
	struct block_device *part;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int nr_integrity_segments;
	short unsigned int write_hint;
	short unsigned int ioprio;
	enum mq_rq_state state;
	refcount_t ref;
	unsigned int timeout;
	long unsigned int deadline;
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_mq_tags;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	long unsigned int dispatched[7];
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	long unsigned int poll_considered;
	long unsigned int poll_invoked;
	long unsigned int poll_success;
	struct list_head hctx_list;
	struct srcu_struct srcu[0];
	long: 64;
	long: 64;
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct elevator_type;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	char icq_cache_name[22];
	struct list_head list;
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	int (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *, int);
	void (*set_rq_budget_token)(struct request *, int);
	int (*get_rq_budget_token)(struct request *);
	enum blk_eh_timer_return (*timeout)(struct request *, bool);
	int (*poll)(struct blk_mq_hw_ctx *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*initialize_rq_fn)(struct request *);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	int (*map_queues)(struct blk_mq_tag_set *);
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	atomic_t active_queues_shared_sbitmap;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct blk_mq_tags **tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
};

struct blk_integrity_iter {
	void *prot_buf;
	void *data_buf;
	sector_t seed;
	unsigned int data_size;
	short unsigned int interval;
	const char *disk_name;
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

enum blkg_iostat_type {
	BLKG_IOSTAT_READ = 0,
	BLKG_IOSTAT_WRITE = 1,
	BLKG_IOSTAT_DISCARD = 2,
	BLKG_IOSTAT_NR = 3,
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	refcount_t online_pin;
	struct xarray blkg_tree;
	struct blkcg_gq *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[6];
	struct list_head all_blkcgs_node;
	struct list_head cgwb_list;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
};

enum memcg_stat_item {
	MEMCG_SWAP = 39,
	MEMCG_SOCK = 40,
	MEMCG_PERCPU_B = 41,
	MEMCG_NR_STAT = 42,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_SWAP_HIGH = 5,
	MEMCG_SWAP_MAX = 6,
	MEMCG_SWAP_FAIL = 7,
	MEMCG_NR_MEMORY_EVENTS = 8,
};

enum mem_cgroup_events_target {
	MEM_CGROUP_TARGET_THRESH = 0,
	MEM_CGROUP_TARGET_SOFTLIMIT = 1,
	MEM_CGROUP_NTARGETS = 2,
};

struct memcg_vmstats_percpu {
	long int state[42];
	long unsigned int events[99];
	long int state_prev[42];
	long unsigned int events_prev[99];
	long unsigned int nr_page_events;
	long unsigned int targets[2];
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	unsigned int generation;
};

struct shrinker_info {
	struct callback_head rcu;
	atomic_long_t *nr_deferred;
	long unsigned int *map;
};

struct lruvec_stats_percpu {
	long int state[39];
	long int state_prev[39];
};

struct lruvec_stats {
	long int state[39];
	long int state_pending[39];
};

struct mem_cgroup_per_node {
	struct lruvec lruvec;
	struct lruvec_stats_percpu *lruvec_stats_percpu;
	struct lruvec_stats lruvec_stats;
	long unsigned int lru_zone_size[20];
	struct mem_cgroup_reclaim_iter iter;
	struct shrinker_info *shrinker_info;
	struct rb_node tree_node;
	long unsigned int usage_in_excess;
	bool on_tree;
	struct mem_cgroup *memcg;
};

struct eventfd_ctx;

struct mem_cgroup_threshold {
	struct eventfd_ctx *eventfd;
	long unsigned int threshold;
};

struct mem_cgroup_threshold_ary {
	int current_threshold;
	unsigned int size;
	struct mem_cgroup_threshold entries[0];
};

struct obj_cgroup {
	struct percpu_ref refcnt;
	struct mem_cgroup *memcg;
	atomic_t nr_charged_bytes;
	union {
		struct list_head list;
		struct callback_head rcu;
	};
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_MAX = 28,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	LINUX_MIB_TCPMIGRATEREQSUCCESS = 124,
	LINUX_MIB_TCPMIGRATEREQFAILURE = 125,
	__LINUX_MIB_MAX = 126,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	__LINUX_MIB_TLSMAX = 11,
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct linux_mib {
	long unsigned int mibs[126];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	long: 64;
	long: 64;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	u32 (*undo_cwnd)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	void *__pad1;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	atomic_t __refcnt;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO = 13,
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

typedef u8 u_int8_t;

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

enum tcp_conntrack {
	TCP_CONNTRACK_NONE = 0,
	TCP_CONNTRACK_SYN_SENT = 1,
	TCP_CONNTRACK_SYN_RECV = 2,
	TCP_CONNTRACK_ESTABLISHED = 3,
	TCP_CONNTRACK_FIN_WAIT = 4,
	TCP_CONNTRACK_CLOSE_WAIT = 5,
	TCP_CONNTRACK_LAST_ACK = 6,
	TCP_CONNTRACK_TIME_WAIT = 7,
	TCP_CONNTRACK_CLOSE = 8,
	TCP_CONNTRACK_LISTEN = 9,
	TCP_CONNTRACK_MAX = 10,
	TCP_CONNTRACK_IGNORE = 11,
	TCP_CONNTRACK_RETRANS = 12,
	TCP_CONNTRACK_UNACK = 13,
	TCP_CONNTRACK_TIMEOUT_MAX = 14,
};

enum udp_conntrack {
	UDP_CT_UNREPLIED = 0,
	UDP_CT_REPLIED = 1,
	UDP_CT_MAX = 2,
};

enum gre_conntrack {
	GRE_CT_UNREPLIED = 0,
	GRE_CT_REPLIED = 1,
	GRE_CT_MAX = 2,
};

struct ct_pcpu {
	spinlock_t lock;
	struct hlist_nulls_head unconfirmed;
	struct hlist_nulls_head dying;
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int clash_resolve;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
	unsigned int chaintoolong;
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

typedef __u32 Elf32_Word;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

typedef __u64 __be64;

typedef unsigned int slab_flags_t;

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct tty_driver;

struct tty_operations;

struct tty_ldisc;

struct tty_port;

struct tty_struct {
	int magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	long unsigned int flags;
	int count;
	struct winsize winsize;
	struct {
		spinlock_t lock;
		bool stopped;
		bool tco_stopped;
		long unsigned int unused[0];
	} flow;
	struct {
		spinlock_t lock;
		struct pid *pgrp;
		struct pid *session;
		unsigned char pktstatus;
		bool packet;
		long unsigned int unused[0];
	} ctrl;
	int hw_stopped;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {
	struct net *net;
} possible_net_t;

struct proto;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sk_buff_head {
	struct sk_buff *next;
	struct sk_buff *prev;
	__u32 qlen;
	spinlock_t lock;
};

typedef u64 netdev_features_t;

struct sock_cgroup_data {
	struct cgroup *cgroup;
};

struct sk_filter;

struct socket_wq;

struct socket;

struct sock_reuseport;

struct sock {
	struct sock_common __sk_common;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff *sk_rx_skb_cache;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	int sk_wait_pending;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct dst_entry *sk_rx_dst;
	int sk_rx_dst_ifindex;
	u32 sk_rx_dst_cookie;
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff *sk_tx_skb_cache;
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	netdev_features_t sk_route_nocaps;
	netdev_features_t sk_route_forced_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_padding: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	u8 sk_prefer_busy_poll;
	u16 sk_busy_poll_budget;
	spinlock_t sk_peer_lock;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	u16 sk_tsflags;
	int sk_bind_phc;
	u8 sk_shutdown;
	atomic_t sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	unsigned int (*write_room)(struct tty_struct *);
	unsigned int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_driver {
	int magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_ldisc_ops {
	char *name;
	int num;
	int flags;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t, void **, long unsigned int);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	int (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, const char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, const char *, int);
	struct module *owner;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

typedef struct {
	local64_t v;
} u64_stats_t;

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
	BPF_PROG_TYPE_SYSCALL = 31,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	BPF_SK_REUSEPORT_SELECT = 39,
	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
	BPF_PERF_EVENT = 41,
	__MAX_BPF_ATTACH_TYPE = 42,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
		__u64 fd_array;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
			struct {
				__u64 bpf_cookie;
			} perf_event;
		};
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct btf_type;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_verifier_env;

struct bpf_func_state;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	int (*map_redirect)(struct bpf_map *, u32, u64);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	int (*map_for_each_callback)(struct bpf_map *, void *, void *, u64);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	int timer_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	struct mem_cgroup *memcg;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	atomic64_t writecnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[56];
	bool kernel_btf;
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[128];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_kfunc_desc_tab;

struct bpf_prog_ops;

struct btf_mod_pair;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	struct bpf_kfunc_desc_tab *kfunc_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct btf_mod_pair *used_btfs;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct bpf_prog_stats;

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	u16 call_get_func_ip: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_stats *stats;
	int *active;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	struct sock_filter insns[0];
	struct bpf_insn insnsi[0];
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

struct net_device_stats {
	union {
		long unsigned int rx_packets;
		atomic_long_t __rx_packets;
	};
	union {
		long unsigned int tx_packets;
		atomic_long_t __tx_packets;
	};
	union {
		long unsigned int rx_bytes;
		atomic_long_t __rx_bytes;
	};
	union {
		long unsigned int tx_bytes;
		atomic_long_t __tx_bytes;
	};
	union {
		long unsigned int rx_errors;
		atomic_long_t __rx_errors;
	};
	union {
		long unsigned int tx_errors;
		atomic_long_t __tx_errors;
	};
	union {
		long unsigned int rx_dropped;
		atomic_long_t __rx_dropped;
	};
	union {
		long unsigned int tx_dropped;
		atomic_long_t __tx_dropped;
	};
	union {
		long unsigned int multicast;
		atomic_long_t __multicast;
	};
	union {
		long unsigned int collisions;
		atomic_long_t __collisions;
	};
	union {
		long unsigned int rx_length_errors;
		atomic_long_t __rx_length_errors;
	};
	union {
		long unsigned int rx_over_errors;
		atomic_long_t __rx_over_errors;
	};
	union {
		long unsigned int rx_crc_errors;
		atomic_long_t __rx_crc_errors;
	};
	union {
		long unsigned int rx_frame_errors;
		atomic_long_t __rx_frame_errors;
	};
	union {
		long unsigned int rx_fifo_errors;
		atomic_long_t __rx_fifo_errors;
	};
	union {
		long unsigned int rx_missed_errors;
		atomic_long_t __rx_missed_errors;
	};
	union {
		long unsigned int tx_aborted_errors;
		atomic_long_t __tx_aborted_errors;
	};
	union {
		long unsigned int tx_carrier_errors;
		atomic_long_t __tx_carrier_errors;
	};
	union {
		long unsigned int tx_fifo_errors;
		atomic_long_t __tx_fifo_errors;
	};
	union {
		long unsigned int tx_heartbeat_errors;
		atomic_long_t __tx_heartbeat_errors;
	};
	union {
		long unsigned int tx_window_errors;
		atomic_long_t __tx_window_errors;
	};
	union {
		long unsigned int rx_compressed;
		atomic_long_t __rx_compressed;
	};
	union {
		long unsigned int tx_compressed;
		atomic_long_t __tx_compressed;
	};
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
	struct rb_root tree;
};

struct wireless_dev;

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

struct pcpu_dstats;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct udp_tunnel_nic;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct ethtool_ops;

struct l3mdev_ops;

struct ndisc_ops;

struct header_ops;

struct vlan_info;

struct dsa_port;

struct in_device;

struct inet6_dev;

struct wpan_dev;

struct netdev_rx_queue;

struct mini_Qdisc;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct garp_port;

struct mrp_port;

struct rtnl_link_ops;

struct phy_device;

struct udp_tunnel_nic_info;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	unsigned int flags;
	unsigned int priv_flags;
	unsigned int extra_priv_flags;
	const struct net_device_ops *netdev_ops;
	int ifindex;
	short unsigned int gflags;
	short unsigned int hard_header_len;
	unsigned int mtu;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	int group;
	struct net_device_stats stats;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct ethtool_ops *ethtool_ops;
	const struct l3mdev_ops *l3mdev_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct header_ops *header_ops;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	short unsigned int padded;
	spinlock_t addr_list_lock;
	int irq;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	unsigned char local_addr_mask[32];
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct vlan_info *vlan_info;
	struct dsa_port *dsa_ptr;
	struct in_device *ip_ptr;
	struct inet6_dev *ip6_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	int napi_defer_hard_irqs;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct mini_Qdisc *miniq_ingress;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	long: 64;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct xps_dev_maps *xps_maps[2];
	struct mini_Qdisc *miniq_egress;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	refcount_t dev_refcnt;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	possible_net_t nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct garp_port *garp_port;
	struct mrp_port *mrp_port;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	struct lock_class_key *qdisc_running_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	unsigned int threaded: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_KEY = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCK_COMMON = 12,
	PTR_TO_TCP_SOCK = 13,
	PTR_TO_TP_BUFFER = 14,
	PTR_TO_XDP_SOCK = 15,
	PTR_TO_BTF_ID = 16,
	PTR_TO_MEM = 17,
	PTR_TO_BUF = 18,
	PTR_TO_PERCPU_BTF_ID = 19,
	PTR_TO_FUNC = 20,
	__BPF_REG_TYPE_MAX = 21,
	PTR_TO_MAP_VALUE_OR_NULL = 260,
	PTR_TO_SOCKET_OR_NULL = 267,
	PTR_TO_SOCK_COMMON_OR_NULL = 268,
	PTR_TO_TCP_SOCK_OR_NULL = 269,
	PTR_TO_BTF_ID_OR_NULL = 272,
	__BPF_REG_TYPE_LIMIT = 1023,
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
};

struct bpf_tramp_image {
	void *image;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_trampoline {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
	u64 selector;
	struct module *mod;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	void *aux;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

struct btf_mod_pair {
	struct btf *btf;
	struct module *module;
};

typedef short unsigned int __kernel_sa_family_t;

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct msghdr {
	void *msg_name;
	int msg_namelen;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
	struct kiocb *msg_iocb;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
	} u;
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct fib_rule;

struct fib_lookup_arg;

struct fib_rule_hdr;

struct nlattr;

struct netlink_ext_ack;

struct nla_policy;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	const struct nla_policy *policy;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[16];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	__u8 flags;
	__u8 nud_state;
	__u8 type;
	__u8 dead;
	u8 protocol;
	seqlock_t ha_lock;
	long: 0;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct callback_head rcu;
	struct net_device *dev;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__u32 ra_defrtr_metric;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	atomic_t mc_forwarding;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	__u32 ioam6_id;
	__u32 ioam6_id_wide;
	__u8 ioam6_enabled;
	struct ctl_table_header *sysctl_header;
};

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	long: 64;
	long: 64;
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	unsigned int napi_id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
	u32 flags;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize: 8;
	u32 frame_sz: 24;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
	u32 flags;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	u8 cookie[20];
	u8 cookie_len;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		struct netlink_range_validation *range;
		struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
		u16 strict_start_type;
	};
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct netdev_queue {
	struct net_device *dev;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	int numa_node;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device *sb_dev;
	long: 64;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dql dql;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_packed {
	__u64 bytes;
	__u64 packets;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct net_rate_estimator;

struct gnet_stats_basic_cpu;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	spinlock_t busylock;
	spinlock_t seqlock;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long int privdata[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct netdev_rx_queue {
	struct xdp_rxq_info xdp_rxq;
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	unsigned int nr_ids;
	s16 num_tc;
	struct xps_map *attr_map[0];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum net_device_path_type {
	DEV_PATH_ETHERNET = 0,
	DEV_PATH_VLAN = 1,
	DEV_PATH_BRIDGE = 2,
	DEV_PATH_PPPOE = 3,
	DEV_PATH_DSA = 4,
	DEV_PATH_MTK_WDMA = 5,
};

struct net_device_path {
	enum net_device_path_type type;
	const struct net_device *dev;
	union {
		struct {
			u16 id;
			__be16 proto;
			u8 h_dest[6];
		} encap;
		struct {
			enum {
				DEV_PATH_BR_VLAN_KEEP = 0,
				DEV_PATH_BR_VLAN_TAG = 1,
				DEV_PATH_BR_VLAN_UNTAG = 2,
				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
			} vlan_mode;
			u16 vlan_id;
			__be16 vlan_proto;
		} bridge;
		struct {
			int port;
			u16 proto;
		} dsa;
		struct {
			u8 wdma_idx;
			u8 queue;
			u16 wcid;
			u8 bss;
		} mtk_wdma;
	};
};

struct net_device_path_ctx {
	const struct net_device *dev;
	u8 daddr[6];
	int num_vlans;
	struct {
		u16 id;
		__be16 proto;
	} vlan[2];
};

enum tc_setup_type {
	TC_SETUP_QDISC_MQPRIO = 0,
	TC_SETUP_CLSU32 = 1,
	TC_SETUP_CLSFLOWER = 2,
	TC_SETUP_CLSMATCHALL = 3,
	TC_SETUP_CLSBPF = 4,
	TC_SETUP_BLOCK = 5,
	TC_SETUP_QDISC_CBS = 6,
	TC_SETUP_QDISC_RED = 7,
	TC_SETUP_QDISC_PRIO = 8,
	TC_SETUP_QDISC_MQ = 9,
	TC_SETUP_QDISC_ETF = 10,
	TC_SETUP_ROOT_QDISC = 11,
	TC_SETUP_QDISC_GRED = 12,
	TC_SETUP_QDISC_TAPRIO = 13,
	TC_SETUP_FT = 14,
	TC_SETUP_QDISC_ETS = 15,
	TC_SETUP_QDISC_TBF = 16,
	TC_SETUP_QDISC_FIFO = 17,
	TC_SETUP_QDISC_HTB = 18,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

struct xsk_buff_pool;

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct devlink_port;

struct ip_tunnel_parm;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocbond)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocwandev)(struct net_device *, struct if_settings *);
	int (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_change_proto_down)(struct net_device *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	struct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	int data[13];
	long unsigned int data_state[1];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_drvinfo;

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_link_ext_state_info;

struct ethtool_eeprom;

struct ethtool_coalesce;

struct kernel_ethtool_coalesce;

struct ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_flash;

struct ethtool_channels;

struct ethtool_dump;

struct ethtool_ts_info;

struct ethtool_modinfo;

struct ethtool_eee;

struct ethtool_tunable;

struct ethtool_link_ksettings;

struct ethtool_fec_stats;

struct ethtool_fecparam;

struct ethtool_module_eeprom;

struct ethtool_eth_phy_stats;

struct ethtool_eth_mac_stats;

struct ethtool_eth_ctrl_stats;

struct ethtool_rmon_stats;

struct ethtool_rmon_hist_range;

struct ethtool_ops {
	u32 cap_link_lanes_supported: 1;
	u32 supported_coalesce_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
};

struct l3mdev_ops {
	u32 (*l3mdev_fib_table)(const struct net_device *);
	struct sk_buff * (*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16);
	struct sk_buff * (*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16);
	struct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *, struct flowi6 *);
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct delayed_work mc_gq_work;
	struct delayed_work mc_ifc_work;
	struct delayed_work mc_dad_work;
	struct delayed_work mc_query_work;
	struct delayed_work mc_report_work;
	struct sk_buff_head mc_query_queue;
	struct sk_buff_head mc_report_queue;
	spinlock_t mc_query_lock;
	spinlock_t mc_report_lock;
	struct mutex mc_lock;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
	unsigned int ra_mtu;
};

struct tcf_proto;

struct tcf_block;

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	struct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);
	void (*setup)(struct net_device *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_info;

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_stats_basic_cpu {
	struct gnet_stats_basic_packed bstats;
	struct u64_stats_sync syncp;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct bpf_prog_stats {
	u64_stats_t cnt;
	u64_stats_t nsecs;
	u64_stats_t misses;
	struct u64_stats_sync syncp;
	long: 64;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_GC_STALETIME = 7,
	NEIGH_VAR_QUEUE_LEN_BYTES = 8,
	NEIGH_VAR_PROXY_QLEN = 9,
	NEIGH_VAR_ANYCAST_DELAY = 10,
	NEIGH_VAR_PROXY_DELAY = 11,
	NEIGH_VAR_LOCKTIME = 12,
	NEIGH_VAR_QUEUE_LEN = 13,
	NEIGH_VAR_RETRANS_TIME_MS = 14,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,
	NEIGH_VAR_GC_INTERVAL = 16,
	NEIGH_VAR_GC_THRESH1 = 17,
	NEIGH_VAR_GC_THRESH2 = 18,
	NEIGH_VAR_GC_THRESH3 = 19,
	NEIGH_VAR_MAX = 20,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	u8 flags;
	u8 protocol;
	u32 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct smc_hashinfo;

struct sk_psock;

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	bool (*bpf_bypass_getsockopt)(int, int);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*sock_is_readable)(struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
	struct callback_head rcu;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct delayed_work mca_work;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 18,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

typedef __u16 __le16;

typedef __u64 __le64;

struct minix_super_block {
	__u16 s_ninodes;
	__u16 s_nzones;
	__u16 s_imap_blocks;
	__u16 s_zmap_blocks;
	__u16 s_firstdatazone;
	__u16 s_log_zone_size;
	__u32 s_max_size;
	__u16 s_magic;
	__u16 s_state;
	__u32 s_zones;
};

struct romfs_super_block {
	__be32 word0;
	__be32 word1;
	__be32 size;
	__be32 checksum;
	char name[0];
};

struct cramfs_inode {
	__u32 mode: 16;
	__u32 uid: 16;
	__u32 size: 24;
	__u32 gid: 8;
	__u32 namelen: 6;
	__u32 offset: 26;
};

struct cramfs_info {
	__u32 crc;
	__u32 edition;
	__u32 blocks;
	__u32 files;
};

struct cramfs_super {
	__u32 magic;
	__u32 size;
	__u32 flags;
	__u32 future;
	__u8 signature[16];
	struct cramfs_info fsid;
	__u8 name[16];
	struct cramfs_inode root;
};

struct squashfs_super_block {
	__le32 s_magic;
	__le32 inodes;
	__le32 mkfs_time;
	__le32 block_size;
	__le32 fragments;
	__le16 compression;
	__le16 block_log;
	__le16 flags;
	__le16 no_ids;
	__le16 s_major;
	__le16 s_minor;
	__le64 root_inode;
	__le64 bytes_used;
	__le64 id_table_start;
	__le64 xattr_id_table_start;
	__le64 inode_table_start;
	__le64 directory_table_start;
	__le64 fragment_table_start;
	__le64 lookup_table_start;
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

struct __va_list {
	void *__stack;
	void *__gr_top;
	void *__vr_top;
	int __gr_offs;
	int __vr_offs;
};

typedef struct __va_list va_list;

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	char *name;
	time64_t mtime;
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_CMA = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_EVENT_ITEMS = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_FREE_CMA_PAGES = 9,
	NR_VM_ZONE_STAT_ITEMS = 10,
};

enum {
	MM_LEAF_TOTAL = 0,
	MM_LEAF_OLD = 1,
	MM_LEAF_YOUNG = 2,
	MM_NONLEAF_TOTAL = 3,
	MM_NONLEAF_FOUND = 4,
	MM_NONLEAF_ADDED = 5,
	NR_MM_STATS = 6,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	NR_WMARK = 3,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	HUGETLB_PAGE_DTOR = 2,
	TRANSHUGE_PAGE_DTOR = 3,
	NR_COMPOUND_DTORS = 4,
};

enum {
	TSK_TRACE_FL_TRACE_BIT = 0,
	TSK_TRACE_FL_GRAPH_BIT = 1,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_FANOTIFY_GROUPS = 10,
	UCOUNT_FANOTIFY_MARKS = 11,
	UCOUNT_RLIMIT_NPROC = 12,
	UCOUNT_RLIMIT_MSGQUEUE = 13,
	UCOUNT_RLIMIT_SIGPENDING = 14,
	UCOUNT_RLIMIT_MEMLOCK = 15,
	UCOUNT_COUNTS = 16,
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_ASYM_CPUCAPACITY_FULL = 6,
	__SD_SHARE_CPUCAPACITY = 7,
	__SD_SHARE_PKG_RESOURCES = 8,
	__SD_SERIALIZE = 9,
	__SD_ASYM_PACKING = 10,
	__SD_PREFER_SIBLING = 11,
	__SD_OVERLAP = 12,
	__SD_NUMA = 13,
	__SD_FLAG_CNT = 14,
};

typedef long unsigned int uintptr_t;

struct step_hook {
	struct list_head node;
	int (*fn)(struct pt_regs *, long unsigned int);
};

struct break_hook {
	struct list_head node;
	int (*fn)(struct pt_regs *, long unsigned int);
	u16 imm;
	u16 mask;
};

enum dbg_active_el {
	DBG_ACTIVE_EL0 = 0,
	DBG_ACTIVE_EL1 = 1,
};

struct nmi_ctx {
	u64 hcr;
	unsigned int cnt;
};

struct midr_range {
	u32 model;
	u32 rv_min;
	u32 rv_max;
};

struct arm64_midr_revidr {
	u32 midr_rv;
	u32 revidr_mask;
};

struct arm64_cpu_capabilities {
	const char *desc;
	u16 capability;
	u16 type;
	bool (*matches)(const struct arm64_cpu_capabilities *, int);
	void (*cpu_enable)(const struct arm64_cpu_capabilities *);
	union {
		struct {
			struct midr_range midr_range;
			const struct arm64_midr_revidr * const fixed_revs;
		};
		const struct midr_range *midr_range_list;
		struct {
			u32 sys_reg;
			u8 field_pos;
			u8 min_field_value;
			u8 hwcap_type;
			bool sign;
			long unsigned int hwcap;
		};
	};
	const struct arm64_cpu_capabilities *match_list;
};

enum cpu_pm_event {
	CPU_PM_ENTER = 0,
	CPU_PM_ENTER_FAILED = 1,
	CPU_PM_EXIT = 2,
	CPU_CLUSTER_PM_ENTER = 3,
	CPU_CLUSTER_PM_ENTER_FAILED = 4,
	CPU_CLUSTER_PM_EXIT = 5,
};

struct fpsimd_last_state_struct {
	struct user_fpsimd_state *st;
	void *sve_state;
	unsigned int sve_vl;
};

enum arm64_hyp_spectre_vector {
	HYP_VECTOR_DIRECT = 0,
	HYP_VECTOR_SPECTRE_DIRECT = 1,
	HYP_VECTOR_INDIRECT = 2,
	HYP_VECTOR_SPECTRE_INDIRECT = 3,
};

typedef void (*bp_hardening_cb_t)();

struct bp_hardening_data {
	enum arm64_hyp_spectre_vector slot;
	bp_hardening_cb_t fn;
};

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_USER = 1,
	CONTEXT_GUEST = 2,
};

enum stack_type {
	STACK_TYPE_UNKNOWN = 0,
	STACK_TYPE_TASK = 1,
	STACK_TYPE_IRQ = 2,
	STACK_TYPE_OVERFLOW = 3,
	STACK_TYPE_SDEI_NORMAL = 4,
	STACK_TYPE_SDEI_CRITICAL = 5,
	__NR_STACK_TYPES = 6,
};

struct stack_info {
	long unsigned int low;
	long unsigned int high;
	enum stack_type type;
};

struct plist_head {
	struct list_head node_list;
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

struct arch_elf_state {
	int flags;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

struct stackframe {
	long unsigned int fp;
	long unsigned int pc;
	long unsigned int stacks_done[1];
	long unsigned int prev_fp;
	enum stack_type prev_type;
};

struct user_sve_header {
	__u32 size;
	__u32 max_size;
	__u16 vl;
	__u16 max_vl;
	__u16 flags;
	__u16 __reserved;
};

struct user_pac_mask {
	__u64 data_mask;
	__u64 insn_mask;
};

struct user_pac_address_keys {
	__int128 unsigned apiakey;
	__int128 unsigned apibkey;
	__int128 unsigned apdakey;
	__int128 unsigned apdbkey;
};

struct user_pac_generic_keys {
	__int128 unsigned apgakey;
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum bpf_type_flag {
	PTR_MAYBE_NULL = 256,
	MEM_RDONLY = 512,
	__BPF_TYPE_LAST_FLAG = 512,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_UNINIT_MAP_VALUE = 4,
	ARG_PTR_TO_MEM = 5,
	ARG_PTR_TO_UNINIT_MEM = 6,
	ARG_CONST_SIZE = 7,
	ARG_CONST_SIZE_OR_ZERO = 8,
	ARG_PTR_TO_CTX = 9,
	ARG_ANYTHING = 10,
	ARG_PTR_TO_SPIN_LOCK = 11,
	ARG_PTR_TO_SOCK_COMMON = 12,
	ARG_PTR_TO_INT = 13,
	ARG_PTR_TO_LONG = 14,
	ARG_PTR_TO_SOCKET = 15,
	ARG_PTR_TO_BTF_ID = 16,
	ARG_PTR_TO_ALLOC_MEM = 17,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 18,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 19,
	ARG_PTR_TO_PERCPU_BTF_ID = 20,
	ARG_PTR_TO_FUNC = 21,
	ARG_PTR_TO_STACK = 22,
	ARG_PTR_TO_CONST_STR = 23,
	ARG_PTR_TO_TIMER = 24,
	__BPF_ARG_TYPE_MAX = 25,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 259,
	ARG_PTR_TO_MEM_OR_NULL = 261,
	ARG_PTR_TO_CTX_OR_NULL = 265,
	ARG_PTR_TO_SOCKET_OR_NULL = 271,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 273,
	ARG_PTR_TO_STACK_OR_NULL = 278,
	__BPF_ARG_TYPE_LIMIT = 1023,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_SOCKET = 3,
	RET_PTR_TO_TCP_SOCK = 4,
	RET_PTR_TO_SOCK_COMMON = 5,
	RET_PTR_TO_ALLOC_MEM = 6,
	RET_PTR_TO_MEM_OR_BTF_ID = 7,
	RET_PTR_TO_BTF_ID = 8,
	__BPF_RET_TYPE_MAX = 9,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 258,
	RET_PTR_TO_SOCKET_OR_NULL = 259,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 260,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 261,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 262,
	RET_PTR_TO_BTF_ID_OR_NULL = 264,
	__BPF_RET_TYPE_LIMIT = 1023,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

enum cgroup_bpf_attach_type {
	CGROUP_BPF_ATTACH_TYPE_INVALID = 4294967295,
	CGROUP_INET_INGRESS = 0,
	CGROUP_INET_EGRESS = 1,
	CGROUP_INET_SOCK_CREATE = 2,
	CGROUP_SOCK_OPS = 3,
	CGROUP_DEVICE = 4,
	CGROUP_INET4_BIND = 5,
	CGROUP_INET6_BIND = 6,
	CGROUP_INET4_CONNECT = 7,
	CGROUP_INET6_CONNECT = 8,
	CGROUP_INET4_POST_BIND = 9,
	CGROUP_INET6_POST_BIND = 10,
	CGROUP_UDP4_SENDMSG = 11,
	CGROUP_UDP6_SENDMSG = 12,
	CGROUP_SYSCTL = 13,
	CGROUP_UDP4_RECVMSG = 14,
	CGROUP_UDP6_RECVMSG = 15,
	CGROUP_GETSOCKOPT = 16,
	CGROUP_SETSOCKOPT = 17,
	CGROUP_INET4_GETPEERNAME = 18,
	CGROUP_INET6_GETPEERNAME = 19,
	CGROUP_INET4_GETSOCKNAME = 20,
	CGROUP_INET6_GETSOCKNAME = 21,
	CGROUP_INET_SOCK_RELEASE = 22,
	MAX_CGROUP_BPF_ATTACH_TYPE = 23,
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	memory_cgrp_id = 4,
	pids_cgrp_id = 5,
	rdma_cgrp_id = 6,
	CGROUP_SUBSYS_COUNT = 7,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 1,
	TYPE_MAX = 2,
};

struct membuf {
	void *p;
	size_t left;
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

struct pt_regs_offset {
	const char *name;
	int offset;
};

enum aarch64_regset {
	REGSET_GPR = 0,
	REGSET_FPR = 1,
	REGSET_TLS = 2,
	REGSET_HW_BREAK = 3,
	REGSET_HW_WATCH = 4,
	REGSET_SYSTEM_CALL = 5,
	REGSET_SVE = 6,
	REGSET_PAC_MASK = 7,
	REGSET_PAC_ENABLED_KEYS = 8,
	REGSET_PACA_KEYS = 9,
	REGSET_PACG_KEYS = 10,
	REGSET_TAGGED_ADDR_CTRL = 11,
};

enum ptrace_syscall_dir {
	PTRACE_SYSCALL_ENTER = 0,
	PTRACE_SYSCALL_EXIT = 1,
};

typedef phys_addr_t resource_size_t;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct mpidr_hash {
	u64 mask;
	u32 shift_aff[4];
	u32 bits;
};

struct cpuinfo_32bit {
	u32 reg_id_dfr0;
	u32 reg_id_dfr1;
	u32 reg_id_isar0;
	u32 reg_id_isar1;
	u32 reg_id_isar2;
	u32 reg_id_isar3;
	u32 reg_id_isar4;
	u32 reg_id_isar5;
	u32 reg_id_isar6;
	u32 reg_id_mmfr0;
	u32 reg_id_mmfr1;
	u32 reg_id_mmfr2;
	u32 reg_id_mmfr3;
	u32 reg_id_mmfr4;
	u32 reg_id_mmfr5;
	u32 reg_id_pfr0;
	u32 reg_id_pfr1;
	u32 reg_id_pfr2;
	u32 reg_mvfr0;
	u32 reg_mvfr1;
	u32 reg_mvfr2;
};

struct cpuinfo_arm64 {
	struct cpu cpu;
	struct kobject kobj;
	u64 reg_ctr;
	u64 reg_cntfrq;
	u64 reg_dczid;
	u64 reg_midr;
	u64 reg_revidr;
	u64 reg_gmid;
	u64 reg_id_aa64dfr0;
	u64 reg_id_aa64dfr1;
	u64 reg_id_aa64isar0;
	u64 reg_id_aa64isar1;
	u64 reg_id_aa64isar2;
	u64 reg_id_aa64mmfr0;
	u64 reg_id_aa64mmfr1;
	u64 reg_id_aa64mmfr2;
	u64 reg_id_aa64pfr0;
	u64 reg_id_aa64pfr1;
	u64 reg_id_aa64zfr0;
	struct cpuinfo_32bit aarch32;
	u64 reg_zcr;
};

struct cpu_operations {
	const char *name;
	int (*cpu_init)(unsigned int);
	int (*cpu_prepare)(unsigned int);
	int (*cpu_boot)(unsigned int);
	void (*cpu_postboot)();
	bool (*cpu_can_disable)(unsigned int);
	int (*cpu_disable)(unsigned int);
	void (*cpu_die)(unsigned int);
	int (*cpu_kill)(unsigned int);
	int (*cpu_init_idle)(unsigned int);
	int (*cpu_suspend)(long unsigned int);
};

struct sigcontext {
	__u64 fault_address;
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
	long: 64;
	__u8 __reserved[4096];
};

struct _aarch64_ctx {
	__u32 magic;
	__u32 size;
};

struct fpsimd_context {
	struct _aarch64_ctx head;
	__u32 fpsr;
	__u32 fpcr;
	__int128 unsigned vregs[32];
};

struct esr_context {
	struct _aarch64_ctx head;
	__u64 esr;
};

struct extra_context {
	struct _aarch64_ctx head;
	__u64 datap;
	__u32 size;
	__u32 __reserved[3];
};

struct sve_context {
	struct _aarch64_ctx head;
	__u16 vl;
	__u16 __reserved[3];
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

typedef struct siginfo siginfo_t;

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	sigset_t uc_sigmask;
	__u8 __unused[120];
	long: 64;
	struct sigcontext uc_mcontext;
};

struct rt_sigframe {
	struct siginfo info;
	struct ucontext uc;
};

struct frame_record {
	u64 fp;
	u64 lr;
};

struct rt_sigframe_user_layout {
	struct rt_sigframe *sigframe;
	struct frame_record *next_frame;
	long unsigned int size;
	long unsigned int limit;
	long unsigned int fpsimd_offset;
	long unsigned int esr_offset;
	long unsigned int sve_offset;
	long unsigned int extra_offset;
	long unsigned int end_offset;
};

struct user_ctxs {
	struct fpsimd_context *fpsimd;
	struct sve_context *sve;
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

typedef long int (*syscall_fn_t)(const struct pt_regs *);

typedef bool (*stack_trace_consume_fn)(void *, long unsigned int);

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

typedef bool pstate_check_t(long unsigned int);

enum ftr_type {
	FTR_EXACT = 0,
	FTR_LOWER_SAFE = 1,
	FTR_HIGHER_SAFE = 2,
	FTR_HIGHER_OR_ZERO_SAFE = 3,
};

struct arm64_ftr_bits {
	bool sign;
	bool visible;
	bool strict;
	enum ftr_type type;
	u8 shift;
	u8 width;
	s64 safe_val;
};

struct arm64_ftr_override {
	u64 val;
	u64 mask;
};

struct arm64_ftr_reg {
	const char *name;
	u64 strict_mask;
	u64 user_mask;
	u64 sys_val;
	u64 user_val;
	struct arm64_ftr_override *override;
	const struct arm64_ftr_bits *ftr_bits;
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_TRAPNO = 4,
	SIL_FAULT_MCEERR = 5,
	SIL_FAULT_BNDERR = 6,
	SIL_FAULT_PKUERR = 7,
	SIL_FAULT_PERF_EVENT = 8,
	SIL_CHLD = 9,
	SIL_RT = 10,
	SIL_SYS = 11,
};

enum die_val {
	DIE_UNUSED = 0,
	DIE_OOPS = 1,
};

struct undef_hook {
	struct list_head node;
	u32 instr_mask;
	u32 instr_val;
	u64 pstate_mask;
	u64 pstate_val;
	int (*fn)(struct pt_regs *, u32);
};

struct sys64_hook {
	long unsigned int esr_mask;
	long unsigned int esr_val;
	void (*handler)(long unsigned int, struct pt_regs *);
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_HINDEX_MASK = 983040,
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

struct arch_vdso_data {};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

enum vdso_abi {
	VDSO_ABI_AA64 = 0,
	VDSO_ABI_AA32 = 1,
};

enum vvar_pages {
	VVAR_DATA_PAGE_OFFSET = 0,
	VVAR_TIMENS_PAGE_OFFSET = 1,
	VVAR_NR_PAGES = 2,
};

struct vdso_abi_info {
	const char *name;
	const char *vdso_code_start;
	const char *vdso_code_end;
	long unsigned int vdso_pages;
	struct vm_special_mapping *dm;
	struct vm_special_mapping *cm;
};

enum aarch64_map {
	AA64_MAP_VVAR = 0,
	AA64_MAP_VDSO = 1,
};

struct psci_operations {
	u32 (*get_version)();
	int (*cpu_suspend)(u32, long unsigned int);
	int (*cpu_off)(u32);
	int (*cpu_on)(long unsigned int, long unsigned int);
	int (*migrate)(long unsigned int);
	int (*affinity_info)(long unsigned int, long unsigned int);
	int (*migrate_info_type)();
};

struct return_address_data {
	unsigned int level;
	void *addr;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

typedef int (*cmp_func_t)(const void *, const void *);

enum {
	CAP_HWCAP = 1,
};

enum aarch64_insn_imm_type {
	AARCH64_INSN_IMM_ADR = 0,
	AARCH64_INSN_IMM_26 = 1,
	AARCH64_INSN_IMM_19 = 2,
	AARCH64_INSN_IMM_16 = 3,
	AARCH64_INSN_IMM_14 = 4,
	AARCH64_INSN_IMM_12 = 5,
	AARCH64_INSN_IMM_9 = 6,
	AARCH64_INSN_IMM_7 = 7,
	AARCH64_INSN_IMM_6 = 8,
	AARCH64_INSN_IMM_S = 9,
	AARCH64_INSN_IMM_R = 10,
	AARCH64_INSN_IMM_N = 11,
	AARCH64_INSN_IMM_MAX = 12,
};

enum aarch64_insn_register_type {
	AARCH64_INSN_REGTYPE_RT = 0,
	AARCH64_INSN_REGTYPE_RN = 1,
	AARCH64_INSN_REGTYPE_RT2 = 2,
	AARCH64_INSN_REGTYPE_RM = 3,
	AARCH64_INSN_REGTYPE_RD = 4,
	AARCH64_INSN_REGTYPE_RA = 5,
	AARCH64_INSN_REGTYPE_RS = 6,
};

struct secondary_data {
	struct task_struct *task;
	long int status;
};

enum mitigation_state {
	SPECTRE_UNAFFECTED = 0,
	SPECTRE_MITIGATED = 1,
	SPECTRE_VULNERABLE = 2,
};

enum fixed_addresses {
	FIX_HOLE = 0,
	FIX_FDT_END = 1,
	FIX_FDT = 1024,
	FIX_EARLYCON_MEM_BASE = 1025,
	FIX_TEXT_POKE0 = 1026,
	FIX_ENTRY_TRAMP_TEXT3 = 1027,
	FIX_ENTRY_TRAMP_TEXT2 = 1028,
	FIX_ENTRY_TRAMP_TEXT1 = 1029,
	FIX_ENTRY_TRAMP_DATA = 1030,
	__end_of_permanent_fixed_addresses = 1031,
	FIX_BTMAP_END = 1031,
	FIX_BTMAP_BEGIN = 1478,
	FIX_PTE = 1479,
	FIX_PMD = 1480,
	FIX_PUD = 1481,
	FIX_PGD = 1482,
	__end_of_fixed_addresses = 1483,
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

typedef int (*cpu_stop_fn_t)(void *);

enum vcpu_sysreg {
	__INVALID_SYSREG__ = 0,
	MPIDR_EL1 = 1,
	CSSELR_EL1 = 2,
	SCTLR_EL1 = 3,
	ACTLR_EL1 = 4,
	CPACR_EL1 = 5,
	ZCR_EL1 = 6,
	TTBR0_EL1 = 7,
	TTBR1_EL1 = 8,
	TCR_EL1 = 9,
	ESR_EL1 = 10,
	AFSR0_EL1 = 11,
	AFSR1_EL1 = 12,
	FAR_EL1 = 13,
	MAIR_EL1 = 14,
	VBAR_EL1 = 15,
	CONTEXTIDR_EL1 = 16,
	TPIDR_EL0 = 17,
	TPIDRRO_EL0 = 18,
	TPIDR_EL1 = 19,
	AMAIR_EL1 = 20,
	CNTKCTL_EL1 = 21,
	PAR_EL1 = 22,
	MDSCR_EL1 = 23,
	MDCCINT_EL1 = 24,
	DISR_EL1 = 25,
	PMCR_EL0 = 26,
	PMSELR_EL0 = 27,
	PMEVCNTR0_EL0 = 28,
	PMEVCNTR30_EL0 = 58,
	PMCCNTR_EL0 = 59,
	PMEVTYPER0_EL0 = 60,
	PMEVTYPER30_EL0 = 90,
	PMCCFILTR_EL0 = 91,
	PMCNTENSET_EL0 = 92,
	PMINTENSET_EL1 = 93,
	PMOVSSET_EL0 = 94,
	PMUSERENR_EL0 = 95,
	APIAKEYLO_EL1 = 96,
	APIAKEYHI_EL1 = 97,
	APIBKEYLO_EL1 = 98,
	APIBKEYHI_EL1 = 99,
	APDAKEYLO_EL1 = 100,
	APDAKEYHI_EL1 = 101,
	APDBKEYLO_EL1 = 102,
	APDBKEYHI_EL1 = 103,
	APGAKEYLO_EL1 = 104,
	APGAKEYHI_EL1 = 105,
	ELR_EL1 = 106,
	SP_EL1 = 107,
	SPSR_EL1 = 108,
	CNTVOFF_EL2 = 109,
	CNTV_CVAL_EL0 = 110,
	CNTV_CTL_EL0 = 111,
	CNTP_CVAL_EL0 = 112,
	CNTP_CTL_EL0 = 113,
	RGSR_EL1 = 114,
	GCR_EL1 = 115,
	TFSR_EL1 = 116,
	TFSRE0_EL1 = 117,
	DACR32_EL2 = 118,
	IFSR32_EL2 = 119,
	FPEXC32_EL2 = 120,
	DBGVCR32_EL2 = 121,
	NR_SYS_REGS = 122,
};

enum arm64_bp_harden_el1_vectors {
	EL1_VECTOR_BHB_LOOP = 0,
	EL1_VECTOR_BHB_FW = 1,
	EL1_VECTOR_BHB_CLEAR_INSN = 2,
	EL1_VECTOR_KPTI = 3,
};

struct __ftr_reg_entry {
	u32 sys_id;
	struct arm64_ftr_reg *reg;
};

typedef void kpti_remap_fn(int, int, phys_addr_t);

typedef void ttbr_replace_func(phys_addr_t);

struct alt_instr {
	s32 orig_offset;
	s32 alt_offset;
	u16 cpufeature;
	u8 orig_len;
	u8 alt_len;
};

typedef void (*alternative_cb_t)(struct alt_instr *, __le32 *, __le32 *, int);

struct alt_region {
	struct alt_instr *begin;
	struct alt_instr *end;
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
	IRQ_NO_DEBUG = 2097152,
};

struct arch_msi_msg_addr_lo {
	u32 address_lo;
};

typedef struct arch_msi_msg_addr_lo arch_msi_msg_addr_lo_t;

struct arch_msi_msg_addr_hi {
	u32 address_hi;
};

typedef struct arch_msi_msg_addr_hi arch_msi_msg_addr_hi_t;

struct arch_msi_msg_data {
	u32 data;
};

typedef struct arch_msi_msg_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct platform_msi_priv_data;

struct platform_msi_desc {
	struct platform_msi_priv_data *msi_priv_data;
	u16 msi_index;
};

struct fsl_mc_msi_desc {
	u16 msi_index;
};

struct ti_sci_inta_msi_desc {
	u16 dev_index;
};

struct irq_affinity_desc;

struct msi_desc {
	struct list_head list;
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	const void *iommu_cookie;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	union {
		struct {
			union {
				u32 msi_mask;
				u32 msix_ctrl;
			};
			struct {
				u8 is_msix: 1;
				u8 multiple: 3;
				u8 multi_cap: 3;
				u8 can_mask: 1;
				u8 is_64: 1;
				u8 is_virtual: 1;
				u16 entry_nr;
				unsigned int default_irq;
			} msi_attrib;
			union {
				u8 mask_pos;
				void *mask_base;
			};
		};
		struct platform_msi_desc platform;
		struct fsl_mc_msi_desc fsl_mc;
		struct ti_sci_inta_msi_desc inta;
	};
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_NR_BUSES = 4,
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
};

struct trace_event_data_offsets_ipi_handler {};

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

enum ipi_msg_type {
	IPI_RESCHEDULE = 0,
	IPI_CALL_FUNC = 1,
	IPI_CPU_STOP = 2,
	IPI_CPU_CRASH_STOP = 3,
	IPI_TIMER = 4,
	IPI_IRQ_WORK = 5,
	IPI_WAKEUP = 6,
	NR_IPI = 7,
};

enum scale_freq_source {
	SCALE_FREQ_SOURCE_CPUFREQ = 0,
	SCALE_FREQ_SOURCE_ARCH = 1,
	SCALE_FREQ_SOURCE_CPPC = 2,
};

struct scale_freq_data {
	enum scale_freq_source source;
	void (*set_freq_scale)();
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

enum arm_smccc_conduit {
	SMCCC_CONDUIT_NONE = 0,
	SMCCC_CONDUIT_SMC = 1,
	SMCCC_CONDUIT_HVC = 2,
};

struct arm_smccc_res {
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
};

enum aarch64_insn_register {
	AARCH64_INSN_REG_0 = 0,
	AARCH64_INSN_REG_1 = 1,
	AARCH64_INSN_REG_2 = 2,
	AARCH64_INSN_REG_3 = 3,
	AARCH64_INSN_REG_4 = 4,
	AARCH64_INSN_REG_5 = 5,
	AARCH64_INSN_REG_6 = 6,
	AARCH64_INSN_REG_7 = 7,
	AARCH64_INSN_REG_8 = 8,
	AARCH64_INSN_REG_9 = 9,
	AARCH64_INSN_REG_10 = 10,
	AARCH64_INSN_REG_11 = 11,
	AARCH64_INSN_REG_12 = 12,
	AARCH64_INSN_REG_13 = 13,
	AARCH64_INSN_REG_14 = 14,
	AARCH64_INSN_REG_15 = 15,
	AARCH64_INSN_REG_16 = 16,
	AARCH64_INSN_REG_17 = 17,
	AARCH64_INSN_REG_18 = 18,
	AARCH64_INSN_REG_19 = 19,
	AARCH64_INSN_REG_20 = 20,
	AARCH64_INSN_REG_21 = 21,
	AARCH64_INSN_REG_22 = 22,
	AARCH64_INSN_REG_23 = 23,
	AARCH64_INSN_REG_24 = 24,
	AARCH64_INSN_REG_25 = 25,
	AARCH64_INSN_REG_26 = 26,
	AARCH64_INSN_REG_27 = 27,
	AARCH64_INSN_REG_28 = 28,
	AARCH64_INSN_REG_29 = 29,
	AARCH64_INSN_REG_FP = 29,
	AARCH64_INSN_REG_30 = 30,
	AARCH64_INSN_REG_LR = 30,
	AARCH64_INSN_REG_ZR = 31,
	AARCH64_INSN_REG_SP = 31,
};

enum aarch64_insn_variant {
	AARCH64_INSN_VARIANT_32BIT = 0,
	AARCH64_INSN_VARIANT_64BIT = 1,
};

enum aarch64_insn_movewide_type {
	AARCH64_INSN_MOVEWIDE_ZERO = 0,
	AARCH64_INSN_MOVEWIDE_KEEP = 1,
	AARCH64_INSN_MOVEWIDE_INVERSE = 2,
};

enum aarch64_insn_logic_type {
	AARCH64_INSN_LOGIC_AND = 0,
	AARCH64_INSN_LOGIC_BIC = 1,
	AARCH64_INSN_LOGIC_ORR = 2,
	AARCH64_INSN_LOGIC_ORN = 3,
	AARCH64_INSN_LOGIC_EOR = 4,
	AARCH64_INSN_LOGIC_EON = 5,
	AARCH64_INSN_LOGIC_AND_SETFLAGS = 6,
	AARCH64_INSN_LOGIC_BIC_SETFLAGS = 7,
};

enum spectre_v4_policy {
	SPECTRE_V4_POLICY_MITIGATION_DYNAMIC = 0,
	SPECTRE_V4_POLICY_MITIGATION_ENABLED = 1,
	SPECTRE_V4_POLICY_MITIGATION_DISABLED = 2,
};

struct spectre_v4_param {
	const char *str;
	enum spectre_v4_policy policy;
};

enum bhb_mitigation_bits {
	BHB_LOOP = 0,
	BHB_FW = 1,
	BHB_HW = 2,
	BHB_INSN = 3,
};

struct ftr_set_desc {
	char name[20];
	struct arm64_ftr_override *override;
	struct {
		char name[10];
		u8 shift;
		bool (*filter)(u64);
	} fields[0];
};

struct arm_cpuidle_irq_context {};

struct aarch64_insn_patch {
	void **text_addrs;
	u32 *new_insns;
	int insn_cnt;
	atomic_t cpu_count;
};

enum aarch64_insn_branch_type {
	AARCH64_INSN_BRANCH_NOLINK = 0,
	AARCH64_INSN_BRANCH_LINK = 1,
	AARCH64_INSN_BRANCH_RETURN = 2,
	AARCH64_INSN_BRANCH_COMP_ZERO = 3,
	AARCH64_INSN_BRANCH_COMP_NONZERO = 4,
};

typedef __u64 Elf64_Off;

typedef __s64 Elf64_Sxword;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

enum aarch64_reloc_op {
	RELOC_OP_NONE = 0,
	RELOC_OP_ABS = 1,
	RELOC_OP_PREL = 2,
	RELOC_OP_PAGE = 3,
};

enum aarch64_insn_movw_imm_type {
	AARCH64_INSN_IMM_MOVNZ = 0,
	AARCH64_INSN_IMM_MOVKZ = 1,
};

typedef void (*swap_func_t)(void *, void *, int);

enum aarch64_insn_adsb_type {
	AARCH64_INSN_ADSB_ADD = 0,
	AARCH64_INSN_ADSB_SUB = 1,
	AARCH64_INSN_ADSB_ADD_SETFLAGS = 2,
	AARCH64_INSN_ADSB_SUB_SETFLAGS = 3,
};

enum aarch64_insn_adr_type {
	AARCH64_INSN_ADR_TYPE_ADRP = 0,
	AARCH64_INSN_ADR_TYPE_ADR = 1,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_event_arm_regs {
	PERF_REG_ARM64_X0 = 0,
	PERF_REG_ARM64_X1 = 1,
	PERF_REG_ARM64_X2 = 2,
	PERF_REG_ARM64_X3 = 3,
	PERF_REG_ARM64_X4 = 4,
	PERF_REG_ARM64_X5 = 5,
	PERF_REG_ARM64_X6 = 6,
	PERF_REG_ARM64_X7 = 7,
	PERF_REG_ARM64_X8 = 8,
	PERF_REG_ARM64_X9 = 9,
	PERF_REG_ARM64_X10 = 10,
	PERF_REG_ARM64_X11 = 11,
	PERF_REG_ARM64_X12 = 12,
	PERF_REG_ARM64_X13 = 13,
	PERF_REG_ARM64_X14 = 14,
	PERF_REG_ARM64_X15 = 15,
	PERF_REG_ARM64_X16 = 16,
	PERF_REG_ARM64_X17 = 17,
	PERF_REG_ARM64_X18 = 18,
	PERF_REG_ARM64_X19 = 19,
	PERF_REG_ARM64_X20 = 20,
	PERF_REG_ARM64_X21 = 21,
	PERF_REG_ARM64_X22 = 22,
	PERF_REG_ARM64_X23 = 23,
	PERF_REG_ARM64_X24 = 24,
	PERF_REG_ARM64_X25 = 25,
	PERF_REG_ARM64_X26 = 26,
	PERF_REG_ARM64_X27 = 27,
	PERF_REG_ARM64_X28 = 28,
	PERF_REG_ARM64_X29 = 29,
	PERF_REG_ARM64_LR = 30,
	PERF_REG_ARM64_SP = 31,
	PERF_REG_ARM64_PC = 32,
	PERF_REG_ARM64_MAX = 33,
};

struct perf_guest_info_callbacks {
	int (*is_in_guest)();
	int (*is_user_mode)();
	long unsigned int (*get_guest_ip)();
	void (*handle_intel_pt_intr)();
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

struct frame_tail {
	struct frame_tail *fp;
	long unsigned int lr;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct pdev_archdata {};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct mfd_cell;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*remove_new)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};

struct arm_pmu;

struct pmu_hw_events {
	struct perf_event *events[32];
	long unsigned int used_mask[1];
	raw_spinlock_t pmu_lock;
	struct arm_pmu *percpu_pmu;
	int irq;
};

struct arm_pmu {
	struct pmu pmu;
	cpumask_t supported_cpus;
	char *name;
	int pmuver;
	irqreturn_t (*handle_irq)(struct arm_pmu *);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	int (*get_event_idx)(struct pmu_hw_events *, struct perf_event *);
	void (*clear_event_idx)(struct pmu_hw_events *, struct perf_event *);
	int (*set_event_filter)(struct hw_perf_event *, struct perf_event_attr *);
	u64 (*read_counter)(struct perf_event *);
	void (*write_counter)(struct perf_event *, u64);
	void (*start)(struct arm_pmu *);
	void (*stop)(struct arm_pmu *);
	void (*reset)(void *);
	int (*map_event)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int num_events;
	bool secure_access;
	long unsigned int pmceid_bitmap[1];
	long unsigned int pmceid_ext_bitmap[1];
	struct platform_device *plat_device;
	struct pmu_hw_events *hw_events;
	struct hlist_node node;
	struct notifier_block cpu_pm_nb;
	const struct attribute_group *attr_groups[5];
	u64 reg_pmmir;
	long unsigned int acpi_cpuid;
};

enum armpmu_attr_groups {
	ARMPMU_ATTR_GROUP_COMMON = 0,
	ARMPMU_ATTR_GROUP_EVENTS = 1,
	ARMPMU_ATTR_GROUP_FORMATS = 2,
	ARMPMU_ATTR_GROUP_CAPS = 3,
	ARMPMU_NR_ATTR_GROUPS = 4,
};

typedef int (*armpmu_init_fn)(struct arm_pmu *);

struct pmu_probe_info {
	unsigned int cpuid;
	unsigned int mask;
	armpmu_init_fn init;
};

struct clock_read_data {
	u64 epoch_ns;
	u64 epoch_cyc;
	u64 sched_clock_mask;
	u64 (*read_sched_clock)();
	u32 mult;
	u32 shift;
};

struct armv8pmu_probe_info {
	struct arm_pmu *pmu;
	bool present;
};

enum hw_breakpoint_ops {
	HW_BREAKPOINT_INSTALL = 0,
	HW_BREAKPOINT_UNINSTALL = 1,
	HW_BREAKPOINT_RESTORE = 2,
};

struct cpu_suspend_ctx {
	u64 ctx_regs[13];
	u64 sp;
};

struct sleep_stack_data {
	struct cpu_suspend_ctx system_regs;
	long unsigned int callee_saved_regs[12];
};

enum jump_label_type {
	JUMP_LABEL_NOP = 0,
	JUMP_LABEL_JMP = 1,
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
	__u32 override_only;
};

struct pci_bus;

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

typedef short unsigned int pci_bus_flags_t;

struct pci_dev;

struct pci_ops;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	int domain_nr;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	unsigned int unsafe_warn: 1;
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_IOV_RESOURCES = 7,
	PCI_IOV_RESOURCE_END = 12,
	PCI_BRIDGE_RESOURCES = 13,
	PCI_BRIDGE_RESOURCE_END = 16,
	PCI_NUM_RESOURCES = 17,
	DEVICE_COUNT_RESOURCE = 17,
};

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef unsigned int pcie_reset_state_t;

typedef short unsigned int pci_dev_flags_t;

struct pci_vpd {
	struct mutex lock;
	unsigned int len;
	u8 cap;
};

struct aer_stats;

struct rcec_ea;

struct pci_driver;

struct pcie_link_state;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u16 aer_cap;
	struct aer_stats *aer_stats;
	struct rcec_ea *rcec_ea;
	struct pci_dev *rcec;
	u32 devcap;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int runtime_d3cold: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	u16 l1ss;
	unsigned int pasid_no_tlp: 1;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[17];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[17];
	struct bin_attribute *res_attr_wc[17];
	const struct attribute_group **msi_irq_groups;
	struct pci_vpd vpd;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	char *driver_override;
	long unsigned int priv_flags;
	u8 reset_methods[7];
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	struct device_driver driver;
	struct pci_dynids dynids;
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

struct pvclock_vcpu_stolen_time {
	__le32 revision;
	__le32 attributes;
	__le64 stolen_time;
	u8 padding[48];
};

struct pv_time_stolen_time_region {
	struct pvclock_vcpu_stolen_time *kaddr;
};

struct pbe {
	void *address;
	void *orig_address;
	struct pbe *next;
};

struct trans_pgd_info {
	void * (*trans_alloc_page)(void *);
	void *trans_alloc_arg;
};

struct arch_hibernate_hdr_invariants {
	char uts_version[65];
};

struct arch_hibernate_hdr {
	struct arch_hibernate_hdr_invariants invariants;
	phys_addr_t ttbr1_el1;
	void (*reenter_kernel)();
	phys_addr_t __hyp_stub_vectors;
	u64 sleep_cpu_mpidr;
};

struct freelist_node {
	atomic_t refs;
	struct freelist_node *next;
};

struct freelist_head {
	struct freelist_node *head;
};

typedef u32 probe_opcode_t;

typedef void probes_handler_t(u32, long int, struct pt_regs *);

struct arch_probe_insn {
	probe_opcode_t *insn;
	pstate_check_t *pstate_cc;
	probes_handler_t *handler;
	long unsigned int restore;
};

typedef u32 kprobe_opcode_t;

struct arch_specific_insn {
	struct arch_probe_insn api;
};

struct kprobe;

struct prev_kprobe {
	struct kprobe *kp;
	unsigned int status;
};

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

struct kprobe_ctlblk {
	unsigned int kprobe_status;
	long unsigned int saved_irqflag;
	struct prev_kprobe prev_kprobe;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe_holder;

struct kretprobe_instance {
	union {
		struct freelist_node freelist;
		struct callback_head rcu;
	};
	struct llist_node llist;
	struct kretprobe_holder *rph;
	kprobe_opcode_t *ret_addr;
	void *fp;
	char data[0];
};

struct kretprobe;

struct kretprobe_holder {
	struct kretprobe *rp;
	refcount_t ref;
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct freelist_head freelist;
	struct kretprobe_holder *rph;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

enum probe_insn {
	INSN_REJECTED = 0,
	INSN_GOOD_NO_SLOT = 1,
	INSN_GOOD = 2,
};

enum aarch64_insn_encoding_class {
	AARCH64_INSN_CLS_UNKNOWN = 0,
	AARCH64_INSN_CLS_SVE = 1,
	AARCH64_INSN_CLS_DP_IMM = 2,
	AARCH64_INSN_CLS_DP_REG = 3,
	AARCH64_INSN_CLS_DP_FPSIMD = 4,
	AARCH64_INSN_CLS_LDST = 5,
	AARCH64_INSN_CLS_BR_SYS = 6,
};

enum aarch64_insn_special_register {
	AARCH64_INSN_SPCLREG_SPSR_EL1 = 49664,
	AARCH64_INSN_SPCLREG_ELR_EL1 = 49665,
	AARCH64_INSN_SPCLREG_SP_EL0 = 49672,
	AARCH64_INSN_SPCLREG_SPSEL = 49680,
	AARCH64_INSN_SPCLREG_CURRENTEL = 49682,
	AARCH64_INSN_SPCLREG_DAIF = 55825,
	AARCH64_INSN_SPCLREG_NZCV = 55824,
	AARCH64_INSN_SPCLREG_FPCR = 55840,
	AARCH64_INSN_SPCLREG_DSPSR_EL0 = 55848,
	AARCH64_INSN_SPCLREG_DLR_EL0 = 55849,
	AARCH64_INSN_SPCLREG_SPSR_EL2 = 57856,
	AARCH64_INSN_SPCLREG_ELR_EL2 = 57857,
	AARCH64_INSN_SPCLREG_SP_EL1 = 57864,
	AARCH64_INSN_SPCLREG_SPSR_INQ = 57880,
	AARCH64_INSN_SPCLREG_SPSR_ABT = 57881,
	AARCH64_INSN_SPCLREG_SPSR_UND = 57882,
	AARCH64_INSN_SPCLREG_SPSR_FIQ = 57883,
	AARCH64_INSN_SPCLREG_SPSR_EL3 = 61952,
	AARCH64_INSN_SPCLREG_ELR_EL3 = 61953,
	AARCH64_INSN_SPCLREG_SP_EL2 = 61968,
};

struct io_tlb_slot;

struct io_tlb_mem {
	phys_addr_t start;
	phys_addr_t end;
	long unsigned int nslabs;
	long unsigned int used;
	unsigned int index;
	spinlock_t lock;
	struct dentry *debugfs;
	bool late_alloc;
	bool force_bounce;
	bool for_alloc;
	struct io_tlb_slot *slots;
};

struct iopf_device_param;

struct iommu_fault_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iopf_device_param *iopf_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct iommu_fault_unrecoverable {
	__u32 reason;
	__u32 flags;
	__u32 pasid;
	__u32 perm;
	__u64 addr;
	__u64 fetch_addr;
};

struct iommu_fault_page_request {
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u64 addr;
	__u64 private_data[2];
};

struct iommu_fault {
	__u32 type;
	__u32 padding;
	union {
		struct iommu_fault_unrecoverable event;
		struct iommu_fault_page_request prm;
		__u8 padding2[56];
	};
};

struct iommu_page_response {
	__u32 argsz;
	__u32 version;
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 code;
};

struct iommu_inv_addr_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
	__u64 addr;
	__u64 granule_size;
	__u64 nb_granules;
};

struct iommu_inv_pasid_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
};

struct iommu_cache_invalidate_info {
	__u32 argsz;
	__u32 version;
	__u8 cache;
	__u8 granularity;
	__u8 padding[6];
	union {
		struct iommu_inv_pasid_info pasid_info;
		struct iommu_inv_addr_info addr_info;
	} granu;
};

struct iommu_gpasid_bind_data_vtd {
	__u64 flags;
	__u32 pat;
	__u32 emt;
};

struct iommu_gpasid_bind_data {
	__u32 argsz;
	__u32 version;
	__u32 format;
	__u32 addr_width;
	__u64 flags;
	__u64 gpgd;
	__u64 hpasid;
	__u64 gpasid;
	__u8 padding[8];
	union {
		struct iommu_gpasid_bind_data_vtd vtd;
	} vendor;
};

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_dma_cookie;

struct iommu_domain {
	unsigned int type;
	const struct iommu_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	struct iommu_dma_cookie *iova_cookie;
};

typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
	struct page *freelist;
	bool queued;
};

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
};

struct iommu_sva {
	struct device *dev;
};

struct iommu_fault_event {
	struct iommu_fault fault;
	struct list_head list;
};

struct iommu_fault_param {
	iommu_dev_fault_handler_t handler;
	void *data;
	struct list_head faults;
	struct mutex lock;
};

struct iommu_fwspec {
	const struct iommu_ops *ops;
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	unsigned int num_ids;
	u32 ids[0];
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct io_tlb_slot {
	phys_addr_t orig_addr;
	size_t alloc_size;
	unsigned int list;
};

typedef struct {
	pgd_t pgd;
} p4d_t;

struct hstate {
	struct mutex resize_lock;
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[4];
	unsigned int nr_huge_pages_node[4];
	unsigned int free_huge_pages_node[4];
	unsigned int surplus_huge_pages_node[4];
	char name[32];
};

struct fault_info {
	int (*fn)(long unsigned int, long unsigned int, struct pt_regs *);
	int sig;
	int code;
	const char *name;
};

enum swiotlb_force {
	SWIOTLB_NORMAL = 0,
	SWIOTLB_FORCE = 1,
	SWIOTLB_NO_FORCE = 2,
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	PG_arch_2 = 22,
	__NR_PAGEFLAGS = 23,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 6,
	PG_isolated = 18,
	PG_reported = 2,
};

typedef u8 uint8_t;

typedef u64 p4dval_t;

struct mem_section_usage {
	long unsigned int subsection_map[1];
	long unsigned int pageblock_flags[0];
};

struct mem_section {
	long unsigned int section_mem_map;
	struct mem_section_usage *usage;
};

typedef __be32 fdt32_t;

struct fdt_header {
	fdt32_t magic;
	fdt32_t totalsize;
	fdt32_t off_dt_struct;
	fdt32_t off_dt_strings;
	fdt32_t off_mem_rsvmap;
	fdt32_t version;
	fdt32_t last_comp_version;
	fdt32_t boot_cpuid_phys;
	fdt32_t size_dt_strings;
	fdt32_t size_dt_struct;
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

struct page_change_data {
	pgprot_t set_mask;
	pgprot_t clear_mask;
};

typedef long unsigned int vm_flags_t;

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

enum aarch64_insn_hint_cr_op {
	AARCH64_INSN_HINT_NOP = 0,
	AARCH64_INSN_HINT_YIELD = 32,
	AARCH64_INSN_HINT_WFE = 64,
	AARCH64_INSN_HINT_WFI = 96,
	AARCH64_INSN_HINT_SEV = 128,
	AARCH64_INSN_HINT_SEVL = 160,
	AARCH64_INSN_HINT_XPACLRI = 224,
	AARCH64_INSN_HINT_PACIA_1716 = 256,
	AARCH64_INSN_HINT_PACIB_1716 = 320,
	AARCH64_INSN_HINT_AUTIA_1716 = 384,
	AARCH64_INSN_HINT_AUTIB_1716 = 448,
	AARCH64_INSN_HINT_PACIAZ = 768,
	AARCH64_INSN_HINT_PACIASP = 800,
	AARCH64_INSN_HINT_PACIBZ = 832,
	AARCH64_INSN_HINT_PACIBSP = 864,
	AARCH64_INSN_HINT_AUTIAZ = 896,
	AARCH64_INSN_HINT_AUTIASP = 928,
	AARCH64_INSN_HINT_AUTIBZ = 960,
	AARCH64_INSN_HINT_AUTIBSP = 992,
	AARCH64_INSN_HINT_ESB = 512,
	AARCH64_INSN_HINT_PSB = 544,
	AARCH64_INSN_HINT_TSB = 576,
	AARCH64_INSN_HINT_CSDB = 640,
	AARCH64_INSN_HINT_CLEARBHB = 704,
	AARCH64_INSN_HINT_BTI = 1024,
	AARCH64_INSN_HINT_BTIC = 1088,
	AARCH64_INSN_HINT_BTIJ = 1152,
	AARCH64_INSN_HINT_BTIJC = 1216,
};

enum aarch64_insn_condition {
	AARCH64_INSN_COND_EQ = 0,
	AARCH64_INSN_COND_NE = 1,
	AARCH64_INSN_COND_CS = 2,
	AARCH64_INSN_COND_CC = 3,
	AARCH64_INSN_COND_MI = 4,
	AARCH64_INSN_COND_PL = 5,
	AARCH64_INSN_COND_VS = 6,
	AARCH64_INSN_COND_VC = 7,
	AARCH64_INSN_COND_HI = 8,
	AARCH64_INSN_COND_LS = 9,
	AARCH64_INSN_COND_GE = 10,
	AARCH64_INSN_COND_LT = 11,
	AARCH64_INSN_COND_GT = 12,
	AARCH64_INSN_COND_LE = 13,
	AARCH64_INSN_COND_AL = 14,
};

enum aarch64_insn_size_type {
	AARCH64_INSN_SIZE_8 = 0,
	AARCH64_INSN_SIZE_16 = 1,
	AARCH64_INSN_SIZE_32 = 2,
	AARCH64_INSN_SIZE_64 = 3,
};

enum aarch64_insn_ldst_type {
	AARCH64_INSN_LDST_LOAD_REG_OFFSET = 0,
	AARCH64_INSN_LDST_STORE_REG_OFFSET = 1,
	AARCH64_INSN_LDST_LOAD_PAIR_PRE_INDEX = 2,
	AARCH64_INSN_LDST_STORE_PAIR_PRE_INDEX = 3,
	AARCH64_INSN_LDST_LOAD_PAIR_POST_INDEX = 4,
	AARCH64_INSN_LDST_STORE_PAIR_POST_INDEX = 5,
	AARCH64_INSN_LDST_LOAD_EX = 6,
	AARCH64_INSN_LDST_STORE_EX = 7,
};

enum aarch64_insn_bitfield_type {
	AARCH64_INSN_BITFIELD_MOVE = 0,
	AARCH64_INSN_BITFIELD_MOVE_UNSIGNED = 1,
	AARCH64_INSN_BITFIELD_MOVE_SIGNED = 2,
};

enum aarch64_insn_data1_type {
	AARCH64_INSN_DATA1_REVERSE_16 = 0,
	AARCH64_INSN_DATA1_REVERSE_32 = 1,
	AARCH64_INSN_DATA1_REVERSE_64 = 2,
};

enum aarch64_insn_data2_type {
	AARCH64_INSN_DATA2_UDIV = 0,
	AARCH64_INSN_DATA2_SDIV = 1,
	AARCH64_INSN_DATA2_LSLV = 2,
	AARCH64_INSN_DATA2_LSRV = 3,
	AARCH64_INSN_DATA2_ASRV = 4,
	AARCH64_INSN_DATA2_RORV = 5,
};

enum aarch64_insn_data3_type {
	AARCH64_INSN_DATA3_MADD = 0,
	AARCH64_INSN_DATA3_MSUB = 1,
};

struct bpf_binary_header {
	u32 pages;
	long: 0;
	u8 image[0];
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct jit_ctx {
	const struct bpf_prog *prog;
	int idx;
	int epilogue_offset;
	int *offset;
	int exentry_idx;
	__le32 *image;
	u32 stack_size;
};

struct arm64_jit_data {
	struct bpf_binary_header *header;
	u8 *image;
	struct jit_ctx ctx;
};

typedef s8 int8_t;

typedef s16 int16_t;

typedef u16 uint16_t;

typedef u64 uint64_t;

typedef s64 int64_t;

typedef uint64_t xen_pfn_t;

typedef uint64_t xen_ulong_t;

typedef int64_t xen_long_t;

typedef struct {
	union {
		unsigned char *p;
		uint64_t q;
	};
} __guest_handle_uchar;

typedef struct {
	union {
		char *p;
		uint64_t q;
	};
} __guest_handle_char;

typedef struct {
	union {
		void *p;
		uint64_t q;
	};
} __guest_handle_void;

typedef struct {
	union {
		uint64_t *p;
		uint64_t q;
	};
} __guest_handle_uint64_t;

typedef struct {
	union {
		uint32_t *p;
		uint64_t q;
	};
} __guest_handle_uint32_t;

struct arch_vcpu_info {};

struct arch_shared_info {};

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct pvclock_wall_clock {
	u32 version;
	u32 sec;
	u32 nsec;
	u32 sec_hi;
};

typedef uint16_t domid_t;

struct multicall_entry {
	xen_ulong_t op;
	xen_long_t result;
	xen_ulong_t args[6];
};

struct vcpu_info {
	uint8_t evtchn_upcall_pending;
	uint8_t evtchn_upcall_mask;
	xen_ulong_t evtchn_pending_sel;
	struct arch_vcpu_info arch;
	struct pvclock_vcpu_time_info time;
};

struct shared_info {
	struct vcpu_info vcpu_info[1];
	xen_ulong_t evtchn_pending[64];
	xen_ulong_t evtchn_mask[64];
	struct pvclock_wall_clock wc;
	uint32_t wc_sec_hi;
	struct arch_shared_info arch;
};

struct start_info {
	char magic[32];
	long unsigned int nr_pages;
	long unsigned int shared_info;
	uint32_t flags;
	xen_pfn_t store_mfn;
	uint32_t store_evtchn;
	union {
		struct {
			xen_pfn_t mfn;
			uint32_t evtchn;
		} domU;
		struct {
			uint32_t info_off;
			uint32_t info_size;
		} dom0;
	} console;
	long unsigned int pt_base;
	long unsigned int nr_pt_frames;
	long unsigned int mfn_list;
	long unsigned int mod_start;
	long unsigned int mod_len;
	int8_t cmd_line[1024];
	long unsigned int first_p2m_pfn;
	long unsigned int nr_p2m_frames;
};

struct dom0_vga_console_info {
	uint8_t video_type;
	union {
		struct {
			uint16_t font_height;
			uint16_t cursor_x;
			uint16_t cursor_y;
			uint16_t rows;
			uint16_t columns;
		} text_mode_3;
		struct {
			uint16_t width;
			uint16_t height;
			uint16_t bytes_per_line;
			uint16_t bits_per_pixel;
			uint32_t lfb_base;
			uint32_t lfb_size;
			uint8_t red_pos;
			uint8_t red_size;
			uint8_t green_pos;
			uint8_t green_size;
			uint8_t blue_pos;
			uint8_t blue_size;
			uint8_t rsvd_pos;
			uint8_t rsvd_size;
			uint32_t gbl_caps;
			uint16_t mode_attrs;
		} vesa_lfb;
	} u;
};

enum clocksource_ids {
	CSID_GENERIC = 0,
	CSID_ARM_ARCH_COUNTER = 1,
	CSID_MAX = 2,
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_ARCHTIMER = 1,
	VDSO_CLOCKMODE_ARCHTIMER_NOCOMPAT = 2,
	VDSO_CLOCKMODE_MAX = 3,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u32 uncertainty_margin;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum clocksource_ids id;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct module *owner;
};

struct sched_shutdown {
	unsigned int reason;
};

struct xenpf_settime32 {
	uint32_t secs;
	uint32_t nsecs;
	uint64_t system_time;
};

struct xenpf_settime64 {
	uint64_t secs;
	uint32_t nsecs;
	uint32_t mbz;
	uint64_t system_time;
};

struct xenpf_add_memtype {
	xen_pfn_t mfn;
	uint64_t nr_mfns;
	uint32_t type;
	uint32_t handle;
	uint32_t reg;
};

struct xenpf_del_memtype {
	uint32_t handle;
	uint32_t reg;
};

struct xenpf_read_memtype {
	uint32_t reg;
	xen_pfn_t mfn;
	uint64_t nr_mfns;
	uint32_t type;
};

struct xenpf_microcode_update {
	__guest_handle_void data;
	uint32_t length;
};

struct xenpf_platform_quirk {
	uint32_t quirk_id;
};

struct xenpf_efi_time {
	uint16_t year;
	uint8_t month;
	uint8_t day;
	uint8_t hour;
	uint8_t min;
	uint8_t sec;
	uint32_t ns;
	int16_t tz;
	uint8_t daylight;
};

struct xenpf_efi_guid {
	uint32_t data1;
	uint16_t data2;
	uint16_t data3;
	uint8_t data4[8];
};

struct xenpf_efi_runtime_call {
	uint32_t function;
	uint32_t misc;
	xen_ulong_t status;
	union {
		struct {
			struct xenpf_efi_time time;
			uint32_t resolution;
			uint32_t accuracy;
		} get_time;
		struct xenpf_efi_time set_time;
		struct xenpf_efi_time get_wakeup_time;
		struct xenpf_efi_time set_wakeup_time;
		struct {
			__guest_handle_void name;
			xen_ulong_t size;
			__guest_handle_void data;
			struct xenpf_efi_guid vendor_guid;
		} get_variable;
		struct {
			__guest_handle_void name;
			xen_ulong_t size;
			__guest_handle_void data;
			struct xenpf_efi_guid vendor_guid;
		} set_variable;
		struct {
			xen_ulong_t size;
			__guest_handle_void name;
			struct xenpf_efi_guid vendor_guid;
		} get_next_variable_name;
		struct {
			uint32_t attr;
			uint64_t max_store_size;
			uint64_t remain_store_size;
			uint64_t max_size;
		} query_variable_info;
		struct {
			__guest_handle_void capsule_header_array;
			xen_ulong_t capsule_count;
			uint64_t max_capsule_size;
			uint32_t reset_type;
		} query_capsule_capabilities;
		struct {
			__guest_handle_void capsule_header_array;
			xen_ulong_t capsule_count;
			uint64_t sg_list;
		} update_capsule;
	} u;
};

union xenpf_efi_info {
	uint32_t version;
	struct {
		uint64_t addr;
		uint32_t nent;
	} cfg;
	struct {
		uint32_t revision;
		uint32_t bufsz;
		__guest_handle_void name;
	} vendor;
	struct {
		uint64_t addr;
		uint64_t size;
		uint64_t attr;
		uint32_t type;
	} mem;
};

struct xenpf_firmware_info {
	uint32_t type;
	uint32_t index;
	union {
		struct {
			uint8_t device;
			uint8_t version;
			uint16_t interface_support;
			uint16_t legacy_max_cylinder;
			uint8_t legacy_max_head;
			uint8_t legacy_sectors_per_track;
			__guest_handle_void edd_params;
		} disk_info;
		struct {
			uint8_t device;
			uint32_t mbr_signature;
		} disk_mbr_signature;
		struct {
			uint8_t capabilities;
			uint8_t edid_transfer_time;
			__guest_handle_uchar edid;
		} vbeddc_info;
		union xenpf_efi_info efi_info;
		uint8_t kbd_shift_flags;
	} u;
};

struct xenpf_enter_acpi_sleep {
	uint16_t val_a;
	uint16_t val_b;
	uint32_t sleep_state;
	uint32_t flags;
};

struct xenpf_change_freq {
	uint32_t flags;
	uint32_t cpu;
	uint64_t freq;
};

struct xenpf_getidletime {
	__guest_handle_uchar cpumap_bitmap;
	uint32_t cpumap_nr_cpus;
	__guest_handle_uint64_t idletime;
	uint64_t now;
};

struct xen_power_register {
	uint32_t space_id;
	uint32_t bit_width;
	uint32_t bit_offset;
	uint32_t access_size;
	uint64_t address;
};

struct xen_processor_csd {
	uint32_t domain;
	uint32_t coord_type;
	uint32_t num;
};

typedef struct {
	union {
		struct xen_processor_csd *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_csd;

struct xen_processor_cx {
	struct xen_power_register reg;
	uint8_t type;
	uint32_t latency;
	uint32_t power;
	uint32_t dpcnt;
	__guest_handle_xen_processor_csd dp;
};

typedef struct {
	union {
		struct xen_processor_cx *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_cx;

struct xen_processor_flags {
	uint32_t bm_control: 1;
	uint32_t bm_check: 1;
	uint32_t has_cst: 1;
	uint32_t power_setup_done: 1;
	uint32_t bm_rld_set: 1;
};

struct xen_processor_power {
	uint32_t count;
	struct xen_processor_flags flags;
	__guest_handle_xen_processor_cx states;
};

struct xen_pct_register {
	uint8_t descriptor;
	uint16_t length;
	uint8_t space_id;
	uint8_t bit_width;
	uint8_t bit_offset;
	uint8_t reserved;
	uint64_t address;
};

struct xen_processor_px {
	uint64_t core_frequency;
	uint64_t power;
	uint64_t transition_latency;
	uint64_t bus_master_latency;
	uint64_t control;
	uint64_t status;
};

typedef struct {
	union {
		struct xen_processor_px *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_px;

struct xen_psd_package {
	uint64_t num_entries;
	uint64_t revision;
	uint64_t domain;
	uint64_t coord_type;
	uint64_t num_processors;
};

struct xen_processor_performance {
	uint32_t flags;
	uint32_t platform_limit;
	struct xen_pct_register control_register;
	struct xen_pct_register status_register;
	uint32_t state_count;
	__guest_handle_xen_processor_px states;
	struct xen_psd_package domain_info;
	uint32_t shared_type;
};

struct xenpf_set_processor_pminfo {
	uint32_t id;
	uint32_t type;
	union {
		struct xen_processor_power power;
		struct xen_processor_performance perf;
		__guest_handle_uint32_t pdc;
	};
};

struct xenpf_pcpuinfo {
	uint32_t xen_cpuid;
	uint32_t max_present;
	uint32_t flags;
	uint32_t apic_id;
	uint32_t acpi_id;
};

struct xenpf_cpu_ol {
	uint32_t cpuid;
};

struct xenpf_cpu_hotadd {
	uint32_t apic_id;
	uint32_t acpi_id;
	uint32_t pxm;
};

struct xenpf_mem_hotadd {
	uint64_t spfn;
	uint64_t epfn;
	uint32_t pxm;
	uint32_t flags;
};

struct xenpf_core_parking {
	uint32_t type;
	uint32_t idle_nums;
};

struct xenpf_symdata {
	uint32_t namelen;
	uint32_t symnum;
	__guest_handle_char name;
	uint64_t address;
	char type;
};

struct xen_platform_op {
	uint32_t cmd;
	uint32_t interface_version;
	union {
		struct xenpf_settime32 settime32;
		struct xenpf_settime64 settime64;
		struct xenpf_add_memtype add_memtype;
		struct xenpf_del_memtype del_memtype;
		struct xenpf_read_memtype read_memtype;
		struct xenpf_microcode_update microcode;
		struct xenpf_platform_quirk platform_quirk;
		struct xenpf_efi_runtime_call efi_runtime_call;
		struct xenpf_firmware_info firmware_info;
		struct xenpf_enter_acpi_sleep enter_acpi_sleep;
		struct xenpf_change_freq change_freq;
		struct xenpf_getidletime getidletime;
		struct xenpf_set_processor_pminfo set_pminfo;
		struct xenpf_pcpuinfo pcpu_info;
		struct xenpf_cpu_ol cpu_ol;
		struct xenpf_cpu_hotadd cpu_add;
		struct xenpf_mem_hotadd mem_add;
		struct xenpf_core_parking core_parking;
		struct xenpf_symdata symdata;
		struct dom0_vga_console_info dom0_console;
		uint8_t pad[128];
	} u;
};

struct xen_memory_region {
	long unsigned int start_pfn;
	long unsigned int n_pfns;
};

struct grant_frames {
	xen_pfn_t *pfn;
	unsigned int count;
	void *vaddr;
};

struct vcpu_register_vcpu_info {
	uint64_t mfn;
	uint32_t offset;
	uint32_t rsvd;
};

struct xen_add_to_physmap {
	domid_t domid;
	uint16_t size;
	unsigned int space;
	xen_ulong_t idx;
	xen_pfn_t gpfn;
};

struct xsd_errors {
	int errnum;
	const char *errstring;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

typedef uint16_t grant_status_t;

typedef uint32_t grant_ref_t;

typedef uint32_t grant_handle_t;

struct gnttab_map_grant_ref {
	uint64_t host_addr;
	uint32_t flags;
	grant_ref_t ref;
	domid_t dom;
	int16_t status;
	grant_handle_t handle;
	uint64_t dev_bus_addr;
};

struct gnttab_unmap_grant_ref {
	uint64_t host_addr;
	uint64_t dev_bus_addr;
	grant_handle_t handle;
	int16_t status;
};

struct xen_p2m_entry {
	long unsigned int pfn;
	long unsigned int mfn;
	long unsigned int nr_pages;
	struct rb_node rbnode_phys;
};

struct gnttab_cache_flush {
	union {
		uint64_t dev_bus_addr;
		grant_ref_t ref;
	} a;
	uint16_t offset;
	uint16_t length;
	uint32_t op;
};

typedef void (*exitcall_t)();

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__crt_ctx[0];
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

struct crypto_shash;

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct crypto_shash {
	unsigned int descsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	unsigned int descsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int digestsize;
	unsigned int statesize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

typedef void sha256_block_fn(struct sha256_state *, const u8 *, int);

struct cpu_feature {
	__u16 feature;
};

struct sha256_ce_state {
	struct sha256_state sst;
	u32 finalize;
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

typedef struct {
	__be64 a;
	__be64 b;
} be128;

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct ghash_key {
	be128 k;
	u64 h[0];
};

struct ghash_desc_ctx {
	u64 digest[2];
	u8 buf[16];
	u32 count;
};

struct gcm_aes_ctx {
	struct crypto_aes_ctx aes_key;
	struct ghash_key ghash_key;
};

struct aes_block {
	u8 b[16];
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_skcipher {
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_aes_xts_ctx {
	struct crypto_aes_ctx key1;
	long: 0;
	struct crypto_aes_ctx key2;
	long: 0;
};

struct crypto_aes_essiv_cbc_ctx {
	struct crypto_aes_ctx key1;
	long: 0;
	struct crypto_aes_ctx key2;
	struct crypto_shash *hash;
};

struct mac_tfm_ctx {
	struct crypto_aes_ctx key;
	long: 0;
	u8 consts[0];
};

struct mac_desc_ctx {
	unsigned int len;
	u8 dg[16];
};

typedef void (*rcu_callback_t)(struct callback_head *);

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_INACTIVE_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_INACTIVE = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 16,
	WORK_CPU_UNBOUND = 64,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 59,
	WORK_OFFQ_POOL_BITS = 31,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	int io_thread;
	struct cgroup *cgrp;
	struct css_set *cset;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

typedef struct poll_table_struct poll_table;

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

struct audit_context;

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

typedef struct {} mm_segment_t;

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

typedef struct {
	unsigned int __softirq_pending;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

typedef void (*dr_release_t)(struct device *, void *);

typedef int (*dr_match_t)(struct device *, void *, void *);

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

typedef __kernel_clock_t clock_t;

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
	long unsigned int pgoff;
	struct file *file;
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct ucounts *ucounts;
};

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct fd {
	struct file *file;
	unsigned int flags;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

enum sig_handler {
	HANDLER_CURRENT = 0,
	HANDLER_SIG_DFL = 1,
	HANDLER_EXIT = 2,
};

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

enum uts_proc {
	UTS_PROC_OSTYPE = 0,
	UTS_PROC_OSRELEASE = 1,
	UTS_PROC_VERSION = 2,
	UTS_PROC_HOSTNAME = 3,
	UTS_PROC_DOMAINNAME = 4,
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

typedef unsigned int xa_mark_t;

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct ida {
	struct xarray xa;
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

struct __una_u32 {
	u32 x;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	unsigned int current_color;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[16];
	int nr_active;
	int max_active;
	struct list_head inactive_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	long: 64;
	long: 64;
	long: 64;
	atomic_t nr_running;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 30000,
	MAYDAY_INITIAL_TIMEOUT = 2,
	MAYDAY_INTERVAL = 10,
	CREATE_COOLDOWN = 100,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	u32 __data_loc_workqueue;
	unsigned int req_cpu;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_queue_work {
	u32 workqueue;
};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

typedef void (*btf_trace_workqueue_queue_work)(void *, unsigned int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

typedef struct {} local_lock_t;

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_PCMCIA_CIS = 10,
	LOCKDOWN_TIOCSSERIAL = 11,
	LOCKDOWN_MODULE_PARAMETERS = 12,
	LOCKDOWN_MMIOTRACE = 13,
	LOCKDOWN_DEBUGFS = 14,
	LOCKDOWN_XMON_WR = 15,
	LOCKDOWN_BPF_WRITE_USER = 16,
	LOCKDOWN_DBG_WRITE_KERNEL = 17,
	LOCKDOWN_INTEGRITY_MAX = 18,
	LOCKDOWN_KCORE = 19,
	LOCKDOWN_KPROBES = 20,
	LOCKDOWN_BPF_READ_KERNEL = 21,
	LOCKDOWN_DBG_READ_KERNEL = 22,
	LOCKDOWN_PERF = 23,
	LOCKDOWN_TRACEFS = 24,
	LOCKDOWN_XMON_RW = 25,
	LOCKDOWN_XFRM_SECRET = 26,
	LOCKDOWN_CONFIDENTIALITY_MAX = 27,
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct sched_param {
	int sched_priority;
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	int (*threadfn)(void *);
	void *data;
	mm_segment_t oldfs;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	int next_id;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	atomic_t msg_bytes;
	atomic_t msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct pin_cookie {};

struct static_key_true {
	struct static_key key;
};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

typedef struct __call_single_data call_single_data_t;

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_gen;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
};

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_h_nr_running;
	u64 exec_clock;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
	long unsigned int tg_load_avg_contrib;
	long int propagate;
	long int prop_runnable_sum;
	long unsigned int h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int idle;
	int runtime_enabled;
	s64 runtime_remaining;
	u64 throttled_clock;
	u64 throttled_clock_pelt;
	u64 throttled_clock_pelt_time;
	int throttled;
	int throttle_count;
	struct list_head throttled_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	unsigned int rt_nr_migratory;
	unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
	unsigned int rt_nr_boosted;
	struct rq *rq;
	struct task_group *tg;
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
};

struct cfs_bandwidth {
	raw_spinlock_t lock;
	ktime_t period;
	u64 quota;
	u64 runtime;
	u64 burst;
	s64 hierarchical_quota;
	u8 idle;
	u8 period_active;
	u8 slack_started;
	struct hrtimer period_timer;
	struct hrtimer slack_timer;
	struct list_head throttled_cfs_rq;
	int nr_periods;
	int nr_throttled;
	u64 throttled_time;
};

struct task_group {
	struct cgroup_subsys_state css;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	long unsigned int shares;
	int idle;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct sched_rt_entity **rt_se;
	struct rt_rq **rt_rq;
	struct rt_bandwidth rt_bandwidth;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct cfs_bandwidth cfs_bandwidth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sched_domain_attr {
	int relax_domain_level;
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
	int nr_idle_scan;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int next_decay_max_lb_cost;
	u64 avg_scan_cost;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

struct sched_group_capacity;

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	long unsigned int cpumask[0];
};

struct em_perf_state {
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
};

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	int milliwatts;
	long unsigned int cpus[0];
};

struct kernel_cpustat {
	u64 cpustat[10];
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	CFTYPE_PRESSURE = 64,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);

struct dl_rq {
	struct rb_root_cached root;
	unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	long unsigned int caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpuidle_state;

struct rq {
	raw_spinlock_t __lock;
	unsigned int nr_running;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
	unsigned int numa_migrate_on;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	long: 64;
	long: 64;
	long: 64;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	long unsigned int cpu_capacity_inverted;
	struct callback_head *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	struct sched_avg avg_thermal;
	u64 idle_stamp;
	u64 avg_idle;
	long unsigned int wake_stamp;
	u64 wake_avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	u64 prev_steal_time;
	long unsigned int calc_load_update;
	long int calc_load_active;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_thermal_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);

typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain *, bool);

typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	s64 exit_latency_ns;
	s64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_state_kobj;

struct cpuidle_driver_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	u64 dl_runtime;
	u64 dl_period;
};

typedef int (*tg_visitor)(struct task_group *, void *);

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_HRTICK_DL = 7,
	__SCHED_FEAT_DOUBLE_TICK = 8,
	__SCHED_FEAT_NONTASK_CAPACITY = 9,
	__SCHED_FEAT_TTWU_QUEUE = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_SIS_UTIL = 12,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 13,
	__SCHED_FEAT_RT_PUSH_IPI = 14,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 15,
	__SCHED_FEAT_LB_MIN = 16,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 17,
	__SCHED_FEAT_WA_IDLE = 18,
	__SCHED_FEAT_WA_WEIGHT = 19,
	__SCHED_FEAT_WA_BIAS = 20,
	__SCHED_FEAT_UTIL_EST = 21,
	__SCHED_FEAT_UTIL_EST_FASTUP = 22,
	__SCHED_FEAT_LATENCY_WARN = 23,
	__SCHED_FEAT_ALT_PERIOD = 24,
	__SCHED_FEAT_BASE_SLICE = 25,
	__SCHED_FEAT_NR = 26,
};

enum cpu_util_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct set_affinity_pending {
	refcount_t refs;
	unsigned int stop_pending;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

struct migration_swap_arg {
	struct task_struct *src_task;
	struct task_struct *dst_task;
	int src_cpu;
	int dst_cpu;
};

struct cfs_schedulable_data {
	struct task_group *tg;
	u64 period;
	u64 quota;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_ASYM_CPUCAPACITY_FULL = 64,
	SD_SHARE_CPUCAPACITY = 128,
	SD_SHARE_PKG_RESOURCES = 256,
	SD_SERIALIZE = 512,
	SD_ASYM_PACKING = 1024,
	SD_PREFER_SIBLING = 2048,
	SD_OVERLAP = 4096,
	SD_NUMA = 8192,
};

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

enum uclamp_id {
	UCLAMP_MIN = 0,
	UCLAMP_MAX = 1,
	UCLAMP_CNT = 2,
};

struct numa_group {
	refcount_t refcount;
	spinlock_t lock;
	int nr_tasks;
	pid_t gid;
	int active_nodes;
	struct callback_head rcu;
	long unsigned int total_faults;
	long unsigned int max_faults_cpu;
	long unsigned int *faults_cpu;
	long unsigned int faults[0];
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum numa_faults_stats {
	NUMA_MEM = 0,
	NUMA_CPU = 1,
	NUMA_MEMBUF = 2,
	NUMA_CPUBUF = 3,
};

enum numa_type {
	node_has_spare = 0,
	node_fully_busy = 1,
	node_overloaded = 2,
};

struct numa_stats {
	long unsigned int load;
	long unsigned int runnable;
	long unsigned int util;
	long unsigned int compute_capacity;
	unsigned int nr_running;
	unsigned int weight;
	enum numa_type node_type;
	int idle_cpu;
};

struct task_numa_env {
	struct task_struct *p;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	struct numa_stats src_stats;
	struct numa_stats dst_stats;
	int imbalance_pct;
	int dist;
	struct task_struct *best_task;
	long int best_imp;
	int best_cpu;
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_asym_packing = 3,
	group_imbalanced = 4,
	group_overloaded = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	long unsigned int group_misfit_task_load;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

typedef struct task_group *rt_rq_iter_t;

struct rt_schedulable_data {
	struct task_group *tg;
	u64 rt_period;
	u64 rt_runtime;
};

enum dl_bw_request {
	dl_bw_req_check_overflow = 0,
	dl_bw_req_alloc = 1,
	dl_bw_req_free = 2,
};

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

struct asym_cap_data {
	struct list_head link;
	long unsigned int capacity;
	long unsigned int cpus[0];
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

struct cpuacct {
	struct cgroup_subsys_state css;
	u64 *cpuusage;
	struct kernel_cpustat *cpustat;
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int util;
	long unsigned int bw_dl;
	long unsigned int max;
	long unsigned int saved_idle_calls;
};

typedef bool (*smp_cond_func_t)(int, void *);

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	bool handoff_set;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked;
	int count;
};

struct qnode {
	struct mcs_spinlock mcs;
};

struct rt_mutex_base {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

struct rt_mutex {
	struct rt_mutex_base rtmutex;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct rt_waiter_node {
	struct rb_node entry;
	int prio;
	u64 deadline;
};

struct rt_mutex_waiter {
	struct rt_waiter_node tree;
	struct rt_waiter_node pi_tree;
	struct task_struct *task;
	struct rt_mutex_base *lock;
	unsigned int wake_state;
	struct ww_acquire_ctx *ww_ctx;
};

struct rt_wake_q_head {
	struct wake_q_head head;
	struct task_struct *rtlock_task;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

typedef int suspend_state_t;

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	enum suspend_stat_step failed_steps[2];
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct platform_hibernation_ops {
	int (*begin)(pm_message_t);
	void (*end)();
	int (*pre_snapshot)();
	void (*finish)();
	int (*prepare)();
	int (*enter)();
	void (*leave)();
	int (*pre_restore)();
	void (*restore_cleanup)();
	void (*recover)();
};

enum {
	HIBERNATION_INVALID = 0,
	HIBERNATION_PLATFORM = 1,
	HIBERNATION_SHUTDOWN = 2,
	HIBERNATION_REBOOT = 3,
	HIBERNATION_SUSPEND = 4,
	HIBERNATION_TEST_RESUME = 5,
	__HIBERNATION_AFTER_LAST = 6,
};

struct swsusp_info {
	struct new_utsname uts;
	u32 version_code;
	long unsigned int num_physpages;
	int cpus;
	long unsigned int image_pages;
	long unsigned int pages;
	long unsigned int size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct snapshot_handle {
	unsigned int cur;
	void *buffer;
	int sync_read;
};

struct linked_page {
	struct linked_page *next;
	char data[4088];
};

struct chain_allocator {
	struct linked_page *chain;
	unsigned int used_space;
	gfp_t gfp_mask;
	int safe_needed;
};

struct rtree_node {
	struct list_head list;
	long unsigned int *data;
};

struct mem_zone_bm_rtree {
	struct list_head list;
	struct list_head nodes;
	struct list_head leaves;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	struct rtree_node *rtree;
	int levels;
	unsigned int blocks;
};

struct bm_position {
	struct mem_zone_bm_rtree *zone;
	struct rtree_node *node;
	long unsigned int node_pfn;
	int node_bit;
};

struct memory_bitmap {
	struct list_head zones;
	struct linked_page *p_list;
	struct bm_position cur;
};

struct mem_extent {
	struct list_head hook;
	long unsigned int start;
	long unsigned int end;
};

struct nosave_region {
	struct list_head list;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
};

typedef struct {
	long unsigned int val;
} swp_entry_t;

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_WORKINGSET = 3,
	BIO_QUIET = 4,
	BIO_CHAIN = 5,
	BIO_REFFED = 6,
	BIO_THROTTLED = 7,
	BIO_TRACE_COMPLETION = 8,
	BIO_CGROUP_ACCT = 9,
	BIO_QOS_THROTTLED = 10,
	BIO_QOS_MERGED = 11,
	BIO_REMAPPED = 12,
	BIO_ZONE_WRITE_LOCKED = 13,
	BIO_PERCPU_CACHE = 14,
	BIO_FLAG_LAST = 15,
};

enum req_opf {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_SAME = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_CGROUP_PUNT = 22,
	__REQ_NOUNMAP = 23,
	__REQ_HIPRI = 24,
	__REQ_DRV = 25,
	__REQ_SWAP = 26,
	__REQ_NR_BITS = 27,
};

struct swap_map_page {
	sector_t entries[511];
	sector_t next_swap;
};

struct swap_map_page_list {
	struct swap_map_page *map;
	struct swap_map_page_list *next;
};

struct swap_map_handle {
	struct swap_map_page *cur;
	struct swap_map_page_list *maps;
	sector_t cur_swap;
	sector_t first_sector;
	unsigned int k;
	long unsigned int reqd_free_pages;
	u32 crc32;
};

struct swsusp_header {
	char reserved[4060];
	u32 crc32;
	sector_t image;
	unsigned int flags;
	char orig_sig[10];
	char sig[10];
};

struct swsusp_extent {
	struct rb_node node;
	long unsigned int start;
	long unsigned int end;
};

struct hib_bio_batch {
	atomic_t count;
	wait_queue_head_t wait;
	blk_status_t error;
	struct blk_plug plug;
};

struct crc_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	unsigned int run_threads;
	wait_queue_head_t go;
	wait_queue_head_t done;
	u32 *crc32;
	size_t *unc_len[3];
	unsigned char *unc[3];
};

struct cmp_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
	unsigned char wrk[16384];
};

struct dec_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
};

typedef s64 compat_loff_t;

struct resume_swap_area {
	__kernel_loff_t offset;
	__u32 dev;
} __attribute__((packed));

struct snapshot_data {
	struct snapshot_handle handle;
	int swap;
	int mode;
	bool frozen;
	bool ready;
	bool platform_support;
	bool free_bitmaps;
	dev_t dev;
};

struct compat_resume_swap_area {
	compat_loff_t offset;
	u32 dev;
} __attribute__((packed));

struct sysrq_key_op {
	void (* const handler)(int);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

typedef unsigned int uint;

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	uint ispeed;
	uint ospeed;
	void *data;
	struct console *next;
};

struct kmsg_dump_iter {
	u64 cur_seq;
	u64 next_seq;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool registered;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

enum desc_state {
	desc_miss = 4294967295,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum printk_info_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

struct latched_seq {
	seqcount_latch_t latch;
	u64 val[2];
};

struct devkmsg_user {
	atomic64_t seq;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
	struct printk_info info;
	char text_buf[8192];
	struct printk_record record;
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 1073741824,
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
	IRQS_SYSFS = 16384,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQ_NO_DEBUG = 2097152,
	_IRQF_MODIFY_MASK = 2096911,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
	IRQTF_READY = 4,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NO_MAP = 128,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

struct msi_alloc_info {
	struct msi_desc *desc;
	irq_hw_number_t hwirq;
	long unsigned int flags;
	union {
		long unsigned int ul;
		void *ptr;
	} scratchpad[2];
};

typedef struct msi_alloc_info msi_alloc_info_t;

struct msi_domain_info;

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*msi_finish)(msi_alloc_info_t *, int);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*handle_error)(struct irq_domain *, struct msi_desc *, int);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
};

struct msi_domain_info {
	u32 flags;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_MULTI_PCI_MSI = 4,
	MSI_FLAG_PCI_MSIX = 8,
	MSI_FLAG_ACTIVATE_EARLY = 16,
	MSI_FLAG_MUST_REACTIVATE = 32,
	MSI_FLAG_LEVEL_CAPABLE = 64,
};

struct cpu_topology {
	int thread_id;
	int core_id;
	int package_id;
	int llc_id;
	cpumask_t thread_sibling;
	cpumask_t core_sibling;
	cpumask_t llc_sibling;
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_stall_warning {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)();

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

struct rcu_tasks {
	struct callback_head *cbs_head;
	struct callback_head **cbs_tail;
	struct wait_queue_head cbs_wq;
	raw_spinlock_t cbs_lock;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int n_gps;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	char *name;
	char *kname;
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

typedef long unsigned int ulong;

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int ofl_seq;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long unsigned int n_boosts;
	long: 64;
	raw_spinlock_t fqslock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool exp_deferred_qs;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
	atomic_t dynticks;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[5];
	struct rcu_node *level[3];
	int ncpus;
	int n_online_cpus;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 boost;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	long: 64;
	long: 64;
	raw_spinlock_t ofl_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kvfree_rcu_bulk_data {
	long unsigned int nr_records;
	struct kvfree_rcu_bulk_data *next;
	void *records[0];
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct kvfree_rcu_bulk_data *bkvhead_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	struct kvfree_rcu_bulk_data *bkvhead[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool monitor_todo;
	bool initialized;
	int count;
	struct delayed_work page_cache_work;
	atomic_t backoff_page_cache_fill;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct rcu_stall_chk_rdr {
	int nesting;
	union rcu_special rs;
	bool on_blkd_list;
};

struct dma_sgt_handle {
	struct sg_table sgt;
	struct page **pages;
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct cma {
	long unsigned int base_pfn;
	long unsigned int count;
	long unsigned int *bitmap;
	unsigned int order_per_bit;
	spinlock_t lock;
	char name[64];
};

struct reserved_mem_ops;

struct reserved_mem {
	const char *name;
	long unsigned int fdt_node;
	long unsigned int phandle;
	const struct reserved_mem_ops *ops;
	phys_addr_t base;
	phys_addr_t size;
	void *priv;
};

struct reserved_mem_ops {
	int (*device_init)(struct reserved_mem *, struct device *);
	void (*device_release)(struct reserved_mem *, struct device *);
};

typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);

struct dma_coherent_mem {
	void *virt_base;
	dma_addr_t device_base;
	long unsigned int pfn_base;
	int size;
	long unsigned int *bitmap;
	spinlock_t spinlock;
	bool use_dev_dma_pfn_offset;
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	enum swiotlb_force swiotlb_force;
	char __data[0];
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
};

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t, enum swiotlb_force);

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

struct stacktrace_cookie {
	long unsigned int *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_suseconds_t suseconds_t;

typedef __u64 timeu64_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	long unsigned int pending_map[8];
	struct hlist_head vectors[512];
	long: 64;
	long: 64;
	long: 64;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	enum clocksource_ids cs_id;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
};

struct audit_ntp_data {};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	int uie_unsupported;
	long unsigned int set_offset_nsec;
	long unsigned int features[1];
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
	long unsigned int last_tick_jiffies;
	unsigned int stalled_jiffies;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

typedef __kernel_timer_t timer_t;

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
	struct task_struct *handling;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct property_entry;

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

struct clock_data {
	seqcount_latch_t seq;
	struct clock_read_data read_data[2];
	ktime_t wrap_kt;
	long unsigned int rate;
	u64 (*actual_read_sched_clock)();
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex_base pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
	atomic_t requeue_state;
};

enum {
	Q_REQUEUE_PI_NONE = 0,
	Q_REQUEUE_PI_IGNORE = 1,
	Q_REQUEUE_PI_IN_PROGRESS = 2,
	Q_REQUEUE_PI_WAIT = 3,
	Q_REQUEUE_PI_DONE = 4,
	Q_REQUEUE_PI_LOCKED = 5,
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

struct cfd_percpu {
	call_single_data_t csd;
};

struct call_function_data {
	struct cfd_percpu *pcpu;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct modversion_info {
	long unsigned int crc;
	char name[56];
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int flags: 8;
	union {
		struct static_key_true dd_key_true;
		struct static_key_false dd_key_false;
	} key;
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug *debug;
	unsigned int num_debug;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[128];
	char module_name[56];
	int exported;
	int show_value;
};

typedef struct {
	int val[2];
} __kernel_fsid_t;

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

typedef __u16 comp_t;

struct acct_v3 {
	char ac_flag;
	char ac_version;
	__u16 ac_tty;
	__u32 ac_exitcode;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u32 ac_etime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	char ac_comm[16];
};

typedef struct acct_v3 acct_t;

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	int active;
	long unsigned int needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
};

typedef __kernel_ulong_t ino_t;

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	BPF_LINK_TYPE_PERF_EVENT = 7,
	MAX_BPF_LINK_TYPE = 8,
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
			__u32 target_obj_id;
			__u32 target_btf_id;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
	};
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
	CGRP_KILL = 4,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_CPUSET_V2_MODE = 16,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 32,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 64,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_pidlist;

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup_opt_features {
	OPT_FEATURE_COUNT = 0,
};

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_memory_localevents = 1,
	Opt_memory_recursiveprot = 2,
	nr__cgroup2_params = 3,
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
};

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	struct cgroup_file events_file;
	atomic64_t events_limit;
};

typedef struct {
	char *from;
	char *to;
} substring_t;

enum rdmacg_resource_type {
	RDMACG_RESOURCE_HCA_HANDLE = 0,
	RDMACG_RESOURCE_HCA_OBJECT = 1,
	RDMACG_RESOURCE_MAX = 2,
};

struct rdma_cgroup {
	struct cgroup_subsys_state css;
	struct list_head rpools;
};

struct rdmacg_device {
	struct list_head dev_node;
	struct list_head rpools;
	char *name;
};

enum rdmacg_file_type {
	RDMACG_RESOURCE_TYPE_MAX = 0,
	RDMACG_RESOURCE_TYPE_STAT = 1,
};

struct rdmacg_resource {
	int max;
	int usage;
};

struct rdmacg_resource_pool {
	struct rdmacg_device *device;
	struct rdmacg_resource resources[2];
	struct list_head cg_node;
	struct list_head dev_node;
	u64 usage_sum;
	int num_max_cnt;
};

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

struct cpuset {
	struct cgroup_subsys_state css;
	long unsigned int flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t subparts_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int pn;
	int relax_domain_level;
	int nr_subparts_cpus;
	int partition_root_state;
	int use_parent_ecpus;
	int child_ecpus_count;
	int nr_deadline_tasks;
	int nr_migrate_dl_tasks;
	u64 sum_migrate_dl_bw;
	struct cgroup_file partition_file;
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

enum subparts_cmd {
	partcmd_enable = 0,
	partcmd_disable = 1,
	partcmd_update = 2,
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_CPU_EXCLUSIVE = 6,
	FILE_MEM_EXCLUSIVE = 7,
	FILE_MEM_HARDWALL = 8,
	FILE_SCHED_LOAD_BALANCE = 9,
	FILE_PARTITION_ROOT = 10,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 11,
	FILE_MEMORY_PRESSURE_ENABLED = 12,
	FILE_MEMORY_PRESSURE = 13,
	FILE_SPREAD_PAGE = 14,
	FILE_SPREAD_SLAB = 15,
} cpuset_filetype_t;

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct ctl_path {
	const char *procname;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	long unsigned int caller;
	cpu_stop_fn_t fn;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct action_cache {
	long unsigned int allow_native[8];
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct seccomp_metadata {
	__u64 filter_off;
	__u64 flags;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

typedef unsigned int (*bpf_dispatcher_fn)(const void *, const struct bpf_insn *, unsigned int (*)(const void *, const struct bpf_insn *));

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	__u32 ioctl_flags;
	union {
		bool setfd;
		int ret;
	};
	struct completion completion;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

struct tp_transition_snapshot {
	long unsigned int rcu;
	long unsigned int srcu;
	bool ongoing;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

struct ring_buffer_per_cpu;

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	long unsigned int cache_pages_removed;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	long int wait_index;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct trace_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	atomic_t resizing;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_lost;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 event_stamp[5];
	u64 read_stamp;
	long unsigned int pages_removed;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_PARENT = 1,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 2,
	FSNOTIFY_OBJ_TYPE_SB = 3,
	FSNOTIFY_OBJ_TYPE_COUNT = 4,
	FSNOTIFY_OBJ_TYPE_DETACHED = 4,
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

struct trace_pid_list;

struct trace_options;

struct trace_func_repeats;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	int no_filter_buffering_ref;
	struct list_head hist_vars;
	struct trace_func_repeats *last_func_repeats;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

struct trace_pid_list {
	int pid_max;
	long unsigned int *pids;
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_OSNOISE = 16,
	TRACE_TIMERLAT = 17,
	TRACE_RAW_DATA = 18,
	TRACE_FUNC_REPEATS = 19,
	__TRACE_LAST_TYPE = 20,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

struct func_repeats_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
	u16 count;
	u16 top_delta_ts;
	u32 bottom_delta_ts;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	bool ignore_pid;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

struct trace_func_repeats {
	long unsigned int ip;
	long unsigned int parent_ip;
	long unsigned int count;
	u64 ts_last_call;
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 22,
	TRACE_ITER_HASH_PTR_BIT = 23,
	TRACE_ITER_STACKTRACE_BIT = 24,
	TRACE_ITER_LAST_BIT = 25,
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_PAUSE_ON_TRACE = 4194304,
	TRACE_ITER_HASH_PTR = 8388608,
	TRACE_ITER_STACKTRACE = 16777216,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

struct trace_min_max_param {
	struct mutex *lock;
	u64 *val;
	u64 *min;
	u64 *max;
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
};

struct err_info {
	const char **errs;
	u8 type;
	u8 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char cmd[256];
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct osnoise_entry {
	struct trace_entry ent;
	u64 noise;
	u64 runtime;
	u64 max_sample;
	unsigned int hw_count;
	unsigned int nmi_count;
	unsigned int irq_count;
	unsigned int softirq_count;
	unsigned int thread_count;
};

struct timerlat_entry {
	struct trace_entry ent;
	unsigned int seqnum;
	int context;
	u64 timer_latency;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

struct module_string {
	struct list_head next;
	struct module *module;
	char *str;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
	PERF_SAMPLE_MAX = 33554432,
	__PERF_SAMPLE_CALLCHAIN_EARLY = 0,
} __attribute__((mode(word)));

typedef long unsigned int perf_trace_t[256];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

typedef int (*filter_pred_fn_t)(struct filter_pred *, void *);

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_pred {
	filter_pred_fn_t fn;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

struct ustring_buffer {
	char buffer[1024];
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

enum {
	EVENT_TRIGGER_FL_PROBE = 1,
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	int flags;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*func)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_ops *, struct event_trigger_data *);
	void (*free)(struct event_trigger_ops *, struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_ops *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*func)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

struct eprobe_trace_entry_head {
	struct trace_entry ent;
	unsigned int type;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(const char *);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_ST_SYMSTR = 17,
	FETCH_OP_MOD_BF = 18,
	FETCH_OP_LP_ARRAY = 19,
	FETCH_OP_TP_ARG = 20,
	FETCH_OP_END = 21,
	FETCH_NOP_SYMBOL = 22,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	bool is_signed;
	bool is_string;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

enum probe_print_type {
	PROBE_PRINT_NORMAL = 0,
	PROBE_PRINT_RETURN = 1,
	PROBE_PRINT_EVENT = 2,
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_BAD_ADDR_SUFFIX = 11,
	TP_ERR_NO_GROUP_NAME = 12,
	TP_ERR_GROUP_TOO_LONG = 13,
	TP_ERR_BAD_GROUP_NAME = 14,
	TP_ERR_NO_EVENT_NAME = 15,
	TP_ERR_EVENT_TOO_LONG = 16,
	TP_ERR_BAD_EVENT_NAME = 17,
	TP_ERR_EVENT_EXIST = 18,
	TP_ERR_RETVAL_ON_PROBE = 19,
	TP_ERR_BAD_STACK_NUM = 20,
	TP_ERR_BAD_ARG_NUM = 21,
	TP_ERR_BAD_VAR = 22,
	TP_ERR_BAD_REG_NAME = 23,
	TP_ERR_BAD_MEM_ADDR = 24,
	TP_ERR_BAD_IMM = 25,
	TP_ERR_IMMSTR_NO_CLOSE = 26,
	TP_ERR_FILE_ON_KPROBE = 27,
	TP_ERR_BAD_FILE_OFFS = 28,
	TP_ERR_SYM_ON_UPROBE = 29,
	TP_ERR_TOO_MANY_OPS = 30,
	TP_ERR_DEREF_NEED_BRACE = 31,
	TP_ERR_BAD_DEREF_OFFS = 32,
	TP_ERR_DEREF_OPEN_BRACE = 33,
	TP_ERR_COMM_CANT_DEREF = 34,
	TP_ERR_BAD_FETCH_ARG = 35,
	TP_ERR_ARRAY_NO_CLOSE = 36,
	TP_ERR_BAD_ARRAY_SUFFIX = 37,
	TP_ERR_BAD_ARRAY_NUM = 38,
	TP_ERR_ARRAY_TOO_BIG = 39,
	TP_ERR_BAD_TYPE = 40,
	TP_ERR_BAD_STRING = 41,
	TP_ERR_BAD_SYMSTRING = 42,
	TP_ERR_BAD_BITFIELD = 43,
	TP_ERR_ARG_NAME_TOO_LONG = 44,
	TP_ERR_NO_ARG_NAME = 45,
	TP_ERR_BAD_ARG_NAME = 46,
	TP_ERR_USED_ARG_NAME = 47,
	TP_ERR_ARG_TOO_LONG = 48,
	TP_ERR_NO_ARG_BODY = 49,
	TP_ERR_BAD_INSN_BNDRY = 50,
	TP_ERR_FAIL_REG_PROBE = 51,
	TP_ERR_DIFF_PROBE_TYPE = 52,
	TP_ERR_DIFF_ARG_TYPE = 53,
	TP_ERR_SAME_PROBE = 54,
};

struct trace_eprobe {
	const char *event_system;
	const char *event_name;
	struct trace_event_call *event;
	struct dyn_event devent;
	struct trace_probe tp;
};

struct eprobe_data {
	struct trace_event_file *file;
	struct trace_eprobe *ep;
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	BPF_FUNC_sys_bpf = 166,
	BPF_FUNC_btf_find_by_name_kind = 167,
	BPF_FUNC_sys_close = 168,
	BPF_FUNC_timer_init = 169,
	BPF_FUNC_timer_set_callback = 170,
	BPF_FUNC_timer_start = 171,
	BPF_FUNC_timer_cancel = 172,
	BPF_FUNC_get_func_ip = 173,
	BPF_FUNC_get_attach_cookie = 174,
	BPF_FUNC_task_pt_regs = 175,
	__BPF_FUNC_MAX_ID = 176,
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
} __attribute__((mode(word)));

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf *, const struct btf_type *, int, int, enum bpf_access_type, u32 *);
	bool (*check_kfunc_call)(u32);
};

struct bpf_array_aux {
	struct {
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
	} owner;
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

struct bpf_trace_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
};

typedef u32 (*bpf_prog_run_fn)(const struct bpf_prog *, const void *);

typedef struct user_pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_get_current_task_btf)();

typedef u64 (*btf_bpf_task_pt_regs)(struct task_struct *);

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_get_func_ip_tracing)(void *);

typedef u64 (*btf_bpf_get_func_ip_kprobe)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_trace)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_pe)(struct bpf_perf_event_data_kern *);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

typedef int (*dynevent_check_arg_fn_t)(void *);

struct dynevent_arg {
	const char *str;
	char separator;
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
};

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	long unsigned int id;
	char __data[0];
};

struct trace_event_data_offsets_error_report_template {};

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct rhash_lock_head {};

struct zero_copy_allocator;

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
		struct zero_copy_allocator *zc_alloc;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
	__u64 recursion_misses;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

typedef sockptr_t bpfptr_t;

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
	bool is_async_cb;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	struct btf_mod_pair used_btfs[64];
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 id_gen;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct bpf_id_pair idmap_scratch[75];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
	bpfptr_t fd_array;
	char type_str_buf[64];
};

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct {
			struct bpf_map *map_ptr;
			u32 map_uid;
		};
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		u32 mem_size;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
		u32 subprogno;
	};
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

struct bpf_reference_state;

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	u32 async_entry_cnt;
	bool in_callback_fn;
	bool in_async_callback_fn;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
	int callback_ref;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
	};
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_prog_kstats {
	u64 nsecs;
	u64 cnt;
	u64 misses;
};

struct bpf_tracing_link {
	struct bpf_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
};

struct bpf_perf_link {
	struct bpf_link link;
	struct file *perf_file;
};

typedef u64 (*btf_bpf_sys_bpf)(int, void *, u32);

typedef u64 (*btf_bpf_sys_close)(u32);

struct audit_buffer;

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

struct bpf_kfunc_desc {
	struct btf_func_model func_model;
	u32 func_id;
	s32 imm;
};

struct bpf_kfunc_desc_tab {
	struct bpf_kfunc_desc descs[256];
	u32 nr_descs;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	BTF_SOCK_TYPE_UNIX = 13,
	MAX_BTF_SOCK_TYPE = 14,
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int map_uid;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
	u32 subprogno;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum stack_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum {
	AT_PKT_END = 4294967295,
	BEYOND_PKT_END = 4294967294,
};

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

enum {
	REASON_BOUNDS = 4294967295,
	REASON_TYPE = 4294967294,
	REASON_PATHS = 4294967293,
	REASON_LIMIT = 4294967292,
	REASON_STACK = 4294967291,
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct umd_info {
	const char *driver_name;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct path wd;
	struct pid *tgid;
};

struct bpf_preload_info {
	char link_name[16];
	int link_id;
};

struct bpf_preload_ops {
	struct umd_info info;
	int (*preload)(struct bpf_preload_info *);
	int (*finish)();
	struct module *owner;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

struct bpf_cg_run_ctx {
	struct bpf_run_ctx run_ctx;
	const struct bpf_prog_array_item *prog_item;
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_ktime_get_coarse_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long int *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, long unsigned int *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

struct bpf_bprintf_buffers {
	char tmp_bufs[1536];
};

typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);

struct bpf_hrtimer {
	struct hrtimer timer;
	struct bpf_map *map;
	struct bpf_prog *prog;
	void *callback_fn;
	void *value;
};

struct bpf_timer_kern {
	struct bpf_hrtimer *timer;
	struct bpf_spin_lock lock;
};

typedef u64 (*btf_bpf_timer_init)(struct bpf_timer_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_timer_set_callback)(struct bpf_timer_kern *, void *, struct bpf_prog_aux *);

typedef u64 (*btf_bpf_timer_start)(struct bpf_timer_kern *, u64, u64);

typedef u64 (*btf_bpf_timer_cancel)(struct bpf_timer_kern *);

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

typedef const struct bpf_func_proto * (*bpf_iter_get_func_proto_t)(enum bpf_func_id, const struct bpf_prog *);

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	bpf_iter_get_func_proto_t get_func_proto;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 0;
	u8 target_private[0];
};

typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_task_vma_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct vm_area_struct *vma;
	u32 tid;
	long unsigned int prev_vm_start;
	long unsigned int prev_vm_end;
};

enum bpf_task_vma_iter_find_op {
	task_vma_iter_first_vma = 0,
	task_vma_iter_next_vma = 1,
	task_vma_iter_find_vma = 2,
};

struct bpf_iter__task_vma {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	union {
		struct vm_area_struct *vma;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket {
	struct hlist_nulls_head head;
	union {
		raw_spinlock_t raw_lock;
		spinlock_t lock;
	};
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bucket *buckets;
	void *elems;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	atomic_t count;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct bpf_htab *htab;
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		struct callback_head rcu;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	long: 0;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t spinlock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

struct bpf_tramp_progs {
	struct bpf_prog *progs[38];
	int nr_progs;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_var {
	__u32 linkage;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__be16 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
	union {
		struct bpf_sock *sk;
	};
	union {
		struct bpf_sock *migrating_sk;
	};
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sk_lookup {
	union {
		union {
			struct bpf_sock *sk;
		};
		__u64 cookie;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__be16 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	struct sock *migrating_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	const void *data;
	const void *data_end;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	unsigned int count;
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	long: 64;
	struct inet_listen_hashbucket listening_hash[32];
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	u64 tmp_reg;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	s32 retval;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	bool no_reuseport;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	u16 num_closed_socks;
	u16 incoming_cpu;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *stream_parser;
	struct bpf_prog *stream_verdict;
	struct bpf_prog *skb_verdict;
};

struct sk_psock_work_state {
	struct sk_buff *skb;
	u32 len;
	u32 off;
};

struct sk_msg;

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	bool redir_ingress;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	spinlock_t ingress_lock;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_destroy)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	void (*saved_data_ready)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	struct proto *sk_proto;
	struct mutex work_mutex;
	struct sk_psock_work_state work_state;
	struct work_struct work;
	struct rcu_work rwork;
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	s32 delivered;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	u32 last_end_seq;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy;
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, va_list);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
	void *BPF_PROG_TYPE_SYSCALL_prog;
	void *BPF_PROG_TYPE_SYSCALL_kern;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
	__ctx_convertBPF_PROG_TYPE_SYSCALL = 28,
	__ctx_convert_unused = 29,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

enum {
	BTF_MODULE_F_LIVE = 1,
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
	int flags;
};

typedef u64 (*btf_bpf_btf_find_by_name_kind)(char *, int, u32, int);

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	u32 image_off;
	struct bpf_ksym ksym;
};

enum {
	BPF_F_BROADCAST = 8,
	BPF_F_EXCLUDE_INGRESS = 16,
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

enum skb_drop_reason {
	SKB_DROP_REASON_NOT_SPECIFIED = 0,
	SKB_DROP_REASON_NO_SOCKET = 1,
	SKB_DROP_REASON_PKT_TOO_SMALL = 2,
	SKB_DROP_REASON_TCP_CSUM = 3,
	SKB_DROP_REASON_SOCKET_FILTER = 4,
	SKB_DROP_REASON_UDP_CSUM = 5,
	SKB_DROP_REASON_NETFILTER_DROP = 6,
	SKB_DROP_REASON_OTHERHOST = 7,
	SKB_DROP_REASON_IP_CSUM = 8,
	SKB_DROP_REASON_IP_INHDR = 9,
	SKB_DROP_REASON_IP_RPFILTER = 10,
	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 11,
	SKB_DROP_REASON_MAX = 12,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
	IFF_TX_SKB_NO_LINEAR = 2147483648,
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	struct bpf_prog *xdp_prog;
	unsigned int count;
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 map_id;
	enum bpf_map_type map_type;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	long: 64;
	long: 64;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	atomic_t refcnt;
	struct callback_head rcu;
	struct work_struct kthread_stop_wq;
	struct completion kthread_running;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

typedef struct ns_common *ns_get_path_helper_t(void *);

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
} __attribute__((mode(word)));

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	long: 64;
	long: 64;
	long: 64;
};

struct stack_map_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

struct bpf_prog_list {
	struct list_head node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

struct bpf_sockopt_buf {
	u8 data[32];
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

typedef u64 (*btf_bpf_get_netns_cookie_sockopt)(struct bpf_sockopt_kern *);

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	struct callback_head rcu;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_prog **progs;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_MAX = 262144,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_MAX = 16,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_MAX = 21,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct __group_key {
	int cpu;
	struct cgroup *cgroup;
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	u8 build_id[20];
	u32 build_id_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	unsigned int *tsk_pinned;
	unsigned int flexible;
};

struct bp_busy_slots {
	unsigned int pinned;
	unsigned int flexible;
};

struct parallel_data;

struct padata_priv {
	struct list_head list;
	struct parallel_data *pd;
	int cb_cpu;
	unsigned int seq_nr;
	int info;
	void (*parallel)(struct padata_priv *);
	void (*serial)(struct padata_priv *);
};

struct padata_cpumask {
	cpumask_var_t pcpu;
	cpumask_var_t cbcpu;
};

struct padata_shell;

struct padata_list;

struct padata_serial_queue;

struct parallel_data {
	struct padata_shell *ps;
	struct padata_list *reorder_list;
	struct padata_serial_queue *squeue;
	refcount_t refcnt;
	unsigned int seq_nr;
	unsigned int processed;
	int cpu;
	struct padata_cpumask cpumask;
	struct work_struct reorder_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct padata_list {
	struct list_head list;
	spinlock_t lock;
};

struct padata_serial_queue {
	struct padata_list serial;
	struct work_struct work;
	struct parallel_data *pd;
};

struct padata_instance;

struct padata_shell {
	struct padata_instance *pinst;
	struct parallel_data *pd;
	struct parallel_data *opd;
	struct list_head list;
};

struct padata_instance {
	struct hlist_node cpu_online_node;
	struct hlist_node cpu_dead_node;
	struct workqueue_struct *parallel_wq;
	struct workqueue_struct *serial_wq;
	struct list_head pslist;
	struct padata_cpumask cpumask;
	struct kobject kobj;
	struct mutex lock;
	u8 flags;
};

struct padata_mt_job {
	void (*thread_fn)(long unsigned int, long unsigned int, void *);
	void *fn_arg;
	long unsigned int start;
	long unsigned int size;
	long unsigned int align;
	long unsigned int min_chunk;
	int max_threads;
};

struct padata_work {
	struct work_struct pw_work;
	struct list_head pw_list;
	void *pw_data;
};

struct padata_mt_job_state {
	spinlock_t lock;
	struct completion completion;
	struct padata_mt_job *job;
	int nworks;
	int nworks_fini;
	long unsigned int chunk_size;
};

struct padata_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct padata_instance *, struct attribute *, char *);
	ssize_t (*store)(struct padata_instance *, struct attribute *, const char *, size_t);
};

struct static_key_mod {
	struct static_key_mod *next;
	struct jump_entry *entries;
	struct module *mod;
};

struct static_key_deferred {
	struct static_key key;
	long unsigned int timeout;
	struct delayed_work work;
};

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
};

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

typedef int __kernel_rwf_t;

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

struct vm_event_state {
	long unsigned int event[99];
};

enum iter_type {
	ITER_IOVEC = 0,
	ITER_KVEC = 1,
	ITER_BVEC = 2,
	ITER_PIPE = 3,
	ITER_XARRAY = 4,
	ITER_DISCARD = 5,
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_THP_SUPPORT = 6,
};

struct wait_page_key {
	struct page *page;
	int bit_nr;
	int page_match;
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page *pages[15];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
	bool alloc_contig;
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct page *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct page *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct array_cache;

struct kmem_cache_node;

struct kmem_cache {
	struct array_cache *cpu_cache;
	unsigned int batchcount;
	unsigned int limit;
	unsigned int shared;
	unsigned int size;
	struct reciprocal_value reciprocal_buffer_size;
	slab_flags_t flags;
	unsigned int num;
	unsigned int gfporder;
	gfp_t allocflags;
	size_t colour;
	unsigned int colour_off;
	struct kmem_cache *freelist_cache;
	unsigned int freelist_size;
	void (*ctor)(void *);
	const char *name;
	struct list_head list;
	int refcount;
	int object_size;
	int align;
	unsigned int *random_seq;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[4];
};

struct alien_cache;

struct kmem_cache_node {
	spinlock_t list_lock;
	struct list_head slabs_partial;
	struct list_head slabs_full;
	struct list_head slabs_free;
	long unsigned int total_slabs;
	long unsigned int free_slabs;
	long unsigned int free_objects;
	unsigned int free_limit;
	unsigned int colour_next;
	struct array_cache *shared;
	struct alien_cache **alien;
	long unsigned int next_reap;
	int free_touched;
};

struct zap_details {
	struct address_space *check_mapping;
	long unsigned int first_index;
	long unsigned int last_index;
	struct page *single_page;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
	MMU_NOTIFY_EXCLUSIVE = 7,
};

struct mmu_notifier_range {
	struct vm_area_struct *vma;
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *owner;
};

struct mmu_table_batch {
	struct callback_head rcu;
	unsigned int nr;
	void *tables[0];
};

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum wb_congested_state {
	WB_async_congested = 0,
	WB_sync_congested = 1,
};

enum {
	XA_CHECK_SCHED = 4096,
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum {
	BLK_RW_ASYNC = 0,
	BLK_RW_SYNC = 1,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);

enum page_memcg_data_flags {
	MEMCG_DATA_OBJCGS = 1,
	MEMCG_DATA_KMEM = 2,
	__NR_MEMCG_DATA_FLAGS = 4,
};

struct dirty_throttle_control {
	struct wb_domain *dom;
	struct dirty_throttle_control *gdtc;
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

enum {
	LRU_GEN_ANON = 0,
	LRU_GEN_FILE = 1,
};

enum {
	LRU_GEN_CORE = 0,
	LRU_GEN_MM_WALK = 1,
	LRU_GEN_NONLEAF_YOUNG = 2,
	NR_LRU_GEN_CAPS = 3,
};

typedef void compound_page_dtor(struct page *);

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	enum lru_list lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct page *);

typedef void (*btf_trace_mm_lru_activate)(void *, struct page *);

struct lru_rotate {
	local_lock_t lock;
	struct pagevec pvec;
};

struct lru_pvecs {
	local_lock_t lock;
	struct pagevec lru_add;
	struct pagevec lru_deactivate_file;
	struct pagevec lru_deactivate;
	struct pagevec lru_lazyfree;
	struct pagevec activate_page;
};

enum lruvec_flags {
	LRUVEC_CONGESTED = 0,
};

enum {
	MEMCG_LRU_NOP = 0,
	MEMCG_LRU_HEAD = 1,
	MEMCG_LRU_TAIL = 2,
	MEMCG_LRU_OLD = 3,
	MEMCG_LRU_YOUNG = 4,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
	ZONE_RECLAIM_ACTIVE = 1,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

enum ttu_flags {
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
};

struct page_vma_mapped_walk {
	struct page *page;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

typedef struct page *new_page_t(struct page *, long unsigned int);

typedef void free_page_t(struct page *, long unsigned int);

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_LONGTERM_PIN = 7,
	MR_DEMOTION = 8,
	MR_TYPES = 9,
};

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	gfp_t gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	unsigned int isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_writepage {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_writepage {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_writepage)(void *, struct page *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	unsigned int no_demotion: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum page_references {
	PAGEREF_RECLAIM = 0,
	PAGEREF_RECLAIM_CLEAN = 1,
	PAGEREF_KEEP = 2,
	PAGEREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

struct ctrl_pos {
	long unsigned int refaulted;
	long unsigned int total;
	int gain;
};

enum transparent_hugepage_flag {
	TRANSPARENT_HUGEPAGE_NEVER_DAX = 0,
	TRANSPARENT_HUGEPAGE_FLAG = 1,
	TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 2,
	TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG = 3,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG = 4,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG = 5,
	TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 6,
	TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 7,
	TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 8,
};

struct xattr;

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct constant_table {
	const char *name;
	int value;
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_PREFERRED_MANY = 5,
	MPOL_MAX = 6,
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	long unsigned int fallocend;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	raw_spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_NOALLOC = 1,
	SGP_CACHE = 2,
	SGP_WRITE = 3,
	SGP_FALLOC = 4,
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);

typedef void (*pcpu_fc_free_fn_t)(void *, size_t);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, bool, bool, size_t, size_t, void *, int, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	bool isolated;
	int start_offset;
	int end_offset;
	struct obj_cgroup **obj_cgroups;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

struct trace_event_raw_kmem_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_kmem_alloc_node {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kfree {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_kmem_cache_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	gfp_t gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_alloc {};

struct trace_event_data_offsets_kmem_alloc_node {};

struct trace_event_data_offsets_kfree {};

struct trace_event_data_offsets_kmem_cache_free {
	u32 name;
};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmalloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *, const char *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int, long int);

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name[4];
	unsigned int size;
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

struct kmem_obj_info {
	void *kp_ptr;
	struct page *kp_page;
	void *kp_objp;
	long unsigned int kp_data_offset;
	struct kmem_cache *kp_slab_cache;
	void *kp_ret;
	void *kp_stack[16];
	void *kp_free_stack[16];
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct node {
	struct device dev;
	struct list_head access_list;
};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	gfp_t gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, long unsigned int, int, struct list_head *);

typedef void (*btf_trace_mm_compaction_begin)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct trace_event_raw_mmap_lock_start_locking {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_raw_mmap_lock_released {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_data_offsets_mmap_lock_start_locking {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_acquire_returned {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_released {
	u32 memcg_path;
};

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, const char *, bool, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, const char *, bool);

struct memcg_path {
	local_lock_t lock;
	char *buf;
	local_t buf_idx;
};

typedef struct {
	u64 val;
} pfn_t;

typedef unsigned int pgtbl_mod_mask;

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_SCANNING = 16384,
};

struct copy_subpage_arg {
	struct page *dst;
	struct page *src;
	struct vm_area_struct *vma;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_data_offsets_vm_unmapped_area {};

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
	HPAGE_PUD = 3,
};

struct rmap_walk_control {
	void *arg;
	bool (*rmap_one)(struct page *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct page *);
	struct anon_vma * (*anon_lock)(struct page *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct page_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
	};
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

typedef int fpi_t;

struct pagesets {
	local_lock_t lock;
};

struct pcpu_drain {
	struct zone *zone;
	struct work_struct work;
};

struct mminit_pfnnid_cache {
	long unsigned int last_start;
	long unsigned int last_end;
	int last_nid;
};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t *ptes;
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

typedef int filler_t(void *, struct page *);

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

typedef void (*node_registration_func_t)(struct node *);

enum {
	SUBPAGE_INDEX_SUBPOOL = 1,
	__NR_USED_SUBPAGE = 2,
};

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
};

struct file_region {
	struct list_head link;
	long int from;
	long int to;
};

enum hugetlb_page_flags {
	HPG_restore_reserve = 0,
	HPG_migratable = 1,
	HPG_temporary = 2,
	HPG_freed = 3,
	HPG_vmemmap_optimized = 4,
	__NR_HPAGEFLAGS = 5,
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
	VMA_DEL_RESV = 4,
};

struct node_hstate {
	struct kobject *hugepages_kobj;
	struct kobject *hstate_kobjs[4];
};

struct hugetlb_cgroup;

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

typedef u32 compat_ulong_t;

struct sp_node {
	struct rb_node nd;
	long unsigned int start;
	long unsigned int end;
	struct mempolicy *policy;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

struct queue_pages {
	struct list_head *pagelist;
	long unsigned int flags;
	nodemask_t *nmask;
	long unsigned int start;
	long unsigned int end;
	struct vm_area_struct *first;
};

struct vmemmap_remap_walk {
	void (*remap_pte)(pte_t *, long unsigned int, struct vmemmap_remap_walk *);
	long unsigned int nr_walked;
	struct page *reuse_page;
	long unsigned int reuse_addr;
	struct list_head *vmemmap_pages;
};

struct mmu_notifier_subscriptions {
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	long unsigned int invalidate_seq;
	long unsigned int active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

struct mmu_notifier;

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	void (*change_pte)(struct mmu_notifier *, struct mm_struct *, long unsigned int, pte_t);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct mmu_interval_notifier;

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, long unsigned int);
};

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	long unsigned int invalidate_seq;
};

struct rmap_item;

struct mm_slot {
	struct hlist_node link;
	struct list_head mm_list;
	struct rmap_item *rmap_list;
	struct mm_struct *mm;
};

struct stable_node;

struct rmap_item {
	struct rmap_item *rmap_list;
	union {
		struct anon_vma *anon_vma;
		int nid;
	};
	struct mm_struct *mm;
	long unsigned int address;
	unsigned int oldchecksum;
	union {
		struct rb_node node;
		struct {
			struct stable_node *head;
			struct hlist_node hlist;
		};
	};
};

struct ksm_scan {
	struct mm_slot *mm_slot;
	long unsigned int address;
	struct rmap_item **rmap_list;
	long unsigned int seqnr;
};

struct stable_node {
	union {
		struct rb_node node;
		struct {
			struct list_head *head;
			struct {
				struct hlist_node hlist_dup;
				struct list_head list;
			};
		};
	};
	struct hlist_head hlist;
	union {
		long unsigned int kpfn;
		long unsigned int chain_prune_time;
	};
	int rmap_hlist_len;
	int nid;
};

enum get_ksm_page_flags {
	GET_KSM_PAGE_NOLOCK = 0,
	GET_KSM_PAGE_LOCK = 1,
	GET_KSM_PAGE_TRYLOCK = 2,
};

struct memory_notify {
	long unsigned int start_pfn;
	long unsigned int nr_pages;
	int status_change_nid_normal;
	int status_change_nid_high;
	int status_change_nid;
};

struct array_cache {
	unsigned int avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int touched;
	void *entry[0];
};

struct alien_cache {
	spinlock_t lock;
	struct array_cache ac;
};

typedef unsigned char freelist_idx_t;

union freelist_init_state {
	struct {
		unsigned int pos;
		unsigned int *list;
		unsigned int count;
	};
	struct rnd_state rnd_state;
};

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page *b_page;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

typedef u32 compat_uptr_t;

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

enum scan_result {
	SCAN_FAIL = 0,
	SCAN_SUCCEED = 1,
	SCAN_PMD_NULL = 2,
	SCAN_EXCEED_NONE_PTE = 3,
	SCAN_EXCEED_SWAP_PTE = 4,
	SCAN_EXCEED_SHARED_PTE = 5,
	SCAN_PTE_NON_PRESENT = 6,
	SCAN_PTE_UFFD_WP = 7,
	SCAN_PAGE_RO = 8,
	SCAN_LACK_REFERENCED_PAGE = 9,
	SCAN_PAGE_NULL = 10,
	SCAN_SCAN_ABORT = 11,
	SCAN_PAGE_COUNT = 12,
	SCAN_PAGE_LRU = 13,
	SCAN_PAGE_LOCK = 14,
	SCAN_PAGE_ANON = 15,
	SCAN_PAGE_COMPOUND = 16,
	SCAN_ANY_PROCESS = 17,
	SCAN_VMA_NULL = 18,
	SCAN_VMA_CHECK = 19,
	SCAN_ADDRESS_RANGE = 20,
	SCAN_SWAP_CACHE_PAGE = 21,
	SCAN_DEL_PAGE_LRU = 22,
	SCAN_ALLOC_HUGE_PAGE_FAIL = 23,
	SCAN_CGROUP_CHARGE_FAIL = 24,
	SCAN_TRUNCATED = 25,
	SCAN_PAGE_HAS_PRIVATE = 26,
};

struct trace_event_raw_mm_khugepaged_scan_pmd {
	struct trace_entry ent;
	struct mm_struct *mm;
	long unsigned int pfn;
	bool writable;
	int referenced;
	int none_or_zero;
	int status;
	int unmapped;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page {
	struct trace_entry ent;
	struct mm_struct *mm;
	int isolated;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_isolate {
	struct trace_entry ent;
	long unsigned int pfn;
	int none_or_zero;
	int referenced;
	bool writable;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_swapin {
	struct trace_entry ent;
	struct mm_struct *mm;
	int swapped_in;
	int referenced;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_mm_khugepaged_scan_pmd {};

struct trace_event_data_offsets_mm_collapse_huge_page {};

struct trace_event_data_offsets_mm_collapse_huge_page_isolate {};

struct trace_event_data_offsets_mm_collapse_huge_page_swapin {};

typedef void (*btf_trace_mm_khugepaged_scan_pmd)(void *, struct mm_struct *, struct page *, bool, int, int, int, int);

typedef void (*btf_trace_mm_collapse_huge_page)(void *, struct mm_struct *, int, int);

typedef void (*btf_trace_mm_collapse_huge_page_isolate)(void *, struct page *, int, int, bool, int);

typedef void (*btf_trace_mm_collapse_huge_page_swapin)(void *, struct mm_struct *, int, int, int);

struct mm_slot___2 {
	struct hlist_node hash;
	struct list_head mm_node;
	struct mm_struct *mm;
	int nr_pte_mapped_thp;
	long unsigned int pte_mapped_thp[8];
};

struct khugepaged_scan {
	struct list_head mm_head;
	struct mm_slot___2 *mm_slot;
	long unsigned int address;
};

struct mem_cgroup_tree_per_node {
	struct rb_root rb_root;
	struct rb_node *rb_rightmost;
	spinlock_t lock;
};

struct mem_cgroup_tree {
	struct mem_cgroup_tree_per_node *rb_tree_per_node[4];
};

struct mem_cgroup_eventfd_list {
	struct list_head list;
	struct eventfd_ctx *eventfd;
};

struct mem_cgroup_event {
	struct mem_cgroup *memcg;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	int (*register_event)(struct mem_cgroup *, struct eventfd_ctx *, const char *);
	void (*unregister_event)(struct mem_cgroup *, struct eventfd_ctx *);
	poll_table pt;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct work_struct remove;
};

struct move_charge_struct {
	spinlock_t lock;
	struct mm_struct *mm;
	struct mem_cgroup *from;
	struct mem_cgroup *to;
	long unsigned int flags;
	long unsigned int precharge;
	long unsigned int moved_charge;
	long unsigned int moved_swap;
	struct task_struct *moving_task;
	wait_queue_head_t waitq;
};

enum res_type {
	_MEM = 0,
	_MEMSWAP = 1,
	_OOM_TYPE = 2,
	_KMEM = 3,
	_TCP = 4,
};

struct memory_stat {
	const char *name;
	unsigned int idx;
};

struct oom_wait_info {
	struct mem_cgroup *memcg;
	wait_queue_entry_t wait;
};

enum oom_status {
	OOM_SUCCESS = 0,
	OOM_FAILED = 1,
	OOM_ASYNC = 2,
	OOM_SKIPPED = 3,
};

struct obj_stock {
	struct obj_cgroup *cached_objcg;
	struct pglist_data *cached_pgdat;
	unsigned int nr_bytes;
	int nr_slab_reclaimable_b;
	int nr_slab_unreclaimable_b;
};

struct memcg_stock_pcp {
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct obj_stock task_obj;
	struct obj_stock irq_obj;
	struct work_struct work;
	long unsigned int flags;
};

enum {
	RES_USAGE = 0,
	RES_LIMIT = 1,
	RES_MAX_USAGE = 2,
	RES_FAILCNT = 3,
	RES_SOFT_LIMIT = 4,
};

union mc_target {
	struct page *page;
	swp_entry_t ent;
};

enum mc_target_type {
	MC_TARGET_NONE = 0,
	MC_TARGET_PAGE = 1,
	MC_TARGET_SWAP = 2,
	MC_TARGET_DEVICE = 3,
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	long unsigned int nr_memory;
	long unsigned int pgpgout;
	long unsigned int nr_kmem;
	struct page *dummy_page;
};

struct numa_stat {
	const char *name;
	unsigned int lru_mask;
};

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

struct swap_cgroup_ctrl {
	struct page **map;
	long unsigned int length;
	spinlock_t lock;
};

struct swap_cgroup {
	short unsigned int id;
};

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

struct trace_event_raw_cma_alloc_class {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	long unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_cma_alloc_start {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_data_offsets_cma_alloc_class {
	u32 name;
};

struct trace_event_data_offsets_cma_release {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_start {
	u32 name;
};

typedef void (*btf_trace_cma_release)(void *, const char *, long unsigned int, const struct page *, long unsigned int);

typedef void (*btf_trace_cma_alloc_start)(void *, const char *, long unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_finish)(void *, const char *, long unsigned int, const struct page *, long unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_busy_retry)(void *, const char *, long unsigned int, const struct page *, long unsigned int, unsigned int);

struct balloon_dev_info {
	long unsigned int isolated_pages;
	spinlock_t pages_lock;
	struct list_head pages;
	int (*migratepage)(struct balloon_dev_info *, struct page *, struct page *, enum migrate_mode);
	struct inode *inode;
};

enum {
	BAD_STACK = 4294967295,
	NOT_STACK = 0,
	GOOD_FRAME = 1,
	GOOD_STACK = 2,
};

struct hugetlbfs_inode_info {
	struct shared_policy policy;
	struct inode vfs_inode;
	unsigned int seals;
};

struct page_reporting_dev_info {
	int (*report)(struct page_reporting_dev_info *, struct scatterlist *, unsigned int);
	struct delayed_work work;
	atomic_t state;
	unsigned int order;
};

enum {
	PAGE_REPORTING_IDLE = 0,
	PAGE_REPORTING_REQUESTED = 1,
	PAGE_REPORTING_ACTIVE = 2,
};

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef __kernel_rwf_t rwf_t;

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	long unsigned int st_dev;
	long unsigned int st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	long unsigned int st_rdev;
	long unsigned int __pad1;
	long int st_size;
	int st_blksize;
	int __pad2;
	long int st_blocks;
	long int st_atime;
	long unsigned int st_atime_nsec;
	long int st_mtime;
	long unsigned int st_mtime_nsec;
	long int st_ctime;
	long unsigned int st_ctime_nsec;
	unsigned int __unused4;
	unsigned int __unused5;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u64 __spare2;
	__u64 __spare3[12];
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	union {
		const char * const *native;
	} ptr;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[32];
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int state;
	unsigned int seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	kuid_t dir_uid;
	umode_t dir_mode;
};

struct renamedata {
	struct user_namespace *old_mnt_userns;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct user_namespace *new_mnt_userns;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct inode **delegated_inode;
	unsigned int flags;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct fileattr {
	u32 flags;
	u32 fsx_xflags;
	u32 fsx_extsize;
	u32 fsx_nextents;
	u32 fsx_projid;
	u32 fsx_cowextsize;
	bool flags_valid: 1;
	bool fsx_valid: 1;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct mount_attr {
	__u64 attr_set;
	__u64 attr_clr;
	__u64 propagation;
	__u64 userns_fd;
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

struct mount_kattr {
	unsigned int attr_set;
	unsigned int attr_clr;
	unsigned int propagation;
	unsigned int lookup_flags;
	bool recurse;
	struct user_namespace *mnt_userns;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct xattr_name {
	char name[256];
};

struct xattr_ctx {
	union {
		const void *cvalue;
		void *value;
	};
	void *kvalue;
	size_t size;
	struct xattr_name *kname;
	unsigned int flags;
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_page_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_inode_foreign_history {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t cgroup_ino;
	unsigned int history;
	char __data[0];
};

struct trace_event_raw_inode_switch_wbs {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t old_cgroup_ino;
	ino_t new_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_track_foreign_dirty {
	struct trace_entry ent;
	char name[32];
	u64 bdi_id;
	ino_t ino;
	unsigned int memcg_id;
	ino_t cgroup_ino;
	ino_t page_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_flush_foreign {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	unsigned int frn_bdi_id;
	unsigned int frn_memcg_id;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_congest_waited_template {
	struct trace_entry ent;
	unsigned int usec_timeout;
	unsigned int usec_delayed;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_page_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_inode_foreign_history {};

struct trace_event_data_offsets_inode_switch_wbs {};

struct trace_event_data_offsets_track_foreign_dirty {};

struct trace_event_data_offsets_flush_foreign {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_congest_waited_template {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_page)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_wait_on_page_writeback)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);

typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);

typedef void (*btf_trace_track_foreign_dirty)(void *, struct page *, struct bdi_writeback *);

typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_congestion_wait)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_wait_iff_congested)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct inode_switch_wbs_context {
	struct rcu_work work;
	struct bdi_writeback *new_wb;
	struct inode *inodes[0];
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct prepend_buffer {
	char *buf;
	int len;
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	long unsigned int f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct dax_device;

struct iomap_page_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *);
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

struct decrypt_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dio {
	int flags;
	int op;
	int op_flags;
	blk_qc_t bio_cookie;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct page *page;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	unsigned int use_writepage;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fanotify_group_private_data {
	struct hlist_head *merge_hash;
	struct list_head access_list;
	wait_queue_head_t access_waitq;
	int flags;
	int f_flags;
	struct ucounts *ucounts;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	struct mutex mark_mutex;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
		struct fanotify_group_private_data fanotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[4];
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignored_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

enum {
	FAN_EVENT_INIT = 0,
	FAN_EVENT_REPORTED = 1,
	FAN_EVENT_ANSWERED = 2,
	FAN_EVENT_CANCELED = 3,
};

struct fanotify_fh {
	u8 type;
	u8 len;
	u8 flags;
	u8 pad;
	unsigned char buf[0];
};

struct fanotify_info {
	u8 dir_fh_totlen;
	u8 file_fh_totlen;
	u8 name_len;
	u8 pad;
	unsigned char buf[0];
};

enum fanotify_event_type {
	FANOTIFY_EVENT_TYPE_FID = 0,
	FANOTIFY_EVENT_TYPE_FID_NAME = 1,
	FANOTIFY_EVENT_TYPE_PATH = 2,
	FANOTIFY_EVENT_TYPE_PATH_PERM = 3,
	FANOTIFY_EVENT_TYPE_OVERFLOW = 4,
	__FANOTIFY_EVENT_TYPE_NUM = 5,
};

struct fanotify_event {
	struct fsnotify_event fse;
	struct hlist_node merge_list;
	u32 mask;
	struct {
		unsigned int type: 3;
		unsigned int hash: 29;
	};
	struct pid *pid;
};

struct fanotify_fid_event {
	struct fanotify_event fae;
	__kernel_fsid_t fsid;
	struct fanotify_fh object_fh;
	unsigned char _inline_fh_buf[12];
};

struct fanotify_name_event {
	struct fanotify_event fae;
	__kernel_fsid_t fsid;
	struct fanotify_info info;
};

struct fanotify_path_event {
	struct fanotify_event fae;
	struct path path;
};

struct fanotify_perm_event {
	struct fanotify_event fae;
	struct path path;
	short unsigned int response;
	short unsigned int state;
	int fd;
};

struct fanotify_event_metadata {
	__u32 event_len;
	__u8 vers;
	__u8 reserved;
	__u16 metadata_len;
	__u64 mask;
	__s32 fd;
	__s32 pid;
};

struct fanotify_event_info_header {
	__u8 info_type;
	__u8 pad;
	__u16 len;
};

struct fanotify_event_info_fid {
	struct fanotify_event_info_header hdr;
	__kernel_fsid_t fsid;
	unsigned char handle[0];
};

struct fanotify_event_info_pidfd {
	struct fanotify_event_info_header hdr;
	__s32 pidfd;
};

struct fanotify_response {
	__s32 fd;
	__u32 response;
};

struct epoll_event {
	__poll_t events;
	__u64 data;
};

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct epitem;

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	unsigned int napi_id;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[34];

struct gnu_property {
	u32 pr_type;
	u32 pr_datasz;
};

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus_common {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
};

struct elf_prstatus {
	struct elf_prstatus_common common;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

enum {
	MBE_REFERENCED_B = 0,
	MBE_REUSABLE_B = 1,
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	long unsigned int e_flags;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct iomap_iter {
	struct inode *inode;
	loff_t pos;
	u64 len;
	s64 processed;
	unsigned int flags;
	struct iomap iomap;
	struct iomap srcmap;
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	loff_t offset;
	u64 length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_iter {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	u64 length;
	unsigned int flags;
	const void *ops;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_iter {};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_releasepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_invalidatepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_iter_dstmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter_srcmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter)(void *, struct iomap_iter *, const void *, long unsigned int);

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
	BIOSET_PERCPU_CACHE = 4,
};

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	struct bio *io_bio;
	struct bio io_inline_bio;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_page)(struct page *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);

struct iomap_page {
	atomic_t read_bytes_pending;
	atomic_t write_bytes_pending;
	spinlock_t uptodate_lock;
	long unsigned int uptodate[0];
};

struct iomap_readpage_ctx {
	struct page *cur_page;
	bool cur_page_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	blk_qc_t (*submit_io)(const struct iomap_iter *, struct bio *, loff_t);
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	size_t done_before;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct request_queue *last_queue;
			blk_qc_t cookie;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
	struct file *file;
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

typedef __kernel_uid32_t qid_t;

enum {
	DQF_INFO_DIRTY_B = 17,
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u16 qs_rtbwarnlimit;
	__u16 qs_pad3;
	__u32 qs_pad4;
	__u64 qs_pad2[7];
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

typedef u32 compat_uint_t;

typedef u64 compat_u64;

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *tail_vma;
	struct mempolicy *task_mempolicy;
};

struct numa_maps {
	long unsigned int pages;
	long unsigned int anon;
	long unsigned int active;
	long unsigned int writeback;
	long unsigned int mapcount_max;
	long unsigned int dirty;
	long unsigned int swapcache;
	long unsigned int node[4];
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

enum resctrl_conf_type {
	CDP_NONE = 0,
	CDP_CODE = 1,
	CDP_DATA = 2,
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct timers_private {
	struct pid *pid;
	struct task_struct *task;
	struct sighand_struct *sighand;
	struct pid_namespace *ns;
	long unsigned int flags;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct seq_net_private {
	struct net *net;
};

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
};

struct kernfs_open_node {
	atomic_t refcnt;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	int (*commit_item)(struct config_item *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_buffer {
	size_t count;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct journal_s {
	long unsigned int j_flags;
	long unsigned int j_atomic_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	struct shrinker j_shrinker;
	struct percpu_counter j_checkpoint_jh_count;
	transaction_t *j_shrink_transaction;
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int, tid_t);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__u32 s_padding[41];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

struct fscrypt_dummy_policy {};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_failed_commits;
	long unsigned int fc_skipped_commits;
	long unsigned int fc_numblks;
	u64 s_fc_avg_commit_time;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	union {
		struct list_head i_orphan;
		unsigned int i_orphan_idx;
	};
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_orphan_file_inum;
	__le32 s_reserved[94];
	__le32 s_checksum;
};

struct ext4_journal_trigger {
	struct jbd2_buffer_trigger_type tr_triggers;
	struct super_block *sb;
};

struct ext4_orphan_block {
	atomic_t ob_free_entries;
	struct buffer_head *ob_bh;
};

struct ext4_orphan_info {
	int of_blocks;
	__u32 of_csum_seed;
	struct ext4_orphan_block *of_binfo;
};

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	long unsigned int s_ext4_flags;
	struct mutex s_orphan_lock;
	struct list_head s_orphan;
	struct ext4_orphan_info s_orphan_info;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *s_journal_bdev;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	struct list_head s_discard_list;
	struct work_struct s_discard_work;
	atomic_t s_retry_alloc_pending;
	struct rb_root s_mb_avg_fragment_size_root;
	rwlock_t s_mb_rb_lock;
	struct list_head *s_mb_largest_free_orders;
	rwlock_t *s_mb_largest_free_orders_locks;
	long unsigned int s_stripe;
	unsigned int s_mb_max_linear_groups;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_groups_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	atomic_t s_bal_cr0_bad_suggestions;
	atomic_t s_bal_cr1_bad_suggestions;
	atomic64_t s_bal_cX_groups_considered[4];
	atomic64_t s_bal_cX_hits[4];
	atomic64_t s_bal_cX_failed[4];
	atomic_t s_mb_buddies_generated;
	atomic64_t s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	atomic_t s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	long: 64;
	long: 64;
	spinlock_t s_es_lock;
	struct ext4_journal_trigger s_journal_triggers[1];
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	time64_t s_last_error_time;
	struct work_struct s_error_work;
	atomic_t s_fc_subtid;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	tid_t s_fc_ineligible_tid;
	struct ext4_fc_replay_state s_fc_replay_state;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	ext4_grpblk_t bb_largest_free_order;
	ext4_group_t bb_group;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	struct rb_node bb_avg_fragment_size_rb;
	struct list_head bb_largest_free_order_node;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
	EXT4_IGET_BAD = 4,
	EXT4_IGET_EA_INODE = 8,
} ext4_iget_flags;

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_REASON_ENCRYPTED_FILENAME = 9,
	EXT4_FC_REASON_MAX = 10,
};

enum ext4_journal_trigger_type {
	EXT4_JTR_ORPHAN_FILE = 0,
	EXT4_JTR_NONE = 1,
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	atomic_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_MAY_INLINE_DATA = 7,
	EXT4_STATE_EXT_PRECACHED = 8,
	EXT4_STATE_LUSTRE_EA_INODE = 9,
	EXT4_STATE_VERITY_IN_PROGRESS = 10,
	EXT4_STATE_FC_COMMITTING = 11,
	EXT4_STATE_ORPHAN_FILE = 12,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FS_ABORTED = 1,
	EXT4_MF_FC_INELIGIBLE = 2,
};

struct fsverity_info;

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct fscrypt_info;

typedef unsigned int __kernel_mode_t;

typedef __kernel_mode_t mode_t;

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	ext4_group_t ac_last_optimal_group;
	__u32 ac_groups_considered;
	__u32 ac_flags;
	__u16 ac_groups_scanned;
	__u16 ac_groups_linear_remaining;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
	I_DATA_SEM_EA = 3,
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidatepage_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	unsigned int fc_ineligible_rc[10];
	long unsigned int fc_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_create {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_link {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_unlink {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidatepage_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_create {};

struct trace_event_data_offsets_ext4_fc_track_link {};

struct trace_event_data_offsets_ext4_fc_track_unlink {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, struct inode *, long int, long int, int);

struct ext4_err_translation {
	int code;
	int errno;
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32 = 10,
	Opt_debug = 11,
	Opt_removed = 12,
	Opt_user_xattr = 13,
	Opt_nouser_xattr = 14,
	Opt_acl = 15,
	Opt_noacl = 16,
	Opt_auto_da_alloc = 17,
	Opt_noauto_da_alloc = 18,
	Opt_noload = 19,
	Opt_commit = 20,
	Opt_min_batch_time = 21,
	Opt_max_batch_time = 22,
	Opt_journal_dev = 23,
	Opt_journal_path = 24,
	Opt_journal_checksum = 25,
	Opt_journal_async_commit = 26,
	Opt_abort = 27,
	Opt_data_journal = 28,
	Opt_data_ordered = 29,
	Opt_data_writeback = 30,
	Opt_data_err_abort = 31,
	Opt_data_err_ignore = 32,
	Opt_test_dummy_encryption = 33,
	Opt_inlinecrypt = 34,
	Opt_usrjquota = 35,
	Opt_grpjquota = 36,
	Opt_offusrjquota = 37,
	Opt_offgrpjquota = 38,
	Opt_jqfmt_vfsold = 39,
	Opt_jqfmt_vfsv0 = 40,
	Opt_jqfmt_vfsv1 = 41,
	Opt_quota = 42,
	Opt_noquota = 43,
	Opt_barrier = 44,
	Opt_nobarrier = 45,
	Opt_err___2 = 46,
	Opt_usrquota = 47,
	Opt_grpquota = 48,
	Opt_prjquota = 49,
	Opt_i_version = 50,
	Opt_dax = 51,
	Opt_dax_always = 52,
	Opt_dax_inode = 53,
	Opt_dax_never = 54,
	Opt_stripe = 55,
	Opt_delalloc = 56,
	Opt_nodelalloc = 57,
	Opt_warn_on_error = 58,
	Opt_nowarn_on_error = 59,
	Opt_mblk_io_submit = 60,
	Opt_lazytime = 61,
	Opt_nolazytime = 62,
	Opt_debug_want_extra_isize = 63,
	Opt_nomblk_io_submit = 64,
	Opt_block_validity = 65,
	Opt_noblock_validity = 66,
	Opt_inode_readahead_blks = 67,
	Opt_journal_ioprio = 68,
	Opt_dioread_nolock = 69,
	Opt_dioread_lock = 70,
	Opt_discard = 71,
	Opt_nodiscard = 72,
	Opt_init_itable = 73,
	Opt_noinit_itable = 74,
	Opt_max_dir_size_kb = 75,
	Opt_nojournal_checksum = 76,
	Opt_nombcache = 77,
	Opt_no_prefetch_block_bitmaps = 78,
	Opt_mb_optimize_scan = 79,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_parsed_options {
	long unsigned int journal_devnum;
	unsigned int journal_ioprio;
	int mb_optimize_scan;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_feature = 10,
	attr_pointer_ui = 11,
	attr_pointer_ul = 12,
	attr_pointer_u64 = 13,
	attr_pointer_u8 = 14,
	attr_pointer_string = 15,
	attr_pointer_atomic = 16,
	attr_journal_task = 17,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

enum {
	EXT4_FC_STATUS_OK = 0,
	EXT4_FC_STATUS_INELIGIBLE = 1,
	EXT4_FC_STATUS_SKIPPED = 2,
	EXT4_FC_STATUS_FAILED = 3,
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct qstr fcd_name;
	unsigned char fcd_iname[32];
	struct list_head fcd_list;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

struct ext4_fc_tl_mem {
	u16 fc_tag;
	u16 fc_len;
};

struct ext4_orphan_block_tail {
	__le32 ob_magic;
	__le32 ob_checksum;
};

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	tid_t head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	int write_op;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_raw_jbd2_journal_shrink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int nr_shrunk;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_checkpoint_list {
	struct trace_entry ent;
	dev_t dev;
	tid_t first_tid;
	tid_t tid;
	tid_t last_tid;
	long unsigned int nr_freed;
	tid_t next_tid;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

struct trace_event_data_offsets_jbd2_journal_shrink {};

struct trace_event_data_offsets_jbd2_shrink_scan_exit {};

struct trace_event_data_offsets_jbd2_shrink_checkpoint_list {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, tid_t, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, tid_t, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_count)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_enter)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_exit)(void *, journal_t *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_checkpoint_list)(void *, journal_t *, tid_t, tid_t, tid_t, long unsigned int, tid_t);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct meta_entry {
	u64 data_block;
	unsigned int index_block;
	short unsigned int offset;
	short unsigned int pad;
};

struct meta_index {
	unsigned int inode_number;
	unsigned int offset;
	short unsigned int entries;
	short unsigned int skip;
	short unsigned int locked;
	short unsigned int pad;
	struct meta_entry meta_entry[127];
};

struct squashfs_cache_entry;

struct squashfs_cache {
	char *name;
	int entries;
	int curr_blk;
	int next_blk;
	int num_waiters;
	int unused;
	int block_size;
	int pages;
	spinlock_t lock;
	wait_queue_head_t wait_queue;
	struct squashfs_cache_entry *entry;
};

struct squashfs_page_actor;

struct squashfs_cache_entry {
	u64 block;
	int length;
	int refcount;
	u64 next_index;
	int pending;
	int error;
	int num_waiters;
	wait_queue_head_t wait_queue;
	struct squashfs_cache *cache;
	void **data;
	struct squashfs_page_actor *actor;
};

struct squashfs_page_actor {
	void **page;
	int pages;
	int length;
	int next_page;
};

struct squashfs_decompressor;

struct squashfs_stream;

struct squashfs_sb_info {
	const struct squashfs_decompressor *decompressor;
	int devblksize;
	int devblksize_log2;
	struct squashfs_cache *block_cache;
	struct squashfs_cache *fragment_cache;
	struct squashfs_cache *read_page;
	int next_meta_index;
	__le64 *id_table;
	__le64 *fragment_index;
	__le64 *xattr_id_table;
	struct mutex meta_index_mutex;
	struct meta_index *meta_index;
	struct squashfs_stream *stream;
	__le64 *inode_lookup_table;
	u64 inode_table;
	u64 directory_table;
	u64 xattr_table;
	unsigned int block_size;
	short unsigned int block_log;
	long long int bytes_used;
	unsigned int inodes;
	unsigned int fragments;
	unsigned int xattr_ids;
	unsigned int ids;
	bool panic_on_errors;
};

struct squashfs_decompressor {
	void * (*init)(struct squashfs_sb_info *, void *);
	void * (*comp_opts)(struct squashfs_sb_info *, void *, int);
	void (*free)(void *);
	int (*decompress)(struct squashfs_sb_info *, void *, struct bio *, int, int, struct squashfs_page_actor *);
	int id;
	char *name;
	int supported;
};

struct squashfs_dir_index {
	__le32 index;
	__le32 start_block;
	__le32 size;
	unsigned char name[0];
};

struct squashfs_dir_entry {
	__le16 offset;
	__le16 inode_number;
	__le16 type;
	__le16 size;
	char name[0];
};

struct squashfs_dir_header {
	__le32 count;
	__le32 start_block;
	__le32 inode_number;
};

struct squashfs_inode_info {
	u64 start;
	int offset;
	u64 xattr;
	unsigned int xattr_size;
	int xattr_count;
	union {
		struct {
			u64 fragment_block;
			int fragment_size;
			int fragment_offset;
			u64 block_list_start;
		};
		struct {
			u64 dir_idx_start;
			int dir_idx_offset;
			int dir_idx_cnt;
			int parent;
		};
	};
	struct inode vfs_inode;
};

struct squashfs_fragment_entry {
	__le64 start_block;
	__le32 size;
	unsigned int unused;
};

struct squashfs_base_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
};

struct squashfs_ipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
};

struct squashfs_lipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 xattr;
};

struct squashfs_dev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
};

struct squashfs_ldev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
	__le32 xattr;
};

struct squashfs_symlink_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 symlink_size;
	char symlink[0];
};

struct squashfs_reg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 fragment;
	__le32 offset;
	__le32 file_size;
	__le16 block_list[0];
};

struct squashfs_lreg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le64 start_block;
	__le64 file_size;
	__le64 sparse;
	__le32 nlink;
	__le32 fragment;
	__le32 offset;
	__le32 xattr;
	__le16 block_list[0];
};

struct squashfs_dir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 nlink;
	__le16 file_size;
	__le16 offset;
	__le32 parent_inode;
};

struct squashfs_ldir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 file_size;
	__le32 start_block;
	__le32 parent_inode;
	__le16 i_count;
	__le16 offset;
	__le32 xattr;
	struct squashfs_dir_index index[0];
};

union squashfs_inode {
	struct squashfs_base_inode base;
	struct squashfs_dev_inode dev;
	struct squashfs_ldev_inode ldev;
	struct squashfs_symlink_inode symlink;
	struct squashfs_reg_inode reg;
	struct squashfs_lreg_inode lreg;
	struct squashfs_dir_inode dir;
	struct squashfs_ldir_inode ldir;
	struct squashfs_ipc_inode ipc;
	struct squashfs_lipc_inode lipc;
};

struct squashfs_xattr_id_table {
	__le64 xattr_table_start;
	__le32 xattr_ids;
	__le32 unused;
};

enum Opt_errors {
	Opt_errors_continue = 0,
	Opt_errors_panic = 1,
};

enum squashfs_param {
	Opt_errors = 0,
};

struct squashfs_mount_opts {
	enum Opt_errors errors;
};

struct squashfs_stream {
	void *stream;
	struct mutex mutex;
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

typedef z_stream *z_streamp;

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum hugetlb_param {
	Opt_gid___4 = 0,
	Opt_min_size = 1,
	Opt_mode___4 = 2,
	Opt_nr_inodes___2 = 3,
	Opt_pagesize = 4,
	Opt_size___2 = 5,
	Opt_uid___3 = 6,
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
};

struct fatent_operations;

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct fat_entry;

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct inode vfs_inode;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
};

typedef long long unsigned int llu;

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

enum {
	Opt_check_n = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_uid___4 = 3,
	Opt_gid___5 = 4,
	Opt_umask = 5,
	Opt_dmask = 6,
	Opt_fmask = 7,
	Opt_allow_utime = 8,
	Opt_codepage = 9,
	Opt_usefree = 10,
	Opt_nocase = 11,
	Opt_quiet = 12,
	Opt_showexec = 13,
	Opt_debug___2 = 14,
	Opt_immutable = 15,
	Opt_dots = 16,
	Opt_nodots = 17,
	Opt_charset = 18,
	Opt_shortname_lower = 19,
	Opt_shortname_win95 = 20,
	Opt_shortname_winnt = 21,
	Opt_shortname_mixed = 22,
	Opt_utf8_no = 23,
	Opt_utf8_yes = 24,
	Opt_uni_xl_no = 25,
	Opt_uni_xl_yes = 26,
	Opt_nonumtail_no = 27,
	Opt_nonumtail_yes = 28,
	Opt_obsolete = 29,
	Opt_flush = 30,
	Opt_tz_utc = 31,
	Opt_rodir = 32,
	Opt_err_cont___2 = 33,
	Opt_err_panic___2 = 34,
	Opt_err_ro___2 = 35,
	Opt_discard___2 = 36,
	Opt_nfs = 37,
	Opt_time_offset = 38,
	Opt_nfs_stale_rw = 39,
	Opt_nfs_nostale_ro = 40,
	Opt_err___3 = 41,
	Opt_dos1xfloppy = 42,
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

typedef struct {
	__u32 v32;
} jint32_t;

typedef struct {
	__u16 v16;
} jint16_t;

struct jffs2_full_dnode;

struct jffs2_full_dirent;

struct jffs2_inode_cache;

struct jffs2_inode_info {
	struct mutex sem;
	uint32_t highest_version;
	struct rb_root fragtree;
	struct jffs2_full_dnode *metadata;
	struct jffs2_full_dirent *dents;
	unsigned char *target;
	struct jffs2_inode_cache *inocache;
	uint16_t flags;
	uint8_t usercompr;
	struct inode vfs_inode;
};

struct jffs2_raw_node_ref;

struct jffs2_full_dnode {
	struct jffs2_raw_node_ref *raw;
	uint32_t ofs;
	uint32_t size;
	uint32_t frags;
};

struct jffs2_full_dirent {
	union {
		struct jffs2_raw_node_ref *raw;
		struct jffs2_inode_cache *ic;
	};
	struct jffs2_full_dirent *next;
	uint32_t version;
	uint32_t ino;
	unsigned int nhash;
	unsigned char type;
	unsigned char name[0];
};

struct jffs2_xattr_ref;

struct jffs2_inode_cache {
	struct jffs2_full_dirent *scan_dents;
	struct jffs2_raw_node_ref *nodes;
	uint8_t class;
	uint8_t flags;
	uint16_t state;
	uint32_t ino;
	struct jffs2_inode_cache *next;
	struct jffs2_xattr_ref *xref;
	uint32_t pino_nlink;
};

struct jffs2_mount_opts {
	bool override_compr;
	unsigned int compr;
	bool set_rp_size;
	unsigned int rp_size;
};

struct jffs2_eraseblock;

struct jffs2_inodirty;

struct jffs2_summary;

struct jffs2_sb_info {
	struct mtd_info *mtd;
	uint32_t highest_ino;
	uint32_t check_ino;
	unsigned int flags;
	struct task_struct *gc_task;
	struct completion gc_thread_start;
	struct completion gc_thread_exit;
	struct mutex alloc_sem;
	uint32_t cleanmarker_size;
	uint32_t flash_size;
	uint32_t used_size;
	uint32_t dirty_size;
	uint32_t wasted_size;
	uint32_t free_size;
	uint32_t erasing_size;
	uint32_t bad_size;
	uint32_t sector_size;
	uint32_t unchecked_size;
	uint32_t nr_free_blocks;
	uint32_t nr_erasing_blocks;
	uint8_t resv_blocks_write;
	uint8_t resv_blocks_deletion;
	uint8_t resv_blocks_gctrigger;
	uint8_t resv_blocks_gcbad;
	uint8_t resv_blocks_gcmerge;
	uint8_t vdirty_blocks_gctrigger;
	uint32_t nospc_dirty_size;
	uint32_t nr_blocks;
	struct jffs2_eraseblock *blocks;
	struct jffs2_eraseblock *nextblock;
	struct jffs2_eraseblock *gcblock;
	struct list_head clean_list;
	struct list_head very_dirty_list;
	struct list_head dirty_list;
	struct list_head erasable_list;
	struct list_head erasable_pending_wbuf_list;
	struct list_head erasing_list;
	struct list_head erase_checking_list;
	struct list_head erase_pending_list;
	struct list_head erase_complete_list;
	struct list_head free_list;
	struct list_head bad_list;
	struct list_head bad_used_list;
	spinlock_t erase_completion_lock;
	wait_queue_head_t erase_wait;
	wait_queue_head_t inocache_wq;
	int inocache_hashsize;
	struct jffs2_inode_cache **inocache_list;
	spinlock_t inocache_lock;
	struct mutex erase_free_sem;
	uint32_t wbuf_pagesize;
	unsigned char *wbuf;
	uint32_t wbuf_ofs;
	uint32_t wbuf_len;
	struct jffs2_inodirty *wbuf_inodes;
	struct rw_semaphore wbuf_sem;
	struct delayed_work wbuf_dwork;
	unsigned char *oobbuf;
	int oobavail;
	struct jffs2_summary *summary;
	struct jffs2_mount_opts mount_opts;
	uint32_t highest_xid;
	uint32_t highest_xseqno;
	struct list_head xattrindex[57];
	struct list_head xattr_unchecked;
	struct list_head xattr_dead_list;
	struct jffs2_xattr_ref *xref_dead_list;
	struct jffs2_xattr_ref *xref_temp;
	struct rw_semaphore xattr_sem;
	uint32_t xdatum_mem_usage;
	uint32_t xdatum_mem_threshold;
	void *os_priv;
};

struct jffs2_eraseblock {
	struct list_head list;
	int bad_count;
	uint32_t offset;
	uint32_t unchecked_size;
	uint32_t used_size;
	uint32_t dirty_size;
	uint32_t wasted_size;
	uint32_t free_size;
	uint32_t allocated_refs;
	struct jffs2_raw_node_ref *first_node;
	struct jffs2_raw_node_ref *last_node;
	struct jffs2_raw_node_ref *gc_node;
};

union jffs2_sum_mem;

struct jffs2_summary {
	uint32_t sum_size;
	uint32_t sum_num;
	uint32_t sum_padded;
	union jffs2_sum_mem *sum_list_head;
	union jffs2_sum_mem *sum_list_tail;
	jint32_t *sum_buf;
};

struct jffs2_xattr_datum;

struct jffs2_xattr_ref {
	void *always_null;
	struct jffs2_raw_node_ref *node;
	uint8_t class;
	uint8_t flags;
	u16 unused;
	uint32_t xseqno;
	union {
		struct jffs2_inode_cache *ic;
		uint32_t ino;
	};
	union {
		struct jffs2_xattr_datum *xd;
		uint32_t xid;
	};
	struct jffs2_xattr_ref *next;
};

struct jffs2_xattr_datum {
	void *always_null;
	struct jffs2_raw_node_ref *node;
	uint8_t class;
	uint8_t flags;
	uint16_t xprefix;
	struct list_head xindex;
	atomic_t refcnt;
	uint32_t xid;
	uint32_t version;
	uint32_t data_crc;
	uint32_t hashkey;
	char *xname;
	uint32_t name_len;
	char *xvalue;
	uint32_t value_len;
};

struct jffs2_raw_node_ref {
	struct jffs2_raw_node_ref *next_in_ino;
	uint32_t flash_offset;
};

struct jffs2_sum_unknown_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
};

struct jffs2_sum_inode_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t inode;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_dirent_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t offset;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	uint8_t nsize;
	uint8_t type;
	uint8_t name[0];
} __attribute__((packed));

struct jffs2_sum_xattr_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t xid;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_xref_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t offset;
} __attribute__((packed));

union jffs2_sum_mem {
	struct jffs2_sum_unknown_mem u;
	struct jffs2_sum_inode_mem i;
	struct jffs2_sum_dirent_mem d;
	struct jffs2_sum_xattr_mem x;
	struct jffs2_sum_xref_mem r;
};

struct jffs2_compressor {
	struct list_head list;
	int priority;
	char *name;
	char compr;
	int (*compress)(unsigned char *, unsigned char *, uint32_t *, uint32_t *);
	int (*decompress)(unsigned char *, unsigned char *, uint32_t, uint32_t);
	int usecount;
	int disabled;
	unsigned char *compr_buf;
	uint32_t compr_buf_size;
	uint32_t stat_compr_orig_size;
	uint32_t stat_compr_new_size;
	uint32_t stat_compr_blocks;
	uint32_t stat_decompr_blocks;
};

typedef struct {
	__u32 m;
} jmode_t;

struct jffs2_raw_dirent {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	jint32_t mctime;
	__u8 nsize;
	__u8 type;
	__u8 unused[2];
	jint32_t node_crc;
	jint32_t name_crc;
	__u8 name[0];
};

struct jffs2_raw_inode {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t ino;
	jint32_t version;
	jmode_t mode;
	jint16_t uid;
	jint16_t gid;
	jint32_t isize;
	jint32_t atime;
	jint32_t mtime;
	jint32_t ctime;
	jint32_t offset;
	jint32_t csize;
	jint32_t dsize;
	__u8 compr;
	__u8 usercompr;
	jint16_t flags;
	jint32_t data_crc;
	jint32_t node_crc;
	__u8 data[0];
};

union jffs2_device_node {
	jint16_t old_id;
	jint32_t new_id;
};

typedef unsigned char u_char;

struct mtd_ecc_stats {
	__u32 corrected;
	__u32 failed;
	__u32 badblocks;
	__u32 bbtblocks;
};

struct mtd_debug_info {
	struct dentry *dfs_dir;
	const char *partname;
	const char *partid;
};

struct mtd_part {
	struct list_head node;
	u64 offset;
	u64 size;
	u32 flags;
};

struct mtd_master {
	struct mutex partitions_lock;
	struct mutex chrdev_lock;
	unsigned int suspended: 1;
};

struct mtd_ooblayout_ops;

struct mtd_pairing_scheme;

struct mtd_erase_region_info;

struct erase_info;

struct mtd_oob_ops;

struct otp_info;

struct nvmem_device;

struct mtd_info {
	u_char type;
	uint32_t flags;
	uint64_t size;
	uint32_t erasesize;
	uint32_t erasesize_minor;
	uint32_t writesize;
	uint32_t writebufsize;
	uint32_t oobsize;
	uint32_t oobavail;
	unsigned int erasesize_shift;
	unsigned int writesize_shift;
	unsigned int erasesize_mask;
	unsigned int writesize_mask;
	unsigned int bitflip_threshold;
	const char *name;
	int index;
	const struct mtd_ooblayout_ops *ooblayout;
	const struct mtd_pairing_scheme *pairing;
	unsigned int ecc_step_size;
	unsigned int ecc_strength;
	int numeraseregions;
	struct mtd_erase_region_info *eraseregions;
	int (*_erase)(struct mtd_info *, struct erase_info *);
	int (*_point)(struct mtd_info *, loff_t, size_t, size_t *, void **, resource_size_t *);
	int (*_unpoint)(struct mtd_info *, loff_t, size_t);
	int (*_read)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_panic_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_read_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_write_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_get_fact_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_fact_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_get_user_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_lock_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_erase_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_writev)(struct mtd_info *, const struct kvec *, long unsigned int, loff_t, size_t *);
	void (*_sync)(struct mtd_info *);
	int (*_lock)(struct mtd_info *, loff_t, uint64_t);
	int (*_unlock)(struct mtd_info *, loff_t, uint64_t);
	int (*_is_locked)(struct mtd_info *, loff_t, uint64_t);
	int (*_block_isreserved)(struct mtd_info *, loff_t);
	int (*_block_isbad)(struct mtd_info *, loff_t);
	int (*_block_markbad)(struct mtd_info *, loff_t);
	int (*_max_bad_blocks)(struct mtd_info *, loff_t, size_t);
	int (*_suspend)(struct mtd_info *);
	void (*_resume)(struct mtd_info *);
	void (*_reboot)(struct mtd_info *);
	int (*_get_device)(struct mtd_info *);
	void (*_put_device)(struct mtd_info *);
	bool oops_panic_write;
	struct notifier_block reboot_notifier;
	struct mtd_ecc_stats ecc_stats;
	int subpage_sft;
	void *priv;
	struct module *owner;
	struct device dev;
	int usecount;
	struct mtd_debug_info dbg;
	struct nvmem_device *nvmem;
	struct nvmem_device *otp_user_nvmem;
	struct nvmem_device *otp_factory_nvmem;
	struct mtd_info *parent;
	struct list_head partitions;
	struct mtd_part part;
	struct mtd_master master;
};

struct otp_info {
	__u32 start;
	__u32 length;
	__u32 locked;
};

struct erase_info {
	uint64_t addr;
	uint64_t len;
	uint64_t fail_addr;
};

struct mtd_erase_region_info {
	uint64_t offset;
	uint32_t erasesize;
	uint32_t numblocks;
	long unsigned int *lockmap;
};

struct mtd_req_stats {
	unsigned int uncorrectable_errors;
	unsigned int corrected_bitflips;
	unsigned int max_bitflips;
};

struct mtd_oob_ops {
	unsigned int mode;
	size_t len;
	size_t retlen;
	size_t ooblen;
	size_t oobretlen;
	uint32_t ooboffs;
	uint8_t *datbuf;
	uint8_t *oobbuf;
	struct mtd_req_stats *stats;
};

struct mtd_oob_region {
	u32 offset;
	u32 length;
};

struct mtd_ooblayout_ops {
	int (*ecc)(struct mtd_info *, int, struct mtd_oob_region *);
	int (*free)(struct mtd_info *, int, struct mtd_oob_region *);
};

struct mtd_pairing_info {
	int pair;
	int group;
};

struct mtd_pairing_scheme {
	int ngroups;
	int (*get_info)(struct mtd_info *, int, struct mtd_pairing_info *);
	int (*get_wunit)(struct mtd_info *, const struct mtd_pairing_info *);
};

struct jffs2_node_frag {
	struct rb_node rb;
	struct jffs2_full_dnode *node;
	uint32_t size;
	uint32_t ofs;
};

struct jffs2_tmp_dnode_info {
	struct rb_node rb;
	struct jffs2_full_dnode *fn;
	uint32_t version;
	uint32_t data_crc;
	uint32_t partial_crc;
	uint32_t csize;
	uint16_t overlapped;
};

struct jffs2_unknown_node {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
};

struct jffs2_raw_xattr {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t xid;
	jint32_t version;
	__u8 xprefix;
	__u8 name_len;
	jint16_t value_len;
	jint32_t data_crc;
	jint32_t node_crc;
	__u8 data[0];
};

struct jffs2_raw_xref {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t ino;
	jint32_t xid;
	jint32_t xseqno;
	jint32_t node_crc;
};

struct jffs2_raw_summary {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t sum_num;
	jint32_t cln_mkr;
	jint32_t padded;
	jint32_t sum_crc;
	jint32_t node_crc;
	jint32_t sum[0];
};

union jffs2_node_union {
	struct jffs2_raw_inode i;
	struct jffs2_raw_dirent d;
	struct jffs2_raw_xattr x;
	struct jffs2_raw_xref r;
	struct jffs2_raw_summary s;
	struct jffs2_unknown_node u;
};

struct jffs2_readinode_info {
	struct rb_root tn_root;
	struct jffs2_tmp_dnode_info *mdata_tn;
	uint32_t highest_version;
	uint32_t latest_mctime;
	uint32_t mctime_ver;
	struct jffs2_full_dirent *fds;
	struct jffs2_raw_node_ref *latest_ref;
};

struct jffs2_sum_marker {
	jint32_t offset;
	jint32_t magic;
};

enum {
	Opt_override_compr = 0,
	Opt_rp_size = 1,
};

enum {
	MTD_OPS_PLACE_OOB = 0,
	MTD_OPS_AUTO_OOB = 1,
	MTD_OPS_RAW = 2,
};

struct jffs2_inodirty {
	uint32_t ino;
	struct jffs2_inodirty *next;
};

typedef int SRes;

typedef unsigned int UInt32;

typedef long long unsigned int UInt64;

typedef size_t SizeT;

typedef struct {
	SRes (*Progress)(void *, UInt64, UInt64);
} ICompressProgress;

typedef struct {
	void * (*Alloc)(void *, size_t);
	void (*Free)(void *, void *);
} ISzAlloc;

typedef enum {
	LZMA_FINISH_ANY = 0,
	LZMA_FINISH_END = 1,
} ELzmaFinishMode;

typedef enum {
	LZMA_STATUS_NOT_SPECIFIED = 0,
	LZMA_STATUS_FINISHED_WITH_MARK = 1,
	LZMA_STATUS_NOT_FINISHED = 2,
	LZMA_STATUS_NEEDS_MORE_INPUT = 3,
	LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK = 4,
} ELzmaStatus;

struct _CLzmaEncProps {
	int level;
	UInt32 dictSize;
	int lc;
	int lp;
	int pb;
	int algo;
	int fb;
	int btMode;
	int numHashBytes;
	UInt32 mc;
	unsigned int writeEndMark;
	int numThreads;
};

typedef struct _CLzmaEncProps CLzmaEncProps;

typedef void *CLzmaEncHandle;

struct jffs2_sum_unknown_flash {
	jint16_t nodetype;
};

struct jffs2_sum_inode_flash {
	jint16_t nodetype;
	jint32_t inode;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_dirent_flash {
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t offset;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	uint8_t nsize;
	uint8_t type;
	uint8_t name[0];
} __attribute__((packed));

struct jffs2_sum_xattr_flash {
	jint16_t nodetype;
	jint32_t xid;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_xref_flash {
	jint16_t nodetype;
	jint32_t offset;
} __attribute__((packed));

struct ubi_volume_info {
	int ubi_num;
	int vol_id;
	int size;
	long long int used_bytes;
	int used_ebs;
	int vol_type;
	int corrupted;
	int upd_marker;
	int alignment;
	int usable_leb_size;
	int name_len;
	const char *name;
	dev_t cdev;
};

struct ubi_device_info {
	int ubi_num;
	int leb_size;
	int leb_start;
	int min_io_size;
	int max_write_size;
	int ro_mode;
	dev_t cdev;
};

enum {
	UBIFS_COMPR_NONE = 0,
	UBIFS_COMPR_LZO = 1,
	UBIFS_COMPR_ZLIB = 2,
	UBIFS_COMPR_ZSTD = 3,
	UBIFS_COMPR_TYPES_CNT = 4,
};

enum {
	UBIFS_INO_NODE = 0,
	UBIFS_DATA_NODE = 1,
	UBIFS_DENT_NODE = 2,
	UBIFS_XENT_NODE = 3,
	UBIFS_TRUN_NODE = 4,
	UBIFS_PAD_NODE = 5,
	UBIFS_SB_NODE = 6,
	UBIFS_MST_NODE = 7,
	UBIFS_REF_NODE = 8,
	UBIFS_IDX_NODE = 9,
	UBIFS_CS_NODE = 10,
	UBIFS_ORPH_NODE = 11,
	UBIFS_AUTH_NODE = 12,
	UBIFS_SIG_NODE = 13,
	UBIFS_NODE_TYPES_CNT = 14,
};

struct ubifs_ch {
	__le32 magic;
	__le32 crc;
	__le64 sqnum;
	__le32 len;
	__u8 node_type;
	__u8 group_type;
	__u8 padding[2];
};

struct ubifs_sb_node {
	struct ubifs_ch ch;
	__u8 padding[2];
	__u8 key_hash;
	__u8 key_fmt;
	__le32 flags;
	__le32 min_io_size;
	__le32 leb_size;
	__le32 leb_cnt;
	__le32 max_leb_cnt;
	__le64 max_bud_bytes;
	__le32 log_lebs;
	__le32 lpt_lebs;
	__le32 orph_lebs;
	__le32 jhead_cnt;
	__le32 fanout;
	__le32 lsave_cnt;
	__le32 fmt_version;
	__le16 default_compr;
	__u8 padding1[2];
	__le32 rp_uid;
	__le32 rp_gid;
	__le64 rp_size;
	__le32 time_gran;
	__u8 uuid[16];
	__le32 ro_compat_version;
	__u8 hmac[64];
	__u8 hmac_wkm[64];
	__le16 hash_algo;
	__u8 hash_mst[64];
	__u8 padding2[3774];
};

struct ubifs_mst_node {
	struct ubifs_ch ch;
	__le64 highest_inum;
	__le64 cmt_no;
	__le32 flags;
	__le32 log_lnum;
	__le32 root_lnum;
	__le32 root_offs;
	__le32 root_len;
	__le32 gc_lnum;
	__le32 ihead_lnum;
	__le32 ihead_offs;
	__le64 index_size;
	__le64 total_free;
	__le64 total_dirty;
	__le64 total_used;
	__le64 total_dead;
	__le64 total_dark;
	__le32 lpt_lnum;
	__le32 lpt_offs;
	__le32 nhead_lnum;
	__le32 nhead_offs;
	__le32 ltab_lnum;
	__le32 ltab_offs;
	__le32 lsave_lnum;
	__le32 lsave_offs;
	__le32 lscan_lnum;
	__le32 empty_lebs;
	__le32 idx_lebs;
	__le32 leb_cnt;
	__u8 hash_root_idx[64];
	__u8 hash_lpt[64];
	__u8 hmac[64];
	__u8 padding[152];
};

enum {
	DIRTY_ZNODE = 0,
	COW_ZNODE = 1,
	OBSOLETE_ZNODE = 2,
};

enum {
	COMMIT_RESTING = 0,
	COMMIT_BACKGROUND = 1,
	COMMIT_REQUIRED = 2,
	COMMIT_RUNNING_BACKGROUND = 3,
	COMMIT_RUNNING_REQUIRED = 4,
	COMMIT_BROKEN = 5,
};

union ubifs_key {
	uint8_t u8[8];
	uint32_t u32[2];
	uint64_t u64[1];
	__le32 j32[2];
};

enum {
	LPROPS_UNCAT = 0,
	LPROPS_DIRTY = 1,
	LPROPS_DIRTY_IDX = 2,
	LPROPS_FREE = 3,
	LPROPS_HEAP_CNT = 3,
	LPROPS_EMPTY = 4,
	LPROPS_FREEABLE = 5,
	LPROPS_FRDI_IDX = 6,
	LPROPS_CAT_MASK = 15,
	LPROPS_TAKEN = 16,
	LPROPS_INDEX = 32,
};

struct ubifs_lprops {
	int free;
	int dirty;
	int flags;
	int lnum;
	union {
		struct list_head list;
		int hpos;
	};
};

struct ubifs_lpt_lprops {
	int free;
	int dirty;
	unsigned int tgc: 1;
	unsigned int cmt: 1;
};

struct ubifs_lp_stats {
	int empty_lebs;
	int taken_empty_lebs;
	int idx_lebs;
	long long int total_free;
	long long int total_dirty;
	long long int total_used;
	long long int total_dead;
	long long int total_dark;
};

struct ubifs_nnode;

struct ubifs_cnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
};

struct ubifs_pnode;

struct ubifs_nbranch {
	int lnum;
	int offs;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	};
};

struct ubifs_nnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_nbranch nbranch[4];
};

struct ubifs_pnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_lprops lprops[4];
};

struct ubifs_lpt_heap {
	struct ubifs_lprops **arr;
	int cnt;
	int max_cnt;
};

struct ubifs_znode;

struct ubifs_zbranch {
	union ubifs_key key;
	union {
		struct ubifs_znode *znode;
		void *leaf;
	};
	int lnum;
	int offs;
	int len;
	u8 hash[0];
};

struct bu_info {
	union ubifs_key key;
	struct ubifs_zbranch zbranch[32];
	void *buf;
	int buf_len;
	int gc_seq;
	int cnt;
	int blk_cnt;
	int eof;
};

struct ubifs_budg_info {
	long long int idx_growth;
	long long int data_growth;
	long long int dd_growth;
	long long int uncommitted_idx;
	long long unsigned int old_idx_sz;
	int min_idx_lebs;
	unsigned int nospace: 1;
	unsigned int nospace_rp: 1;
	int page_budget;
	int inode_budget;
	int dent_budget;
};

struct ubifs_node_range {
	union {
		int len;
		int min_len;
	};
	int max_len;
};

struct ubifs_mount_opts {
	unsigned int unmount_mode: 2;
	unsigned int bulk_read: 2;
	unsigned int chk_data_crc: 2;
	unsigned int override_compr: 1;
	unsigned int compr_type: 2;
};

struct ubifs_jhead;

struct ubi_volume_desc;

struct ubifs_orphan;

struct ubifs_debug_info;

struct ubifs_info {
	struct super_block *vfs_sb;
	struct ubifs_sb_node *sup_node;
	ino_t highest_inum;
	long long unsigned int max_sqnum;
	long long unsigned int cmt_no;
	spinlock_t cnt_lock;
	int fmt_version;
	int ro_compat_version;
	unsigned char uuid[16];
	int lhead_lnum;
	int lhead_offs;
	int ltail_lnum;
	struct mutex log_mutex;
	int min_log_bytes;
	long long int cmt_bud_bytes;
	struct rb_root buds;
	long long int bud_bytes;
	spinlock_t buds_lock;
	int jhead_cnt;
	struct ubifs_jhead *jheads;
	long long int max_bud_bytes;
	long long int bg_bud_bytes;
	struct list_head old_buds;
	int max_bud_cnt;
	struct rw_semaphore commit_sem;
	int cmt_state;
	spinlock_t cs_lock;
	wait_queue_head_t cmt_wq;
	unsigned int big_lpt: 1;
	unsigned int space_fixup: 1;
	unsigned int double_hash: 1;
	unsigned int encrypted: 1;
	unsigned int no_chk_data_crc: 1;
	unsigned int bulk_read: 1;
	unsigned int default_compr: 2;
	unsigned int rw_incompat: 1;
	unsigned int assert_action: 2;
	unsigned int authenticated: 1;
	unsigned int superblock_need_write: 1;
	struct mutex tnc_mutex;
	struct ubifs_zbranch zroot;
	struct ubifs_znode *cnext;
	struct ubifs_znode *enext;
	int *gap_lebs;
	void *cbuf;
	void *ileb_buf;
	int ileb_len;
	int ihead_lnum;
	int ihead_offs;
	int *ilebs;
	int ileb_cnt;
	int ileb_nxt;
	struct rb_root old_idx;
	int *bottom_up_buf;
	struct ubifs_mst_node *mst_node;
	int mst_offs;
	int max_bu_buf_len;
	struct mutex bu_mutex;
	struct bu_info bu;
	struct mutex write_reserve_mutex;
	void *write_reserve_buf;
	int log_lebs;
	long long int log_bytes;
	int log_last;
	int lpt_lebs;
	int lpt_first;
	int lpt_last;
	int orph_lebs;
	int orph_first;
	int orph_last;
	int main_lebs;
	int main_first;
	long long int main_bytes;
	uint8_t key_hash_type;
	uint32_t (*key_hash)(const char *, int);
	int key_fmt;
	int key_len;
	int hash_len;
	int fanout;
	int min_io_size;
	int min_io_shift;
	int max_write_size;
	int max_write_shift;
	int leb_size;
	int leb_start;
	int half_leb_size;
	int idx_leb_size;
	int leb_cnt;
	int max_leb_cnt;
	unsigned int ro_media: 1;
	unsigned int ro_mount: 1;
	unsigned int ro_error: 1;
	atomic_long_t dirty_pg_cnt;
	atomic_long_t dirty_zn_cnt;
	atomic_long_t clean_zn_cnt;
	spinlock_t space_lock;
	struct ubifs_lp_stats lst;
	struct ubifs_budg_info bi;
	long long unsigned int calc_idx_sz;
	int ref_node_alsz;
	int mst_node_alsz;
	int min_idx_node_sz;
	int max_idx_node_sz;
	long long int max_inode_sz;
	int max_znode_sz;
	int leb_overhead;
	int dead_wm;
	int dark_wm;
	int block_cnt;
	struct ubifs_node_range ranges[14];
	struct ubi_volume_desc *ubi;
	struct ubi_device_info di;
	struct ubi_volume_info vi;
	struct rb_root orph_tree;
	struct list_head orph_list;
	struct list_head orph_new;
	struct ubifs_orphan *orph_cnext;
	struct ubifs_orphan *orph_dnext;
	spinlock_t orphan_lock;
	void *orph_buf;
	int new_orphans;
	int cmt_orphans;
	int tot_orphans;
	int max_orphans;
	int ohead_lnum;
	int ohead_offs;
	int no_orphs;
	struct task_struct *bgt;
	char bgt_name[24];
	int need_bgt;
	int need_wbuf_sync;
	int gc_lnum;
	void *sbuf;
	struct list_head idx_gc;
	int idx_gc_cnt;
	int gc_seq;
	int gced_lnum;
	struct list_head infos_list;
	struct mutex umount_mutex;
	unsigned int shrinker_run_no;
	int space_bits;
	int lpt_lnum_bits;
	int lpt_offs_bits;
	int lpt_spc_bits;
	int pcnt_bits;
	int lnum_bits;
	int nnode_sz;
	int pnode_sz;
	int ltab_sz;
	int lsave_sz;
	int pnode_cnt;
	int nnode_cnt;
	int lpt_hght;
	int pnodes_have;
	struct mutex lp_mutex;
	int lpt_lnum;
	int lpt_offs;
	int nhead_lnum;
	int nhead_offs;
	int lpt_drty_flgs;
	int dirty_nn_cnt;
	int dirty_pn_cnt;
	int check_lpt_free;
	long long int lpt_sz;
	void *lpt_nod_buf;
	void *lpt_buf;
	struct ubifs_nnode *nroot;
	struct ubifs_cnode *lpt_cnext;
	struct ubifs_lpt_heap lpt_heap[3];
	struct ubifs_lpt_heap dirty_idx;
	struct list_head uncat_list;
	struct list_head empty_list;
	struct list_head freeable_list;
	struct list_head frdi_idx_list;
	int freeable_cnt;
	int in_a_category_cnt;
	int ltab_lnum;
	int ltab_offs;
	struct ubifs_lpt_lprops *ltab;
	struct ubifs_lpt_lprops *ltab_cmt;
	int lsave_cnt;
	int lsave_lnum;
	int lsave_offs;
	int *lsave;
	int lscan_lnum;
	long long int rp_size;
	long long int report_rp_size;
	kuid_t rp_uid;
	kgid_t rp_gid;
	struct crypto_shash *hash_tfm;
	struct crypto_shash *hmac_tfm;
	int hmac_desc_len;
	char *auth_key_name;
	char *auth_hash_name;
	enum hash_algo auth_hash_algo;
	struct shash_desc *log_hash;
	unsigned int empty: 1;
	unsigned int need_recovery: 1;
	unsigned int replaying: 1;
	unsigned int mounting: 1;
	unsigned int remounting_rw: 1;
	unsigned int probing: 1;
	struct list_head replay_list;
	struct list_head replay_buds;
	long long unsigned int cs_sqnum;
	struct list_head unclean_leb_list;
	struct ubifs_mst_node *rcvrd_mst_node;
	struct rb_root size_tree;
	struct ubifs_mount_opts mount_opts;
	struct ubifs_debug_info *dbg;
};

struct ubifs_wbuf {
	struct ubifs_info *c;
	void *buf;
	int lnum;
	int offs;
	int avail;
	int used;
	int size;
	int jhead;
	int (*sync_callback)(struct ubifs_info *, int, int, int);
	struct mutex io_mutex;
	spinlock_t lock;
	struct hrtimer timer;
	unsigned int no_timer: 1;
	unsigned int need_sync: 1;
	int next_ino;
	ino_t *inodes;
};

struct ubifs_jhead {
	struct ubifs_wbuf wbuf;
	struct list_head buds_list;
	unsigned int grouped: 1;
	struct shash_desc *log_hash;
};

struct ubifs_znode {
	struct ubifs_znode *parent;
	struct ubifs_znode *cnext;
	struct ubifs_znode *cparent;
	int ciip;
	long unsigned int flags;
	time64_t time;
	int level;
	int child_cnt;
	int iip;
	int alt;
	int lnum;
	int offs;
	int len;
	struct ubifs_zbranch zbranch[0];
};

struct ubifs_orphan {
	struct rb_node rb;
	struct list_head list;
	struct list_head new_list;
	struct list_head child_list;
	struct ubifs_orphan *cnext;
	struct ubifs_orphan *dnext;
	ino_t inum;
	unsigned int new: 1;
	unsigned int cmt: 1;
	unsigned int del: 1;
};

struct ubifs_debug_info {
	struct ubifs_zbranch old_zroot;
	int old_zroot_level;
	long long unsigned int old_zroot_sqnum;
	int pc_happened;
	int pc_delay;
	long unsigned int pc_timeout;
	unsigned int pc_cnt;
	unsigned int pc_cnt_max;
	long long int chk_lpt_sz;
	long long int chk_lpt_sz2;
	long long int chk_lpt_wastage;
	int chk_lpt_lebs;
	int new_nhead_offs;
	int new_ihead_lnum;
	int new_ihead_offs;
	struct ubifs_lp_stats saved_lst;
	struct ubifs_budg_info saved_bi;
	long long int saved_free;
	int saved_idx_gc_cnt;
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
	char dfs_dir_name[10];
	struct dentry *dfs_dir;
	struct dentry *dfs_dump_lprops;
	struct dentry *dfs_dump_budg;
	struct dentry *dfs_dump_tnc;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_index;
	struct dentry *dfs_chk_orph;
	struct dentry *dfs_chk_lprops;
	struct dentry *dfs_chk_fs;
	struct dentry *dfs_tst_rcvry;
	struct dentry *dfs_ro_error;
};

enum {
	UBIFS_ITYPE_REG = 0,
	UBIFS_ITYPE_DIR = 1,
	UBIFS_ITYPE_LNK = 2,
	UBIFS_ITYPE_BLK = 3,
	UBIFS_ITYPE_CHR = 4,
	UBIFS_ITYPE_FIFO = 5,
	UBIFS_ITYPE_SOCK = 6,
	UBIFS_ITYPES_CNT = 7,
};

enum {
	UBIFS_INO_KEY = 0,
	UBIFS_DATA_KEY = 1,
	UBIFS_DENT_KEY = 2,
	UBIFS_XENT_KEY = 3,
	UBIFS_KEY_TYPES_CNT = 4,
};

enum {
	UBIFS_COMPR_FL = 1,
	UBIFS_SYNC_FL = 2,
	UBIFS_IMMUTABLE_FL = 4,
	UBIFS_APPEND_FL = 8,
	UBIFS_DIRSYNC_FL = 16,
	UBIFS_XATTR_FL = 32,
	UBIFS_CRYPT_FL = 64,
};

struct ubifs_ino_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 creat_sqnum;
	__le64 size;
	__le64 atime_sec;
	__le64 ctime_sec;
	__le64 mtime_sec;
	__le32 atime_nsec;
	__le32 ctime_nsec;
	__le32 mtime_nsec;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le32 flags;
	__le32 data_len;
	__le32 xattr_cnt;
	__le32 xattr_size;
	__u8 padding1[4];
	__le32 xattr_names;
	__le16 compr_type;
	__u8 padding2[26];
	__u8 data[0];
};

struct ubifs_dent_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 inum;
	__u8 padding1;
	__u8 type;
	__le16 nlen;
	__le32 cookie;
	__u8 name[0];
};

struct ubifs_data_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le32 size;
	__le16 compr_type;
	__le16 compr_size;
	__u8 data[0];
};

struct ubifs_trun_node {
	struct ubifs_ch ch;
	__le32 inum;
	__u8 padding[12];
	__le64 old_size;
	__le64 new_size;
};

struct ubifs_inode {
	struct inode vfs_inode;
	long long unsigned int creat_sqnum;
	long long unsigned int del_cmtno;
	unsigned int xattr_size;
	unsigned int xattr_cnt;
	unsigned int xattr_names;
	unsigned int dirty: 1;
	unsigned int xattr: 1;
	unsigned int bulk_read: 1;
	unsigned int compr_type: 2;
	struct mutex ui_mutex;
	struct rw_semaphore xattr_sem;
	spinlock_t ui_lock;
	loff_t synced_i_size;
	loff_t ui_size;
	int flags;
	long unsigned int last_page_read;
	long unsigned int read_in_a_row;
	int data_len;
	void *data;
};

struct ubifs_budget_req {
	unsigned int fast: 1;
	unsigned int recalculate: 1;
	unsigned int new_page: 1;
	unsigned int dirtied_page: 1;
	unsigned int new_dent: 1;
	unsigned int mod_dent: 1;
	unsigned int new_ino: 1;
	unsigned int new_ino_d: 13;
	unsigned int dirtied_ino: 4;
	int: 8;
	unsigned int dirtied_ino_d: 15;
	int idx_growth;
	int data_growth;
	int dd_growth;
};

union ubifs_dev_desc {
	__le32 new;
	__le64 huge;
};

struct ubifs_global_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
};

enum {
	UBI_DYNAMIC_VOLUME = 3,
	UBI_STATIC_VOLUME = 4,
};

enum {
	UBI_READONLY = 1,
	UBI_READWRITE = 2,
	UBI_EXCLUSIVE = 3,
	UBI_METAONLY = 4,
};

struct crypto_comp {
	struct crypto_tfm base;
};

enum {
	UBIFS_SIMPLE_KEY_FMT = 0,
};

enum {
	UBIFS_MST_DIRTY = 1,
	UBIFS_MST_NO_ORPHS = 2,
	UBIFS_MST_RCVRY = 4,
};

enum {
	ASSACT_REPORT = 0,
	ASSACT_RO = 1,
	ASSACT_PANIC = 2,
};

struct ubifs_unclean_leb {
	struct list_head list;
	int lnum;
	int endpt;
};

struct ubifs_bud {
	int lnum;
	int start;
	int jhead;
	struct list_head list;
	struct rb_node rb;
	struct shash_desc *log_hash;
};

struct ubifs_compressor {
	int compr_type;
	struct crypto_comp *cc;
	struct mutex *comp_mutex;
	struct mutex *decomp_mutex;
	const char *name;
	const char *capi_name;
};

struct fscrypt_operations;

enum {
	Opt_fast_unmount = 0,
	Opt_norm_unmount = 1,
	Opt_bulk_read = 2,
	Opt_no_bulk_read = 3,
	Opt_chk_data_crc = 4,
	Opt_no_chk_data_crc = 5,
	Opt_override_compr___2 = 6,
	Opt_assert = 7,
	Opt_auth_key = 8,
	Opt_auth_hash_name = 9,
	Opt_ignore = 10,
	Opt_err___4 = 11,
};

enum {
	UBIFS_KEY_HASH_R5 = 0,
	UBIFS_KEY_HASH_TEST = 1,
};

enum {
	UBIFS_FLG_BIGLPT = 2,
	UBIFS_FLG_SPACE_FIXUP = 4,
	UBIFS_FLG_DOUBLE_HASH = 8,
	UBIFS_FLG_ENCRYPTION = 16,
	UBIFS_FLG_AUTHENTICATION = 32,
};

struct ubifs_branch {
	__le32 lnum;
	__le32 offs;
	__le32 len;
	__u8 key[0];
};

struct ubifs_idx_node {
	struct ubifs_ch ch;
	__le16 child_cnt;
	__le16 level;
	__u8 branches[0];
} __attribute__((packed));

struct ubifs_cs_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
};

enum {
	UBIFS_NO_NODE_GROUP = 0,
	UBIFS_IN_NODE_GROUP = 1,
	UBIFS_LAST_OF_NODE_GROUP = 2,
};

struct ubifs_pad_node {
	struct ubifs_ch ch;
	__le32 pad_len;
} __attribute__((packed));

struct ubifs_old_idx {
	struct rb_node rb;
	int lnum;
	int offs;
};

enum {
	NAME_LESS = 0,
	NAME_MATCHES = 1,
	NAME_GREATER = 2,
	NOT_ON_MEDIA = 3,
};

struct ubifs_scan_node {
	struct list_head list;
	union ubifs_key key;
	long long unsigned int sqnum;
	int type;
	int offs;
	int len;
	void *node;
};

struct ubifs_scan_leb {
	int lnum;
	int nodes_cnt;
	struct list_head nodes;
	int endpt;
	void *buf;
};

enum {
	SCANNED_GARBAGE = 0,
	SCANNED_EMPTY_SPACE = 4294967295,
	SCANNED_A_NODE = 4294967294,
	SCANNED_A_CORRUPT_NODE = 4294967293,
	SCANNED_A_BAD_PAD_NODE = 4294967292,
};

struct ubifs_ref_node {
	struct ubifs_ch ch;
	__le32 lnum;
	__le32 offs;
	__le32 jhead;
	__u8 padding[28];
};

struct ubifs_auth_node {
	struct ubifs_ch ch;
	__u8 hmac[0];
};

struct replay_entry {
	int lnum;
	int offs;
	int len;
	u8 hash[0];
	unsigned int deletion: 1;
	long long unsigned int sqnum;
	struct list_head list;
	union ubifs_key key;
	union {
		struct fscrypt_name nm;
		struct {
			loff_t old_size;
			loff_t new_size;
		};
	};
};

struct bud_entry {
	struct list_head list;
	struct ubifs_bud *bud;
	long long unsigned int sqnum;
	int free;
	int dirty;
};

struct done_ref {
	struct rb_node rb;
	int lnum;
};

enum {
	DIRTY_CNODE = 0,
	OBSOLETE_CNODE = 1,
	COW_CNODE = 2,
};

struct idx_node {
	struct list_head list;
	int iip;
	union ubifs_key upper_key;
	struct ubifs_idx_node idx;
};

enum {
	LEB_FREED = 0,
	LEB_FREED_IDX = 1,
	LEB_RETAINED = 2,
};

struct ubifs_gced_idx_leb {
	struct list_head list;
	int lnum;
	int unmap;
};

struct ubifs_orph_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
	__le64 inos[0];
};

typedef int (*dbg_leaf_callback)(struct ubifs_info *, struct ubifs_zbranch *, void *);

typedef int (*dbg_znode_callback)(struct ubifs_info *, struct ubifs_znode *, void *);

struct check_orphan {
	struct rb_node rb;
	ino_t inum;
};

struct check_info {
	long unsigned int last_ino;
	long unsigned int tot_inos;
	long unsigned int missing;
	long long unsigned int leaf_cnt;
	struct ubifs_ino_node *node;
	struct rb_root root;
};

enum {
	LPT_SCAN_CONTINUE = 0,
	LPT_SCAN_ADD = 1,
	LPT_SCAN_STOP = 2,
};

typedef int (*ubifs_lpt_scan_callback)(struct ubifs_info *, const struct ubifs_lprops *, int, void *);

struct scan_data {
	int min_space;
	int pick_free;
	int lnum;
	int exclude_index;
};

enum {
	UBIFS_LPT_PNODE = 0,
	UBIFS_LPT_NNODE = 1,
	UBIFS_LPT_LTAB = 2,
	UBIFS_LPT_LSAVE = 3,
	UBIFS_LPT_NODE_CNT = 4,
	UBIFS_LPT_NOT_A_NODE = 15,
};

enum {
	LTAB_DIRTY = 1,
	LSAVE_DIRTY = 2,
};

struct lpt_scan_node {
	union {
		struct ubifs_nnode nnode;
		struct ubifs_pnode pnode;
		struct ubifs_cnode cnode;
	};
	int in_tree;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	} ptr;
};

struct size_entry {
	struct rb_node rb;
	ino_t inum;
	loff_t i_size;
	loff_t d_size;
	int exists;
	struct inode *inode;
};

struct fsck_inode {
	struct rb_node rb;
	ino_t inum;
	umode_t mode;
	unsigned int nlink;
	unsigned int xattr_cnt;
	int references;
	int calc_cnt;
	long long int size;
	unsigned int xattr_sz;
	long long int calc_sz;
	long long int calc_xcnt;
	long long int calc_xsz;
	unsigned int xattr_nms;
	long long int calc_xnms;
};

struct fsck_data {
	struct rb_root inodes;
};

typedef unsigned int autofs_wqt_t;

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	struct inode *inode;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 offset;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

enum {
	Opt_err___5 = 0,
	Opt_fd = 1,
	Opt_uid___5 = 2,
	Opt_gid___6 = 3,
	Opt_pgrp = 4,
	Opt_minproto = 5,
	Opt_maxproto = 6,
	Opt_indirect = 7,
	Opt_direct = 8,
	Opt_offset = 9,
	Opt_strictexpire = 10,
	Opt_ignore___2 = 11,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

enum fuse_opcode {
	FUSE_LOOKUP = 1,
	FUSE_FORGET = 2,
	FUSE_GETATTR = 3,
	FUSE_SETATTR = 4,
	FUSE_READLINK = 5,
	FUSE_SYMLINK = 6,
	FUSE_MKNOD = 8,
	FUSE_MKDIR = 9,
	FUSE_UNLINK = 10,
	FUSE_RMDIR = 11,
	FUSE_RENAME = 12,
	FUSE_LINK = 13,
	FUSE_OPEN = 14,
	FUSE_READ = 15,
	FUSE_WRITE = 16,
	FUSE_STATFS = 17,
	FUSE_RELEASE = 18,
	FUSE_FSYNC = 20,
	FUSE_SETXATTR = 21,
	FUSE_GETXATTR = 22,
	FUSE_LISTXATTR = 23,
	FUSE_REMOVEXATTR = 24,
	FUSE_FLUSH = 25,
	FUSE_INIT = 26,
	FUSE_OPENDIR = 27,
	FUSE_READDIR = 28,
	FUSE_RELEASEDIR = 29,
	FUSE_FSYNCDIR = 30,
	FUSE_GETLK = 31,
	FUSE_SETLK = 32,
	FUSE_SETLKW = 33,
	FUSE_ACCESS = 34,
	FUSE_CREATE = 35,
	FUSE_INTERRUPT = 36,
	FUSE_BMAP = 37,
	FUSE_DESTROY = 38,
	FUSE_IOCTL = 39,
	FUSE_POLL = 40,
	FUSE_NOTIFY_REPLY = 41,
	FUSE_BATCH_FORGET = 42,
	FUSE_FALLOCATE = 43,
	FUSE_READDIRPLUS = 44,
	FUSE_RENAME2 = 45,
	FUSE_LSEEK = 46,
	FUSE_COPY_FILE_RANGE = 47,
	FUSE_SETUPMAPPING = 48,
	FUSE_REMOVEMAPPING = 49,
	FUSE_SYNCFS = 50,
	CUSE_INIT = 4096,
	CUSE_INIT_BSWAP_RESERVED = 1048576,
	FUSE_INIT_BSWAP_RESERVED = 436207616,
};

enum fuse_notify_code {
	FUSE_NOTIFY_POLL = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_CODE_MAX = 7,
};

struct fuse_forget_in {
	uint64_t nlookup;
};

struct fuse_forget_one {
	uint64_t nodeid;
	uint64_t nlookup;
};

struct fuse_batch_forget_in {
	uint32_t count;
	uint32_t dummy;
};

struct fuse_interrupt_in {
	uint64_t unique;
};

struct fuse_notify_poll_wakeup_out {
	uint64_t kh;
};

struct fuse_in_header {
	uint32_t len;
	uint32_t opcode;
	uint64_t unique;
	uint64_t nodeid;
	uint32_t uid;
	uint32_t gid;
	uint32_t pid;
	uint32_t padding;
};

struct fuse_out_header {
	uint32_t len;
	int32_t error;
	uint64_t unique;
};

struct fuse_notify_inval_inode_out {
	uint64_t ino;
	int64_t off;
	int64_t len;
};

struct fuse_notify_inval_entry_out {
	uint64_t parent;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_delete_out {
	uint64_t parent;
	uint64_t child;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_store_out {
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_out {
	uint64_t notify_unique;
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_in {
	uint64_t dummy1;
	uint64_t offset;
	uint32_t size;
	uint32_t dummy2;
	uint64_t dummy3;
	uint64_t dummy4;
};

struct fuse_forget_link {
	struct fuse_forget_one forget_one;
	struct fuse_forget_link *next;
};

struct fuse_mount;

struct fuse_release_args;

struct fuse_file {
	struct fuse_mount *fm;
	struct fuse_release_args *release_args;
	u64 kh;
	u64 fh;
	u64 nodeid;
	refcount_t count;
	u32 open_flags;
	struct list_head write_entry;
	struct {
		struct mutex lock;
		loff_t pos;
		loff_t cache_off;
		u64 version;
	} readdir;
	struct rb_node polled_node;
	wait_queue_head_t poll_wait;
	bool flock: 1;
};

struct fuse_conn;

struct fuse_mount {
	struct fuse_conn *fc;
	struct super_block *sb;
	struct list_head fc_entry;
};

struct fuse_in_arg {
	unsigned int size;
	const void *value;
};

struct fuse_arg {
	unsigned int size;
	void *value;
};

struct fuse_page_desc {
	unsigned int length;
	unsigned int offset;
};

struct fuse_args {
	uint64_t nodeid;
	uint32_t opcode;
	short unsigned int in_numargs;
	short unsigned int out_numargs;
	bool force: 1;
	bool noreply: 1;
	bool nocreds: 1;
	bool in_pages: 1;
	bool out_pages: 1;
	bool user_pages: 1;
	bool out_argvar: 1;
	bool page_zeroing: 1;
	bool page_replace: 1;
	bool may_block: 1;
	struct fuse_in_arg in_args[3];
	struct fuse_arg out_args[2];
	void (*end)(struct fuse_mount *, struct fuse_args *, int);
};

struct fuse_args_pages {
	struct fuse_args args;
	struct page **pages;
	struct fuse_page_desc *descs;
	unsigned int num_pages;
};

enum fuse_req_flag {
	FR_ISREPLY = 0,
	FR_FORCE = 1,
	FR_BACKGROUND = 2,
	FR_WAITING = 3,
	FR_ABORTED = 4,
	FR_INTERRUPTED = 5,
	FR_LOCKED = 6,
	FR_PENDING = 7,
	FR_SENT = 8,
	FR_FINISHED = 9,
	FR_PRIVATE = 10,
	FR_ASYNC = 11,
};

struct fuse_req {
	struct list_head list;
	struct list_head intr_entry;
	struct fuse_args *args;
	refcount_t count;
	long unsigned int flags;
	struct {
		struct fuse_in_header h;
	} in;
	struct {
		struct fuse_out_header h;
	} out;
	wait_queue_head_t waitq;
	struct fuse_mount *fm;
};

struct fuse_iqueue;

struct fuse_iqueue_ops {
	void (*wake_forget_and_unlock)(struct fuse_iqueue *);
	void (*wake_interrupt_and_unlock)(struct fuse_iqueue *);
	void (*wake_pending_and_unlock)(struct fuse_iqueue *);
	void (*release)(struct fuse_iqueue *);
};

struct fuse_iqueue {
	unsigned int connected;
	spinlock_t lock;
	wait_queue_head_t waitq;
	u64 reqctr;
	struct list_head pending;
	struct list_head interrupts;
	struct fuse_forget_link forget_list_head;
	struct fuse_forget_link *forget_list_tail;
	int forget_batch;
	struct fasync_struct *fasync;
	const struct fuse_iqueue_ops *ops;
	void *priv;
};

struct fuse_pqueue {
	unsigned int connected;
	spinlock_t lock;
	struct list_head *processing;
	struct list_head io;
};

struct fuse_dev {
	struct fuse_conn *fc;
	struct fuse_pqueue pq;
	struct list_head entry;
};

struct fuse_sync_bucket;

struct fuse_conn {
	spinlock_t lock;
	refcount_t count;
	atomic_t dev_count;
	struct callback_head rcu;
	kuid_t user_id;
	kgid_t group_id;
	struct pid_namespace *pid_ns;
	struct user_namespace *user_ns;
	unsigned int max_read;
	unsigned int max_write;
	unsigned int max_pages;
	unsigned int max_pages_limit;
	struct fuse_iqueue iq;
	atomic64_t khctr;
	struct rb_root polled_files;
	unsigned int max_background;
	unsigned int congestion_threshold;
	unsigned int num_background;
	unsigned int active_background;
	struct list_head bg_queue;
	spinlock_t bg_lock;
	int initialized;
	int blocked;
	wait_queue_head_t blocked_waitq;
	unsigned int connected;
	bool aborted;
	unsigned int conn_error: 1;
	unsigned int conn_init: 1;
	unsigned int async_read: 1;
	unsigned int abort_err: 1;
	unsigned int atomic_o_trunc: 1;
	unsigned int export_support: 1;
	unsigned int writeback_cache: 1;
	unsigned int parallel_dirops: 1;
	unsigned int handle_killpriv: 1;
	unsigned int cache_symlinks: 1;
	unsigned int legacy_opts_show: 1;
	unsigned int handle_killpriv_v2: 1;
	unsigned int no_open: 1;
	unsigned int no_opendir: 1;
	unsigned int no_fsync: 1;
	unsigned int no_fsyncdir: 1;
	unsigned int no_flush: 1;
	unsigned int no_setxattr: 1;
	unsigned int setxattr_ext: 1;
	unsigned int no_getxattr: 1;
	unsigned int no_listxattr: 1;
	unsigned int no_removexattr: 1;
	unsigned int no_lock: 1;
	unsigned int no_access: 1;
	unsigned int no_create: 1;
	unsigned int no_interrupt: 1;
	unsigned int no_bmap: 1;
	unsigned int no_poll: 1;
	unsigned int big_writes: 1;
	unsigned int dont_mask: 1;
	unsigned int no_flock: 1;
	unsigned int no_fallocate: 1;
	unsigned int no_rename2: 1;
	unsigned int auto_inval_data: 1;
	unsigned int explicit_inval_data: 1;
	unsigned int do_readdirplus: 1;
	unsigned int readdirplus_auto: 1;
	unsigned int async_dio: 1;
	unsigned int no_lseek: 1;
	unsigned int posix_acl: 1;
	unsigned int default_permissions: 1;
	unsigned int allow_other: 1;
	unsigned int no_copy_file_range: 1;
	unsigned int destroy: 1;
	unsigned int delete_stale: 1;
	unsigned int no_control: 1;
	unsigned int no_force_umount: 1;
	unsigned int auto_submounts: 1;
	unsigned int sync_fs: 1;
	atomic_t num_waiting;
	unsigned int minor;
	struct list_head entry;
	dev_t dev;
	struct dentry *ctl_dentry[5];
	int ctl_ndents;
	u32 scramble_key[4];
	atomic64_t attr_version;
	void (*release)(struct fuse_conn *);
	struct rw_semaphore killsb;
	struct list_head devices;
	struct list_head mounts;
	struct fuse_sync_bucket *curr_bucket;
};

struct fuse_sync_bucket {
	atomic_t count;
	wait_queue_head_t waitq;
	struct callback_head rcu;
};

struct fuse_copy_state {
	int write;
	struct fuse_req *req;
	struct iov_iter *iter;
	struct pipe_buffer *pipebufs;
	struct pipe_buffer *currbuf;
	struct pipe_inode_info *pipe;
	long unsigned int nr_segs;
	struct page *pg;
	unsigned int len;
	unsigned int offset;
	unsigned int move_pages: 1;
};

struct fuse_retrieve_args {
	struct fuse_args_pages ap;
	struct fuse_notify_retrieve_in inarg;
};

struct fuse_attr {
	uint64_t ino;
	uint64_t size;
	uint64_t blocks;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t nlink;
	uint32_t uid;
	uint32_t gid;
	uint32_t rdev;
	uint32_t blksize;
	uint32_t flags;
};

struct fuse_entry_out {
	uint64_t nodeid;
	uint64_t generation;
	uint64_t entry_valid;
	uint64_t attr_valid;
	uint32_t entry_valid_nsec;
	uint32_t attr_valid_nsec;
	struct fuse_attr attr;
};

struct fuse_getattr_in {
	uint32_t getattr_flags;
	uint32_t dummy;
	uint64_t fh;
};

struct fuse_attr_out {
	uint64_t attr_valid;
	uint32_t attr_valid_nsec;
	uint32_t dummy;
	struct fuse_attr attr;
};

struct fuse_mknod_in {
	uint32_t mode;
	uint32_t rdev;
	uint32_t umask;
	uint32_t padding;
};

struct fuse_mkdir_in {
	uint32_t mode;
	uint32_t umask;
};

struct fuse_rename2_in {
	uint64_t newdir;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_link_in {
	uint64_t oldnodeid;
};

struct fuse_setattr_in {
	uint32_t valid;
	uint32_t padding;
	uint64_t fh;
	uint64_t size;
	uint64_t lock_owner;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t unused4;
	uint32_t uid;
	uint32_t gid;
	uint32_t unused5;
};

struct fuse_create_in {
	uint32_t flags;
	uint32_t mode;
	uint32_t umask;
	uint32_t open_flags;
};

struct fuse_open_out {
	uint64_t fh;
	uint32_t open_flags;
	uint32_t padding;
};

struct fuse_access_in {
	uint32_t mask;
	uint32_t padding;
};

struct fuse_inode {
	struct inode inode;
	u64 nodeid;
	u64 nlookup;
	struct fuse_forget_link *forget;
	u64 i_time;
	u32 inval_mask;
	umode_t orig_i_mode;
	u64 orig_ino;
	u64 attr_version;
	union {
		struct {
			struct list_head write_files;
			struct list_head queued_writes;
			int writectr;
			wait_queue_head_t page_waitq;
			struct rb_root writepages;
		};
		struct {
			bool cached;
			loff_t size;
			loff_t pos;
			u64 version;
			struct timespec64 mtime;
			u64 iversion;
			spinlock_t lock;
		} rdc;
	};
	long unsigned int state;
	struct mutex mutex;
	spinlock_t lock;
};

enum {
	FUSE_I_ADVISE_RDPLUS = 0,
	FUSE_I_INIT_RDPLUS = 1,
	FUSE_I_SIZE_UNSTABLE = 2,
	FUSE_I_BAD = 3,
};

struct fuse_file_lock {
	uint64_t start;
	uint64_t end;
	uint32_t type;
	uint32_t pid;
};

struct fuse_open_in {
	uint32_t flags;
	uint32_t open_flags;
};

struct fuse_release_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t release_flags;
	uint64_t lock_owner;
};

struct fuse_flush_in {
	uint64_t fh;
	uint32_t unused;
	uint32_t padding;
	uint64_t lock_owner;
};

struct fuse_read_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t read_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t write_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_fsync_in {
	uint64_t fh;
	uint32_t fsync_flags;
	uint32_t padding;
};

struct fuse_lk_in {
	uint64_t fh;
	uint64_t owner;
	struct fuse_file_lock lk;
	uint32_t lk_flags;
	uint32_t padding;
};

struct fuse_lk_out {
	struct fuse_file_lock lk;
};

struct fuse_bmap_in {
	uint64_t block;
	uint32_t blocksize;
	uint32_t padding;
};

struct fuse_bmap_out {
	uint64_t block;
};

struct fuse_poll_in {
	uint64_t fh;
	uint64_t kh;
	uint32_t flags;
	uint32_t events;
};

struct fuse_poll_out {
	uint32_t revents;
	uint32_t padding;
};

struct fuse_fallocate_in {
	uint64_t fh;
	uint64_t offset;
	uint64_t length;
	uint32_t mode;
	uint32_t padding;
};

struct fuse_lseek_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t whence;
	uint32_t padding;
};

struct fuse_lseek_out {
	uint64_t offset;
};

struct fuse_copy_file_range_in {
	uint64_t fh_in;
	uint64_t off_in;
	uint64_t nodeid_out;
	uint64_t fh_out;
	uint64_t off_out;
	uint64_t len;
	uint64_t flags;
};

struct fuse_release_args {
	struct fuse_args args;
	struct fuse_release_in inarg;
	struct inode *inode;
};

struct fuse_io_priv {
	struct kref refcnt;
	int async;
	spinlock_t lock;
	unsigned int reqs;
	ssize_t bytes;
	size_t size;
	__u64 offset;
	bool write;
	bool should_dirty;
	int err;
	struct kiocb *iocb;
	struct completion *done;
	bool blocking;
};

struct fuse_io_args {
	union {
		struct {
			struct fuse_read_in in;
			u64 attr_ver;
		} read;
		struct {
			struct fuse_write_in in;
			struct fuse_write_out out;
			bool page_locked;
		} write;
	};
	struct fuse_args_pages ap;
	struct fuse_io_priv *io;
	struct fuse_file *ff;
};

struct fuse_writepage_args {
	struct fuse_io_args ia;
	struct rb_node writepages_entry;
	struct list_head queue_entry;
	struct fuse_writepage_args *next;
	struct inode *inode;
	struct fuse_sync_bucket *bucket;
};

struct fuse_fill_wb_data {
	struct fuse_writepage_args *wpa;
	struct fuse_file *ff;
	struct inode *inode;
	struct page **orig_pages;
	unsigned int max_pages;
};

struct fuse_kstatfs {
	uint64_t blocks;
	uint64_t bfree;
	uint64_t bavail;
	uint64_t files;
	uint64_t ffree;
	uint32_t bsize;
	uint32_t namelen;
	uint32_t frsize;
	uint32_t padding;
	uint32_t spare[6];
};

struct fuse_statfs_out {
	struct fuse_kstatfs st;
};

struct fuse_init_in {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
};

struct fuse_init_out {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint16_t max_background;
	uint16_t congestion_threshold;
	uint32_t max_write;
	uint32_t time_gran;
	uint16_t max_pages;
	uint16_t map_alignment;
	uint32_t unused[8];
};

struct fuse_syncfs_in {
	uint64_t padding;
};

struct fuse_fs_context {
	int fd;
	struct file *file;
	unsigned int rootmode;
	kuid_t user_id;
	kgid_t group_id;
	bool is_bdev: 1;
	bool fd_present: 1;
	bool rootmode_present: 1;
	bool user_id_present: 1;
	bool group_id_present: 1;
	bool default_permissions: 1;
	bool allow_other: 1;
	bool destroy: 1;
	bool no_control: 1;
	bool no_force_umount: 1;
	bool legacy_opts_show: 1;
	bool dax: 1;
	unsigned int max_read;
	unsigned int blksize;
	const char *subtype;
	struct dax_device *dax_dev;
	void **fudptr;
};

enum {
	OPT_SOURCE = 0,
	OPT_SUBTYPE = 1,
	OPT_FD = 2,
	OPT_ROOTMODE = 3,
	OPT_USER_ID = 4,
	OPT_GROUP_ID = 5,
	OPT_DEFAULT_PERMISSIONS = 6,
	OPT_ALLOW_OTHER = 7,
	OPT_MAX_READ = 8,
	OPT_BLKSIZE = 9,
	OPT_ERR = 10,
};

struct fuse_inode_handle {
	u64 nodeid;
	u32 generation;
};

struct fuse_init_args {
	struct fuse_args args;
	struct fuse_init_in in;
	struct fuse_init_out out;
};

struct fuse_setxattr_in {
	uint32_t size;
	uint32_t flags;
	uint32_t setxattr_flags;
	uint32_t padding;
};

struct fuse_getxattr_in {
	uint32_t size;
	uint32_t padding;
};

struct fuse_getxattr_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_dirent {
	uint64_t ino;
	uint64_t off;
	uint32_t namelen;
	uint32_t type;
	char name[0];
};

struct fuse_direntplus {
	struct fuse_entry_out entry_out;
	struct fuse_dirent dirent;
};

enum fuse_parse_result {
	FOUND_ERR = 4294967295,
	FOUND_NONE = 0,
	FOUND_SOME = 1,
	FOUND_ALL = 2,
};

struct fuse_ioctl_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t cmd;
	uint64_t arg;
	uint32_t in_size;
	uint32_t out_size;
};

struct fuse_ioctl_iovec {
	uint64_t base;
	uint64_t len;
};

struct fuse_ioctl_out {
	int32_t result;
	uint32_t flags;
	uint32_t in_iovs;
	uint32_t out_iovs;
};

struct ovl_config {
	char *lowerdir;
	char *upperdir;
	char *workdir;
	bool default_permissions;
	bool redirect_dir;
	bool redirect_follow;
	const char *redirect_mode;
	bool index;
	bool uuid;
	bool nfs_export;
	int xino;
	bool metacopy;
	bool userxattr;
	bool ovl_volatile;
};

struct ovl_sb {
	struct super_block *sb;
	dev_t pseudo_dev;
	bool bad_uuid;
	bool is_lower;
};

struct ovl_layer {
	struct vfsmount *mnt;
	struct inode *trap;
	struct ovl_sb *fs;
	int idx;
	int fsid;
};

struct ovl_path {
	const struct ovl_layer *layer;
	struct dentry *dentry;
};

struct ovl_fs {
	unsigned int numlayer;
	unsigned int numfs;
	const struct ovl_layer *layers;
	struct ovl_sb *fs;
	struct dentry *workbasedir;
	struct dentry *workdir;
	struct dentry *indexdir;
	long int namelen;
	struct ovl_config config;
	const struct cred *creator_cred;
	bool tmpfile;
	bool noxattr;
	bool upperdir_locked;
	bool workdir_locked;
	bool share_whiteout;
	struct inode *workbasedir_trap;
	struct inode *workdir_trap;
	struct inode *indexdir_trap;
	int xino_mode;
	atomic_long_t last_ino;
	struct dentry *whiteout;
	errseq_t errseq;
};

struct ovl_entry {
	union {
		struct {
			long unsigned int flags;
		};
		struct callback_head rcu;
	};
	unsigned int numlower;
	struct ovl_path lowerstack[0];
};

struct ovl_dir_cache;

struct ovl_inode {
	union {
		struct ovl_dir_cache *cache;
		struct inode *lowerdata;
	};
	const char *redirect;
	u64 version;
	long unsigned int flags;
	struct inode vfs_inode;
	struct dentry *__upperdentry;
	struct ovl_path lowerpath;
	struct mutex lock;
};

enum ovl_path_type {
	__OVL_PATH_UPPER = 1,
	__OVL_PATH_MERGE = 2,
	__OVL_PATH_ORIGIN = 4,
};

enum ovl_xattr {
	OVL_XATTR_OPAQUE = 0,
	OVL_XATTR_REDIRECT = 1,
	OVL_XATTR_ORIGIN = 2,
	OVL_XATTR_IMPURE = 3,
	OVL_XATTR_NLINK = 4,
	OVL_XATTR_UPPER = 5,
	OVL_XATTR_METACOPY = 6,
	OVL_XATTR_PROTATTR = 7,
};

enum ovl_inode_flag {
	OVL_IMPURE = 0,
	OVL_WHITEOUTS = 1,
	OVL_INDEX = 2,
	OVL_UPPERDATA = 3,
	OVL_CONST_INO = 4,
};

enum ovl_entry_flag {
	OVL_E_UPPER_ALIAS = 0,
	OVL_E_OPAQUE = 1,
	OVL_E_CONNECTED = 2,
};

enum {
	OVL_XINO_OFF = 0,
	OVL_XINO_AUTO = 1,
	OVL_XINO_ON = 2,
};

struct ovl_inode_params {
	struct inode *newinode;
	struct dentry *upperdentry;
	struct ovl_path *lowerpath;
	bool index;
	unsigned int numlower;
	char *redirect;
	struct dentry *lowerdata;
};

struct ovl_cattr {
	dev_t rdev;
	umode_t mode;
	const char *link;
	struct dentry *hardlink;
};

enum {
	OPT_LOWERDIR = 0,
	OPT_UPPERDIR = 1,
	OPT_WORKDIR = 2,
	OPT_DEFAULT_PERMISSIONS___2 = 3,
	OPT_REDIRECT_DIR = 4,
	OPT_INDEX_ON = 5,
	OPT_INDEX_OFF = 6,
	OPT_UUID_ON = 7,
	OPT_UUID_OFF = 8,
	OPT_NFS_EXPORT_ON = 9,
	OPT_USERXATTR = 10,
	OPT_NFS_EXPORT_OFF = 11,
	OPT_XINO_ON = 12,
	OPT_XINO_OFF = 13,
	OPT_XINO_AUTO = 14,
	OPT_METACOPY_ON = 15,
	OPT_METACOPY_OFF = 16,
	OPT_VOLATILE = 17,
	OPT_ERR___2 = 18,
};

struct ovl_fb {
	u8 version;
	u8 magic;
	u8 len;
	u8 flags;
	u8 type;
	uuid_t uuid;
	u32 fid[0];
} __attribute__((packed));

struct ovl_fh {
	u8 padding[3];
	union {
		struct ovl_fb fb;
		struct {
			struct {} __empty_buf;
			u8 buf[0];
		};
	};
};

struct ovl_lookup_data {
	struct super_block *sb;
	struct qstr name;
	bool is_dir;
	bool opaque;
	bool stop;
	bool last;
	char *redirect;
	bool metacopy;
};

struct ovl_aio_req {
	struct kiocb iocb;
	refcount_t ref;
	struct kiocb *orig_iocb;
	struct fd fd;
};

enum ovl_copyop {
	OVL_COPY = 0,
	OVL_CLONE = 1,
	OVL_DEDUPE = 2,
};

struct ovl_dir_cache {
	long int refcount;
	u64 version;
	struct list_head entries;
	struct rb_root root;
};

struct ovl_cache_entry {
	unsigned int len;
	unsigned int type;
	u64 real_ino;
	u64 ino;
	struct list_head l_node;
	struct rb_node node;
	struct ovl_cache_entry *next_maybe_whiteout;
	bool is_upper;
	bool is_whiteout;
	char name[0];
};

struct ovl_readdir_data {
	struct dir_context ctx;
	struct dentry *dentry;
	bool is_lowest;
	struct rb_root *root;
	struct list_head *list;
	struct list_head middle;
	struct ovl_cache_entry *first_maybe_whiteout;
	int count;
	int err;
	bool is_upper;
	bool d_type_supported;
};

struct ovl_dir_file {
	bool is_real;
	bool is_upper;
	struct ovl_dir_cache *cache;
	struct list_head *cursor;
	struct file *realfile;
	struct file *upperfile;
};

struct ovl_readdir_translate {
	struct dir_context *orig_ctx;
	struct ovl_dir_cache *cache;
	struct dir_context ctx;
	u64 parent_ino;
	int fsid;
	int xinobits;
	bool xinowarn;
};

struct ovl_copy_up_ctx {
	struct dentry *parent;
	struct dentry *dentry;
	struct path lowerpath;
	struct kstat stat;
	struct kstat pstat;
	const char *link;
	struct dentry *destdir;
	struct qstr destname;
	struct dentry *workdir;
	bool origin;
	bool indexed;
	bool metacopy;
};

struct ovl_cu_creds {
	const struct cred *old;
	struct cred *new;
};

typedef __s64 xfs_off_t;

typedef long long unsigned int xfs_ino_t;

typedef __s64 xfs_daddr_t;

typedef __u32 xfs_nlink_t;

typedef uint32_t prid_t;

typedef uint32_t xfs_agblock_t;

typedef uint32_t xfs_agino_t;

typedef uint32_t xfs_extlen_t;

typedef uint32_t xfs_agnumber_t;

typedef int32_t xfs_extnum_t;

typedef int64_t xfs_fsize_t;

typedef int64_t xfs_lsn_t;

typedef int64_t xfs_csn_t;

typedef uint32_t xfs_dablk_t;

typedef uint32_t xfs_dahash_t;

typedef uint64_t xfs_fsblock_t;

typedef uint64_t xfs_rfsblock_t;

typedef uint64_t xfs_rtblock_t;

typedef uint64_t xfs_fileoff_t;

typedef uint64_t xfs_filblks_t;

typedef void *xfs_failaddr_t;

typedef enum {
	XFS_LOOKUP_EQi = 0,
	XFS_LOOKUP_LEi = 1,
	XFS_LOOKUP_GEi = 2,
} xfs_lookup_t;

typedef enum {
	XFS_BTNUM_BNOi = 0,
	XFS_BTNUM_CNTi = 1,
	XFS_BTNUM_RMAPi = 2,
	XFS_BTNUM_BMAPi = 3,
	XFS_BTNUM_INOi = 4,
	XFS_BTNUM_FINOi = 5,
	XFS_BTNUM_REFCi = 6,
	XFS_BTNUM_MAX = 7,
} xfs_btnum_t;

struct xfs_name {
	const unsigned char *name;
	int len;
	int type;
};

typedef uint32_t xfs_dqid_t;

struct xfs_iext_leaf;

struct xfs_iext_cursor {
	struct xfs_iext_leaf *leaf;
	int pos;
};

typedef enum {
	XFS_EXT_NORM = 0,
	XFS_EXT_UNWRITTEN = 1,
} xfs_exntst_t;

struct xfs_bmbt_irec {
	xfs_fileoff_t br_startoff;
	xfs_fsblock_t br_startblock;
	xfs_filblks_t br_blockcount;
	xfs_exntst_t br_state;
};

enum xfs_ag_resv_type {
	XFS_AG_RESV_NONE = 0,
	XFS_AG_RESV_AGFL = 1,
	XFS_AG_RESV_METADATA = 2,
	XFS_AG_RESV_RMAPBT = 3,
};

typedef struct {
	struct rw_semaphore mr_lock;
} mrlock_t;

enum {
	__XBTS_lookup = 0,
	__XBTS_compare = 1,
	__XBTS_insrec = 2,
	__XBTS_delrec = 3,
	__XBTS_newroot = 4,
	__XBTS_killroot = 5,
	__XBTS_increment = 6,
	__XBTS_decrement = 7,
	__XBTS_lshift = 8,
	__XBTS_rshift = 9,
	__XBTS_split = 10,
	__XBTS_join = 11,
	__XBTS_alloc = 12,
	__XBTS_free = 13,
	__XBTS_moves = 14,
	__XBTS_MAX = 15,
};

struct __xfsstats {
	uint32_t xs_allocx;
	uint32_t xs_allocb;
	uint32_t xs_freex;
	uint32_t xs_freeb;
	uint32_t xs_abt_lookup;
	uint32_t xs_abt_compare;
	uint32_t xs_abt_insrec;
	uint32_t xs_abt_delrec;
	uint32_t xs_blk_mapr;
	uint32_t xs_blk_mapw;
	uint32_t xs_blk_unmap;
	uint32_t xs_add_exlist;
	uint32_t xs_del_exlist;
	uint32_t xs_look_exlist;
	uint32_t xs_cmp_exlist;
	uint32_t xs_bmbt_lookup;
	uint32_t xs_bmbt_compare;
	uint32_t xs_bmbt_insrec;
	uint32_t xs_bmbt_delrec;
	uint32_t xs_dir_lookup;
	uint32_t xs_dir_create;
	uint32_t xs_dir_remove;
	uint32_t xs_dir_getdents;
	uint32_t xs_trans_sync;
	uint32_t xs_trans_async;
	uint32_t xs_trans_empty;
	uint32_t xs_ig_attempts;
	uint32_t xs_ig_found;
	uint32_t xs_ig_frecycle;
	uint32_t xs_ig_missed;
	uint32_t xs_ig_dup;
	uint32_t xs_ig_reclaims;
	uint32_t xs_ig_attrchg;
	uint32_t xs_log_writes;
	uint32_t xs_log_blocks;
	uint32_t xs_log_noiclogs;
	uint32_t xs_log_force;
	uint32_t xs_log_force_sleep;
	uint32_t xs_try_logspace;
	uint32_t xs_sleep_logspace;
	uint32_t xs_push_ail;
	uint32_t xs_push_ail_success;
	uint32_t xs_push_ail_pushbuf;
	uint32_t xs_push_ail_pinned;
	uint32_t xs_push_ail_locked;
	uint32_t xs_push_ail_flushing;
	uint32_t xs_push_ail_restarts;
	uint32_t xs_push_ail_flush;
	uint32_t xs_xstrat_quick;
	uint32_t xs_xstrat_split;
	uint32_t xs_write_calls;
	uint32_t xs_read_calls;
	uint32_t xs_attr_get;
	uint32_t xs_attr_set;
	uint32_t xs_attr_remove;
	uint32_t xs_attr_list;
	uint32_t xs_iflush_count;
	uint32_t xs_icluster_flushcnt;
	uint32_t xs_icluster_flushinode;
	uint32_t vn_active;
	uint32_t vn_alloc;
	uint32_t vn_get;
	uint32_t vn_hold;
	uint32_t vn_rele;
	uint32_t vn_reclaim;
	uint32_t vn_remove;
	uint32_t vn_free;
	uint32_t xb_get;
	uint32_t xb_create;
	uint32_t xb_get_locked;
	uint32_t xb_get_locked_waited;
	uint32_t xb_busy_locked;
	uint32_t xb_miss_locked;
	uint32_t xb_page_retries;
	uint32_t xb_page_found;
	uint32_t xb_get_read;
	uint32_t xs_abtb_2[15];
	uint32_t xs_abtc_2[15];
	uint32_t xs_bmbt_2[15];
	uint32_t xs_ibt_2[15];
	uint32_t xs_fibt_2[15];
	uint32_t xs_rmap_2[15];
	uint32_t xs_refcbt_2[15];
	uint32_t xs_qm_dqreclaims;
	uint32_t xs_qm_dqreclaim_misses;
	uint32_t xs_qm_dquot_dups;
	uint32_t xs_qm_dqcachemisses;
	uint32_t xs_qm_dqcachehits;
	uint32_t xs_qm_dqwants;
	uint32_t xs_qm_dquot;
	uint32_t xs_qm_dquot_unused;
	uint64_t xs_xstrat_bytes;
	uint64_t xs_write_bytes;
	uint64_t xs_read_bytes;
	uint64_t defer_relog;
};

struct xfsstats {
	union {
		struct __xfsstats s;
		uint32_t a[187];
	};
};

struct xfs_kobj {
	struct kobject kobject;
	struct completion complete;
};

struct xstats {
	struct xfsstats *xs_stats;
	struct xfs_kobj xs_kobj;
};

typedef unsigned int xfs_buf_flags_t;

struct xfs_mount;

struct xfs_buftarg {
	dev_t bt_dev;
	struct block_device *bt_bdev;
	struct dax_device *bt_daxdev;
	struct xfs_mount *bt_mount;
	unsigned int bt_meta_sectorsize;
	size_t bt_meta_sectormask;
	size_t bt_logical_sectorsize;
	size_t bt_logical_sectormask;
	struct shrinker bt_shrinker;
	struct list_lru bt_lru;
	struct percpu_counter bt_io_count;
	struct ratelimit_state bt_ioerror_rl;
};

struct xfs_sb {
	uint32_t sb_magicnum;
	uint32_t sb_blocksize;
	xfs_rfsblock_t sb_dblocks;
	xfs_rfsblock_t sb_rblocks;
	xfs_rtblock_t sb_rextents;
	uuid_t sb_uuid;
	xfs_fsblock_t sb_logstart;
	xfs_ino_t sb_rootino;
	xfs_ino_t sb_rbmino;
	xfs_ino_t sb_rsumino;
	xfs_agblock_t sb_rextsize;
	xfs_agblock_t sb_agblocks;
	xfs_agnumber_t sb_agcount;
	xfs_extlen_t sb_rbmblocks;
	xfs_extlen_t sb_logblocks;
	uint16_t sb_versionnum;
	uint16_t sb_sectsize;
	uint16_t sb_inodesize;
	uint16_t sb_inopblock;
	char sb_fname[12];
	uint8_t sb_blocklog;
	uint8_t sb_sectlog;
	uint8_t sb_inodelog;
	uint8_t sb_inopblog;
	uint8_t sb_agblklog;
	uint8_t sb_rextslog;
	uint8_t sb_inprogress;
	uint8_t sb_imax_pct;
	uint64_t sb_icount;
	uint64_t sb_ifree;
	uint64_t sb_fdblocks;
	uint64_t sb_frextents;
	xfs_ino_t sb_uquotino;
	xfs_ino_t sb_gquotino;
	uint16_t sb_qflags;
	uint8_t sb_flags;
	uint8_t sb_shared_vn;
	xfs_extlen_t sb_inoalignmt;
	uint32_t sb_unit;
	uint32_t sb_width;
	uint8_t sb_dirblklog;
	uint8_t sb_logsectlog;
	uint16_t sb_logsectsize;
	uint32_t sb_logsunit;
	uint32_t sb_features2;
	uint32_t sb_bad_features2;
	uint32_t sb_features_compat;
	uint32_t sb_features_ro_compat;
	uint32_t sb_features_incompat;
	uint32_t sb_features_log_incompat;
	uint32_t sb_crc;
	xfs_extlen_t sb_spino_align;
	xfs_ino_t sb_pquotino;
	xfs_lsn_t sb_lsn;
	uuid_t sb_meta_uuid;
};

typedef struct xfs_buftarg xfs_buftarg_t;

struct xfs_ino_geometry {
	uint64_t maxicount;
	unsigned int inode_cluster_size;
	unsigned int inode_cluster_size_raw;
	unsigned int inodes_per_cluster;
	unsigned int blocks_per_cluster;
	unsigned int cluster_align;
	unsigned int cluster_align_inodes;
	unsigned int inoalign_mask;
	unsigned int inobt_mxr[2];
	unsigned int inobt_mnr[2];
	unsigned int inobt_maxlevels;
	unsigned int ialloc_inos;
	unsigned int ialloc_blks;
	unsigned int ialloc_min_blks;
	unsigned int ialloc_align;
	unsigned int agino_log;
	unsigned int attr_fork_offset;
	uint64_t new_diflags2;
};

struct xfs_trans_res {
	uint tr_logres;
	int tr_logcount;
	int tr_logflags;
};

struct xfs_trans_resv {
	struct xfs_trans_res tr_write;
	struct xfs_trans_res tr_itruncate;
	struct xfs_trans_res tr_rename;
	struct xfs_trans_res tr_link;
	struct xfs_trans_res tr_remove;
	struct xfs_trans_res tr_symlink;
	struct xfs_trans_res tr_create;
	struct xfs_trans_res tr_create_tmpfile;
	struct xfs_trans_res tr_mkdir;
	struct xfs_trans_res tr_ifree;
	struct xfs_trans_res tr_ichange;
	struct xfs_trans_res tr_growdata;
	struct xfs_trans_res tr_addafork;
	struct xfs_trans_res tr_writeid;
	struct xfs_trans_res tr_attrinval;
	struct xfs_trans_res tr_attrsetm;
	struct xfs_trans_res tr_attrsetrt;
	struct xfs_trans_res tr_attrrm;
	struct xfs_trans_res tr_clearagi;
	struct xfs_trans_res tr_growrtalloc;
	struct xfs_trans_res tr_growrtzero;
	struct xfs_trans_res tr_growrtfree;
	struct xfs_trans_res tr_qm_setqlim;
	struct xfs_trans_res tr_qm_dqalloc;
	struct xfs_trans_res tr_sb;
	struct xfs_trans_res tr_fsyncts;
};

struct xfs_error_cfg {
	struct xfs_kobj kobj;
	int max_retries;
	long int retry_timeout;
};

struct xfs_ail;

struct xfs_buf;

struct xfs_da_geometry;

struct xlog;

struct xfs_inode;

struct xfs_quotainfo;

struct xfs_mru_cache;

struct xfs_mount {
	struct xfs_sb m_sb;
	struct super_block *m_super;
	struct xfs_ail *m_ail;
	struct xfs_buf *m_sb_bp;
	char *m_rtname;
	char *m_logname;
	struct xfs_da_geometry *m_dir_geo;
	struct xfs_da_geometry *m_attr_geo;
	struct xlog *m_log;
	struct xfs_inode *m_rbmip;
	struct xfs_inode *m_rsumip;
	struct xfs_inode *m_rootip;
	struct xfs_quotainfo *m_quotainfo;
	xfs_buftarg_t *m_ddev_targp;
	xfs_buftarg_t *m_logdev_targp;
	xfs_buftarg_t *m_rtdev_targp;
	struct list_head m_mount_list;
	void *m_inodegc;
	uint8_t *m_rsum_cache;
	struct xfs_mru_cache *m_filestream;
	struct workqueue_struct *m_buf_workqueue;
	struct workqueue_struct *m_unwritten_workqueue;
	struct workqueue_struct *m_reclaim_workqueue;
	struct workqueue_struct *m_sync_workqueue;
	struct workqueue_struct *m_blockgc_wq;
	struct workqueue_struct *m_inodegc_wq;
	int m_bsize;
	uint8_t m_blkbit_log;
	uint8_t m_blkbb_log;
	uint8_t m_agno_log;
	uint8_t m_sectbb_log;
	uint m_blockmask;
	uint m_blockwsize;
	uint m_blockwmask;
	uint m_alloc_mxr[2];
	uint m_alloc_mnr[2];
	uint m_bmap_dmxr[2];
	uint m_bmap_dmnr[2];
	uint m_rmap_mxr[2];
	uint m_rmap_mnr[2];
	uint m_refc_mxr[2];
	uint m_refc_mnr[2];
	uint m_ag_maxlevels;
	uint m_bm_maxlevels[2];
	uint m_rmap_maxlevels;
	uint m_refc_maxlevels;
	xfs_extlen_t m_ag_prealloc_blocks;
	uint m_alloc_set_aside;
	uint m_ag_max_usable;
	int m_dalign;
	int m_swidth;
	xfs_agnumber_t m_maxagi;
	uint m_allocsize_log;
	uint m_allocsize_blocks;
	int m_logbufs;
	int m_logbsize;
	uint m_rsumlevels;
	uint m_rsumsize;
	int m_fixedfsid[2];
	uint m_qflags;
	uint64_t m_features;
	uint64_t m_low_space[5];
	uint64_t m_low_rtexts[5];
	struct xfs_ino_geometry m_ino_geo;
	struct xfs_trans_resv m_resv;
	long unsigned int m_opstate;
	bool m_always_cow;
	bool m_fail_unmount;
	bool m_finobt_nores;
	bool m_update_sb;
	uint8_t m_fs_checked;
	uint8_t m_fs_sick;
	uint8_t m_rt_checked;
	uint8_t m_rt_sick;
	long: 64;
	spinlock_t m_sb_lock;
	struct percpu_counter m_icount;
	struct percpu_counter m_ifree;
	struct percpu_counter m_fdblocks;
	struct percpu_counter m_delalloc_blks;
	atomic64_t m_allocbt_blks;
	struct xarray m_perag_tree;
	spinlock_t m_perag_lock;
	uint64_t m_resblks;
	uint64_t m_resblks_avail;
	uint64_t m_resblks_save;
	struct delayed_work m_reclaim_work;
	struct xfs_kobj m_kobj;
	struct xfs_kobj m_error_kobj;
	struct xfs_kobj m_error_meta_kobj;
	struct xfs_error_cfg m_error_cfg[4];
	struct xstats m_stats;
	xfs_agnumber_t m_agfrotor;
	xfs_agnumber_t m_agirotor;
	spinlock_t m_agirotor_lock;
	struct shrinker m_inodegc_shrinker;
	struct work_struct m_flush_inodes_work;
	uint32_t m_generation;
	struct mutex m_growlock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xfs_buf_map {
	xfs_daddr_t bm_bn;
	int bm_len;
};

struct xfs_buf_ops {
	char *name;
	union {
		__be32 magic[2];
		__be16 magic16[2];
	};
	void (*verify_read)(struct xfs_buf *);
	void (*verify_write)(struct xfs_buf *);
	xfs_failaddr_t (*verify_struct)(struct xfs_buf *);
};

struct xfs_perag;

struct xfs_buf_log_item;

struct xfs_trans;

struct xfs_buf {
	struct rhash_head b_rhash_head;
	xfs_daddr_t b_rhash_key;
	int b_length;
	atomic_t b_hold;
	atomic_t b_lru_ref;
	xfs_buf_flags_t b_flags;
	struct semaphore b_sema;
	struct list_head b_lru;
	spinlock_t b_lock;
	unsigned int b_state;
	int b_io_error;
	wait_queue_head_t b_waiters;
	struct list_head b_list;
	struct xfs_perag *b_pag;
	struct xfs_mount *b_mount;
	struct xfs_buftarg *b_target;
	void *b_addr;
	struct work_struct b_ioend_work;
	struct completion b_iowait;
	struct xfs_buf_log_item *b_log_item;
	struct list_head b_li_list;
	struct xfs_trans *b_transp;
	struct page **b_pages;
	struct page *b_page_array[2];
	struct xfs_buf_map *b_maps;
	struct xfs_buf_map __b_map;
	int b_map_count;
	atomic_t b_pin_count;
	atomic_t b_io_remaining;
	unsigned int b_page_count;
	unsigned int b_offset;
	int b_error;
	int b_retries;
	long unsigned int b_first_retry_time;
	int b_last_error;
	const struct xfs_buf_ops *b_ops;
};

struct xfs_ag_resv {
	xfs_extlen_t ar_orig_reserved;
	xfs_extlen_t ar_reserved;
	xfs_extlen_t ar_asked;
};

struct xfs_perag {
	struct xfs_mount *pag_mount;
	xfs_agnumber_t pag_agno;
	atomic_t pag_ref;
	char pagf_init;
	char pagi_init;
	char pagf_metadata;
	char pagi_inodeok;
	uint8_t pagf_levels[3];
	bool pagf_agflreset;
	uint32_t pagf_flcount;
	xfs_extlen_t pagf_freeblks;
	xfs_extlen_t pagf_longest;
	uint32_t pagf_btreeblks;
	xfs_agino_t pagi_freecount;
	xfs_agino_t pagi_count;
	xfs_agino_t pagl_pagino;
	xfs_agino_t pagl_leftrec;
	xfs_agino_t pagl_rightrec;
	int pagb_count;
	uint8_t pagf_refcount_level;
	struct xfs_ag_resv pag_meta_resv;
	struct xfs_ag_resv pag_rmapbt_resv;
	uint16_t pag_checked;
	uint16_t pag_sick;
	spinlock_t pag_state_lock;
	spinlock_t pagb_lock;
	struct rb_root pagb_tree;
	unsigned int pagb_gen;
	wait_queue_head_t pagb_wait;
	atomic_t pagf_fstrms;
	spinlock_t pag_ici_lock;
	struct xarray pag_ici_root;
	int pag_ici_reclaimable;
	long unsigned int pag_ici_reclaim_cursor;
	spinlock_t pag_buf_lock;
	struct rhashtable pag_buf_hash;
	struct callback_head callback_head;
	struct delayed_work pag_blockgc_work;
	struct rhashtable pagi_unlinked_hash;
};

struct xfs_item_ops;

struct xfs_log_vec;

struct xfs_log_item {
	struct list_head li_ail;
	struct list_head li_trans;
	xfs_lsn_t li_lsn;
	struct xfs_mount *li_mountp;
	struct xfs_ail *li_ailp;
	uint li_type;
	long unsigned int li_flags;
	struct xfs_buf *li_buf;
	struct list_head li_bio_list;
	const struct xfs_item_ops *li_ops;
	struct list_head li_cil;
	struct xfs_log_vec *li_lv;
	struct xfs_log_vec *li_lv_shadow;
	xfs_csn_t li_seq;
};

struct xfs_buf_log_format {
	short unsigned int blf_type;
	short unsigned int blf_size;
	short unsigned int blf_flags;
	short unsigned int blf_len;
	int64_t blf_blkno;
	unsigned int blf_map_size;
	unsigned int blf_data_map[17];
};

struct xfs_buf_log_item {
	struct xfs_log_item bli_item;
	struct xfs_buf *bli_buf;
	unsigned int bli_flags;
	unsigned int bli_recur;
	atomic_t bli_refcount;
	int bli_format_count;
	struct xfs_buf_log_format *bli_formats;
	struct xfs_buf_log_format __bli_format;
};

struct xlog_ticket;

struct xfs_dquot_acct;

struct xfs_trans {
	unsigned int t_magic;
	unsigned int t_log_res;
	unsigned int t_log_count;
	unsigned int t_blk_res;
	unsigned int t_blk_res_used;
	unsigned int t_rtx_res;
	unsigned int t_rtx_res_used;
	unsigned int t_flags;
	xfs_fsblock_t t_firstblock;
	struct xlog_ticket *t_ticket;
	struct xfs_mount *t_mountp;
	struct xfs_dquot_acct *t_dqinfo;
	int64_t t_icount_delta;
	int64_t t_ifree_delta;
	int64_t t_fdblocks_delta;
	int64_t t_res_fdblocks_delta;
	int64_t t_frextents_delta;
	int64_t t_res_frextents_delta;
	int64_t t_dblocks_delta;
	int64_t t_agcount_delta;
	int64_t t_imaxpct_delta;
	int64_t t_rextsize_delta;
	int64_t t_rbmblocks_delta;
	int64_t t_rblocks_delta;
	int64_t t_rextents_delta;
	int64_t t_rextslog_delta;
	struct list_head t_items;
	struct list_head t_busy;
	struct list_head t_dfops;
	long unsigned int t_pflags;
};

struct xfs_agf {
	__be32 agf_magicnum;
	__be32 agf_versionnum;
	__be32 agf_seqno;
	__be32 agf_length;
	__be32 agf_roots[3];
	__be32 agf_levels[3];
	__be32 agf_flfirst;
	__be32 agf_fllast;
	__be32 agf_flcount;
	__be32 agf_freeblks;
	__be32 agf_longest;
	__be32 agf_btreeblks;
	uuid_t agf_uuid;
	__be32 agf_rmap_blocks;
	__be32 agf_refcount_blocks;
	__be32 agf_refcount_root;
	__be32 agf_refcount_level;
	__be64 agf_spare64[14];
	__be64 agf_lsn;
	__be32 agf_crc;
	__be32 agf_spare2;
};

enum xfs_dinode_fmt {
	XFS_DINODE_FMT_DEV = 0,
	XFS_DINODE_FMT_LOCAL = 1,
	XFS_DINODE_FMT_EXTENTS = 2,
	XFS_DINODE_FMT_BTREE = 3,
	XFS_DINODE_FMT_UUID = 4,
};

struct xfs_alloc_rec {
	__be32 ar_startblock;
	__be32 ar_blockcount;
};

typedef struct xfs_alloc_rec xfs_alloc_key_t;

struct xfs_alloc_rec_incore {
	xfs_agblock_t ar_startblock;
	xfs_extlen_t ar_blockcount;
};

typedef uint64_t xfs_inofree_t;

struct xfs_inobt_rec {
	__be32 ir_startino;
	union {
		struct {
			__be32 ir_freecount;
		} f;
		struct {
			__be16 ir_holemask;
			__u8 ir_count;
			__u8 ir_freecount;
		} sp;
	} ir_u;
	__be64 ir_free;
};

struct xfs_inobt_rec_incore {
	xfs_agino_t ir_startino;
	uint16_t ir_holemask;
	uint8_t ir_count;
	uint8_t ir_freecount;
	xfs_inofree_t ir_free;
};

struct xfs_inobt_key {
	__be32 ir_startino;
};

struct xfs_owner_info {
	uint64_t oi_owner;
	xfs_fileoff_t oi_offset;
	unsigned int oi_flags;
};

struct xfs_rmap_rec {
	__be32 rm_startblock;
	__be32 rm_blockcount;
	__be64 rm_owner;
	__be64 rm_offset;
};

struct xfs_rmap_irec {
	xfs_agblock_t rm_startblock;
	xfs_extlen_t rm_blockcount;
	uint64_t rm_owner;
	uint64_t rm_offset;
	unsigned int rm_flags;
};

struct xfs_rmap_key {
	__be32 rm_startblock;
	__be64 rm_owner;
	__be64 rm_offset;
} __attribute__((packed));

struct xfs_refcount_rec {
	__be32 rc_startblock;
	__be32 rc_blockcount;
	__be32 rc_refcount;
};

struct xfs_refcount_key {
	__be32 rc_startblock;
};

struct xfs_refcount_irec {
	xfs_agblock_t rc_startblock;
	xfs_extlen_t rc_blockcount;
	xfs_nlink_t rc_refcount;
};

struct xfs_bmbt_rec {
	__be64 l0;
	__be64 l1;
};

typedef struct xfs_bmbt_rec xfs_bmbt_rec_t;

typedef xfs_bmbt_rec_t xfs_bmdr_rec_t;

struct xfs_bmbt_key {
	__be64 br_startoff;
};

typedef struct xfs_bmbt_key xfs_bmdr_key_t;

struct xfs_btree_block_shdr {
	__be32 bb_leftsib;
	__be32 bb_rightsib;
	__be64 bb_blkno;
	__be64 bb_lsn;
	uuid_t bb_uuid;
	__be32 bb_owner;
	__le32 bb_crc;
};

struct xfs_btree_block_lhdr {
	__be64 bb_leftsib;
	__be64 bb_rightsib;
	__be64 bb_blkno;
	__be64 bb_lsn;
	uuid_t bb_uuid;
	__be64 bb_owner;
	__le32 bb_crc;
	__be32 bb_pad;
};

struct xfs_btree_block {
	__be32 bb_magic;
	__be16 bb_level;
	__be16 bb_numrecs;
	union {
		struct xfs_btree_block_shdr s;
		struct xfs_btree_block_lhdr l;
	} bb_u;
};

typedef uint32_t xlog_tid_t;

struct xlog_rec_header {
	__be32 h_magicno;
	__be32 h_cycle;
	__be32 h_version;
	__be32 h_len;
	__be64 h_lsn;
	__be64 h_tail_lsn;
	__le32 h_crc;
	__be32 h_prev_block;
	__be32 h_num_logops;
	__be32 h_cycle_data[64];
	__be32 h_fmt;
	uuid_t h_fs_uuid;
	__be32 h_size;
};

typedef struct xlog_rec_header xlog_rec_header_t;

struct xlog_rec_ext_header {
	__be32 xh_cycle;
	__be32 xh_cycle_data[64];
};

typedef struct xlog_rec_ext_header xlog_rec_ext_header_t;

union xlog_in_core2 {
	xlog_rec_header_t hic_header;
	xlog_rec_ext_header_t hic_xheader;
	char hic_sector[512];
};

typedef union xlog_in_core2 xlog_in_core_2_t;

struct xfs_log_iovec {
	void *i_addr;
	int i_len;
	uint i_type;
};

struct xfs_trans_header {
	uint th_magic;
	uint th_type;
	int32_t th_tid;
	uint th_num_items;
};

typedef struct xfs_trans_header xfs_trans_header_t;

struct xfs_inode_log_format {
	uint16_t ilf_type;
	uint16_t ilf_size;
	uint32_t ilf_fields;
	uint16_t ilf_asize;
	uint16_t ilf_dsize;
	uint32_t ilf_pad;
	uint64_t ilf_ino;
	union {
		uint32_t ilfu_rdev;
		uint8_t __pad[16];
	} ilf_u;
	int64_t ilf_blkno;
	int32_t ilf_len;
	int32_t ilf_boffset;
};

struct xfs_icreate_log {
	uint16_t icl_type;
	uint16_t icl_size;
	__be32 icl_ag;
	__be32 icl_agbno;
	__be32 icl_count;
	__be32 icl_isize;
	__be32 icl_length;
	__be32 icl_gen;
};

enum {
	XFS_LOWSP_1_PCNT = 0,
	XFS_LOWSP_2_PCNT = 1,
	XFS_LOWSP_3_PCNT = 2,
	XFS_LOWSP_4_PCNT = 3,
	XFS_LOWSP_5_PCNT = 4,
	XFS_LOWSP_MAX = 5,
};

enum {
	XFS_ERR_METADATA = 0,
	XFS_ERR_CLASS_MAX = 1,
};

enum {
	XFS_ERR_DEFAULT = 0,
	XFS_ERR_EIO = 1,
	XFS_ERR_ENOSPC = 2,
	XFS_ERR_ENODEV = 3,
	XFS_ERR_ERRNO_MAX = 4,
};

typedef uint xfs_dir2_data_aoff_t;

struct xfs_da_geometry {
	unsigned int blksize;
	unsigned int fsbcount;
	uint8_t fsblog;
	uint8_t blklog;
	unsigned int node_hdr_size;
	unsigned int node_ents;
	unsigned int magicpct;
	xfs_dablk_t datablk;
	unsigned int leaf_hdr_size;
	unsigned int leaf_max_ents;
	xfs_dablk_t leafblk;
	unsigned int free_hdr_size;
	unsigned int free_max_bests;
	xfs_dablk_t freeblk;
	xfs_dir2_data_aoff_t data_first_offset;
	size_t data_entry_offset;
};

struct xlog_grant_head {
	spinlock_t lock;
	struct list_head waiters;
	atomic64_t grant;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xfs_cil;

struct xlog_in_core;

typedef struct xlog_in_core xlog_in_core_t;

struct xlog {
	struct xfs_mount *l_mp;
	struct xfs_ail *l_ailp;
	struct xfs_cil *l_cilp;
	struct xfs_buftarg *l_targ;
	struct workqueue_struct *l_ioend_workqueue;
	struct delayed_work l_work;
	long int l_opstate;
	uint l_quotaoffs_flag;
	struct list_head *l_buf_cancel_table;
	int l_iclog_hsize;
	int l_iclog_heads;
	uint l_sectBBsize;
	int l_iclog_size;
	int l_iclog_bufs;
	xfs_daddr_t l_logBBstart;
	int l_logsize;
	int l_logBBsize;
	wait_queue_head_t l_flush_wait;
	int l_covered_state;
	xlog_in_core_t *l_iclog;
	spinlock_t l_icloglock;
	int l_curr_cycle;
	int l_prev_cycle;
	int l_curr_block;
	int l_prev_block;
	atomic64_t l_last_sync_lsn;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t l_tail_lsn;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xlog_grant_head l_reserve_head;
	struct xlog_grant_head l_write_head;
	struct xfs_kobj l_kobj;
	xfs_lsn_t l_recovery_lsn;
	uint32_t l_iclog_roundoff;
	struct rw_semaphore l_incompat_users;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xfs_imap {
	xfs_daddr_t im_blkno;
	short unsigned int im_len;
	short unsigned int im_boffset;
};

struct xfs_ifork {
	int64_t if_bytes;
	struct xfs_btree_block *if_broot;
	unsigned int if_seq;
	int if_height;
	union {
		void *if_root;
		char *if_data;
	} if_u1;
	short int if_broot_bytes;
	int8_t if_format;
	xfs_extnum_t if_nextents;
};

struct xfs_dquot;

struct xfs_inode_log_item;

struct xfs_inode {
	struct xfs_mount *i_mount;
	struct xfs_dquot *i_udquot;
	struct xfs_dquot *i_gdquot;
	struct xfs_dquot *i_pdquot;
	xfs_ino_t i_ino;
	struct xfs_imap i_imap;
	struct xfs_ifork *i_afp;
	struct xfs_ifork *i_cowfp;
	struct xfs_ifork i_df;
	struct xfs_inode_log_item *i_itemp;
	mrlock_t i_lock;
	atomic_t i_pincount;
	struct llist_node i_gclist;
	uint16_t i_checked;
	uint16_t i_sick;
	spinlock_t i_flags_lock;
	long unsigned int i_flags;
	uint64_t i_delayed_blks;
	xfs_fsize_t i_disk_size;
	xfs_rfsblock_t i_nblocks;
	prid_t i_projid;
	xfs_extlen_t i_extsize;
	union {
		xfs_extlen_t i_cowextsize;
		uint16_t i_flushiter;
	};
	uint8_t i_forkoff;
	uint16_t i_diflags;
	uint64_t i_diflags2;
	struct timespec64 i_crtime;
	struct inode i_vnode;
	spinlock_t i_ioend_lock;
	struct work_struct i_ioend_work;
	struct list_head i_ioend_list;
};

enum xfs_defer_ops_type {
	XFS_DEFER_OPS_TYPE_BMAP = 0,
	XFS_DEFER_OPS_TYPE_REFCOUNT = 1,
	XFS_DEFER_OPS_TYPE_RMAP = 2,
	XFS_DEFER_OPS_TYPE_FREE = 3,
	XFS_DEFER_OPS_TYPE_AGFL_FREE = 4,
	XFS_DEFER_OPS_TYPE_MAX = 5,
};

struct xfs_defer_pending {
	struct list_head dfp_list;
	struct list_head dfp_work;
	struct xfs_log_item *dfp_intent;
	struct xfs_log_item *dfp_done;
	unsigned int dfp_count;
	enum xfs_defer_ops_type dfp_type;
};

union xfs_btree_irec {
	struct xfs_alloc_rec_incore a;
	struct xfs_bmbt_irec b;
	struct xfs_inobt_rec_incore i;
	struct xfs_rmap_irec r;
	struct xfs_refcount_irec rc;
};

struct xbtree_afakeroot;

struct xfs_btree_cur_ag {
	struct xfs_perag *pag;
	union {
		struct xfs_buf *agbp;
		struct xbtree_afakeroot *afake;
	};
	union {
		struct {
			long unsigned int nr_ops;
			int shape_changes;
		} refc;
		struct {
			bool active;
		} abt;
	};
};

struct xbtree_ifakeroot;

struct xfs_btree_cur_ino {
	struct xfs_inode *ip;
	struct xbtree_ifakeroot *ifake;
	int allocated;
	short int forksize;
	char whichfork;
	char flags;
};

struct xfs_btree_ops;

struct xfs_btree_cur {
	struct xfs_trans *bc_tp;
	struct xfs_mount *bc_mp;
	const struct xfs_btree_ops *bc_ops;
	uint bc_flags;
	union xfs_btree_irec bc_rec;
	struct xfs_buf *bc_bufs[9];
	int bc_ptrs[9];
	uint8_t bc_ra[9];
	uint8_t bc_nlevels;
	uint8_t bc_blocklog;
	xfs_btnum_t bc_btnum;
	int bc_statoff;
	union {
		struct xfs_btree_cur_ag bc_ag;
		struct xfs_btree_cur_ino bc_ino;
	};
};

struct xfs_da_node_entry {
	__be32 hashval;
	__be32 before;
};

typedef uint8_t xfs_dqtype_t;

typedef uint64_t xfs_qcnt_t;

typedef uint16_t xfs_qwarncnt_t;

struct xfs_dquot_res {
	xfs_qcnt_t reserved;
	xfs_qcnt_t count;
	xfs_qcnt_t hardlimit;
	xfs_qcnt_t softlimit;
	time64_t timer;
	xfs_qwarncnt_t warnings;
};

struct xfs_dq_logitem {
	struct xfs_log_item qli_item;
	struct xfs_dquot *qli_dquot;
	xfs_lsn_t qli_flush_lsn;
};

struct xfs_dquot {
	struct list_head q_lru;
	struct xfs_mount *q_mount;
	xfs_dqtype_t q_type;
	uint16_t q_flags;
	xfs_dqid_t q_id;
	uint q_nrefs;
	int q_bufoffset;
	xfs_daddr_t q_blkno;
	xfs_fileoff_t q_fileoffset;
	struct xfs_dquot_res q_blk;
	struct xfs_dquot_res q_ino;
	struct xfs_dquot_res q_rtb;
	struct xfs_dq_logitem q_logitem;
	xfs_qcnt_t q_prealloc_lo_wmark;
	xfs_qcnt_t q_prealloc_hi_wmark;
	int64_t q_low_space[3];
	struct mutex q_qlock;
	struct completion q_flush;
	atomic_t q_pincount;
	struct wait_queue_head q_pinwait;
};

union xfs_btree_ptr {
	__be32 s;
	__be64 l;
};

union xfs_btree_key {
	struct xfs_bmbt_key bmbt;
	xfs_bmdr_key_t bmbr;
	xfs_alloc_key_t alloc;
	struct xfs_inobt_key inobt;
	struct xfs_rmap_key rmap;
	struct xfs_rmap_key __rmap_bigkey[2];
	struct xfs_refcount_key refc;
};

union xfs_btree_rec {
	struct xfs_bmbt_rec bmbt;
	xfs_bmdr_rec_t bmbr;
	struct xfs_alloc_rec alloc;
	struct xfs_inobt_rec inobt;
	struct xfs_rmap_rec rmap;
	struct xfs_refcount_rec refc;
};

struct xfs_btree_ops {
	size_t key_len;
	size_t rec_len;
	struct xfs_btree_cur * (*dup_cursor)(struct xfs_btree_cur *);
	void (*update_cursor)(struct xfs_btree_cur *, struct xfs_btree_cur *);
	void (*set_root)(struct xfs_btree_cur *, const union xfs_btree_ptr *, int);
	int (*alloc_block)(struct xfs_btree_cur *, const union xfs_btree_ptr *, union xfs_btree_ptr *, int *);
	int (*free_block)(struct xfs_btree_cur *, struct xfs_buf *);
	void (*update_lastrec)(struct xfs_btree_cur *, const struct xfs_btree_block *, const union xfs_btree_rec *, int, int);
	int (*get_minrecs)(struct xfs_btree_cur *, int);
	int (*get_maxrecs)(struct xfs_btree_cur *, int);
	int (*get_dmaxrecs)(struct xfs_btree_cur *, int);
	void (*init_key_from_rec)(union xfs_btree_key *, const union xfs_btree_rec *);
	void (*init_rec_from_cur)(struct xfs_btree_cur *, union xfs_btree_rec *);
	void (*init_ptr_from_cur)(struct xfs_btree_cur *, union xfs_btree_ptr *);
	void (*init_high_key_from_rec)(union xfs_btree_key *, const union xfs_btree_rec *);
	int64_t (*key_diff)(struct xfs_btree_cur *, const union xfs_btree_key *);
	int64_t (*diff_two_keys)(struct xfs_btree_cur *, const union xfs_btree_key *, const union xfs_btree_key *);
	const struct xfs_buf_ops *buf_ops;
	int (*keys_inorder)(struct xfs_btree_cur *, const union xfs_btree_key *, const union xfs_btree_key *);
	int (*recs_inorder)(struct xfs_btree_cur *, const union xfs_btree_rec *, const union xfs_btree_rec *);
};

struct xbtree_afakeroot {
	xfs_agblock_t af_root;
	unsigned int af_levels;
	unsigned int af_blocks;
};

struct xbtree_ifakeroot {
	struct xfs_ifork *if_fork;
	int64_t if_blocks;
	unsigned int if_levels;
	unsigned int if_fork_size;
	unsigned int if_format;
	unsigned int if_extents;
};

enum xfs_dacmp {
	XFS_CMP_DIFFERENT = 0,
	XFS_CMP_EXACT = 1,
	XFS_CMP_CASE = 2,
};

struct xfs_da_args {
	struct xfs_da_geometry *geo;
	const uint8_t *name;
	int namelen;
	uint8_t filetype;
	void *value;
	int valuelen;
	unsigned int attr_filter;
	unsigned int attr_flags;
	xfs_dahash_t hashval;
	xfs_ino_t inumber;
	struct xfs_inode *dp;
	struct xfs_trans *trans;
	xfs_extlen_t total;
	int whichfork;
	xfs_dablk_t blkno;
	int index;
	xfs_dablk_t rmtblkno;
	int rmtblkcnt;
	int rmtvaluelen;
	xfs_dablk_t blkno2;
	int index2;
	xfs_dablk_t rmtblkno2;
	int rmtblkcnt2;
	int rmtvaluelen2;
	int op_flags;
	enum xfs_dacmp cmpresult;
};

typedef unsigned int xfs_alloctype_t;

struct xfs_alloc_arg {
	struct xfs_trans *tp;
	struct xfs_mount *mp;
	struct xfs_buf *agbp;
	struct xfs_perag *pag;
	xfs_fsblock_t fsbno;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t minlen;
	xfs_extlen_t maxlen;
	xfs_extlen_t mod;
	xfs_extlen_t prod;
	xfs_extlen_t minleft;
	xfs_extlen_t total;
	xfs_extlen_t alignment;
	xfs_extlen_t minalignslop;
	xfs_agblock_t min_agbno;
	xfs_agblock_t max_agbno;
	xfs_extlen_t len;
	xfs_alloctype_t type;
	xfs_alloctype_t otype;
	int datatype;
	char wasdel;
	char wasfromfl;
	struct xfs_owner_info oinfo;
	enum xfs_ag_resv_type resv;
};

struct xfs_attrlist_cursor_kern {
	__u32 hashval;
	__u32 blkno;
	__u32 offset;
	__u16 pad1;
	__u8 pad2;
	__u8 initted;
};

struct xfs_attr_list_context;

typedef void (*put_listent_func_t)(struct xfs_attr_list_context *, int, unsigned char *, int, int);

struct xfs_attr_list_context {
	struct xfs_trans *tp;
	struct xfs_inode *dp;
	struct xfs_attrlist_cursor_kern cursor;
	void *buffer;
	int seen_enough;
	bool allow_incomplete;
	ssize_t count;
	int dupcnt;
	int bufsize;
	int firstu;
	unsigned int attr_filter;
	int resynch;
	put_listent_func_t put_listent;
	int index;
};

struct xfs_item_ops {
	unsigned int flags;
	void (*iop_size)(struct xfs_log_item *, int *, int *);
	void (*iop_format)(struct xfs_log_item *, struct xfs_log_vec *);
	void (*iop_pin)(struct xfs_log_item *);
	void (*iop_unpin)(struct xfs_log_item *, int);
	uint (*iop_push)(struct xfs_log_item *, struct list_head *);
	void (*iop_committing)(struct xfs_log_item *, xfs_csn_t);
	void (*iop_release)(struct xfs_log_item *);
	xfs_lsn_t (*iop_committed)(struct xfs_log_item *, xfs_lsn_t);
	int (*iop_recover)(struct xfs_log_item *, struct list_head *);
	bool (*iop_match)(struct xfs_log_item *, uint64_t);
	struct xfs_log_item * (*iop_relog)(struct xfs_log_item *, struct xfs_trans *);
};

struct xfs_log_vec {
	struct xfs_log_vec *lv_next;
	int lv_niovecs;
	struct xfs_log_iovec *lv_iovecp;
	struct xfs_log_item *lv_item;
	char *lv_buf;
	int lv_bytes;
	int lv_buf_len;
	int lv_size;
};

struct xlog_res {
	uint r_len;
	uint r_type;
};

typedef struct xlog_res xlog_res_t;

struct xlog_ticket {
	struct list_head t_queue;
	struct task_struct *t_task;
	xlog_tid_t t_tid;
	atomic_t t_ref;
	int t_curr_res;
	int t_unit_res;
	char t_ocnt;
	char t_cnt;
	char t_clientid;
	char t_flags;
	uint t_res_num;
	uint t_res_num_ophdrs;
	uint t_res_arr_sum;
	uint t_res_o_flow;
	xlog_res_t t_res_arr[15];
};

enum xlog_iclog_state {
	XLOG_STATE_ACTIVE = 0,
	XLOG_STATE_WANT_SYNC = 1,
	XLOG_STATE_SYNCING = 2,
	XLOG_STATE_DONE_SYNC = 3,
	XLOG_STATE_CALLBACK = 4,
	XLOG_STATE_DIRTY = 5,
};

struct xlog_in_core {
	wait_queue_head_t ic_force_wait;
	wait_queue_head_t ic_write_wait;
	struct xlog_in_core *ic_next;
	struct xlog_in_core *ic_prev;
	struct xlog *ic_log;
	u32 ic_size;
	u32 ic_offset;
	enum xlog_iclog_state ic_state;
	unsigned int ic_flags;
	char *ic_datap;
	struct list_head ic_callbacks;
	long: 64;
	long: 64;
	atomic_t ic_refcnt;
	xlog_in_core_2_t *ic_data;
	struct semaphore ic_sema;
	struct work_struct ic_end_io_work;
	struct bio ic_bio;
	struct bio_vec ic_bvec[0];
};

struct xfs_cil_ctx {
	struct xfs_cil *cil;
	xfs_csn_t sequence;
	xfs_lsn_t start_lsn;
	xfs_lsn_t commit_lsn;
	struct xlog_in_core *commit_iclog;
	struct xlog_ticket *ticket;
	int nvecs;
	int space_used;
	struct list_head busy_extents;
	struct xfs_log_vec *lv_chain;
	struct list_head iclog_entry;
	struct list_head committing;
	struct work_struct discard_endio_work;
	struct work_struct push_work;
};

struct xfs_cil {
	struct xlog *xc_log;
	struct list_head xc_cil;
	spinlock_t xc_cil_lock;
	struct workqueue_struct *xc_push_wq;
	long: 64;
	long: 64;
	long: 64;
	struct rw_semaphore xc_ctx_lock;
	struct xfs_cil_ctx *xc_ctx;
	long: 64;
	long: 64;
	spinlock_t xc_push_lock;
	xfs_csn_t xc_push_seq;
	bool xc_push_commit_stable;
	struct list_head xc_committing;
	wait_queue_head_t xc_commit_wait;
	wait_queue_head_t xc_start_wait;
	xfs_csn_t xc_current_sequence;
	wait_queue_head_t xc_push_wait;
	long: 64;
};

struct xfs_dqtrx {
	struct xfs_dquot *qt_dquot;
	uint64_t qt_blk_res;
	int64_t qt_bcount_delta;
	int64_t qt_delbcnt_delta;
	uint64_t qt_rtblk_res;
	uint64_t qt_rtblk_res_used;
	int64_t qt_rtbcount_delta;
	int64_t qt_delrtb_delta;
	uint64_t qt_ino_res;
	uint64_t qt_ino_res_used;
	int64_t qt_icount_delta;
};

enum {
	XFS_QLOWSP_1_PCNT = 0,
	XFS_QLOWSP_3_PCNT = 1,
	XFS_QLOWSP_5_PCNT = 2,
	XFS_QLOWSP_MAX = 3,
};

enum xlog_recover_reorder {
	XLOG_REORDER_BUFFER_LIST = 0,
	XLOG_REORDER_ITEM_LIST = 1,
	XLOG_REORDER_INODE_BUFFER_LIST = 2,
	XLOG_REORDER_CANCEL_LIST = 3,
};

struct xlog_recover_item;

struct xlog_recover_item_ops {
	uint16_t item_type;
	enum xlog_recover_reorder (*reorder)(struct xlog_recover_item *);
	void (*ra_pass2)(struct xlog *, struct xlog_recover_item *);
	int (*commit_pass1)(struct xlog *, struct xlog_recover_item *);
	int (*commit_pass2)(struct xlog *, struct list_head *, struct xlog_recover_item *, xfs_lsn_t);
};

struct xlog_recover_item {
	struct list_head ri_list;
	int ri_cnt;
	int ri_total;
	struct xfs_log_iovec *ri_buf;
	const struct xlog_recover_item_ops *ri_ops;
};

struct xlog_recover {
	struct hlist_node r_list;
	xlog_tid_t r_log_tid;
	xfs_trans_header_t r_theader;
	int r_state;
	xfs_lsn_t r_lsn;
	struct list_head r_itemq;
};

struct xfs_fsmap {
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	xfs_fileoff_t fmr_offset;
	xfs_filblks_t fmr_length;
};

struct xfs_icwalk {
	__u32 icw_flags;
	kuid_t icw_uid;
	kgid_t icw_gid;
	prid_t icw_prid;
	__u64 icw_min_file_size;
	long int icw_scan_limit;
};

struct trace_event_raw_xfs_attr_list_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 hashval;
	u32 blkno;
	u32 offset;
	void *buffer;
	int bufsize;
	int count;
	int firstu;
	int dupcnt;
	unsigned int attr_filter;
	char __data[0];
};

struct trace_event_raw_xlog_intent_recovery_failed {
	struct trace_entry ent;
	dev_t dev;
	int error;
	void *function;
	char __data[0];
};

struct trace_event_raw_xfs_perag_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int refcount;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_inodegc_worker {
	struct trace_entry ent;
	dev_t dev;
	unsigned int shrinker_hits;
	char __data[0];
};

struct trace_event_raw_xfs_fs_class {
	struct trace_entry ent;
	dev_t dev;
	long long unsigned int mflags;
	long unsigned int opstate;
	long unsigned int sbflags;
	void *caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_inodegc_shrinker_scan {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	void *caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_ag_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	char __data[0];
};

struct trace_event_raw_xfs_attr_list_node_descend {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 hashval;
	u32 blkno;
	u32 offset;
	void *buffer;
	int bufsize;
	int count;
	int firstu;
	int dupcnt;
	unsigned int attr_filter;
	u32 bt_hashval;
	u32 bt_before;
	char __data[0];
};

struct trace_event_raw_xfs_bmap_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	void *leaf;
	int pos;
	xfs_fileoff_t startoff;
	xfs_fsblock_t startblock;
	xfs_filblks_t blockcount;
	xfs_exntst_t state;
	int bmap_state;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_buf_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t bno;
	int nblks;
	int hold;
	int pincount;
	unsigned int lockval;
	unsigned int flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_buf_flags_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t bno;
	unsigned int length;
	int hold;
	int pincount;
	unsigned int lockval;
	unsigned int flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_buf_ioerror {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t bno;
	unsigned int length;
	unsigned int flags;
	int hold;
	int pincount;
	unsigned int lockval;
	int error;
	xfs_failaddr_t caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_buf_item_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t buf_bno;
	unsigned int buf_len;
	int buf_hold;
	int buf_pincount;
	int buf_lockval;
	unsigned int buf_flags;
	unsigned int bli_recur;
	int bli_refcount;
	unsigned int bli_flags;
	long unsigned int li_flags;
	char __data[0];
};

struct trace_event_raw_xfs_filestream_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_agnumber_t agno;
	int streams;
	char __data[0];
};

struct trace_event_raw_xfs_filestream_pick {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_agnumber_t agno;
	int streams;
	xfs_extlen_t free;
	int nscan;
	char __data[0];
};

struct trace_event_raw_xfs_lock_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int lock_flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_inode_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	long unsigned int iflags;
	char __data[0];
};

struct trace_event_raw_xfs_filemap_fault {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	enum page_entry_size pe_size;
	bool write_fault;
	char __data[0];
};

struct trace_event_raw_xfs_iref_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int count;
	int pincount;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_iomap_prealloc_size {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsblock_t blocks;
	int shift;
	unsigned int writeio_blocks;
	char __data[0];
};

struct trace_event_raw_xfs_irec_merge_pre {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	uint16_t holemask;
	xfs_agino_t nagino;
	uint16_t nholemask;
	char __data[0];
};

struct trace_event_raw_xfs_irec_merge_post {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	uint16_t holemask;
	char __data[0];
};

struct trace_event_raw_xfs_namespace_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dp_ino;
	int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xfs_rename {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t src_dp_ino;
	xfs_ino_t target_dp_ino;
	int src_namelen;
	int target_namelen;
	u32 __data_loc_src_name;
	u32 __data_loc_target_name;
	char __data[0];
};

struct trace_event_raw_xfs_dquot_class {
	struct trace_entry ent;
	dev_t dev;
	u32 id;
	xfs_dqtype_t type;
	unsigned int flags;
	unsigned int nrefs;
	long long unsigned int res_bcount;
	long long unsigned int res_rtbcount;
	long long unsigned int res_icount;
	long long unsigned int bcount;
	long long unsigned int rtbcount;
	long long unsigned int icount;
	long long unsigned int blk_hardlimit;
	long long unsigned int blk_softlimit;
	long long unsigned int rtb_hardlimit;
	long long unsigned int rtb_softlimit;
	long long unsigned int ino_hardlimit;
	long long unsigned int ino_softlimit;
	char __data[0];
};

struct trace_event_raw_xfs_trans_mod_dquot {
	struct trace_entry ent;
	dev_t dev;
	xfs_dqtype_t type;
	unsigned int flags;
	unsigned int dqid;
	unsigned int field;
	int64_t delta;
	char __data[0];
};

struct trace_event_raw_xfs_dqtrx_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_dqtype_t type;
	unsigned int flags;
	u32 dqid;
	uint64_t blk_res;
	int64_t bcount_delta;
	int64_t delbcnt_delta;
	uint64_t rtblk_res;
	uint64_t rtblk_res_used;
	int64_t rtbcount_delta;
	int64_t delrtb_delta;
	uint64_t ino_res;
	uint64_t ino_res_used;
	int64_t icount_delta;
	char __data[0];
};

struct trace_event_raw_xfs_loggrant_class {
	struct trace_entry ent;
	dev_t dev;
	char ocnt;
	char cnt;
	int curr_res;
	int unit_res;
	unsigned int flags;
	int reserveq;
	int writeq;
	int grant_reserve_cycle;
	int grant_reserve_bytes;
	int grant_write_cycle;
	int grant_write_bytes;
	int curr_cycle;
	int curr_block;
	xfs_lsn_t tail_lsn;
	char __data[0];
};

struct trace_event_raw_xfs_log_item_class {
	struct trace_entry ent;
	dev_t dev;
	void *lip;
	uint type;
	long unsigned int flags;
	xfs_lsn_t lsn;
	char __data[0];
};

struct trace_event_raw_xfs_log_force {
	struct trace_entry ent;
	dev_t dev;
	xfs_lsn_t lsn;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_ail_class {
	struct trace_entry ent;
	dev_t dev;
	void *lip;
	uint type;
	long unsigned int flags;
	xfs_lsn_t old_lsn;
	xfs_lsn_t new_lsn;
	char __data[0];
};

struct trace_event_raw_xfs_log_assign_tail_lsn {
	struct trace_entry ent;
	dev_t dev;
	xfs_lsn_t new_lsn;
	xfs_lsn_t old_lsn;
	xfs_lsn_t last_sync_lsn;
	char __data[0];
};

struct trace_event_raw_xfs_file_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_xfs_imap_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	loff_t size;
	loff_t offset;
	size_t count;
	int whichfork;
	xfs_fileoff_t startoff;
	xfs_fsblock_t startblock;
	xfs_filblks_t blockcount;
	char __data[0];
};

struct trace_event_raw_xfs_simple_io_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	loff_t isize;
	loff_t disize;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_xfs_itrunc_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	xfs_fsize_t new_size;
	char __data[0];
};

struct trace_event_raw_xfs_pagecache_inval {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	xfs_off_t start;
	xfs_off_t finish;
	char __data[0];
};

struct trace_event_raw_xfs_bunmap {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	xfs_fileoff_t fileoff;
	xfs_filblks_t len;
	long unsigned int caller_ip;
	int flags;
	char __data[0];
};

struct trace_event_raw_xfs_extent_busy_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_extent_busy_trim {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	xfs_agblock_t tbno;
	xfs_extlen_t tlen;
	char __data[0];
};

struct trace_event_raw_xfs_agf_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int flags;
	__u32 length;
	__u32 bno_root;
	__u32 cnt_root;
	__u32 bno_level;
	__u32 cnt_level;
	__u32 flfirst;
	__u32 fllast;
	__u32 flcount;
	__u32 freeblks;
	__u32 longest;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_free_extent {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	int resv;
	int haveleft;
	int haveright;
	char __data[0];
};

struct trace_event_raw_xfs_alloc_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t minlen;
	xfs_extlen_t maxlen;
	xfs_extlen_t mod;
	xfs_extlen_t prod;
	xfs_extlen_t minleft;
	xfs_extlen_t total;
	xfs_extlen_t alignment;
	xfs_extlen_t minalignslop;
	xfs_extlen_t len;
	short int type;
	short int otype;
	char wasdel;
	char wasfromfl;
	int resv;
	int datatype;
	xfs_fsblock_t firstblock;
	char __data[0];
};

struct trace_event_raw_xfs_alloc_cur_check {
	struct trace_entry ent;
	dev_t dev;
	xfs_btnum_t btnum;
	xfs_agblock_t bno;
	xfs_extlen_t len;
	xfs_extlen_t diff;
	bool new;
	char __data[0];
};

struct trace_event_raw_xfs_da_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 __data_loc_name;
	int namelen;
	xfs_dahash_t hashval;
	xfs_ino_t inumber;
	int op_flags;
	char __data[0];
};

struct trace_event_raw_xfs_attr_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 __data_loc_name;
	int namelen;
	int valuelen;
	xfs_dahash_t hashval;
	unsigned int attr_filter;
	unsigned int attr_flags;
	int op_flags;
	char __data[0];
};

struct trace_event_raw_xfs_dir2_space_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int op_flags;
	int idx;
	char __data[0];
};

struct trace_event_raw_xfs_dir2_leafn_moveents {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int op_flags;
	int src_idx;
	int dst_idx;
	int count;
	char __data[0];
};

struct trace_event_raw_xfs_swap_extent_class {
	struct trace_entry ent;
	dev_t dev;
	int which;
	xfs_ino_t ino;
	int format;
	int nex;
	int broot_size;
	int fork_off;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t headblk;
	xfs_daddr_t tailblk;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_record {
	struct trace_entry ent;
	dev_t dev;
	xfs_lsn_t lsn;
	int len;
	int num_logops;
	int pass;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_item_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int item;
	xlog_tid_t tid;
	xfs_lsn_t lsn;
	int type;
	int pass;
	int count;
	int total;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_buf_item_class {
	struct trace_entry ent;
	dev_t dev;
	int64_t blkno;
	short unsigned int len;
	short unsigned int flags;
	short unsigned int size;
	unsigned int map_size;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_ino_item_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	short unsigned int size;
	int fields;
	short unsigned int asize;
	short unsigned int dsize;
	int64_t blkno;
	int len;
	int boffset;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_icreate_item_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	unsigned int count;
	unsigned int isize;
	xfs_agblock_t length;
	unsigned int gen;
	char __data[0];
};

struct trace_event_raw_xfs_discard_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_btree_cur_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_btnum_t btnum;
	int level;
	int nlevels;
	int ptr;
	xfs_daddr_t daddr;
	char __data[0];
};

struct trace_event_raw_xfs_defer_class {
	struct trace_entry ent;
	dev_t dev;
	struct xfs_trans *tp;
	char committed;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_defer_error_class {
	struct trace_entry ent;
	dev_t dev;
	struct xfs_trans *tp;
	char committed;
	int error;
	char __data[0];
};

struct trace_event_raw_xfs_defer_pending_class {
	struct trace_entry ent;
	dev_t dev;
	int type;
	void *intent;
	char committed;
	int nr;
	char __data[0];
};

struct trace_event_raw_xfs_phys_extent_deferred_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int type;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_map_extent_deferred_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_ino_t ino;
	xfs_agblock_t agbno;
	int whichfork;
	xfs_fileoff_t l_loff;
	xfs_filblks_t l_len;
	xfs_exntst_t l_state;
	int op;
	char __data[0];
};

struct trace_event_raw_xfs_rmap_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	uint64_t owner;
	uint64_t offset;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_ag_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int error;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_rmapbt_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	uint64_t owner;
	uint64_t offset;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_ag_resv_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int resv;
	xfs_extlen_t freeblks;
	xfs_extlen_t flcount;
	xfs_extlen_t reserved;
	xfs_extlen_t asked;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_ag_btree_lookup_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_lookup_t dir;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_extent_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t startblock;
	xfs_extlen_t blockcount;
	xfs_nlink_t refcount;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_extent_at_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t startblock;
	xfs_extlen_t blockcount;
	xfs_nlink_t refcount;
	xfs_agblock_t agbno;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_double_extent_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t i1_startblock;
	xfs_extlen_t i1_blockcount;
	xfs_nlink_t i1_refcount;
	xfs_agblock_t i2_startblock;
	xfs_extlen_t i2_blockcount;
	xfs_nlink_t i2_refcount;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_double_extent_at_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t i1_startblock;
	xfs_extlen_t i1_blockcount;
	xfs_nlink_t i1_refcount;
	xfs_agblock_t i2_startblock;
	xfs_extlen_t i2_blockcount;
	xfs_nlink_t i2_refcount;
	xfs_agblock_t agbno;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_triple_extent_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t i1_startblock;
	xfs_extlen_t i1_blockcount;
	xfs_nlink_t i1_refcount;
	xfs_agblock_t i2_startblock;
	xfs_extlen_t i2_blockcount;
	xfs_nlink_t i2_refcount;
	xfs_agblock_t i3_startblock;
	xfs_extlen_t i3_blockcount;
	xfs_nlink_t i3_refcount;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_finish_one_leftover {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int type;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	xfs_agblock_t new_agbno;
	xfs_extlen_t new_len;
	char __data[0];
};

struct trace_event_raw_xfs_inode_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int error;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_double_io_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t src_ino;
	loff_t src_isize;
	loff_t src_disize;
	loff_t src_offset;
	long long int len;
	xfs_ino_t dest_ino;
	loff_t dest_isize;
	loff_t dest_disize;
	loff_t dest_offset;
	char __data[0];
};

struct trace_event_raw_xfs_inode_irec_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fileoff_t lblk;
	xfs_extlen_t len;
	xfs_fsblock_t pblk;
	int state;
	char __data[0];
};

struct trace_event_raw_xfs_reflink_remap_blocks {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t src_ino;
	xfs_fileoff_t src_lblk;
	xfs_filblks_t len;
	xfs_ino_t dest_ino;
	xfs_fileoff_t dest_lblk;
	char __data[0];
};

struct trace_event_raw_xfs_ioctl_clone {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int src_ino;
	loff_t src_isize;
	long unsigned int dest_ino;
	loff_t dest_isize;
	char __data[0];
};

struct trace_event_raw_xfs_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	xfs_agnumber_t agno;
	xfs_fsblock_t bno;
	xfs_filblks_t len;
	uint64_t owner;
	uint64_t offset;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	xfs_daddr_t block;
	xfs_daddr_t len;
	uint64_t owner;
	uint64_t offset;
	uint64_t flags;
	char __data[0];
};

struct trace_event_raw_xfs_trans_resv_calc {
	struct trace_entry ent;
	dev_t dev;
	int type;
	uint logres;
	int logcount;
	int logflags;
	char __data[0];
};

struct trace_event_raw_xfs_trans_class {
	struct trace_entry ent;
	dev_t dev;
	uint32_t tid;
	uint32_t flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_iunlink_update_bucket {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	unsigned int bucket;
	xfs_agino_t old_ptr;
	xfs_agino_t new_ptr;
	char __data[0];
};

struct trace_event_raw_xfs_iunlink_update_dinode {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	xfs_agino_t old_ptr;
	xfs_agino_t new_ptr;
	char __data[0];
};

struct trace_event_raw_xfs_ag_inode_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	char __data[0];
};

struct trace_event_raw_xfs_fs_corrupt_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_ag_corrupt_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_inode_corrupt_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_iwalk_ag {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t startino;
	char __data[0];
};

struct trace_event_raw_xfs_iwalk_ag_rec {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t startino;
	uint64_t freemask;
	char __data[0];
};

struct trace_event_raw_xfs_pwork_init {
	struct trace_entry ent;
	dev_t dev;
	unsigned int nr_threads;
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_xfs_kmem_class {
	struct trace_entry ent;
	ssize_t size;
	int flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_check_new_dalign {
	struct trace_entry ent;
	dev_t dev;
	int new_dalign;
	xfs_ino_t sb_rootino;
	xfs_ino_t calc_rootino;
	char __data[0];
};

struct trace_event_raw_xfs_btree_commit_afakeroot {
	struct trace_entry ent;
	dev_t dev;
	xfs_btnum_t btnum;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	unsigned int levels;
	unsigned int blocks;
	char __data[0];
};

struct trace_event_raw_xfs_btree_commit_ifakeroot {
	struct trace_entry ent;
	dev_t dev;
	xfs_btnum_t btnum;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	unsigned int levels;
	unsigned int blocks;
	int whichfork;
	char __data[0];
};

struct trace_event_raw_xfs_btree_bload_level_geometry {
	struct trace_entry ent;
	dev_t dev;
	xfs_btnum_t btnum;
	unsigned int level;
	unsigned int nlevels;
	uint64_t nr_this_level;
	unsigned int nr_per_block;
	unsigned int desired_npb;
	long long unsigned int blocks;
	long long unsigned int blocks_with_extra;
	char __data[0];
};

struct trace_event_raw_xfs_btree_bload_block {
	struct trace_entry ent;
	dev_t dev;
	xfs_btnum_t btnum;
	unsigned int level;
	long long unsigned int block_idx;
	long long unsigned int nr_blocks;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	unsigned int nr_records;
	char __data[0];
};

struct trace_event_raw_xfs_timestamp_range_class {
	struct trace_entry ent;
	dev_t dev;
	long long int min;
	long long int max;
	char __data[0];
};

struct trace_event_raw_xfs_icwalk_class {
	struct trace_entry ent;
	dev_t dev;
	__u32 flags;
	uint32_t uid;
	uint32_t gid;
	prid_t prid;
	__u64 min_file_size;
	long int scan_limit;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xlog_iclog_class {
	struct trace_entry ent;
	dev_t dev;
	uint32_t state;
	int32_t refcount;
	uint32_t offset;
	uint32_t flags;
	long long unsigned int lsn;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_das_state_class {
	struct trace_entry ent;
	int das;
	xfs_ino_t ino;
	char __data[0];
};

struct trace_event_raw_xfs_force_shutdown {
	struct trace_entry ent;
	dev_t dev;
	int ptag;
	int flags;
	u32 __data_loc_fname;
	int line_num;
	char __data[0];
};

struct trace_event_data_offsets_xfs_attr_list_class {};

struct trace_event_data_offsets_xlog_intent_recovery_failed {};

struct trace_event_data_offsets_xfs_perag_class {};

struct trace_event_data_offsets_xfs_inodegc_worker {};

struct trace_event_data_offsets_xfs_fs_class {};

struct trace_event_data_offsets_xfs_inodegc_shrinker_scan {};

struct trace_event_data_offsets_xfs_ag_class {};

struct trace_event_data_offsets_xfs_attr_list_node_descend {};

struct trace_event_data_offsets_xfs_bmap_class {};

struct trace_event_data_offsets_xfs_buf_class {};

struct trace_event_data_offsets_xfs_buf_flags_class {};

struct trace_event_data_offsets_xfs_buf_ioerror {};

struct trace_event_data_offsets_xfs_buf_item_class {};

struct trace_event_data_offsets_xfs_filestream_class {};

struct trace_event_data_offsets_xfs_filestream_pick {};

struct trace_event_data_offsets_xfs_lock_class {};

struct trace_event_data_offsets_xfs_inode_class {};

struct trace_event_data_offsets_xfs_filemap_fault {};

struct trace_event_data_offsets_xfs_iref_class {};

struct trace_event_data_offsets_xfs_iomap_prealloc_size {};

struct trace_event_data_offsets_xfs_irec_merge_pre {};

struct trace_event_data_offsets_xfs_irec_merge_post {};

struct trace_event_data_offsets_xfs_namespace_class {
	u32 name;
};

struct trace_event_data_offsets_xfs_rename {
	u32 src_name;
	u32 target_name;
};

struct trace_event_data_offsets_xfs_dquot_class {};

struct trace_event_data_offsets_xfs_trans_mod_dquot {};

struct trace_event_data_offsets_xfs_dqtrx_class {};

struct trace_event_data_offsets_xfs_loggrant_class {};

struct trace_event_data_offsets_xfs_log_item_class {};

struct trace_event_data_offsets_xfs_log_force {};

struct trace_event_data_offsets_xfs_ail_class {};

struct trace_event_data_offsets_xfs_log_assign_tail_lsn {};

struct trace_event_data_offsets_xfs_file_class {};

struct trace_event_data_offsets_xfs_imap_class {};

struct trace_event_data_offsets_xfs_simple_io_class {};

struct trace_event_data_offsets_xfs_itrunc_class {};

struct trace_event_data_offsets_xfs_pagecache_inval {};

struct trace_event_data_offsets_xfs_bunmap {};

struct trace_event_data_offsets_xfs_extent_busy_class {};

struct trace_event_data_offsets_xfs_extent_busy_trim {};

struct trace_event_data_offsets_xfs_agf_class {};

struct trace_event_data_offsets_xfs_free_extent {};

struct trace_event_data_offsets_xfs_alloc_class {};

struct trace_event_data_offsets_xfs_alloc_cur_check {};

struct trace_event_data_offsets_xfs_da_class {
	u32 name;
};

struct trace_event_data_offsets_xfs_attr_class {
	u32 name;
};

struct trace_event_data_offsets_xfs_dir2_space_class {};

struct trace_event_data_offsets_xfs_dir2_leafn_moveents {};

struct trace_event_data_offsets_xfs_swap_extent_class {};

struct trace_event_data_offsets_xfs_log_recover {};

struct trace_event_data_offsets_xfs_log_recover_record {};

struct trace_event_data_offsets_xfs_log_recover_item_class {};

struct trace_event_data_offsets_xfs_log_recover_buf_item_class {};

struct trace_event_data_offsets_xfs_log_recover_ino_item_class {};

struct trace_event_data_offsets_xfs_log_recover_icreate_item_class {};

struct trace_event_data_offsets_xfs_discard_class {};

struct trace_event_data_offsets_xfs_btree_cur_class {};

struct trace_event_data_offsets_xfs_defer_class {};

struct trace_event_data_offsets_xfs_defer_error_class {};

struct trace_event_data_offsets_xfs_defer_pending_class {};

struct trace_event_data_offsets_xfs_phys_extent_deferred_class {};

struct trace_event_data_offsets_xfs_map_extent_deferred_class {};

struct trace_event_data_offsets_xfs_rmap_class {};

struct trace_event_data_offsets_xfs_ag_error_class {};

struct trace_event_data_offsets_xfs_rmapbt_class {};

struct trace_event_data_offsets_xfs_ag_resv_class {};

struct trace_event_data_offsets_xfs_ag_btree_lookup_class {};

struct trace_event_data_offsets_xfs_refcount_extent_class {};

struct trace_event_data_offsets_xfs_refcount_extent_at_class {};

struct trace_event_data_offsets_xfs_refcount_double_extent_class {};

struct trace_event_data_offsets_xfs_refcount_double_extent_at_class {};

struct trace_event_data_offsets_xfs_refcount_triple_extent_class {};

struct trace_event_data_offsets_xfs_refcount_finish_one_leftover {};

struct trace_event_data_offsets_xfs_inode_error_class {};

struct trace_event_data_offsets_xfs_double_io_class {};

struct trace_event_data_offsets_xfs_inode_irec_class {};

struct trace_event_data_offsets_xfs_reflink_remap_blocks {};

struct trace_event_data_offsets_xfs_ioctl_clone {};

struct trace_event_data_offsets_xfs_fsmap_class {};

struct trace_event_data_offsets_xfs_getfsmap_class {};

struct trace_event_data_offsets_xfs_trans_resv_calc {};

struct trace_event_data_offsets_xfs_trans_class {};

struct trace_event_data_offsets_xfs_iunlink_update_bucket {};

struct trace_event_data_offsets_xfs_iunlink_update_dinode {};

struct trace_event_data_offsets_xfs_ag_inode_class {};

struct trace_event_data_offsets_xfs_fs_corrupt_class {};

struct trace_event_data_offsets_xfs_ag_corrupt_class {};

struct trace_event_data_offsets_xfs_inode_corrupt_class {};

struct trace_event_data_offsets_xfs_iwalk_ag {};

struct trace_event_data_offsets_xfs_iwalk_ag_rec {};

struct trace_event_data_offsets_xfs_pwork_init {};

struct trace_event_data_offsets_xfs_kmem_class {};

struct trace_event_data_offsets_xfs_check_new_dalign {};

struct trace_event_data_offsets_xfs_btree_commit_afakeroot {};

struct trace_event_data_offsets_xfs_btree_commit_ifakeroot {};

struct trace_event_data_offsets_xfs_btree_bload_level_geometry {};

struct trace_event_data_offsets_xfs_btree_bload_block {};

struct trace_event_data_offsets_xfs_timestamp_range_class {};

struct trace_event_data_offsets_xfs_icwalk_class {};

struct trace_event_data_offsets_xlog_iclog_class {};

struct trace_event_data_offsets_xfs_das_state_class {};

struct trace_event_data_offsets_xfs_force_shutdown {
	u32 fname;
};

typedef void (*btf_trace_xfs_attr_list_sf)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_sf_all)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_leaf)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_leaf_end)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_full)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_add)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_wrong_blk)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_notfound)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_leaf_list)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_node_list)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xlog_intent_recovery_failed)(void *, struct xfs_mount *, int, void *);

typedef void (*btf_trace_xfs_perag_get)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_perag_get_tag)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_perag_put)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_perag_set_inode_tag)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_perag_clear_inode_tag)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_inodegc_worker)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_inodegc_flush)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_start)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_stop)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_queue)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_throttle)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_fs_sync_fs)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_start)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_stop)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_worker)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_flush_all)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_shrinker_scan)(void *, struct xfs_mount *, struct shrink_control *, void *);

typedef void (*btf_trace_xfs_read_agf)(void *, struct xfs_mount *, xfs_agnumber_t);

typedef void (*btf_trace_xfs_alloc_read_agf)(void *, struct xfs_mount *, xfs_agnumber_t);

typedef void (*btf_trace_xfs_read_agi)(void *, struct xfs_mount *, xfs_agnumber_t);

typedef void (*btf_trace_xfs_ialloc_read_agi)(void *, struct xfs_mount *, xfs_agnumber_t);

typedef void (*btf_trace_xfs_attr_list_node_descend)(void *, struct xfs_attr_list_context *, struct xfs_da_node_entry *);

typedef void (*btf_trace_xfs_iext_insert)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_iext_remove)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_bmap_pre_update)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_bmap_post_update)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_read_extent)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_write_extent)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_buf_init)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_free)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_hold)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_rele)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iodone)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_submit)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_lock)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_lock_done)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_trylock_fail)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_trylock)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_unlock)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iowait)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iowait_done)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_queue)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_queued)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_split)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_pushbuf)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_get_uncached)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_item_relse)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iodone_async)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_error_relse)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_drain_buftarg)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_trans_read_buf_shut)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_btree_corrupt)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_reset_dqcounts)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_find)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_get)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_read)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_ioerror)(void *, struct xfs_buf *, int, xfs_failaddr_t);

typedef void (*btf_trace_xfs_buf_item_size)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_size_ordered)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_size_stale)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_format)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_format_stale)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_ordered)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_pin)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_unpin)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_unpin_stale)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_release)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_committed)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_push)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_get_buf)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_get_buf_recur)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_getsb)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_getsb_recur)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_read_buf)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_read_buf_recur)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_log_buf)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_brelse)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_bjoin)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_bhold)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_bhold_release)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_binval)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_filestream_free)(void *, struct xfs_mount *, xfs_ino_t, xfs_agnumber_t);

typedef void (*btf_trace_xfs_filestream_lookup)(void *, struct xfs_mount *, xfs_ino_t, xfs_agnumber_t);

typedef void (*btf_trace_xfs_filestream_scan)(void *, struct xfs_mount *, xfs_ino_t, xfs_agnumber_t);

typedef void (*btf_trace_xfs_filestream_pick)(void *, struct xfs_inode *, xfs_agnumber_t, xfs_extlen_t, int);

typedef void (*btf_trace_xfs_ilock)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_ilock_nowait)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_ilock_demote)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_iunlock)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_iget_skip)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_recycle)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_recycle_fail)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_hit)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_miss)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_getattr)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_setattr)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_readlink)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inactive_symlink)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_alloc_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_free_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_zero_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_collapse_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_insert_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_readdir)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_vm_bmap)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_file_ioctl)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_file_compat_ioctl)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_ioctl_setattr)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_dir_fsync)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_file_fsync)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_destroy_inode)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_update_time)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_dquot_dqalloc)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_dquot_dqdetach)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_eofblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_clear_eofblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_free_eofblocks_invalid)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_cowblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_clear_cowblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_free_cowblocks_invalid)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_reclaimable)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_reclaiming)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_need_inactive)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_inactivating)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_filemap_fault)(void *, struct xfs_inode *, enum page_entry_size, bool);

typedef void (*btf_trace_xfs_iomap_prealloc_size)(void *, struct xfs_inode *, xfs_fsblock_t, int, unsigned int);

typedef void (*btf_trace_xfs_irec_merge_pre)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agino_t, uint16_t, xfs_agino_t, uint16_t);

typedef void (*btf_trace_xfs_irec_merge_post)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agino_t, uint16_t);

typedef void (*btf_trace_xfs_irele)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_inode_pin)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_inode_unpin)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_inode_unpin_nowait)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_remove)(void *, struct xfs_inode *, struct xfs_name *);

typedef void (*btf_trace_xfs_link)(void *, struct xfs_inode *, struct xfs_name *);

typedef void (*btf_trace_xfs_lookup)(void *, struct xfs_inode *, struct xfs_name *);

typedef void (*btf_trace_xfs_create)(void *, struct xfs_inode *, struct xfs_name *);

typedef void (*btf_trace_xfs_symlink)(void *, struct xfs_inode *, struct xfs_name *);

typedef void (*btf_trace_xfs_rename)(void *, struct xfs_inode *, struct xfs_inode *, struct xfs_name *, struct xfs_name *);

typedef void (*btf_trace_xfs_dqadjust)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_want)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_dirty)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_busy)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_done)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqattach_found)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqattach_get)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqalloc)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqtobp_read)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqread)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqread_fail)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_hit)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_miss)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_freeing)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_dup)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqput)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqput_free)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqrele)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqflush)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqflush_force)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqflush_done)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_trans_apply_dquot_deltas_before)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_trans_apply_dquot_deltas_after)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_trans_mod_dquot)(void *, struct xfs_trans *, struct xfs_dquot *, unsigned int, int64_t);

typedef void (*btf_trace_xfs_trans_apply_dquot_deltas)(void *, struct xfs_dqtrx *);

typedef void (*btf_trace_xfs_trans_mod_dquot_before)(void *, struct xfs_dqtrx *);

typedef void (*btf_trace_xfs_trans_mod_dquot_after)(void *, struct xfs_dqtrx *);

typedef void (*btf_trace_xfs_log_umount_write)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_grant_sleep)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_grant_wake)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_grant_wake_up)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_reserve)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_reserve_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_regrant)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_regrant_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_regrant)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_regrant_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_regrant_sub)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_ungrant)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_ungrant_sub)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_ungrant_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_cil_wait)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_force)(void *, struct xfs_mount *, xfs_lsn_t, long unsigned int);

typedef void (*btf_trace_xfs_ail_push)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_pinned)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_locked)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_flushing)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_insert)(void *, struct xfs_log_item *, xfs_lsn_t, xfs_lsn_t);

typedef void (*btf_trace_xfs_ail_move)(void *, struct xfs_log_item *, xfs_lsn_t, xfs_lsn_t);

typedef void (*btf_trace_xfs_ail_delete)(void *, struct xfs_log_item *, xfs_lsn_t, xfs_lsn_t);

typedef void (*btf_trace_xfs_log_assign_tail_lsn)(void *, struct xlog *, xfs_lsn_t);

typedef void (*btf_trace_xfs_file_buffered_read)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_direct_read)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_dax_read)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_buffered_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_direct_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_dax_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_reflink_bounce_dio_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_map_blocks_found)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_map_blocks_alloc)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_iomap_alloc)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_iomap_found)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_delalloc_enospc)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_unwritten_convert)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_setfilesize)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_zero_eof)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_end_io_direct_write)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_end_io_direct_write_unwritten)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_end_io_direct_write_append)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_itruncate_extents_start)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_itruncate_extents_end)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_pagecache_inval)(void *, struct xfs_inode *, xfs_off_t, xfs_off_t);

typedef void (*btf_trace_xfs_bunmap)(void *, struct xfs_inode *, xfs_fileoff_t, xfs_filblks_t, int, long unsigned int);

typedef void (*btf_trace_xfs_extent_busy)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_enomem)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_force)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_reuse)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_clear)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_trim)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_agf)(void *, struct xfs_mount *, struct xfs_agf *, int, long unsigned int);

typedef void (*btf_trace_xfs_agfl_reset)(void *, struct xfs_mount *, struct xfs_agf *, int, long unsigned int);

typedef void (*btf_trace_xfs_free_extent)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, enum xfs_ag_resv_type, int, int);

typedef void (*btf_trace_xfs_alloc_exact_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_exact_notfound)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_exact_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_nominleft)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_first)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_right)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_left)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_lookup)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_lookup_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_noentry)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_busy)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_neither)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_noentry)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_nominleft)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_busy)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_freelist)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_notenough)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_badargs)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_nofix)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_noagbp)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_loopfailed)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_allfailed)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_check)(void *, struct xfs_mount *, xfs_btnum_t, xfs_agblock_t, xfs_extlen_t, xfs_extlen_t, bool);

typedef void (*btf_trace_xfs_dir2_sf_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_toino4)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_toino8)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_to_block)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_to_sf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_to_leaf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_to_block)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_to_node)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_to_leaf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_add)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_remove)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_to_leaf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add_old)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add_new)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add_work)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_compact)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_get)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_remove)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_split_before)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_split_after)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_clearflag)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_setflag)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_flipflags)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_to_sf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_to_node)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_rebalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_unbalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_toosmall)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_get)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_fillstate)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_refillstate)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_rmtval_get)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_rmtval_set)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_join)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_link_before)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_link_after)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_unlink_back)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_unlink_forward)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_root_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_root_join)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_add)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_remove)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_rebalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_unbalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_toosmall)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_swap_lastblock)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_grow_inode)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_shrink_inode)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_fixhashpath)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_path_shift)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leafn_add)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_leafn_remove)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_grow_inode)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_shrink_inode)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_leafn_moveents)(void *, struct xfs_da_args *, int, int, int);

typedef void (*btf_trace_xfs_swap_extent_before)(void *, struct xfs_inode *, int);

typedef void (*btf_trace_xfs_swap_extent_after)(void *, struct xfs_inode *, int);

typedef void (*btf_trace_xfs_log_recover)(void *, struct xlog *, xfs_daddr_t, xfs_daddr_t);

typedef void (*btf_trace_xfs_log_recover_record)(void *, struct xlog *, struct xlog_rec_header *, int);

typedef void (*btf_trace_xfs_log_recover_item_add)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_add_cont)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_reorder_head)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_reorder_tail)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_recover)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_buf_not_cancel)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_cancel)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_cancel_add)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_cancel_ref_inc)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_recover)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_skip)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_inode_buf)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_reg_buf)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_dquot_buf)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_inode_recover)(void *, struct xlog *, struct xfs_inode_log_format *);

typedef void (*btf_trace_xfs_log_recover_inode_cancel)(void *, struct xlog *, struct xfs_inode_log_format *);

typedef void (*btf_trace_xfs_log_recover_inode_skip)(void *, struct xlog *, struct xfs_inode_log_format *);

typedef void (*btf_trace_xfs_log_recover_icreate_cancel)(void *, struct xlog *, struct xfs_icreate_log *);

typedef void (*btf_trace_xfs_log_recover_icreate_recover)(void *, struct xlog *, struct xfs_icreate_log *);

typedef void (*btf_trace_xfs_discard_extent)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_discard_toosmall)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_discard_exclude)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_discard_busy)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_btree_updkeys)(void *, struct xfs_btree_cur *, int, struct xfs_buf *);

typedef void (*btf_trace_xfs_btree_overlapped_query_range)(void *, struct xfs_btree_cur *, int, struct xfs_buf *);

typedef void (*btf_trace_xfs_defer_cancel)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_trans_roll)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_trans_abort)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_finish)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_finish_done)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_trans_roll_error)(void *, struct xfs_trans *, int);

typedef void (*btf_trace_xfs_defer_finish_error)(void *, struct xfs_trans *, int);

typedef void (*btf_trace_xfs_defer_create_intent)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_cancel_list)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_pending_finish)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_pending_abort)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_relog_intent)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_bmap_free_defer)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_bmap_free_deferred)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_agfl_free_defer)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_agfl_free_deferred)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_rmap_unmap)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_unmap_done)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_unmap_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_map)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_map_done)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_map_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_convert)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_convert_done)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_convert_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_convert_state)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_defer)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_ino_t, int, xfs_fileoff_t, xfs_filblks_t, xfs_exntst_t);

typedef void (*btf_trace_xfs_rmap_deferred)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_ino_t, int, xfs_fileoff_t, xfs_filblks_t, xfs_exntst_t);

typedef void (*btf_trace_xfs_rmapbt_alloc_block)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_rmapbt_free_block)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_rmap_update)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_insert)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_delete)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_insert_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_delete_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_update_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_find_left_neighbor_candidate)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_find_left_neighbor_query)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_lookup_le_range_candidate)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_lookup_le_range)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_lookup_le_range_result)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_find_right_neighbor_result)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_find_left_neighbor_result)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_bmap_defer)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_ino_t, int, xfs_fileoff_t, xfs_filblks_t, xfs_exntst_t);

typedef void (*btf_trace_xfs_bmap_deferred)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_ino_t, int, xfs_fileoff_t, xfs_filblks_t, xfs_exntst_t);

typedef void (*btf_trace_xfs_ag_resv_init)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_free)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_alloc_extent)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_free_extent)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_critical)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_needed)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_free_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_ag_resv_init_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcountbt_alloc_block)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcountbt_free_block)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_lookup)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_lookup_t);

typedef void (*btf_trace_xfs_refcount_get)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_update)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_insert)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_delete)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_insert_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_delete_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_update_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_increase)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_decrease)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_cow_increase)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_cow_decrease)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_merge_center_extents)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *, struct xfs_refcount_irec *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_modify_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_recover_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_split_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *, xfs_agblock_t);

typedef void (*btf_trace_xfs_refcount_merge_left_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_merge_right_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_find_left_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *, struct xfs_refcount_irec *, xfs_agblock_t);

typedef void (*btf_trace_xfs_refcount_find_right_extent)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_refcount_irec *, struct xfs_refcount_irec *, xfs_agblock_t);

typedef void (*btf_trace_xfs_refcount_adjust_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_adjust_cow_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_merge_center_extents_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_modify_extent_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_split_extent_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_merge_left_extent_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_merge_right_extent_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_left_extent_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_right_extent_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_shared)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_find_shared_result)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_find_shared_error)(void *, struct xfs_mount *, xfs_agnumber_t, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_defer)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_deferred)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_finish_one_leftover)(void *, struct xfs_mount *, xfs_agnumber_t, int, xfs_agblock_t, xfs_extlen_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_reflink_set_inode_flag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_reflink_unset_inode_flag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_reflink_update_inode_size)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_reflink_remap_blocks)(void *, struct xfs_inode *, xfs_fileoff_t, xfs_filblks_t, struct xfs_inode *, xfs_fileoff_t);

typedef void (*btf_trace_xfs_reflink_remap_range)(void *, struct xfs_inode *, xfs_off_t, xfs_off_t, struct xfs_inode *, xfs_off_t);

typedef void (*btf_trace_xfs_reflink_remap_range_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_set_inode_flag_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_update_inode_size_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_remap_blocks_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_remap_extent_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_remap_extent_src)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_remap_extent_dest)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_compare_extents)(void *, struct xfs_inode *, xfs_off_t, xfs_off_t, struct xfs_inode *, xfs_off_t);

typedef void (*btf_trace_xfs_reflink_compare_extents_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_ioctl_clone)(void *, struct inode *, struct inode *);

typedef void (*btf_trace_xfs_reflink_unshare)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_reflink_unshare_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_trim_around_shared)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cow_found)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cow_enospc)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_convert_cow)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cancel_cow_range)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_reflink_end_cow)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_reflink_cow_remap)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cancel_cow_range_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_end_cow_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_cancel_cow)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_swap_extent_rmap_remap)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_swap_extent_rmap_remap_piece)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_swap_extent_rmap_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_fsmap_low_key)(void *, struct xfs_mount *, u32, xfs_agnumber_t, const struct xfs_rmap_irec *);

typedef void (*btf_trace_xfs_fsmap_high_key)(void *, struct xfs_mount *, u32, xfs_agnumber_t, const struct xfs_rmap_irec *);

typedef void (*btf_trace_xfs_fsmap_mapping)(void *, struct xfs_mount *, u32, xfs_agnumber_t, const struct xfs_rmap_irec *);

typedef void (*btf_trace_xfs_getfsmap_low_key)(void *, struct xfs_mount *, struct xfs_fsmap *);

typedef void (*btf_trace_xfs_getfsmap_high_key)(void *, struct xfs_mount *, struct xfs_fsmap *);

typedef void (*btf_trace_xfs_getfsmap_mapping)(void *, struct xfs_mount *, struct xfs_fsmap *);

typedef void (*btf_trace_xfs_trans_resv_calc)(void *, struct xfs_mount *, unsigned int, struct xfs_trans_res *);

typedef void (*btf_trace_xfs_trans_alloc)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_cancel)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_commit)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_dup)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_free)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_roll)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_add_item)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_commit_items)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_free_items)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_iunlink_update_bucket)(void *, struct xfs_mount *, xfs_agnumber_t, unsigned int, xfs_agino_t, xfs_agino_t);

typedef void (*btf_trace_xfs_iunlink_update_dinode)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agino_t, xfs_agino_t, xfs_agino_t);

typedef void (*btf_trace_xfs_iunlink)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iunlink_remove)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iunlink_map_prev_fallback)(void *, struct xfs_mount *, xfs_agnumber_t);

typedef void (*btf_trace_xfs_fs_mark_sick)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_fs_mark_healthy)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_fs_unfixed_corruption)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_rt_mark_sick)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_rt_mark_healthy)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_rt_unfixed_corruption)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_ag_mark_sick)(void *, struct xfs_mount *, xfs_agnumber_t, unsigned int);

typedef void (*btf_trace_xfs_ag_mark_healthy)(void *, struct xfs_mount *, xfs_agnumber_t, unsigned int);

typedef void (*btf_trace_xfs_ag_unfixed_corruption)(void *, struct xfs_mount *, xfs_agnumber_t, unsigned int);

typedef void (*btf_trace_xfs_inode_mark_sick)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_inode_mark_healthy)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_iwalk_ag)(void *, struct xfs_mount *, xfs_agnumber_t, xfs_agino_t);

typedef void (*btf_trace_xfs_iwalk_ag_rec)(void *, struct xfs_mount *, xfs_agnumber_t, struct xfs_inobt_rec_incore *);

typedef void (*btf_trace_xfs_pwork_init)(void *, struct xfs_mount *, unsigned int, pid_t);

typedef void (*btf_trace_kmem_alloc)(void *, ssize_t, int, long unsigned int);

typedef void (*btf_trace_xfs_check_new_dalign)(void *, struct xfs_mount *, int, xfs_ino_t);

typedef void (*btf_trace_xfs_btree_commit_afakeroot)(void *, struct xfs_btree_cur *);

typedef void (*btf_trace_xfs_btree_commit_ifakeroot)(void *, struct xfs_btree_cur *);

typedef void (*btf_trace_xfs_btree_bload_level_geometry)(void *, struct xfs_btree_cur *, unsigned int, uint64_t, unsigned int, unsigned int, uint64_t, uint64_t);

typedef void (*btf_trace_xfs_btree_bload_block)(void *, struct xfs_btree_cur *, unsigned int, uint64_t, uint64_t, union xfs_btree_ptr *, unsigned int);

typedef void (*btf_trace_xfs_inode_timestamp_range)(void *, struct xfs_mount *, long long int, long long int);

typedef void (*btf_trace_xfs_quota_expiry_range)(void *, struct xfs_mount *, long long int, long long int);

typedef void (*btf_trace_xfs_ioc_free_eofblocks)(void *, struct xfs_mount *, struct xfs_icwalk *, long unsigned int);

typedef void (*btf_trace_xfs_blockgc_free_space)(void *, struct xfs_mount *, struct xfs_icwalk *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_activate)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_clean)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_callback)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_callbacks_start)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_callbacks_done)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_force)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_force_lsn)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_get_space)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_release)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_switch)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_sync)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_syncing)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_sync_done)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_want_sync)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_wait_on)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_write)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xfs_attr_sf_addname_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_set_iter_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_node_addname_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_remove_iter_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_rmtval_remove_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_force_shutdown)(void *, struct xfs_mount *, int, int, const char *, int);

typedef unsigned int xfs_km_flags_t;

struct xfs_ag_geometry {
	uint32_t ag_number;
	uint32_t ag_length;
	uint32_t ag_freeblks;
	uint32_t ag_icount;
	uint32_t ag_ifree;
	uint32_t ag_sick;
	uint32_t ag_checked;
	uint32_t ag_flags;
	uint64_t ag_reserved[12];
};

struct xfs_dsb {
	__be32 sb_magicnum;
	__be32 sb_blocksize;
	__be64 sb_dblocks;
	__be64 sb_rblocks;
	__be64 sb_rextents;
	uuid_t sb_uuid;
	__be64 sb_logstart;
	__be64 sb_rootino;
	__be64 sb_rbmino;
	__be64 sb_rsumino;
	__be32 sb_rextsize;
	__be32 sb_agblocks;
	__be32 sb_agcount;
	__be32 sb_rbmblocks;
	__be32 sb_logblocks;
	__be16 sb_versionnum;
	__be16 sb_sectsize;
	__be16 sb_inodesize;
	__be16 sb_inopblock;
	char sb_fname[12];
	__u8 sb_blocklog;
	__u8 sb_sectlog;
	__u8 sb_inodelog;
	__u8 sb_inopblog;
	__u8 sb_agblklog;
	__u8 sb_rextslog;
	__u8 sb_inprogress;
	__u8 sb_imax_pct;
	__be64 sb_icount;
	__be64 sb_ifree;
	__be64 sb_fdblocks;
	__be64 sb_frextents;
	__be64 sb_uquotino;
	__be64 sb_gquotino;
	__be16 sb_qflags;
	__u8 sb_flags;
	__u8 sb_shared_vn;
	__be32 sb_inoalignmt;
	__be32 sb_unit;
	__be32 sb_width;
	__u8 sb_dirblklog;
	__u8 sb_logsectlog;
	__be16 sb_logsectsize;
	__be32 sb_logsunit;
	__be32 sb_features2;
	__be32 sb_bad_features2;
	__be32 sb_features_compat;
	__be32 sb_features_ro_compat;
	__be32 sb_features_incompat;
	__be32 sb_features_log_incompat;
	__le32 sb_crc;
	__be32 sb_spino_align;
	__be64 sb_pquotino;
	__be64 sb_lsn;
	uuid_t sb_meta_uuid;
};

struct xfs_agi {
	__be32 agi_magicnum;
	__be32 agi_versionnum;
	__be32 agi_seqno;
	__be32 agi_length;
	__be32 agi_count;
	__be32 agi_root;
	__be32 agi_level;
	__be32 agi_freecount;
	__be32 agi_newino;
	__be32 agi_dirino;
	__be32 agi_unlinked[64];
	uuid_t agi_uuid;
	__be32 agi_crc;
	__be32 agi_pad32;
	__be64 agi_lsn;
	__be32 agi_free_root;
	__be32 agi_free_level;
	__be32 agi_iblocks;
	__be32 agi_fblocks;
};

struct xfs_agfl {
	__be32 agfl_magicnum;
	__be32 agfl_seqno;
	uuid_t agfl_uuid;
	__be64 agfl_lsn;
	__be32 agfl_crc;
} __attribute__((packed));

typedef struct xfs_alloc_rec xfs_alloc_rec_t;

typedef struct xfs_alloc_arg xfs_alloc_arg_t;

struct aghdr_init_data {
	xfs_agblock_t agno;
	xfs_extlen_t agsize;
	struct list_head buffer_list;
	xfs_rfsblock_t nfree;
	xfs_daddr_t daddr;
	size_t numblks;
	xfs_btnum_t type;
};

typedef struct xfs_trans xfs_trans_t;

typedef void (*aghdr_init_work_f)(struct xfs_mount *, struct xfs_buf *, struct aghdr_init_data *);

struct xfs_aghdr_grow_data {
	xfs_daddr_t daddr;
	size_t numblks;
	const struct xfs_buf_ops *ops;
	aghdr_init_work_f work;
	xfs_btnum_t type;
	bool need_init;
};

struct xfs_sysctl_val {
	int min;
	int val;
	int max;
};

typedef struct xfs_sysctl_val xfs_sysctl_val_t;

struct xfs_param {
	xfs_sysctl_val_t sgid_inherit;
	xfs_sysctl_val_t symlink_mode;
	xfs_sysctl_val_t panic_mask;
	xfs_sysctl_val_t error_level;
	xfs_sysctl_val_t syncd_timer;
	xfs_sysctl_val_t stats_clear;
	xfs_sysctl_val_t inherit_sync;
	xfs_sysctl_val_t inherit_nodump;
	xfs_sysctl_val_t inherit_noatim;
	xfs_sysctl_val_t xfs_buf_timer;
	xfs_sysctl_val_t xfs_buf_age;
	xfs_sysctl_val_t inherit_nosym;
	xfs_sysctl_val_t rotorstep;
	xfs_sysctl_val_t inherit_nodfrg;
	xfs_sysctl_val_t fstrm_timer;
	xfs_sysctl_val_t blockgc_timer;
};

typedef struct xfs_param xfs_param_t;

enum xfs_blft {
	XFS_BLFT_UNKNOWN_BUF = 0,
	XFS_BLFT_UDQUOT_BUF = 1,
	XFS_BLFT_PDQUOT_BUF = 2,
	XFS_BLFT_GDQUOT_BUF = 3,
	XFS_BLFT_BTREE_BUF = 4,
	XFS_BLFT_AGF_BUF = 5,
	XFS_BLFT_AGFL_BUF = 6,
	XFS_BLFT_AGI_BUF = 7,
	XFS_BLFT_DINO_BUF = 8,
	XFS_BLFT_SYMLINK_BUF = 9,
	XFS_BLFT_DIR_BLOCK_BUF = 10,
	XFS_BLFT_DIR_DATA_BUF = 11,
	XFS_BLFT_DIR_FREE_BUF = 12,
	XFS_BLFT_DIR_LEAF1_BUF = 13,
	XFS_BLFT_DIR_LEAFN_BUF = 14,
	XFS_BLFT_DA_NODE_BUF = 15,
	XFS_BLFT_ATTR_LEAF_BUF = 16,
	XFS_BLFT_ATTR_RMT_BUF = 17,
	XFS_BLFT_SB_BUF = 18,
	XFS_BLFT_RTBITMAP_BUF = 19,
	XFS_BLFT_RTSUMMARY_BUF = 20,
	XFS_BLFT_MAX_BUF = 32,
};

typedef struct xfs_mount xfs_mount_t;

typedef struct xfs_btree_cur xfs_btree_cur_t;

typedef int (*xfs_btree_query_range_fn)(struct xfs_btree_cur *, const union xfs_btree_rec *, void *);

typedef int (*xfs_alloc_query_range_fn)(struct xfs_btree_cur *, const struct xfs_alloc_rec_incore *, void *);

typedef int (*xfs_agfl_walk_fn)(struct xfs_mount *, xfs_agblock_t, void *);

struct xfs_extent_free_item {
	xfs_fsblock_t xefi_startblock;
	xfs_extlen_t xefi_blockcount;
	bool xefi_skip_discard;
	struct list_head xefi_list;
	struct xfs_owner_info xefi_oinfo;
};

struct xfs_alloc_cur {
	struct xfs_btree_cur *cnt;
	struct xfs_btree_cur *bnolt;
	struct xfs_btree_cur *bnogt;
	xfs_extlen_t cur_len;
	xfs_agblock_t rec_bno;
	xfs_extlen_t rec_len;
	xfs_agblock_t bno;
	xfs_extlen_t len;
	xfs_extlen_t diff;
	unsigned int busy_gen;
	bool busy;
};

struct xfs_alloc_query_range_info {
	xfs_alloc_query_range_fn fn;
	void *priv;
};

struct xfs_attr_sf_hdr {
	__be16 totsize;
	__u8 count;
	__u8 padding;
};

struct xfs_attr_sf_entry {
	uint8_t namelen;
	uint8_t valuelen;
	uint8_t flags;
	uint8_t nameval[0];
};

struct xfs_attr_shortform {
	struct xfs_attr_sf_hdr hdr;
	struct xfs_attr_sf_entry list[1];
};

typedef struct xfs_da_args xfs_da_args_t;

struct xfs_da_state_blk {
	struct xfs_buf *bp;
	xfs_dablk_t blkno;
	xfs_daddr_t disk_blkno;
	int index;
	xfs_dahash_t hashval;
	int magic;
};

typedef struct xfs_da_state_blk xfs_da_state_blk_t;

struct xfs_da_state_path {
	int active;
	xfs_da_state_blk_t blk[5];
};

typedef struct xfs_da_state_path xfs_da_state_path_t;

struct xfs_da_state {
	xfs_da_args_t *args;
	struct xfs_mount *mp;
	xfs_da_state_path_t path;
	xfs_da_state_path_t altpath;
	unsigned char inleaf;
	unsigned char extravalid;
	unsigned char extraafter;
	xfs_da_state_blk_t extrablk;
};

typedef struct xfs_da_state xfs_da_state_t;

typedef struct xfs_inode xfs_inode_t;

enum xfs_delattr_state {
	XFS_DAS_UNINIT = 0,
	XFS_DAS_RMTBLK = 1,
	XFS_DAS_RM_NAME = 2,
	XFS_DAS_RM_SHRINK = 3,
	XFS_DAS_FOUND_LBLK = 4,
	XFS_DAS_FOUND_NBLK = 5,
	XFS_DAS_FLIP_LFLAG = 6,
	XFS_DAS_RM_LBLK = 7,
	XFS_DAS_RD_LEAF = 8,
	XFS_DAS_ALLOC_NODE = 9,
	XFS_DAS_FLIP_NFLAG = 10,
	XFS_DAS_RM_NBLK = 11,
	XFS_DAS_CLR_FLAG = 12,
};

struct xfs_delattr_context {
	struct xfs_da_args *da_args;
	struct xfs_bmbt_irec map;
	xfs_dablk_t lblkno;
	int blkcnt;
	struct xfs_da_state *da_state;
	unsigned int flags;
	enum xfs_delattr_state dela_state;
};

struct xfs_da_blkinfo {
	__be32 forw;
	__be32 back;
	__be16 magic;
	__be16 pad;
};

typedef struct xfs_da_blkinfo xfs_da_blkinfo_t;

struct xfs_da3_blkinfo {
	struct xfs_da_blkinfo hdr;
	__be32 crc;
	__be64 blkno;
	__be64 lsn;
	uuid_t uuid;
	__be64 owner;
};

struct xfs_da_node_hdr {
	struct xfs_da_blkinfo info;
	__be16 __count;
	__be16 __level;
};

struct xfs_da_intnode {
	struct xfs_da_node_hdr hdr;
	struct xfs_da_node_entry __btree[0];
};

struct xfs_attr_leaf_map {
	__be16 base;
	__be16 size;
};

typedef struct xfs_attr_leaf_map xfs_attr_leaf_map_t;

struct xfs_attr_leaf_hdr {
	xfs_da_blkinfo_t info;
	__be16 count;
	__be16 usedbytes;
	__be16 firstused;
	__u8 holes;
	__u8 pad1;
	xfs_attr_leaf_map_t freemap[3];
};

typedef struct xfs_attr_leaf_hdr xfs_attr_leaf_hdr_t;

struct xfs_attr_leaf_entry {
	__be32 hashval;
	__be16 nameidx;
	__u8 flags;
	__u8 pad2;
};

typedef struct xfs_attr_leaf_entry xfs_attr_leaf_entry_t;

struct xfs_attr_leaf_name_local {
	__be16 valuelen;
	__u8 namelen;
	__u8 nameval[1];
};

typedef struct xfs_attr_leaf_name_local xfs_attr_leaf_name_local_t;

struct xfs_attr_leaf_name_remote {
	__be32 valueblk;
	__be32 valuelen;
	__u8 namelen;
	__u8 name[1];
};

typedef struct xfs_attr_leaf_name_remote xfs_attr_leaf_name_remote_t;

struct xfs_attr_leafblock {
	xfs_attr_leaf_hdr_t hdr;
	xfs_attr_leaf_entry_t entries[1];
};

typedef struct xfs_attr_leafblock xfs_attr_leafblock_t;

struct xfs_attr3_leaf_hdr {
	struct xfs_da3_blkinfo info;
	__be16 count;
	__be16 usedbytes;
	__be16 firstused;
	__u8 holes;
	__u8 pad1;
	struct xfs_attr_leaf_map freemap[3];
	__be32 pad2;
};

struct xfs_attr3_leafblock {
	struct xfs_attr3_leaf_hdr hdr;
	struct xfs_attr_leaf_entry entries[1];
};

struct xfs_da3_icnode_hdr {
	uint32_t forw;
	uint32_t back;
	uint16_t magic;
	uint16_t count;
	uint16_t level;
	struct xfs_da_node_entry *btree;
};

struct xfs_attr3_icleaf_hdr {
	uint32_t forw;
	uint32_t back;
	uint16_t magic;
	uint16_t count;
	uint16_t usedbytes;
	uint32_t firstused;
	__u8 holes;
	struct {
		uint16_t base;
		uint16_t size;
	} freemap[3];
};

struct xfs_attr3_rmt_hdr {
	__be32 rm_magic;
	__be32 rm_offset;
	__be32 rm_bytes;
	__be32 rm_crc;
	uuid_t rm_uuid;
	__be64 rm_owner;
	__be64 rm_blkno;
	__be64 rm_lsn;
};

typedef int16_t xfs_aextnum_t;

typedef struct xfs_bmbt_irec xfs_bmbt_irec_t;

typedef struct xfs_bmbt_key xfs_bmbt_key_t;

typedef __be64 xfs_bmbt_ptr_t;

typedef int (*xfs_btree_visit_blocks_fn)(struct xfs_btree_cur *, int, void *);

struct xfs_bmalloca {
	struct xfs_trans *tp;
	struct xfs_inode *ip;
	struct xfs_bmbt_irec prev;
	struct xfs_bmbt_irec got;
	xfs_fileoff_t offset;
	xfs_extlen_t length;
	xfs_fsblock_t blkno;
	struct xfs_btree_cur *cur;
	struct xfs_iext_cursor icur;
	int nallocs;
	int logflags;
	xfs_extlen_t total;
	xfs_extlen_t minlen;
	xfs_extlen_t minleft;
	bool eof;
	bool wasdel;
	bool aeof;
	bool conv;
	int datatype;
	int flags;
};

enum xfs_bmap_intent_type {
	XFS_BMAP_MAP = 1,
	XFS_BMAP_UNMAP = 2,
};

struct xfs_bmap_intent {
	struct list_head bi_list;
	enum xfs_bmap_intent_type bi_type;
	struct xfs_inode *bi_owner;
	int bi_whichfork;
	struct xfs_bmbt_irec bi_bmap;
};

struct xfs_iread_state {
	struct xfs_iext_cursor icur;
	xfs_extnum_t loaded;
};

struct xfs_bmdr_block {
	__be16 bb_level;
	__be16 bb_numrecs;
};

typedef struct xfs_bmdr_block xfs_bmdr_block_t;

typedef uint64_t xfs_bmbt_rec_base_t;

typedef __be64 xfs_bmdr_ptr_t;

struct xfs_btree_split_args {
	struct xfs_btree_cur *cur;
	int level;
	union xfs_btree_ptr *ptrp;
	union xfs_btree_key *key;
	struct xfs_btree_cur **curp;
	int *stat;
	int result;
	bool kswapd;
	struct completion *done;
	struct work_struct work;
};

struct xfs_btree_block_change_owner_info {
	uint64_t new_owner;
	struct list_head *buffer_list;
};

typedef int (*xfs_btree_bload_get_record_fn)(struct xfs_btree_cur *, void *);

typedef int (*xfs_btree_bload_claim_block_fn)(struct xfs_btree_cur *, union xfs_btree_ptr *, void *);

typedef size_t (*xfs_btree_bload_iroot_size_fn)(struct xfs_btree_cur *, unsigned int, void *);

struct xfs_btree_bload {
	xfs_btree_bload_get_record_fn get_record;
	xfs_btree_bload_claim_block_fn claim_block;
	xfs_btree_bload_iroot_size_fn iroot_size;
	uint64_t nr_records;
	int leaf_slack;
	int node_slack;
	uint64_t nr_blocks;
	unsigned int btree_height;
};

struct xfs_da3_node_hdr {
	struct xfs_da3_blkinfo info;
	__be16 __count;
	__be16 __level;
	__be32 __pad32;
};

typedef struct xfs_da_intnode xfs_da_intnode_t;

struct xfs_da3_intnode {
	struct xfs_da3_node_hdr hdr;
	struct xfs_da_node_entry __btree[0];
};

struct xfs_dir2_leaf_hdr {
	xfs_da_blkinfo_t info;
	__be16 count;
	__be16 stale;
};

typedef struct xfs_dir2_leaf_hdr xfs_dir2_leaf_hdr_t;

struct xfs_dir2_leaf_entry {
	__be32 hashval;
	__be32 address;
};

typedef struct xfs_dir2_leaf_entry xfs_dir2_leaf_entry_t;

struct xfs_dir2_leaf {
	xfs_dir2_leaf_hdr_t hdr;
	xfs_dir2_leaf_entry_t __ents[0];
};

typedef struct xfs_dir2_leaf xfs_dir2_leaf_t;

struct xfs_dir3_icleaf_hdr {
	uint32_t forw;
	uint32_t back;
	uint16_t magic;
	uint16_t count;
	uint16_t stale;
	struct xfs_dir2_leaf_entry *ents;
};

struct xfs_defer_op_type {
	struct xfs_log_item * (*create_intent)(struct xfs_trans *, struct list_head *, unsigned int, bool);
	void (*abort_intent)(struct xfs_log_item *);
	struct xfs_log_item * (*create_done)(struct xfs_trans *, struct xfs_log_item *, unsigned int);
	int (*finish_item)(struct xfs_trans *, struct xfs_log_item *, struct list_head *, struct xfs_btree_cur **);
	void (*finish_cleanup)(struct xfs_trans *, struct xfs_btree_cur *, int);
	void (*cancel_item)(struct list_head *);
	unsigned int max_items;
};

struct xfs_defer_capture {
	struct list_head dfc_list;
	struct list_head dfc_dfops;
	unsigned int dfc_tpflags;
	unsigned int dfc_blkres;
	unsigned int dfc_rtxres;
	unsigned int dfc_logres;
	struct xfs_inode *dfc_capture_ip;
};

struct xfs_inode_log_item {
	struct xfs_log_item ili_item;
	struct xfs_inode *ili_inode;
	short unsigned int ili_lock_flags;
	spinlock_t ili_lock;
	unsigned int ili_last_fields;
	unsigned int ili_fields;
	unsigned int ili_fsync_fields;
	xfs_lsn_t ili_flush_lsn;
	xfs_csn_t ili_commit_seq;
};

typedef xfs_off_t xfs_dir2_off_t;

typedef uint32_t xfs_dir2_db_t;

struct xfs_dir2_sf_hdr {
	uint8_t count;
	uint8_t i8count;
	uint8_t parent[8];
};

typedef struct xfs_dir2_sf_hdr xfs_dir2_sf_hdr_t;

typedef uint32_t xfs_dir2_dataptr_t;

struct xfs_dir2_sf_entry {
	__u8 namelen;
	__u8 offset[2];
	__u8 name[0];
};

typedef struct xfs_dir2_sf_entry xfs_dir2_sf_entry_t;

struct xfs_dir2_data_free {
	__be16 offset;
	__be16 length;
};

typedef struct xfs_dir2_data_free xfs_dir2_data_free_t;

struct xfs_dir2_data_hdr {
	__be32 magic;
	xfs_dir2_data_free_t bestfree[3];
};

typedef struct xfs_dir2_data_hdr xfs_dir2_data_hdr_t;

struct xfs_dir3_blk_hdr {
	__be32 magic;
	__be32 crc;
	__be64 blkno;
	__be64 lsn;
	uuid_t uuid;
	__be64 owner;
};

struct xfs_dir2_data_entry {
	__be64 inumber;
	__u8 namelen;
	__u8 name[0];
};

typedef struct xfs_dir2_data_entry xfs_dir2_data_entry_t;

struct xfs_dir2_data_unused {
	__be16 freetag;
	__be16 length;
	__be16 tag;
};

typedef struct xfs_dir2_data_unused xfs_dir2_data_unused_t;

struct xfs_dir2_leaf_tail {
	__be32 bestcount;
};

typedef struct xfs_dir2_leaf_tail xfs_dir2_leaf_tail_t;

struct xfs_dir2_block_tail {
	__be32 count;
	__be32 stale;
};

typedef struct xfs_dir2_block_tail xfs_dir2_block_tail_t;

struct xfs_dir3_data_hdr {
	struct xfs_dir3_blk_hdr hdr;
	xfs_dir2_data_free_t best_free[3];
	__be32 pad;
};

typedef uint16_t xfs_dir2_data_off_t;

struct xfs_dir3_leaf_hdr {
	struct xfs_da3_blkinfo info;
	__be16 count;
	__be16 stale;
	__be32 pad;
};

struct xfs_dir3_leaf {
	struct xfs_dir3_leaf_hdr hdr;
	struct xfs_dir2_leaf_entry __ents[0];
};

struct xfs_dir2_free_hdr {
	__be32 magic;
	__be32 firstdb;
	__be32 nvalid;
	__be32 nused;
};

typedef struct xfs_dir2_free_hdr xfs_dir2_free_hdr_t;

struct xfs_dir2_free {
	xfs_dir2_free_hdr_t hdr;
	__be16 bests[0];
};

struct xfs_dir3_icfree_hdr {
	uint32_t magic;
	uint32_t firstdb;
	uint32_t nvalid;
	uint32_t nused;
	__be16 *bests;
};

typedef struct xfs_dir2_free xfs_dir2_free_t;

struct xfs_dir3_free_hdr {
	struct xfs_dir3_blk_hdr hdr;
	__be32 firstdb;
	__be32 nvalid;
	__be32 nused;
	__be32 pad;
};

struct xfs_dir3_free {
	struct xfs_dir3_free_hdr hdr;
	__be16 bests[0];
};

struct xfs_disk_dquot {
	__be16 d_magic;
	__u8 d_version;
	__u8 d_type;
	__be32 d_id;
	__be64 d_blk_hardlimit;
	__be64 d_blk_softlimit;
	__be64 d_ino_hardlimit;
	__be64 d_ino_softlimit;
	__be64 d_bcount;
	__be64 d_icount;
	__be32 d_itimer;
	__be32 d_btimer;
	__be16 d_iwarns;
	__be16 d_bwarns;
	__be32 d_pad0;
	__be64 d_rtb_hardlimit;
	__be64 d_rtb_softlimit;
	__be64 d_rtbcount;
	__be32 d_rtbtimer;
	__be16 d_rtbwarns;
	__be16 d_pad;
};

struct xfs_dqblk {
	struct xfs_disk_dquot dd_diskdq;
	char dd_fill[4];
	__be32 dd_crc;
	__be64 dd_lsn;
	uuid_t dd_uuid;
};

struct xfs_quota_limits {
	xfs_qcnt_t hard;
	xfs_qcnt_t soft;
	time64_t time;
	xfs_qwarncnt_t warn;
};

struct xfs_def_quota {
	struct xfs_quota_limits blk;
	struct xfs_quota_limits ino;
	struct xfs_quota_limits rtb;
};

struct xfs_quotainfo {
	struct xarray qi_uquota_tree;
	struct xarray qi_gquota_tree;
	struct xarray qi_pquota_tree;
	struct mutex qi_tree_lock;
	struct xfs_inode *qi_uquotaip;
	struct xfs_inode *qi_gquotaip;
	struct xfs_inode *qi_pquotaip;
	struct list_lru qi_lru;
	int qi_dquots;
	struct mutex qi_quotaofflock;
	xfs_filblks_t qi_dqchunklen;
	uint qi_dqperchunk;
	struct xfs_def_quota qi_usr_default;
	struct xfs_def_quota qi_grp_default;
	struct xfs_def_quota qi_prj_default;
	struct shrinker qi_shrinker;
	time64_t qi_expiry_min;
	time64_t qi_expiry_max;
};

struct xfs_dquot_acct {
	struct xfs_dqtrx dqs[6];
};

enum {
	XFS_QM_TRANS_USR = 0,
	XFS_QM_TRANS_GRP = 1,
	XFS_QM_TRANS_PRJ = 2,
	XFS_QM_TRANS_DQTYPES = 3,
};

typedef __be64 xfs_timestamp_t;

struct xfs_dinode {
	__be16 di_magic;
	__be16 di_mode;
	__u8 di_version;
	__u8 di_format;
	__be16 di_onlink;
	__be32 di_uid;
	__be32 di_gid;
	__be32 di_nlink;
	__be16 di_projid_lo;
	__be16 di_projid_hi;
	__u8 di_pad[6];
	__be16 di_flushiter;
	xfs_timestamp_t di_atime;
	xfs_timestamp_t di_mtime;
	xfs_timestamp_t di_ctime;
	__be64 di_size;
	__be64 di_nblocks;
	__be32 di_extsize;
	__be32 di_nextents;
	__be16 di_anextents;
	__u8 di_forkoff;
	__s8 di_aformat;
	__be32 di_dmevmask;
	__be16 di_dmstate;
	__be16 di_flags;
	__be32 di_gen;
	__be32 di_next_unlinked;
	__le32 di_crc;
	__be64 di_changecount;
	__be64 di_lsn;
	__be64 di_flags2;
	__be32 di_cowextsize;
	__u8 di_pad2[12];
	xfs_timestamp_t di_crtime;
	__be64 di_ino;
	uuid_t di_uuid;
};

typedef struct xfs_inobt_rec_incore xfs_inobt_rec_incore_t;

struct xfs_icluster {
	bool deleted;
	xfs_ino_t first_ino;
	uint64_t alloc;
};

struct xfs_ialloc_count_inodes {
	xfs_agino_t count;
	xfs_agino_t freecount;
};

struct xfs_iext_rec {
	uint64_t lo;
	uint64_t hi;
};

struct xfs_iext_leaf {
	struct xfs_iext_rec recs[15];
	struct xfs_iext_leaf *prev;
	struct xfs_iext_leaf *next;
};

enum {
	NODE_SIZE = 256,
	KEYS_PER_NODE = 16,
	RECS_PER_LEAF = 15,
};

struct xfs_iext_node {
	uint64_t keys[16];
	void *ptrs[16];
};

typedef __u32 xfs_dev_t;

typedef struct xfs_dinode xfs_dinode_t;

struct xfs_legacy_timestamp {
	__be32 t_sec;
	__be32 t_nsec;
};

typedef int (*xfs_rmap_query_range_fn)(struct xfs_btree_cur *, const struct xfs_rmap_irec *, void *);

enum xfs_rmap_intent_type {
	XFS_RMAP_MAP = 0,
	XFS_RMAP_MAP_SHARED = 1,
	XFS_RMAP_UNMAP = 2,
	XFS_RMAP_UNMAP_SHARED = 3,
	XFS_RMAP_CONVERT = 4,
	XFS_RMAP_CONVERT_SHARED = 5,
	XFS_RMAP_ALLOC = 6,
	XFS_RMAP_FREE = 7,
};

struct xfs_rmap_intent {
	struct list_head ri_list;
	enum xfs_rmap_intent_type ri_type;
	uint64_t ri_owner;
	int ri_whichfork;
	struct xfs_bmbt_irec ri_bmap;
};

struct xfs_find_left_neighbor_info {
	struct xfs_rmap_irec high;
	struct xfs_rmap_irec *irec;
	int *stat;
};

struct xfs_rmap_query_range_info {
	xfs_rmap_query_range_fn fn;
	void *priv;
};

struct xfs_rmap_key_state {
	uint64_t owner;
	uint64_t offset;
	unsigned int flags;
};

enum xfs_refcount_intent_type {
	XFS_REFCOUNT_INCREASE = 1,
	XFS_REFCOUNT_DECREASE = 2,
	XFS_REFCOUNT_ALLOC_COW = 3,
	XFS_REFCOUNT_FREE_COW = 4,
};

struct xfs_refcount_intent {
	struct list_head ri_list;
	enum xfs_refcount_intent_type ri_type;
	xfs_fsblock_t ri_startblock;
	xfs_extlen_t ri_blockcount;
};

enum xfs_refc_adjust_op {
	XFS_REFCOUNT_ADJUST_INCREASE = 1,
	XFS_REFCOUNT_ADJUST_DECREASE = 4294967295,
	XFS_REFCOUNT_ADJUST_COW_ALLOC = 0,
	XFS_REFCOUNT_ADJUST_COW_FREE = 4294967295,
};

struct xfs_refcount_recovery {
	struct list_head rr_list;
	struct xfs_refcount_irec rr_rrec;
};

struct xfs_fsop_geom {
	__u32 blocksize;
	__u32 rtextsize;
	__u32 agblocks;
	__u32 agcount;
	__u32 logblocks;
	__u32 sectsize;
	__u32 inodesize;
	__u32 imaxpct;
	__u64 datablocks;
	__u64 rtblocks;
	__u64 rtextents;
	__u64 logstart;
	unsigned char uuid[16];
	__u32 sunit;
	__u32 swidth;
	__s32 version;
	__u32 flags;
	__u32 logsectsize;
	__u32 rtsectsize;
	__u32 dirblocksize;
	__u32 logsunit;
	uint32_t sick;
	uint32_t checked;
	__u64 reserved[17];
};

typedef struct xfs_dsb xfs_dsb_t;

struct xfs_dsymlink_hdr {
	__be32 sl_magic;
	__be32 sl_offset;
	__be32 sl_bytes;
	__be32 sl_crc;
	uuid_t sl_uuid;
	__be64 sl_owner;
	__be64 sl_blkno;
	__be64 sl_lsn;
};

struct xfs_ail {
	struct xfs_mount *ail_mount;
	struct task_struct *ail_task;
	struct list_head ail_head;
	xfs_lsn_t ail_target;
	xfs_lsn_t ail_target_prev;
	struct list_head ail_cursors;
	spinlock_t ail_lock;
	xfs_lsn_t ail_last_pushed_lsn;
	int ail_log_flush;
	struct list_head ail_buf_list;
	wait_queue_head_t ail_empty;
};

typedef int32_t xfs_suminfo_t;

typedef uint32_t xfs_rtword_t;

typedef int64_t xfs_srtblock_t;

struct xfs_rtalloc_rec {
	xfs_rtblock_t ar_startext;
	xfs_rtblock_t ar_extcount;
};

typedef int (*xfs_rtalloc_query_range_fn)(struct xfs_trans *, const struct xfs_rtalloc_rec *, void *);

struct xfs_writepage_ctx {
	struct iomap_writepage_ctx ctx;
	unsigned int data_seq;
	unsigned int cow_seq;
};

struct xfs_attr_sf_sort {
	uint8_t entno;
	uint8_t namelen;
	uint8_t valuelen;
	uint8_t flags;
	xfs_dahash_t hash;
	unsigned char *name;
};

typedef struct xfs_attr_sf_sort xfs_attr_sf_sort_t;

typedef uint64_t xfs_ufsize_t;

struct getbmapx {
	__s64 bmv_offset;
	__s64 bmv_block;
	__s64 bmv_length;
	__s32 bmv_count;
	__s32 bmv_entries;
	__s32 bmv_iflags;
	__s32 bmv_oflags;
	__s32 bmv_unused1;
	__s32 bmv_unused2;
};

struct xfs_bstime {
	__kernel_long_t tv_sec;
	__s32 tv_nsec;
};

typedef struct xfs_bstime xfs_bstime_t;

struct xfs_bstat {
	__u64 bs_ino;
	__u16 bs_mode;
	__u16 bs_nlink;
	__u32 bs_uid;
	__u32 bs_gid;
	__u32 bs_rdev;
	__s32 bs_blksize;
	__s64 bs_size;
	xfs_bstime_t bs_atime;
	xfs_bstime_t bs_mtime;
	xfs_bstime_t bs_ctime;
	int64_t bs_blocks;
	__u32 bs_xflags;
	__s32 bs_extsize;
	__s32 bs_extents;
	__u32 bs_gen;
	__u16 bs_projid_lo;
	__u16 bs_forkoff;
	__u16 bs_projid_hi;
	uint16_t bs_sick;
	uint16_t bs_checked;
	unsigned char bs_pad[2];
	__u32 bs_cowextsize;
	__u32 bs_dmevmask;
	__u16 bs_dmstate;
	__u16 bs_aextents;
};

struct xfs_swapext {
	int64_t sx_version;
	int64_t sx_fdtarget;
	int64_t sx_fdtmp;
	xfs_off_t sx_offset;
	xfs_off_t sx_length;
	char sx_pad[16];
	struct xfs_bstat sx_stat;
};

struct kgetbmap {
	__s64 bmv_offset;
	__s64 bmv_block;
	__s64 bmv_length;
	__s32 bmv_oflags;
};

struct xfs_fid64 {
	u64 ino;
	u32 gen;
	u64 parent_ino;
	u32 parent_gen;
} __attribute__((packed));

struct xfs_extent_busy {
	struct rb_node rb_node;
	struct list_head list;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	xfs_extlen_t length;
	unsigned int flags;
};

enum layout_break_reason {
	BREAK_WRITE = 0,
	BREAK_UNMAP = 1,
};

enum xfs_prealloc_flags {
	XFS_PREALLOC_SET = 2,
	XFS_PREALLOC_CLEAR = 4,
	XFS_PREALLOC_SYNC = 8,
	XFS_PREALLOC_INVISIBLE = 16,
};

struct xfs_mru_cache_elem {
	struct list_head list_node;
	long unsigned int key;
};

typedef void (*xfs_mru_cache_free_func_t)(void *, struct xfs_mru_cache_elem *);

struct xfs_fstrm_item {
	struct xfs_mru_cache_elem mru;
	xfs_agnumber_t ag;
};

enum xfs_fstrm_alloc {
	XFS_PICK_USERDATA = 1,
	XFS_PICK_LOWSPACE = 2,
};

struct xfs_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct xfs_fsmap fmh_keys[2];
};

struct xfs_getfsmap_info {
	struct xfs_fsmap_head *head;
	struct fsmap *fsmap_recs;
	struct xfs_buf *agf_bp;
	struct xfs_perag *pag;
	xfs_daddr_t next_daddr;
	u64 missing_owner;
	u32 dev;
	struct xfs_rmap_irec low;
	struct xfs_rmap_irec high;
	bool last;
};

struct xfs_getfsmap_dev {
	u32 dev;
	int (*fn)(struct xfs_trans *, const struct xfs_fsmap *, struct xfs_getfsmap_info *);
};

struct xfs_fsop_counts {
	__u64 freedata;
	__u64 freertx;
	__u64 freeino;
	__u64 allocino;
};

typedef struct xfs_fsop_counts xfs_fsop_counts_t;

struct xfs_fsop_resblks {
	__u64 resblks;
	__u64 resblks_avail;
};

typedef struct xfs_fsop_resblks xfs_fsop_resblks_t;

struct xfs_growfs_data {
	__u64 newblocks;
	__u32 imaxpct;
};

struct xfs_growfs_log {
	__u32 newblocks;
	__u32 isint;
};

struct xfs_globals {
	int log_recovery_delay;
	int mount_delay;
	bool bug_on_assert;
	bool always_cow;
};

struct xfs_bulkstat {
	uint64_t bs_ino;
	uint64_t bs_size;
	uint64_t bs_blocks;
	uint64_t bs_xflags;
	int64_t bs_atime;
	int64_t bs_mtime;
	int64_t bs_ctime;
	int64_t bs_btime;
	uint32_t bs_gen;
	uint32_t bs_uid;
	uint32_t bs_gid;
	uint32_t bs_projectid;
	uint32_t bs_atime_nsec;
	uint32_t bs_mtime_nsec;
	uint32_t bs_ctime_nsec;
	uint32_t bs_btime_nsec;
	uint32_t bs_blksize;
	uint32_t bs_rdev;
	uint32_t bs_cowextsize_blks;
	uint32_t bs_extsize_blks;
	uint32_t bs_nlink;
	uint32_t bs_extents;
	uint32_t bs_aextents;
	uint16_t bs_version;
	uint16_t bs_forkoff;
	uint16_t bs_sick;
	uint16_t bs_checked;
	uint16_t bs_mode;
	uint16_t bs_pad2;
	uint64_t bs_pad[7];
};

struct ioctl_sick_map {
	unsigned int sick_mask;
	unsigned int ioctl_mask;
};

struct xfs_inodegc {
	struct llist_head list;
	struct work_struct work;
	unsigned int items;
	unsigned int shrinker_hits;
};

enum xfs_icwalk_goal {
	XFS_ICWALK_BLOCKGC = 1,
	XFS_ICWALK_RECLAIM = 0,
};

struct dioattr {
	__u32 d_mem;
	__u32 d_miniosz;
	__u32 d_maxiosz;
};

struct xfs_flock64 {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

typedef struct xfs_flock64 xfs_flock64_t;

struct xfs_growfs_rt {
	__u64 newblocks;
	__u32 extsize;
};

typedef struct xfs_growfs_rt xfs_growfs_rt_t;

struct xfs_fsop_bulkreq {
	__u64 *lastip;
	__s32 icount;
	void *ubuffer;
	__s32 *ocount;
};

struct xfs_inogrp {
	__u64 xi_startino;
	__s32 xi_alloccount;
	__u64 xi_allocmask;
};

struct xfs_inumbers {
	uint64_t xi_startino;
	uint64_t xi_allocmask;
	uint8_t xi_alloccount;
	uint8_t xi_version;
	uint8_t xi_padding[6];
};

struct xfs_bulk_ireq {
	uint64_t ino;
	uint32_t flags;
	uint32_t icount;
	uint32_t ocount;
	uint32_t agno;
	uint64_t reserved[5];
};

struct xfs_bulkstat_req {
	struct xfs_bulk_ireq hdr;
	struct xfs_bulkstat bulkstat[0];
};

struct xfs_inumbers_req {
	struct xfs_bulk_ireq hdr;
	struct xfs_inumbers inumbers[0];
};

struct xfs_error_injection {
	__s32 fd;
	__s32 errtag;
};

typedef struct xfs_error_injection xfs_error_injection_t;

struct xfs_fs_eofblocks {
	__u32 eof_version;
	__u32 eof_flags;
	uid_t eof_uid;
	gid_t eof_gid;
	prid_t eof_prid;
	__u32 pad32;
	__u64 eof_min_file_size;
	__u64 pad64[12];
};

struct xfs_fsop_handlereq {
	__u32 fd;
	void *path;
	__u32 oflags;
	void *ihandle;
	__u32 ihandlen;
	void *ohandle;
	__u32 *ohandlen;
};

typedef struct xfs_fsop_handlereq xfs_fsop_handlereq_t;

struct xfs_attrlist_cursor {
	__u32 opaque[4];
};

struct xfs_attrlist {
	__s32 al_count;
	__s32 al_more;
	__s32 al_offset[1];
};

struct xfs_attrlist_ent {
	__u32 a_valuelen;
	char a_name[1];
};

struct xfs_fsop_attrlist_handlereq {
	struct xfs_fsop_handlereq hreq;
	struct xfs_attrlist_cursor pos;
	__u32 flags;
	__u32 buflen;
	void *buffer;
};

struct xfs_attr_multiop {
	__u32 am_opcode;
	__s32 am_error;
	void *am_attrname;
	void *am_attrvalue;
	__u32 am_length;
	__u32 am_flags;
};

typedef struct xfs_attr_multiop xfs_attr_multiop_t;

struct xfs_fsop_attrmulti_handlereq {
	struct xfs_fsop_handlereq hreq;
	__u32 opcount;
	struct xfs_attr_multiop *ops;
};

typedef struct xfs_fsop_attrmulti_handlereq xfs_fsop_attrmulti_handlereq_t;

typedef struct {
	__u32 val[2];
} xfs_fsid_t;

struct xfs_fid {
	__u16 fid_len;
	__u16 fid_pad;
	__u32 fid_gen;
	__u64 fid_ino;
};

typedef struct xfs_fid xfs_fid_t;

struct xfs_handle {
	union {
		__s64 align;
		xfs_fsid_t _ha_fsid;
	} ha_u;
	xfs_fid_t ha_fid;
};

typedef struct xfs_handle xfs_handle_t;

typedef struct xfs_swapext xfs_swapext_t;

struct xfs_scrub_metadata {
	__u32 sm_type;
	__u32 sm_flags;
	__u64 sm_ino;
	__u32 sm_gen;
	__u32 sm_agno;
	__u64 sm_reserved[5];
};

struct xfs_ibulk {
	struct xfs_mount *mp;
	struct user_namespace *mnt_userns;
	void *ubuffer;
	xfs_ino_t startino;
	unsigned int icount;
	unsigned int ocount;
	unsigned int flags;
};

typedef int (*bulkstat_one_fmt_pf)(struct xfs_ibulk *, const struct xfs_bulkstat *);

typedef int (*inumbers_fmt_pf)(struct xfs_ibulk *, const struct xfs_inumbers *);

struct xfs_iunlink {
	struct rhash_head iu_rhash_head;
	xfs_agino_t iu_agino;
	xfs_agino_t iu_next_unlinked;
};

typedef int (*xfs_iwalk_fn)(struct xfs_mount *, struct xfs_trans *, xfs_ino_t, void *);

typedef int (*xfs_inobt_walk_fn)(struct xfs_mount *, struct xfs_trans *, xfs_agnumber_t, const struct xfs_inobt_rec_incore *, void *);

struct xfs_bstat_chunk {
	bulkstat_one_fmt_pf formatter;
	struct xfs_ibulk *breq;
	struct xfs_bulkstat *buf;
};

struct xfs_inumbers_chunk {
	inumbers_fmt_pf formatter;
	struct xfs_ibulk *breq;
};

struct xfs_pwork;

typedef int (*xfs_pwork_work_fn)(struct xfs_mount *, struct xfs_pwork *);

struct xfs_pwork_ctl;

struct xfs_pwork {
	struct work_struct work;
	struct xfs_pwork_ctl *pctl;
};

struct xfs_pwork_ctl {
	struct workqueue_struct *wq;
	struct xfs_mount *mp;
	xfs_pwork_work_fn work_fn;
	struct wait_queue_head poll_wait;
	atomic_t nr_work;
	int error;
};

struct xfs_iwalk_ag {
	struct xfs_pwork pwork;
	struct xfs_mount *mp;
	struct xfs_trans *tp;
	struct xfs_perag *pag;
	xfs_ino_t startino;
	xfs_ino_t lastino;
	struct xfs_inobt_rec_incore *recs;
	unsigned int sz_recs;
	unsigned int nr_recs;
	xfs_iwalk_fn iwalk_fn;
	xfs_inobt_walk_fn inobt_walk_fn;
	void *data;
	unsigned int trim_start: 1;
	unsigned int skip_empty: 1;
	unsigned int drop_trans: 1;
};

typedef struct xfs_sb xfs_sb_t;

struct xfs_mru_cache {
	struct xarray store;
	struct list_head *lists;
	struct list_head reap_list;
	spinlock_t lock;
	unsigned int grp_count;
	unsigned int grp_time;
	unsigned int lru_grp;
	long unsigned int time_zero;
	xfs_mru_cache_free_func_t free_func;
	struct delayed_work work;
	unsigned int queued;
	void *data;
};

struct xstats_entry {
	char *desc;
	int endpoint;
};

enum xfs_dax_mode {
	XFS_DAX_INODE = 0,
	XFS_DAX_ALWAYS = 1,
	XFS_DAX_NEVER = 2,
};

enum {
	Opt_logbufs = 0,
	Opt_logbsize = 1,
	Opt_logdev = 2,
	Opt_rtdev = 3,
	Opt_wsync = 4,
	Opt_noalign = 5,
	Opt_swalloc = 6,
	Opt_sunit = 7,
	Opt_swidth = 8,
	Opt_nouuid = 9,
	Opt_grpid___2 = 10,
	Opt_nogrpid___2 = 11,
	Opt_bsdgroups = 12,
	Opt_sysvgroups = 13,
	Opt_allocsize = 14,
	Opt_norecovery = 15,
	Opt_inode64___2 = 16,
	Opt_inode32___2 = 17,
	Opt_ikeep = 18,
	Opt_noikeep = 19,
	Opt_largeio = 20,
	Opt_nolargeio = 21,
	Opt_attr2 = 22,
	Opt_noattr2 = 23,
	Opt_filestreams = 24,
	Opt_quota___2 = 25,
	Opt_noquota___2 = 26,
	Opt_usrquota___2 = 27,
	Opt_grpquota___2 = 28,
	Opt_prjquota___2 = 29,
	Opt_uquota = 30,
	Opt_gquota = 31,
	Opt_pquota = 32,
	Opt_uqnoenforce = 33,
	Opt_gqnoenforce = 34,
	Opt_pqnoenforce = 35,
	Opt_qnoenforce = 36,
	Opt_discard___3 = 37,
	Opt_nodiscard___2 = 38,
	Opt_dax___2 = 39,
	Opt_dax_enum = 40,
};

struct proc_xfs_info {
	uint64_t flag;
	char *str;
};

struct xfs_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, char *);
	ssize_t (*store)(struct kobject *, const char *, size_t);
};

struct xfs_error_init {
	char *name;
	int max_retries;
	int retry_timeout;
};

struct xfs_ail_cursor {
	struct list_head list;
	struct xfs_log_item *item;
};

struct xfs_unmount_log_format {
	uint16_t magic;
	uint16_t pad1;
	uint32_t pad2;
};

struct xlog_op_header {
	__be32 oh_tid;
	__be32 oh_len;
	__u8 oh_clientid;
	__u8 oh_flags;
	__u16 oh_res2;
};

typedef struct xlog_op_header xlog_op_header_t;

typedef struct xlog_ticket xlog_ticket_t;

enum _record_type {
	_START_RECORD = 0,
	_COMMIT_RECORD = 1,
};

struct xfs_map_extent {
	uint64_t me_owner;
	uint64_t me_startblock;
	uint64_t me_startoff;
	uint32_t me_len;
	uint32_t me_flags;
};

struct xfs_bui_log_format {
	uint16_t bui_type;
	uint16_t bui_size;
	uint32_t bui_nextents;
	uint64_t bui_id;
	struct xfs_map_extent bui_extents[0];
};

struct xfs_bud_log_format {
	uint16_t bud_type;
	uint16_t bud_size;
	uint32_t __pad;
	uint64_t bud_bui_id;
};

struct xfs_bui_log_item {
	struct xfs_log_item bui_item;
	atomic_t bui_refcount;
	atomic_t bui_next_extent;
	struct xfs_bui_log_format bui_format;
};

struct xfs_bud_log_item {
	struct xfs_log_item bud_item;
	struct xfs_bui_log_item *bud_buip;
	struct xfs_bud_log_format bud_format;
};

struct xfs_buf_cancel {
	xfs_daddr_t bc_blkno;
	uint bc_len;
	int bc_refcount;
	struct list_head bc_list;
};

struct xfs_dq_logformat {
	uint16_t qlf_type;
	uint16_t qlf_size;
	xfs_dqid_t qlf_id;
	int64_t qlf_blkno;
	int32_t qlf_len;
	uint32_t qlf_boffset;
};

struct xfs_qoff_logformat {
	short unsigned int qf_type;
	short unsigned int qf_size;
	unsigned int qf_flags;
	char qf_pad[12];
};

typedef struct xfs_log_iovec xfs_log_iovec_t;

struct xfs_extent {
	xfs_fsblock_t ext_start;
	xfs_extlen_t ext_len;
};

typedef struct xfs_extent xfs_extent_t;

struct xfs_extent_32 {
	uint64_t ext_start;
	uint32_t ext_len;
} __attribute__((packed));

typedef struct xfs_extent_32 xfs_extent_32_t;

struct xfs_extent_64 {
	uint64_t ext_start;
	uint32_t ext_len;
	uint32_t ext_pad;
};

typedef struct xfs_extent_64 xfs_extent_64_t;

struct xfs_efi_log_format {
	uint16_t efi_type;
	uint16_t efi_size;
	uint32_t efi_nextents;
	uint64_t efi_id;
	xfs_extent_t efi_extents[1];
};

typedef struct xfs_efi_log_format xfs_efi_log_format_t;

struct xfs_efi_log_format_32 {
	uint16_t efi_type;
	uint16_t efi_size;
	uint32_t efi_nextents;
	uint64_t efi_id;
	xfs_extent_32_t efi_extents[1];
} __attribute__((packed));

typedef struct xfs_efi_log_format_32 xfs_efi_log_format_32_t;

struct xfs_efi_log_format_64 {
	uint16_t efi_type;
	uint16_t efi_size;
	uint32_t efi_nextents;
	uint64_t efi_id;
	xfs_extent_64_t efi_extents[1];
};

typedef struct xfs_efi_log_format_64 xfs_efi_log_format_64_t;

struct xfs_efd_log_format {
	uint16_t efd_type;
	uint16_t efd_size;
	uint32_t efd_nextents;
	uint64_t efd_efi_id;
	xfs_extent_t efd_extents[1];
};

typedef struct xfs_efd_log_format xfs_efd_log_format_t;

struct xfs_efi_log_item {
	struct xfs_log_item efi_item;
	atomic_t efi_refcount;
	atomic_t efi_next_extent;
	xfs_efi_log_format_t efi_format;
};

struct xfs_efd_log_item {
	struct xfs_log_item efd_item;
	struct xfs_efi_log_item *efd_efip;
	uint efd_next_extent;
	xfs_efd_log_format_t efd_format;
};

struct xfs_icreate_item {
	struct xfs_log_item ic_item;
	struct xfs_icreate_log ic_format;
};

struct xfs_inode_log_format_32 {
	uint16_t ilf_type;
	uint16_t ilf_size;
	uint32_t ilf_fields;
	uint16_t ilf_asize;
	uint16_t ilf_dsize;
	uint64_t ilf_ino;
	union {
		uint32_t ilfu_rdev;
		uint8_t __pad[16];
	} ilf_u;
	int64_t ilf_blkno;
	int32_t ilf_len;
	int32_t ilf_boffset;
} __attribute__((packed));

typedef uint64_t xfs_log_timestamp_t;

struct xfs_log_legacy_timestamp {
	int32_t t_sec;
	int32_t t_nsec;
};

struct xfs_log_dinode {
	uint16_t di_magic;
	uint16_t di_mode;
	int8_t di_version;
	int8_t di_format;
	uint8_t di_pad3[2];
	uint32_t di_uid;
	uint32_t di_gid;
	uint32_t di_nlink;
	uint16_t di_projid_lo;
	uint16_t di_projid_hi;
	uint8_t di_pad[6];
	uint16_t di_flushiter;
	xfs_log_timestamp_t di_atime;
	xfs_log_timestamp_t di_mtime;
	xfs_log_timestamp_t di_ctime;
	xfs_fsize_t di_size;
	xfs_rfsblock_t di_nblocks;
	xfs_extlen_t di_extsize;
	xfs_extnum_t di_nextents;
	xfs_aextnum_t di_anextents;
	uint8_t di_forkoff;
	int8_t di_aformat;
	uint32_t di_dmevmask;
	uint16_t di_dmstate;
	uint16_t di_flags;
	uint32_t di_gen;
	xfs_agino_t di_next_unlinked;
	uint32_t di_crc;
	uint64_t di_changecount;
	xfs_lsn_t di_lsn;
	uint64_t di_flags2;
	uint32_t di_cowextsize;
	uint8_t di_pad2[12];
	xfs_log_timestamp_t di_crtime;
	xfs_ino_t di_ino;
	uuid_t di_uuid;
};

struct xfs_phys_extent {
	uint64_t pe_startblock;
	uint32_t pe_len;
	uint32_t pe_flags;
};

struct xfs_cui_log_format {
	uint16_t cui_type;
	uint16_t cui_size;
	uint32_t cui_nextents;
	uint64_t cui_id;
	struct xfs_phys_extent cui_extents[0];
};

struct xfs_cud_log_format {
	uint16_t cud_type;
	uint16_t cud_size;
	uint32_t __pad;
	uint64_t cud_cui_id;
};

struct xfs_cui_log_item {
	struct xfs_log_item cui_item;
	atomic_t cui_refcount;
	atomic_t cui_next_extent;
	struct xfs_cui_log_format cui_format;
};

struct xfs_cud_log_item {
	struct xfs_log_item cud_item;
	struct xfs_cui_log_item *cud_cuip;
	struct xfs_cud_log_format cud_format;
};

struct xfs_rui_log_format {
	uint16_t rui_type;
	uint16_t rui_size;
	uint32_t rui_nextents;
	uint64_t rui_id;
	struct xfs_map_extent rui_extents[0];
};

struct xfs_rud_log_format {
	uint16_t rud_type;
	uint16_t rud_size;
	uint32_t __pad;
	uint64_t rud_rui_id;
};

struct xfs_rui_log_item {
	struct xfs_log_item rui_item;
	atomic_t rui_refcount;
	atomic_t rui_next_extent;
	struct xfs_rui_log_format rui_format;
};

struct xfs_rud_log_item {
	struct xfs_log_item rud_item;
	struct xfs_rui_log_item *rud_ruip;
	struct xfs_rud_log_format rud_format;
};

typedef struct xfs_agi xfs_agi_t;

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum {
	Opt_uid___6 = 0,
	Opt_gid___7 = 1,
	Opt_mode___5 = 2,
	Opt_err___6 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

struct btrfs_ioctl_vol_args {
	__s64 fd;
	char name[4088];
};

struct btrfs_qgroup_limit {
	__u64 flags;
	__u64 max_rfer;
	__u64 max_excl;
	__u64 rsv_rfer;
	__u64 rsv_excl;
};

struct btrfs_qgroup_inherit {
	__u64 flags;
	__u64 num_qgroups;
	__u64 num_ref_copies;
	__u64 num_excl_copies;
	struct btrfs_qgroup_limit lim;
	__u64 qgroups[0];
};

struct btrfs_scrub_progress {
	__u64 data_extents_scrubbed;
	__u64 tree_extents_scrubbed;
	__u64 data_bytes_scrubbed;
	__u64 tree_bytes_scrubbed;
	__u64 read_errors;
	__u64 csum_errors;
	__u64 verify_errors;
	__u64 no_csum;
	__u64 csum_discards;
	__u64 super_errors;
	__u64 malloc_errors;
	__u64 uncorrectable_errors;
	__u64 corrected_errors;
	__u64 last_physical;
	__u64 unverified_errors;
};

struct btrfs_balance_args {
	__u64 profiles;
	union {
		__u64 usage;
		struct {
			__u32 usage_min;
			__u32 usage_max;
		};
	};
	__u64 devid;
	__u64 pstart;
	__u64 pend;
	__u64 vstart;
	__u64 vend;
	__u64 target;
	__u64 flags;
	union {
		__u64 limit;
		struct {
			__u32 limit_min;
			__u32 limit_max;
		};
	};
	__u32 stripes_min;
	__u32 stripes_max;
	__u64 unused[6];
};

struct btrfs_balance_progress {
	__u64 expected;
	__u64 considered;
	__u64 completed;
};

enum btrfs_dev_stat_values {
	BTRFS_DEV_STAT_WRITE_ERRS = 0,
	BTRFS_DEV_STAT_READ_ERRS = 1,
	BTRFS_DEV_STAT_FLUSH_ERRS = 2,
	BTRFS_DEV_STAT_CORRUPTION_ERRS = 3,
	BTRFS_DEV_STAT_GENERATION_ERRS = 4,
	BTRFS_DEV_STAT_VALUES_MAX = 5,
};

struct btrfs_disk_key {
	__le64 objectid;
	__u8 type;
	__le64 offset;
} __attribute__((packed));

struct btrfs_key {
	__u64 objectid;
	__u8 type;
	__u64 offset;
} __attribute__((packed));

struct btrfs_dev_item {
	__le64 devid;
	__le64 total_bytes;
	__le64 bytes_used;
	__le32 io_align;
	__le32 io_width;
	__le32 sector_size;
	__le64 type;
	__le64 generation;
	__le64 start_offset;
	__le32 dev_group;
	__u8 seek_speed;
	__u8 bandwidth;
	__u8 uuid[16];
	__u8 fsid[16];
} __attribute__((packed));

struct btrfs_inode_ref {
	__le64 index;
	__le16 name_len;
} __attribute__((packed));

struct btrfs_timespec {
	__le64 sec;
	__le32 nsec;
} __attribute__((packed));

struct btrfs_inode_item {
	__le64 generation;
	__le64 transid;
	__le64 size;
	__le64 nbytes;
	__le64 block_group;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le64 rdev;
	__le64 flags;
	__le64 sequence;
	__le64 reserved[4];
	struct btrfs_timespec atime;
	struct btrfs_timespec ctime;
	struct btrfs_timespec mtime;
	struct btrfs_timespec otime;
};

struct btrfs_dir_item {
	struct btrfs_disk_key location;
	__le64 transid;
	__le16 data_len;
	__le16 name_len;
	__u8 type;
} __attribute__((packed));

struct btrfs_root_item {
	struct btrfs_inode_item inode;
	__le64 generation;
	__le64 root_dirid;
	__le64 bytenr;
	__le64 byte_limit;
	__le64 bytes_used;
	__le64 last_snapshot;
	__le64 flags;
	__le32 refs;
	struct btrfs_disk_key drop_progress;
	__u8 drop_level;
	__u8 level;
	__le64 generation_v2;
	__u8 uuid[16];
	__u8 parent_uuid[16];
	__u8 received_uuid[16];
	__le64 ctransid;
	__le64 otransid;
	__le64 stransid;
	__le64 rtransid;
	struct btrfs_timespec ctime;
	struct btrfs_timespec otime;
	struct btrfs_timespec stime;
	struct btrfs_timespec rtime;
	__le64 reserved[8];
} __attribute__((packed));

struct btrfs_root_ref {
	__le64 dirid;
	__le64 sequence;
	__le16 name_len;
} __attribute__((packed));

enum {
	BTRFS_FILE_EXTENT_INLINE = 0,
	BTRFS_FILE_EXTENT_REG = 1,
	BTRFS_FILE_EXTENT_PREALLOC = 2,
	BTRFS_NR_FILE_EXTENT_TYPES = 3,
};

struct btrfs_file_extent_item {
	__le64 generation;
	__le64 ram_bytes;
	__u8 compression;
	__u8 encryption;
	__le16 other_encoding;
	__u8 type;
	__le64 disk_bytenr;
	__le64 disk_num_bytes;
	__le64 offset;
	__le64 num_bytes;
} __attribute__((packed));

enum btrfs_raid_types {
	BTRFS_RAID_RAID10 = 0,
	BTRFS_RAID_RAID1 = 1,
	BTRFS_RAID_DUP = 2,
	BTRFS_RAID_RAID0 = 3,
	BTRFS_RAID_SINGLE = 4,
	BTRFS_RAID_RAID5 = 5,
	BTRFS_RAID_RAID6 = 6,
	BTRFS_RAID_RAID1C3 = 7,
	BTRFS_RAID_RAID1C4 = 8,
	BTRFS_NR_RAID_TYPES = 9,
};

enum {
	IO_TREE_FS_PINNED_EXTENTS = 0,
	IO_TREE_FS_EXCLUDED_EXTENTS = 1,
	IO_TREE_BTREE_INODE_IO = 2,
	IO_TREE_INODE_IO = 3,
	IO_TREE_INODE_IO_FAILURE = 4,
	IO_TREE_RELOC_BLOCKS = 5,
	IO_TREE_TRANS_DIRTY_PAGES = 6,
	IO_TREE_ROOT_DIRTY_LOG_PAGES = 7,
	IO_TREE_INODE_FILE_EXTENT = 8,
	IO_TREE_LOG_CSUM_RANGE = 9,
	IO_TREE_SELFTEST = 10,
	IO_TREE_DEVICE_ALLOC_STATE = 11,
};

struct btrfs_fs_info;

struct extent_io_tree {
	struct rb_root state;
	struct btrfs_fs_info *fs_info;
	void *private_data;
	u64 dirty_bytes;
	bool track_uptodate;
	u8 owner;
	spinlock_t lock;
};

struct extent_map_tree {
	struct rb_root_cached map;
	struct list_head modified_extents;
	rwlock_t lock;
};

struct btrfs_space_info;

struct btrfs_block_rsv {
	u64 size;
	u64 reserved;
	struct btrfs_space_info *space_info;
	spinlock_t lock;
	short unsigned int full;
	short unsigned int type;
	short unsigned int failfast;
	u64 qgroup_rsv_size;
	u64 qgroup_rsv_reserved;
};

struct btrfs_block_group;

struct btrfs_free_cluster {
	spinlock_t lock;
	spinlock_t refill_lock;
	struct rb_root root;
	u64 max_size;
	u64 window_start;
	bool fragmented;
	struct btrfs_block_group *block_group;
	struct list_head block_group_list;
};

struct btrfs_discard_ctl {
	struct workqueue_struct *discard_workers;
	struct delayed_work work;
	spinlock_t lock;
	struct btrfs_block_group *block_group;
	struct list_head discard_list[3];
	u64 prev_discard;
	u64 prev_discard_time;
	atomic_t discardable_extents;
	atomic64_t discardable_bytes;
	u64 max_discard_size;
	u64 delay_ms;
	u32 iops_limit;
	u32 kbps_limit;
	u64 discard_extent_bytes;
	u64 discard_bitmap_bytes;
	atomic64_t discard_bytes_saved;
};

struct btrfs_work;

typedef void (*btrfs_func_t)(struct btrfs_work *);

struct __btrfs_workqueue;

struct btrfs_work {
	btrfs_func_t func;
	btrfs_func_t ordered_func;
	btrfs_func_t ordered_free;
	struct work_struct normal_work;
	struct list_head ordered_list;
	struct __btrfs_workqueue *wq;
	long unsigned int flags;
};

struct btrfs_device;

struct btrfs_dev_replace {
	u64 replace_state;
	time64_t time_started;
	time64_t time_stopped;
	atomic64_t num_write_errors;
	atomic64_t num_uncorrectable_read_errors;
	u64 cursor_left;
	u64 committed_cursor_left;
	u64 cursor_left_last_write_of_item;
	u64 cursor_right;
	u64 cont_reading_from_srcdev_mode;
	int is_valid;
	int item_needs_writeback;
	struct btrfs_device *srcdev;
	struct btrfs_device *tgtdev;
	struct mutex lock_finishing_cancel_unmount;
	struct rw_semaphore rwsem;
	struct btrfs_scrub_progress scrub_progress;
	struct percpu_counter bio_counter;
	wait_queue_head_t replace_wait;
};

enum btrfs_exclusive_operation {
	BTRFS_EXCLOP_NONE = 0,
	BTRFS_EXCLOP_BALANCE = 1,
	BTRFS_EXCLOP_DEV_ADD = 2,
	BTRFS_EXCLOP_DEV_REMOVE = 3,
	BTRFS_EXCLOP_DEV_REPLACE = 4,
	BTRFS_EXCLOP_RESIZE = 5,
	BTRFS_EXCLOP_SWAP_ACTIVATE = 6,
};

struct btrfs_root;

struct btrfs_transaction;

struct btrfs_super_block;

struct btrfs_stripe_hash_table;

struct btrfs_workqueue;

struct btrfs_fs_devices;

struct reloc_control;

struct btrfs_balance_control;

struct ulist;

struct btrfs_delayed_root;

struct btrfs_fs_info {
	u8 chunk_tree_uuid[16];
	long unsigned int flags;
	struct btrfs_root *extent_root;
	struct btrfs_root *tree_root;
	struct btrfs_root *chunk_root;
	struct btrfs_root *dev_root;
	struct btrfs_root *fs_root;
	struct btrfs_root *csum_root;
	struct btrfs_root *quota_root;
	struct btrfs_root *uuid_root;
	struct btrfs_root *free_space_root;
	struct btrfs_root *data_reloc_root;
	struct btrfs_root *log_root_tree;
	spinlock_t fs_roots_radix_lock;
	struct xarray fs_roots_radix;
	spinlock_t block_group_cache_lock;
	u64 first_logical_byte;
	struct rb_root block_group_cache_tree;
	atomic64_t free_chunk_space;
	struct extent_io_tree excluded_extents;
	struct extent_map_tree mapping_tree;
	struct btrfs_block_rsv global_block_rsv;
	struct btrfs_block_rsv trans_block_rsv;
	struct btrfs_block_rsv chunk_block_rsv;
	struct btrfs_block_rsv delayed_block_rsv;
	struct btrfs_block_rsv delayed_refs_rsv;
	struct btrfs_block_rsv empty_block_rsv;
	u64 generation;
	u64 last_trans_committed;
	u64 last_reloc_trans;
	u64 avg_delayed_ref_runtime;
	u64 last_trans_log_full_commit;
	long unsigned int mount_opt;
	long unsigned int pending_changes;
	long unsigned int compress_type: 4;
	unsigned int compress_level;
	u32 commit_interval;
	u64 max_inline;
	struct btrfs_transaction *running_transaction;
	wait_queue_head_t transaction_throttle;
	wait_queue_head_t transaction_wait;
	wait_queue_head_t transaction_blocked_wait;
	wait_queue_head_t async_submit_wait;
	spinlock_t super_lock;
	struct btrfs_super_block *super_copy;
	struct btrfs_super_block *super_for_commit;
	struct super_block *sb;
	struct inode *btree_inode;
	struct mutex tree_log_mutex;
	struct mutex transaction_kthread_mutex;
	struct mutex cleaner_mutex;
	struct mutex chunk_mutex;
	struct mutex ro_block_group_mutex;
	struct btrfs_stripe_hash_table *stripe_hash_table;
	struct mutex ordered_operations_mutex;
	struct rw_semaphore commit_root_sem;
	struct rw_semaphore cleanup_work_sem;
	struct rw_semaphore subvol_sem;
	spinlock_t trans_lock;
	struct mutex reloc_mutex;
	struct list_head trans_list;
	struct list_head dead_roots;
	struct list_head caching_block_groups;
	spinlock_t delayed_iput_lock;
	struct list_head delayed_iputs;
	atomic_t nr_delayed_iputs;
	wait_queue_head_t delayed_iputs_wait;
	atomic64_t tree_mod_seq;
	rwlock_t tree_mod_log_lock;
	struct rb_root tree_mod_log;
	struct list_head tree_mod_seq_list;
	atomic_t async_delalloc_pages;
	spinlock_t ordered_root_lock;
	struct list_head ordered_roots;
	struct mutex delalloc_root_mutex;
	spinlock_t delalloc_root_lock;
	struct list_head delalloc_roots;
	struct btrfs_workqueue *workers;
	struct btrfs_workqueue *delalloc_workers;
	struct btrfs_workqueue *flush_workers;
	struct btrfs_workqueue *endio_workers;
	struct btrfs_workqueue *endio_meta_workers;
	struct btrfs_workqueue *endio_raid56_workers;
	struct btrfs_workqueue *rmw_workers;
	struct btrfs_workqueue *endio_meta_write_workers;
	struct btrfs_workqueue *endio_write_workers;
	struct btrfs_workqueue *endio_freespace_worker;
	struct btrfs_workqueue *caching_workers;
	struct btrfs_workqueue *readahead_workers;
	struct btrfs_workqueue *fixup_workers;
	struct btrfs_workqueue *delayed_workers;
	struct task_struct *transaction_kthread;
	struct task_struct *cleaner_kthread;
	u32 thread_pool_size;
	struct kobject *space_info_kobj;
	struct kobject *qgroups_kobj;
	struct percpu_counter dirty_metadata_bytes;
	struct percpu_counter delalloc_bytes;
	struct percpu_counter ordered_bytes;
	s32 dirty_metadata_batch;
	s32 delalloc_batch;
	struct list_head dirty_cowonly_roots;
	struct btrfs_fs_devices *fs_devices;
	struct list_head space_info;
	struct btrfs_space_info *data_sinfo;
	struct reloc_control *reloc_ctl;
	struct btrfs_free_cluster data_alloc_cluster;
	struct btrfs_free_cluster meta_alloc_cluster;
	spinlock_t defrag_inodes_lock;
	struct rb_root defrag_inodes;
	atomic_t defrag_running;
	seqlock_t profiles_lock;
	u64 avail_data_alloc_bits;
	u64 avail_metadata_alloc_bits;
	u64 avail_system_alloc_bits;
	spinlock_t balance_lock;
	struct mutex balance_mutex;
	atomic_t balance_pause_req;
	atomic_t balance_cancel_req;
	struct btrfs_balance_control *balance_ctl;
	wait_queue_head_t balance_wait_q;
	atomic_t reloc_cancel_req;
	u32 data_chunk_allocations;
	u32 metadata_ratio;
	void *bdev_holder;
	struct mutex scrub_lock;
	atomic_t scrubs_running;
	atomic_t scrub_pause_req;
	atomic_t scrubs_paused;
	atomic_t scrub_cancel_req;
	wait_queue_head_t scrub_pause_wait;
	refcount_t scrub_workers_refcnt;
	struct btrfs_workqueue *scrub_workers;
	struct btrfs_workqueue *scrub_wr_completion_workers;
	struct btrfs_workqueue *scrub_parity_workers;
	struct btrfs_discard_ctl discard_ctl;
	u64 qgroup_flags;
	struct rb_root qgroup_tree;
	spinlock_t qgroup_lock;
	struct ulist *qgroup_ulist;
	struct mutex qgroup_ioctl_lock;
	struct list_head dirty_qgroups;
	u64 qgroup_seq;
	struct mutex qgroup_rescan_lock;
	struct btrfs_key qgroup_rescan_progress;
	struct btrfs_workqueue *qgroup_rescan_workers;
	struct completion qgroup_rescan_completion;
	struct btrfs_work qgroup_rescan_work;
	bool qgroup_rescan_running;
	long unsigned int fs_state;
	struct btrfs_delayed_root *delayed_root;
	spinlock_t reada_lock;
	struct xarray reada_tree;
	atomic_t reada_works_cnt;
	spinlock_t buffer_lock;
	struct xarray buffer_radix;
	int backup_root_index;
	struct btrfs_dev_replace dev_replace;
	struct semaphore uuid_tree_rescan_sem;
	struct work_struct async_reclaim_work;
	struct work_struct async_data_reclaim_work;
	struct work_struct preempt_reclaim_work;
	struct work_struct reclaim_bgs_work;
	struct list_head reclaim_bgs;
	int bg_reclaim_threshold;
	spinlock_t unused_bgs_lock;
	struct list_head unused_bgs;
	struct mutex unused_bg_unpin_mutex;
	struct mutex reclaim_bgs_lock;
	u32 nodesize;
	u32 sectorsize;
	u32 sectorsize_bits;
	u32 csum_size;
	u32 csums_per_leaf;
	u32 stripesize;
	u64 max_extent_size;
	spinlock_t swapfile_pins_lock;
	struct rb_root swapfile_pins;
	struct crypto_shash *csum_shash;
	enum btrfs_exclusive_operation exclusive_operation;
	union {
		u64 zone_size;
		u64 zoned;
	};
	u64 max_zone_append_size;
	struct mutex zoned_meta_io_lock;
	spinlock_t treelog_bg_lock;
	u64 treelog_bg;
	spinlock_t relocation_bg_lock;
	u64 data_reloc_bg;
	struct mutex zoned_data_reloc_io_lock;
};

struct io_failure_record;

struct extent_state {
	u64 start;
	u64 end;
	struct rb_node rb_node;
	wait_queue_head_t wq;
	refcount_t refs;
	u32 state;
	struct io_failure_record *failrec;
};

struct io_failure_record {
	struct page *page;
	u64 start;
	u64 len;
	u64 logical;
	long unsigned int bio_flags;
	int this_mirror;
	int failed_mirror;
};

struct ulist {
	long unsigned int nnodes;
	struct list_head nodes;
	struct rb_root root;
};

struct extent_buffer {
	u64 start;
	long unsigned int len;
	long unsigned int bflags;
	struct btrfs_fs_info *fs_info;
	spinlock_t refs_lock;
	atomic_t refs;
	atomic_t io_pages;
	int read_mirror;
	struct callback_head callback_head;
	pid_t lock_owner;
	s8 log_index;
	struct rw_semaphore lock;
	struct page *pages[16];
	struct list_head release_list;
};

struct map_lookup;

struct extent_map {
	struct rb_node rb_node;
	u64 start;
	u64 len;
	u64 mod_start;
	u64 mod_len;
	u64 orig_start;
	u64 orig_block_len;
	u64 ram_bytes;
	u64 block_start;
	u64 block_len;
	u64 generation;
	long unsigned int flags;
	struct map_lookup *map_lookup;
	refcount_t refs;
	unsigned int compress_type;
	struct list_head list;
};

struct btrfs_ordered_inode_tree {
	spinlock_t lock;
	struct rb_root tree;
	struct rb_node *last;
};

struct btrfs_delayed_node;

struct btrfs_inode {
	struct btrfs_root *root;
	struct btrfs_key location;
	spinlock_t lock;
	struct extent_map_tree extent_tree;
	struct extent_io_tree io_tree;
	struct extent_io_tree io_failure_tree;
	struct extent_io_tree file_extent_tree;
	struct mutex log_mutex;
	struct btrfs_ordered_inode_tree ordered_tree;
	struct list_head delalloc_inodes;
	struct rb_node rb_node;
	long unsigned int runtime_flags;
	atomic_t sync_writers;
	u64 generation;
	u64 last_trans;
	u64 logged_trans;
	int last_sub_trans;
	int last_log_commit;
	u64 delalloc_bytes;
	u64 new_delalloc_bytes;
	u64 defrag_bytes;
	u64 disk_i_size;
	u64 index_cnt;
	u64 dir_index;
	u64 last_unlink_trans;
	u64 last_reflink_trans;
	u64 csum_bytes;
	u32 flags;
	u32 ro_flags;
	unsigned int outstanding_extents;
	struct btrfs_block_rsv block_rsv;
	unsigned int prop_compress;
	unsigned int defrag_compress;
	struct btrfs_delayed_node *delayed_node;
	struct timespec64 i_otime;
	struct list_head delayed_iput;
	struct rw_semaphore i_mmap_lock;
	struct inode vfs_inode;
};

enum {
	EXTENT_FLAG_PINNED = 0,
	EXTENT_FLAG_COMPRESSED = 1,
	EXTENT_FLAG_PREALLOC = 2,
	EXTENT_FLAG_LOGGING = 3,
	EXTENT_FLAG_FILLING = 4,
	EXTENT_FLAG_FS_MAPPING = 5,
};

struct btrfs_io_stripe {
	struct btrfs_device *dev;
	u64 physical;
	u64 length;
};

struct map_lookup {
	u64 type;
	int io_align;
	int io_width;
	u64 stripe_len;
	int num_stripes;
	int sub_stripes;
	int verified_stripes;
	struct btrfs_io_stripe stripes[0];
};

struct __btrfs_workqueue {
	struct workqueue_struct *normal_wq;
	struct btrfs_fs_info *fs_info;
	struct list_head ordered_list;
	spinlock_t list_lock;
	atomic_t pending;
	int limit_active;
	int current_active;
	int thresh;
	unsigned int count;
	spinlock_t thres_lock;
};

struct btrfs_space_info {
	spinlock_t lock;
	u64 total_bytes;
	u64 bytes_used;
	u64 bytes_pinned;
	u64 bytes_reserved;
	u64 bytes_may_use;
	u64 bytes_readonly;
	u64 bytes_zone_unusable;
	u64 max_extent_size;
	int clamp;
	unsigned int full: 1;
	unsigned int chunk_alloc: 1;
	unsigned int flush: 1;
	unsigned int force_alloc;
	u64 disk_used;
	u64 disk_total;
	u64 flags;
	struct list_head list;
	struct list_head ro_bgs;
	struct list_head priority_tickets;
	struct list_head tickets;
	u64 reclaim_size;
	u64 tickets_id;
	struct rw_semaphore groups_sem;
	struct list_head block_groups[9];
	struct kobject kobj;
	struct kobject *block_group_kobjs[9];
};

enum btrfs_lock_nesting {
	BTRFS_NESTING_NORMAL = 0,
	BTRFS_NESTING_COW = 1,
	BTRFS_NESTING_LEFT = 2,
	BTRFS_NESTING_RIGHT = 3,
	BTRFS_NESTING_LEFT_COW = 4,
	BTRFS_NESTING_RIGHT_COW = 5,
	BTRFS_NESTING_SPLIT = 6,
	BTRFS_NESTING_NEW_ROOT = 7,
	BTRFS_NESTING_MAX = 8,
};

struct btrfs_drew_lock {
	atomic_t readers;
	struct percpu_counter writers;
	wait_queue_head_t pending_writers;
	wait_queue_head_t pending_readers;
};

enum {
	BTRFS_FS_STATE_ERROR = 0,
	BTRFS_FS_STATE_REMOUNTING = 1,
	BTRFS_FS_STATE_RO = 2,
	BTRFS_FS_STATE_TRANS_ABORTED = 3,
	BTRFS_FS_STATE_DEV_REPLACING = 4,
	BTRFS_FS_STATE_DUMMY_FS_INFO = 5,
	BTRFS_FS_STATE_LOG_CLEANUP_ERROR = 6,
};

struct btrfs_header {
	u8 csum[32];
	u8 fsid[16];
	__le64 bytenr;
	__le64 flags;
	u8 chunk_tree_uuid[16];
	__le64 generation;
	__le64 owner;
	__le32 nritems;
	u8 level;
} __attribute__((packed));

struct btrfs_root_backup {
	__le64 tree_root;
	__le64 tree_root_gen;
	__le64 chunk_root;
	__le64 chunk_root_gen;
	__le64 extent_root;
	__le64 extent_root_gen;
	__le64 fs_root;
	__le64 fs_root_gen;
	__le64 dev_root;
	__le64 dev_root_gen;
	__le64 csum_root;
	__le64 csum_root_gen;
	__le64 total_bytes;
	__le64 bytes_used;
	__le64 num_devices;
	__le64 unused_64[4];
	u8 tree_root_level;
	u8 chunk_root_level;
	u8 extent_root_level;
	u8 fs_root_level;
	u8 dev_root_level;
	u8 csum_root_level;
	u8 unused_8[10];
};

struct btrfs_super_block {
	u8 csum[32];
	u8 fsid[16];
	__le64 bytenr;
	__le64 flags;
	__le64 magic;
	__le64 generation;
	__le64 root;
	__le64 chunk_root;
	__le64 log_root;
	__le64 log_root_transid;
	__le64 total_bytes;
	__le64 bytes_used;
	__le64 root_dir_objectid;
	__le64 num_devices;
	__le32 sectorsize;
	__le32 nodesize;
	__le32 __unused_leafsize;
	__le32 stripesize;
	__le32 sys_chunk_array_size;
	__le64 chunk_root_generation;
	__le64 compat_flags;
	__le64 compat_ro_flags;
	__le64 incompat_flags;
	__le16 csum_type;
	u8 root_level;
	u8 chunk_root_level;
	u8 log_root_level;
	struct btrfs_dev_item dev_item;
	char label[256];
	__le64 cache_generation;
	__le64 uuid_tree_generation;
	u8 metadata_uuid[16];
	__le64 reserved[28];
	u8 sys_chunk_array[2048];
	struct btrfs_root_backup super_roots[4];
} __attribute__((packed));

struct btrfs_item {
	struct btrfs_disk_key key;
	__le32 offset;
	__le32 size;
} __attribute__((packed));

struct btrfs_path {
	struct extent_buffer *nodes[8];
	int slots[8];
	u8 locks[8];
	u8 reada;
	u8 lowest_level;
	unsigned int search_for_split: 1;
	unsigned int keep_locks: 1;
	unsigned int skip_locking: 1;
	unsigned int search_commit_root: 1;
	unsigned int need_commit_sem: 1;
	unsigned int skip_release_on_error: 1;
	unsigned int search_for_extension: 1;
};

struct rcu_string;

struct btrfs_zoned_device_info;

struct scrub_ctx;

struct reada_zone;

struct btrfs_device {
	struct list_head dev_list;
	struct list_head dev_alloc_list;
	struct list_head post_commit_list;
	struct btrfs_fs_devices *fs_devices;
	struct btrfs_fs_info *fs_info;
	struct rcu_string *name;
	u64 generation;
	struct block_device *bdev;
	struct btrfs_zoned_device_info *zone_info;
	fmode_t mode;
	long unsigned int dev_state;
	blk_status_t last_flush_error;
	u64 devid;
	u64 total_bytes;
	u64 disk_total_bytes;
	u64 bytes_used;
	u32 io_align;
	u32 io_width;
	u64 type;
	u32 sector_size;
	u8 uuid[16];
	u64 commit_total_bytes;
	u64 commit_bytes_used;
	struct bio *flush_bio;
	struct completion flush_wait;
	struct scrub_ctx *scrub_ctx;
	atomic_t reada_in_flight;
	u64 reada_next;
	struct reada_zone *reada_curr_zone;
	struct xarray reada_zones;
	struct xarray reada_extents;
	int dev_stats_valid;
	atomic_t dev_stats_ccnt;
	atomic_t dev_stat_values[5];
	struct extent_io_tree alloc_state;
	struct completion kobj_unregister;
	struct kobject devid_kobj;
	u64 scrub_speed_max;
};

enum btrfs_discard_state {
	BTRFS_DISCARD_EXTENTS = 0,
	BTRFS_DISCARD_BITMAPS = 1,
	BTRFS_DISCARD_RESET_CURSOR = 2,
};

struct btrfs_io_ctl {
	void *cur;
	void *orig;
	struct page *page;
	struct page **pages;
	struct btrfs_fs_info *fs_info;
	struct inode *inode;
	long unsigned int size;
	int index;
	int num_pages;
	int entries;
	int bitmaps;
};

struct btrfs_full_stripe_locks_tree {
	struct rb_root root;
	struct mutex lock;
};

struct btrfs_caching_control;

struct btrfs_free_space_ctl;

struct btrfs_block_group {
	struct btrfs_fs_info *fs_info;
	struct inode *inode;
	spinlock_t lock;
	u64 start;
	u64 length;
	u64 pinned;
	u64 reserved;
	u64 used;
	u64 delalloc_bytes;
	u64 bytes_super;
	u64 flags;
	u64 cache_generation;
	u32 bitmap_high_thresh;
	u32 bitmap_low_thresh;
	struct rw_semaphore data_rwsem;
	long unsigned int full_stripe_len;
	unsigned int ro;
	unsigned int iref: 1;
	unsigned int has_caching_ctl: 1;
	unsigned int removed: 1;
	unsigned int to_copy: 1;
	unsigned int relocating_repair: 1;
	unsigned int chunk_item_inserted: 1;
	unsigned int zoned_data_reloc_ongoing: 1;
	int disk_cache_state;
	int cached;
	struct btrfs_caching_control *caching_ctl;
	u64 last_byte_to_unpin;
	struct btrfs_space_info *space_info;
	struct btrfs_free_space_ctl *free_space_ctl;
	struct rb_node cache_node;
	struct list_head list;
	refcount_t refs;
	struct list_head cluster_list;
	struct list_head bg_list;
	struct list_head ro_list;
	atomic_t frozen;
	struct list_head discard_list;
	int discard_index;
	u64 discard_eligible_time;
	u64 discard_cursor;
	enum btrfs_discard_state discard_state;
	struct list_head dirty_list;
	struct list_head io_list;
	struct btrfs_io_ctl io_ctl;
	atomic_t reservations;
	atomic_t nocow_writers;
	struct mutex free_space_lock;
	int needs_free_space;
	bool seq_zone;
	int swap_extents;
	struct btrfs_full_stripe_locks_tree full_stripe_locks_root;
	u64 alloc_offset;
	u64 zone_unusable;
	u64 meta_write_pointer;
};

enum {
	BTRFS_FS_BARRIER = 0,
	BTRFS_FS_CLOSING_START = 1,
	BTRFS_FS_CLOSING_DONE = 2,
	BTRFS_FS_LOG_RECOVERING = 3,
	BTRFS_FS_OPEN = 4,
	BTRFS_FS_QUOTA_ENABLED = 5,
	BTRFS_FS_UPDATE_UUID_TREE_GEN = 6,
	BTRFS_FS_CREATING_FREE_SPACE_TREE = 7,
	BTRFS_FS_BTREE_ERR = 8,
	BTRFS_FS_LOG1_ERR = 9,
	BTRFS_FS_LOG2_ERR = 10,
	BTRFS_FS_QUOTA_OVERRIDE = 11,
	BTRFS_FS_FROZEN = 12,
	BTRFS_FS_BALANCE_RUNNING = 13,
	BTRFS_FS_RELOC_RUNNING = 14,
	BTRFS_FS_CLEANER_RUNNING = 15,
	BTRFS_FS_CSUM_IMPL_FAST = 16,
	BTRFS_FS_DISCARD_RUNNING = 17,
	BTRFS_FS_CLEANUP_SPACE_CACHE_V1 = 18,
	BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED = 19,
	BTRFS_FS_TREE_MOD_LOG_USERS = 20,
	BTRFS_FS_UNFINISHED_DROPS = 21,
};

struct btrfs_qgroup_swapped_blocks {
	spinlock_t lock;
	bool swapped;
	struct rb_root blocks[8];
};

struct btrfs_root {
	struct extent_buffer *node;
	struct extent_buffer *commit_root;
	struct btrfs_root *log_root;
	struct btrfs_root *reloc_root;
	long unsigned int state;
	struct btrfs_root_item root_item;
	struct btrfs_key root_key;
	struct btrfs_fs_info *fs_info;
	struct extent_io_tree dirty_log_pages;
	struct mutex objectid_mutex;
	spinlock_t accounting_lock;
	struct btrfs_block_rsv *block_rsv;
	struct mutex log_mutex;
	wait_queue_head_t log_writer_wait;
	wait_queue_head_t log_commit_wait[2];
	struct list_head log_ctxs[2];
	atomic_t log_writers;
	atomic_t log_commit[2];
	atomic_t log_batch;
	int log_transid;
	int log_transid_committed;
	int last_log_commit;
	pid_t log_start_pid;
	u64 last_trans;
	u32 type;
	u64 free_objectid;
	struct btrfs_key defrag_progress;
	struct btrfs_key defrag_max;
	struct list_head dirty_list;
	struct list_head root_list;
	spinlock_t log_extents_lock[2];
	struct list_head logged_list[2];
	int orphan_cleanup_state;
	spinlock_t inode_lock;
	struct rb_root inode_tree;
	struct xarray delayed_nodes_tree;
	dev_t anon_dev;
	spinlock_t root_item_lock;
	refcount_t refs;
	struct mutex delalloc_mutex;
	spinlock_t delalloc_lock;
	struct list_head delalloc_inodes;
	struct list_head delalloc_root;
	u64 nr_delalloc_inodes;
	struct mutex ordered_extent_mutex;
	spinlock_t ordered_extent_lock;
	struct list_head ordered_extents;
	struct list_head ordered_root;
	u64 nr_ordered_extents;
	struct list_head reloc_dirty_list;
	int send_in_progress;
	int dedupe_in_progress;
	struct btrfs_drew_lock snapshot_lock;
	atomic_t snapshot_force_cow;
	spinlock_t qgroup_meta_rsv_lock;
	u64 qgroup_meta_rsv_pertrans;
	u64 qgroup_meta_rsv_prealloc;
	wait_queue_head_t qgroup_flush_wait;
	atomic_t nr_swapfiles;
	struct btrfs_qgroup_swapped_blocks swapped_blocks;
	struct extent_io_tree log_csum_range;
};

enum btrfs_trans_state {
	TRANS_STATE_RUNNING = 0,
	TRANS_STATE_COMMIT_START = 1,
	TRANS_STATE_COMMIT_DOING = 2,
	TRANS_STATE_UNBLOCKED = 3,
	TRANS_STATE_SUPER_COMMITTED = 4,
	TRANS_STATE_COMPLETED = 5,
	TRANS_STATE_MAX = 6,
};

struct btrfs_delayed_ref_root {
	struct rb_root_cached href_root;
	struct rb_root dirty_extent_root;
	spinlock_t lock;
	atomic_t num_entries;
	long unsigned int num_heads;
	long unsigned int num_heads_ready;
	u64 pending_csums;
	long unsigned int flags;
	u64 run_delayed_start;
	u64 qgroup_to_skip;
};

struct btrfs_transaction {
	u64 transid;
	atomic_t num_extwriters;
	atomic_t num_writers;
	refcount_t use_count;
	long unsigned int flags;
	enum btrfs_trans_state state;
	int aborted;
	struct list_head list;
	struct extent_io_tree dirty_pages;
	time64_t start_time;
	wait_queue_head_t writer_wait;
	wait_queue_head_t commit_wait;
	struct list_head pending_snapshots;
	struct list_head dev_update_list;
	struct list_head switch_commits;
	struct list_head dirty_bgs;
	struct list_head io_bgs;
	struct list_head dropped_roots;
	struct extent_io_tree pinned_extents;
	struct mutex cache_write_mutex;
	spinlock_t dirty_bgs_lock;
	struct list_head deleted_bgs;
	spinlock_t dropped_roots_lock;
	struct btrfs_delayed_ref_root delayed_refs;
	struct btrfs_fs_info *fs_info;
	atomic_t pending_ordered;
	wait_queue_head_t pending_wait;
	spinlock_t releasing_ebs_lock;
	struct list_head releasing_ebs;
};

enum btrfs_chunk_allocation_policy {
	BTRFS_CHUNK_ALLOC_REGULAR = 0,
	BTRFS_CHUNK_ALLOC_ZONED = 1,
};

enum btrfs_read_policy {
	BTRFS_READ_POLICY_PID = 0,
	BTRFS_NR_READ_POLICY = 1,
};

struct btrfs_fs_devices {
	u8 fsid[16];
	u8 metadata_uuid[16];
	bool fsid_change;
	struct list_head fs_list;
	u64 num_devices;
	u64 open_devices;
	u64 rw_devices;
	u64 missing_devices;
	u64 total_rw_bytes;
	u64 total_devices;
	u64 latest_generation;
	struct btrfs_device *latest_dev;
	struct mutex device_list_mutex;
	struct list_head devices;
	struct list_head alloc_list;
	struct list_head seed_list;
	bool seeding;
	int opened;
	bool rotating;
	struct btrfs_fs_info *fs_info;
	struct kobject fsid_kobj;
	struct kobject *devices_kobj;
	struct kobject *devinfo_kobj;
	struct completion kobj_unregister;
	enum btrfs_chunk_allocation_policy chunk_alloc_policy;
	enum btrfs_read_policy read_policy;
};

struct btrfs_balance_control {
	struct btrfs_balance_args data;
	struct btrfs_balance_args meta;
	struct btrfs_balance_args sys;
	u64 flags;
	struct btrfs_balance_progress stat;
};

struct btrfs_delayed_root {
	spinlock_t lock;
	struct list_head node_list;
	struct list_head prepare_list;
	atomic_t items;
	atomic_t items_seq;
	int nodes;
	wait_queue_head_t wait;
};

enum {
	BTRFS_MOUNT_NODATASUM = 1,
	BTRFS_MOUNT_NODATACOW = 2,
	BTRFS_MOUNT_NOBARRIER = 4,
	BTRFS_MOUNT_SSD = 8,
	BTRFS_MOUNT_DEGRADED = 16,
	BTRFS_MOUNT_COMPRESS = 32,
	BTRFS_MOUNT_NOTREELOG = 64,
	BTRFS_MOUNT_FLUSHONCOMMIT = 128,
	BTRFS_MOUNT_SSD_SPREAD = 256,
	BTRFS_MOUNT_NOSSD = 512,
	BTRFS_MOUNT_DISCARD_SYNC = 1024,
	BTRFS_MOUNT_FORCE_COMPRESS = 2048,
	BTRFS_MOUNT_SPACE_CACHE = 4096,
	BTRFS_MOUNT_CLEAR_CACHE = 8192,
	BTRFS_MOUNT_USER_SUBVOL_RM_ALLOWED = 16384,
	BTRFS_MOUNT_ENOSPC_DEBUG = 32768,
	BTRFS_MOUNT_AUTO_DEFRAG = 65536,
	BTRFS_MOUNT_USEBACKUPROOT = 131072,
	BTRFS_MOUNT_SKIP_BALANCE = 262144,
	BTRFS_MOUNT_CHECK_INTEGRITY = 524288,
	BTRFS_MOUNT_CHECK_INTEGRITY_DATA = 1048576,
	BTRFS_MOUNT_PANIC_ON_FATAL_ERROR = 2097152,
	BTRFS_MOUNT_RESCAN_UUID_TREE = 4194304,
	BTRFS_MOUNT_FRAGMENT_DATA = 8388608,
	BTRFS_MOUNT_FRAGMENT_METADATA = 16777216,
	BTRFS_MOUNT_FREE_SPACE_TREE = 33554432,
	BTRFS_MOUNT_NOLOGREPLAY = 67108864,
	BTRFS_MOUNT_REF_VERIFY = 134217728,
	BTRFS_MOUNT_DISCARD_ASYNC = 268435456,
	BTRFS_MOUNT_IGNOREBADROOTS = 536870912,
	BTRFS_MOUNT_IGNOREDATACSUMS = 1073741824,
};

enum btrfs_reserve_flush_enum {
	BTRFS_RESERVE_NO_FLUSH = 0,
	BTRFS_RESERVE_FLUSH_LIMIT = 1,
	BTRFS_RESERVE_FLUSH_EVICT = 2,
	BTRFS_RESERVE_FLUSH_DATA = 3,
	BTRFS_RESERVE_FLUSH_FREE_SPACE_INODE = 4,
	BTRFS_RESERVE_FLUSH_ALL = 5,
	BTRFS_RESERVE_FLUSH_ALL_STEAL = 6,
};

enum btrfs_flush_state {
	FLUSH_DELAYED_ITEMS_NR = 1,
	FLUSH_DELAYED_ITEMS = 2,
	FLUSH_DELAYED_REFS_NR = 3,
	FLUSH_DELAYED_REFS = 4,
	FLUSH_DELALLOC = 5,
	FLUSH_DELALLOC_WAIT = 6,
	FLUSH_DELALLOC_FULL = 7,
	ALLOC_CHUNK = 8,
	ALLOC_CHUNK_FORCE = 9,
	RUN_DELAYED_IPUTS = 10,
	COMMIT_TRANS = 11,
};

struct btrfs_delayed_node {
	u64 inode_id;
	u64 bytes_reserved;
	struct btrfs_root *root;
	struct list_head n_list;
	struct list_head p_list;
	struct rb_root_cached ins_root;
	struct rb_root_cached del_root;
	struct mutex mutex;
	struct btrfs_inode_item inode_item;
	refcount_t refs;
	u64 index_cnt;
	long unsigned int flags;
	int count;
};

enum {
	BTRFS_ORDERED_REGULAR = 0,
	BTRFS_ORDERED_NOCOW = 1,
	BTRFS_ORDERED_PREALLOC = 2,
	BTRFS_ORDERED_COMPRESSED = 3,
	BTRFS_ORDERED_DIRECT = 4,
	BTRFS_ORDERED_IO_DONE = 5,
	BTRFS_ORDERED_COMPLETE = 6,
	BTRFS_ORDERED_IOERR = 7,
	BTRFS_ORDERED_TRUNCATED = 8,
	BTRFS_ORDERED_LOGGED = 9,
	BTRFS_ORDERED_LOGGED_CSUM = 10,
	BTRFS_ORDERED_PENDING = 11,
};

struct btrfs_ordered_extent {
	u64 file_offset;
	u64 disk_bytenr;
	u64 num_bytes;
	u64 disk_num_bytes;
	u64 bytes_left;
	u64 outstanding_isize;
	u64 truncated_len;
	long unsigned int flags;
	int compress_type;
	int qgroup_rsv;
	refcount_t refs;
	struct inode *inode;
	struct list_head list;
	struct list_head log_list;
	wait_queue_head_t wait;
	struct rb_node rb_node;
	struct list_head root_extent_list;
	struct btrfs_work work;
	struct completion completion;
	struct btrfs_work flush_work;
	struct list_head work_list;
	u64 physical;
	struct block_device *bdev;
};

struct btrfs_delayed_ref_node {
	struct rb_node ref_node;
	struct list_head add_list;
	u64 bytenr;
	u64 num_bytes;
	u64 seq;
	refcount_t refs;
	int ref_mod;
	unsigned int action: 8;
	unsigned int type: 8;
	unsigned int is_head: 1;
	unsigned int in_tree: 1;
};

struct btrfs_delayed_extent_op {
	struct btrfs_disk_key key;
	u8 level;
	bool update_key;
	bool update_flags;
	bool is_data;
	u64 flags_to_set;
};

struct btrfs_delayed_ref_head {
	u64 bytenr;
	u64 num_bytes;
	refcount_t refs;
	struct mutex mutex;
	spinlock_t lock;
	struct rb_root_cached ref_tree;
	struct list_head ref_add_list;
	struct rb_node href_node;
	struct btrfs_delayed_extent_op *extent_op;
	int total_ref_mod;
	int ref_mod;
	unsigned int must_insert_reserved: 1;
	unsigned int is_data: 1;
	unsigned int is_system: 1;
	unsigned int processing: 1;
};

struct btrfs_delayed_tree_ref {
	struct btrfs_delayed_ref_node node;
	u64 root;
	u64 parent;
	int level;
};

struct btrfs_delayed_data_ref {
	struct btrfs_delayed_ref_node node;
	u64 root;
	u64 parent;
	u64 objectid;
	u64 offset;
};

struct btrfs_pending_snapshot;

struct btrfs_trans_handle {
	u64 transid;
	u64 bytes_reserved;
	u64 chunk_bytes_reserved;
	long unsigned int delayed_ref_updates;
	struct btrfs_transaction *transaction;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_block_rsv *orig_rsv;
	struct btrfs_pending_snapshot *pending_snapshot;
	refcount_t use_count;
	unsigned int type;
	short int aborted;
	bool adding_csums;
	bool allocating_chunk;
	bool removing_chunk;
	bool reloc_reserved;
	bool in_fsync;
	struct btrfs_root *root;
	struct btrfs_fs_info *fs_info;
	struct list_head new_bgs;
};

struct btrfs_pending_snapshot {
	struct dentry *dentry;
	struct inode *dir;
	struct btrfs_root *root;
	struct btrfs_root_item *root_item;
	struct btrfs_root *snap;
	struct btrfs_qgroup_inherit *inherit;
	struct btrfs_path *path;
	struct btrfs_block_rsv block_rsv;
	int error;
	dev_t anon_dev;
	bool readonly;
	struct list_head list;
};

struct rcu_string {
	struct callback_head rcu;
	char str[0];
};

struct btrfs_zoned_device_info {
	u64 zone_size;
	u8 zone_size_shift;
	u64 max_zone_append_size;
	u32 nr_zones;
	long unsigned int *seq_zones;
	long unsigned int *empty_zones;
	struct blk_zone *zone_cache;
	struct blk_zone sb_zones[6];
};

struct btrfs_device_info {
	struct btrfs_device *dev;
	u64 dev_offset;
	u64 max_avail;
	u64 total_avail;
};

struct btrfs_raid_attr {
	u8 sub_stripes;
	u8 dev_stripes;
	u8 devs_max;
	u8 devs_min;
	u8 tolerated_failures;
	u8 devs_increment;
	u8 ncopies;
	u8 nparity;
	u8 mindev_error;
	const char raid_name[8];
	u64 bg_flag;
};

enum btrfs_compression_type {
	BTRFS_COMPRESS_NONE = 0,
	BTRFS_COMPRESS_ZLIB = 1,
	BTRFS_COMPRESS_LZO = 2,
	BTRFS_COMPRESS_ZSTD = 3,
	BTRFS_NR_COMPRESS_TYPES = 4,
};

enum btrfs_trim_state {
	BTRFS_TRIM_STATE_UNTRIMMED = 0,
	BTRFS_TRIM_STATE_TRIMMED = 1,
	BTRFS_TRIM_STATE_TRIMMING = 2,
};

struct btrfs_free_space {
	struct rb_node offset_index;
	u64 offset;
	u64 bytes;
	u64 max_extent_size;
	long unsigned int *bitmap;
	struct list_head list;
	enum btrfs_trim_state trim_state;
	s32 bitmap_extents;
};

struct btrfs_free_space_op;

struct btrfs_free_space_ctl {
	spinlock_t tree_lock;
	struct rb_root free_space_offset;
	u64 free_space;
	int extents_thresh;
	int free_extents;
	int total_bitmaps;
	int unit;
	u64 start;
	s32 discardable_extents[2];
	s64 discardable_bytes[2];
	const struct btrfs_free_space_op *op;
	void *private;
	struct mutex cache_writeout_mutex;
	struct list_head trimming_ranges;
};

struct btrfs_free_space_op {
	bool (*use_bitmap)(struct btrfs_free_space_ctl *, struct btrfs_free_space *);
};

struct extent_inode_elem;

struct prelim_ref {
	struct rb_node rbnode;
	u64 root_id;
	struct btrfs_key key_for_search;
	int level;
	int count;
	struct extent_inode_elem *inode_list;
	u64 parent;
	u64 wanted_disk_byte;
};

struct btrfs_caching_control {
	struct list_head list;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct btrfs_work work;
	struct btrfs_block_group *block_group;
	u64 progress;
	refcount_t count;
};

struct btrfs_qgroup_extent_record {
	struct rb_node node;
	u64 bytenr;
	u64 num_bytes;
	u32 data_rsv;
	u64 data_rsv_refroot;
	struct ulist *old_roots;
};

enum btrfs_qgroup_rsv_type {
	BTRFS_QGROUP_RSV_DATA = 0,
	BTRFS_QGROUP_RSV_META_PERTRANS = 1,
	BTRFS_QGROUP_RSV_META_PREALLOC = 2,
	BTRFS_QGROUP_RSV_LAST = 3,
};

struct btrfs_qgroup_rsv {
	u64 values[3];
};

struct btrfs_qgroup {
	u64 qgroupid;
	u64 rfer;
	u64 rfer_cmpr;
	u64 excl;
	u64 excl_cmpr;
	u64 lim_flags;
	u64 max_rfer;
	u64 max_excl;
	u64 rsv_rfer;
	u64 rsv_excl;
	struct btrfs_qgroup_rsv rsv;
	struct list_head groups;
	struct list_head members;
	struct list_head dirty;
	struct rb_node node;
	u64 old_refcnt;
	u64 new_refcnt;
	struct kobject kobj;
};

struct trace_event_raw_btrfs_transaction_commit {
	struct trace_entry ent;
	u8 fsid[16];
	u64 generation;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs__inode {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 blocks;
	u64 disk_i_size;
	u64 generation;
	u64 last_trans;
	u64 logged_trans;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_get_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 ino;
	u64 start;
	u64 len;
	u64 orig_start;
	u64 block_start;
	u64 block_len;
	long unsigned int flags;
	int refs;
	unsigned int compress_type;
	char __data[0];
};

struct trace_event_raw_btrfs_handle_em_exist {
	struct trace_entry ent;
	u8 fsid[16];
	u64 e_start;
	u64 e_len;
	u64 map_start;
	u64 map_len;
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_btrfs__file_extent_item_regular {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_obj;
	u64 ino;
	loff_t isize;
	u64 disk_isize;
	u64 num_bytes;
	u64 ram_bytes;
	u64 disk_bytenr;
	u64 disk_num_bytes;
	u64 extent_offset;
	u8 extent_type;
	u8 compression;
	u64 extent_start;
	u64 extent_end;
	char __data[0];
};

struct trace_event_raw_btrfs__file_extent_item_inline {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_obj;
	u64 ino;
	loff_t isize;
	u64 disk_isize;
	u8 extent_type;
	u8 compression;
	u64 extent_start;
	u64 extent_end;
	char __data[0];
};

struct trace_event_raw_btrfs__ordered_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 file_offset;
	u64 start;
	u64 len;
	u64 disk_len;
	u64 bytes_left;
	long unsigned int flags;
	int compress_type;
	int refs;
	u64 root_objectid;
	u64 truncated_len;
	char __data[0];
};

struct trace_event_raw_btrfs__writepage {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	long unsigned int index;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	char for_kupdate;
	char for_reclaim;
	char range_cyclic;
	long unsigned int writeback_index;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_writepage_end_io_hook {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 start;
	u64 end;
	int uptodate;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_sync_file {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 parent;
	int datasync;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_sync_fs {
	struct trace_entry ent;
	u8 fsid[16];
	int wait;
	char __data[0];
};

struct trace_event_raw_btrfs_add_block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 offset;
	u64 size;
	u64 flags;
	u64 bytes_used;
	u64 bytes_super;
	int create;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_tree_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	u64 parent;
	u64 ref_root;
	int level;
	int type;
	u64 seq;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_data_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	u64 parent;
	u64 ref_root;
	u64 owner;
	u64 offset;
	int type;
	u64 seq;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_ref_head {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	int is_data;
	char __data[0];
};

struct trace_event_raw_btrfs__chunk {
	struct trace_entry ent;
	u8 fsid[16];
	int num_stripes;
	u64 type;
	int sub_stripes;
	u64 offset;
	u64 size;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_cow_block {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 buf_start;
	int refs;
	u64 cow_start;
	int buf_level;
	int cow_level;
	char __data[0];
};

struct trace_event_raw_btrfs_space_reservation {
	struct trace_entry ent;
	u8 fsid[16];
	u32 __data_loc_type;
	u64 val;
	u64 bytes;
	int reserve;
	char __data[0];
};

struct trace_event_raw_btrfs_trigger_flush {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 bytes;
	int flush;
	u32 __data_loc_reason;
	char __data[0];
};

struct trace_event_raw_btrfs_flush_space {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 num_bytes;
	int state;
	int ret;
	bool for_preempt;
	char __data[0];
};

struct trace_event_raw_btrfs__reserved_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_find_free_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 num_bytes;
	u64 empty_size;
	u64 data;
	char __data[0];
};

struct trace_event_raw_btrfs__reserve_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_btrfs_find_cluster {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 bytes;
	u64 empty_size;
	u64 min_bytes;
	char __data[0];
};

struct trace_event_raw_btrfs_failed_cluster_setup {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_setup_cluster {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 max_size;
	u64 size;
	int bitmap;
	char __data[0];
};

struct trace_event_raw_alloc_extent_state {
	struct trace_entry ent;
	const struct extent_state *state;
	gfp_t mask;
	const void *ip;
	char __data[0];
};

struct trace_event_raw_free_extent_state {
	struct trace_entry ent;
	const struct extent_state *state;
	const void *ip;
	char __data[0];
};

struct trace_event_raw_btrfs__work {
	struct trace_entry ent;
	u8 fsid[16];
	const void *work;
	const void *wq;
	const void *func;
	const void *ordered_func;
	const void *ordered_free;
	const void *normal_work;
	char __data[0];
};

struct trace_event_raw_btrfs__work__done {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wtag;
	char __data[0];
};

struct trace_event_raw_btrfs__workqueue {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wq;
	u32 __data_loc_name;
	int high;
	char __data[0];
};

struct trace_event_raw_btrfs__workqueue_done {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wq;
	char __data[0];
};

struct trace_event_raw_btrfs__qgroup_rsv_data {
	struct trace_entry ent;
	u8 fsid[16];
	u64 rootid;
	u64 ino;
	u64 start;
	u64 len;
	u64 reserved;
	int op;
	char __data[0];
};

struct trace_event_raw_btrfs_qgroup_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	char __data[0];
};

struct trace_event_raw_qgroup_num_dirty_extents {
	struct trace_entry ent;
	u8 fsid[16];
	u64 transid;
	u64 num_dirty_extents;
	char __data[0];
};

struct trace_event_raw_btrfs_qgroup_account_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 transid;
	u64 bytenr;
	u64 num_bytes;
	u64 nr_old_roots;
	u64 nr_new_roots;
	char __data[0];
};

struct trace_event_raw_qgroup_update_counters {
	struct trace_entry ent;
	u8 fsid[16];
	u64 qgid;
	u64 old_rfer;
	u64 old_excl;
	u64 cur_old_count;
	u64 cur_new_count;
	char __data[0];
};

struct trace_event_raw_qgroup_update_reserve {
	struct trace_entry ent;
	u8 fsid[16];
	u64 qgid;
	u64 cur_reserved;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_reserve {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_convert {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_free_all_pertrans {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_btrfs__prelim_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_id;
	u64 objectid;
	u8 type;
	u64 offset;
	int level;
	int old_count;
	u64 parent;
	u64 bytenr;
	int mod_count;
	u64 tree_size;
	char __data[0];
};

struct trace_event_raw_btrfs_inode_mod_outstanding_extents {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 ino;
	int mod;
	char __data[0];
};

struct trace_event_raw_btrfs__block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 len;
	u64 used;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_btrfs_set_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int set_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_clear_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int clear_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_convert_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int set_bits;
	unsigned int clear_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_dump_space_info {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 total_bytes;
	u64 bytes_used;
	u64 bytes_pinned;
	u64 bytes_reserved;
	u64 bytes_may_use;
	u64 bytes_readonly;
	u64 reclaim_size;
	int clamp;
	u64 global_reserved;
	u64 trans_reserved;
	u64 delayed_refs_reserved;
	u64 delayed_reserved;
	u64 free_chunk_space;
	u64 delalloc_bytes;
	u64 ordered_bytes;
	char __data[0];
};

struct trace_event_raw_btrfs_reserve_ticket {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 bytes;
	u64 start_ns;
	int flush;
	int error;
	char __data[0];
};

struct trace_event_raw_btrfs_sleep_tree_lock {
	struct trace_entry ent;
	u8 fsid[16];
	u64 block;
	u64 generation;
	u64 start_ns;
	u64 end_ns;
	u64 diff_ns;
	u64 owner;
	int is_log_tree;
	char __data[0];
};

struct trace_event_raw_btrfs_locking_events {
	struct trace_entry ent;
	u8 fsid[16];
	u64 block;
	u64 generation;
	u64 owner;
	int is_log_tree;
	char __data[0];
};

struct trace_event_raw_btrfs__space_info_update {
	struct trace_entry ent;
	u8 fsid[16];
	u64 type;
	u64 old;
	s64 diff;
	char __data[0];
};

struct trace_event_data_offsets_btrfs_transaction_commit {};

struct trace_event_data_offsets_btrfs__inode {};

struct trace_event_data_offsets_btrfs_get_extent {};

struct trace_event_data_offsets_btrfs_handle_em_exist {};

struct trace_event_data_offsets_btrfs__file_extent_item_regular {};

struct trace_event_data_offsets_btrfs__file_extent_item_inline {};

struct trace_event_data_offsets_btrfs__ordered_extent {};

struct trace_event_data_offsets_btrfs__writepage {};

struct trace_event_data_offsets_btrfs_writepage_end_io_hook {};

struct trace_event_data_offsets_btrfs_sync_file {};

struct trace_event_data_offsets_btrfs_sync_fs {};

struct trace_event_data_offsets_btrfs_add_block_group {};

struct trace_event_data_offsets_btrfs_delayed_tree_ref {};

struct trace_event_data_offsets_btrfs_delayed_data_ref {};

struct trace_event_data_offsets_btrfs_delayed_ref_head {};

struct trace_event_data_offsets_btrfs__chunk {};

struct trace_event_data_offsets_btrfs_cow_block {};

struct trace_event_data_offsets_btrfs_space_reservation {
	u32 type;
};

struct trace_event_data_offsets_btrfs_trigger_flush {
	u32 reason;
};

struct trace_event_data_offsets_btrfs_flush_space {};

struct trace_event_data_offsets_btrfs__reserved_extent {};

struct trace_event_data_offsets_find_free_extent {};

struct trace_event_data_offsets_btrfs__reserve_extent {};

struct trace_event_data_offsets_btrfs_find_cluster {};

struct trace_event_data_offsets_btrfs_failed_cluster_setup {};

struct trace_event_data_offsets_btrfs_setup_cluster {};

struct trace_event_data_offsets_alloc_extent_state {};

struct trace_event_data_offsets_free_extent_state {};

struct trace_event_data_offsets_btrfs__work {};

struct trace_event_data_offsets_btrfs__work__done {};

struct trace_event_data_offsets_btrfs__workqueue {
	u32 name;
};

struct trace_event_data_offsets_btrfs__workqueue_done {};

struct trace_event_data_offsets_btrfs__qgroup_rsv_data {};

struct trace_event_data_offsets_btrfs_qgroup_extent {};

struct trace_event_data_offsets_qgroup_num_dirty_extents {};

struct trace_event_data_offsets_btrfs_qgroup_account_extent {};

struct trace_event_data_offsets_qgroup_update_counters {};

struct trace_event_data_offsets_qgroup_update_reserve {};

struct trace_event_data_offsets_qgroup_meta_reserve {};

struct trace_event_data_offsets_qgroup_meta_convert {};

struct trace_event_data_offsets_qgroup_meta_free_all_pertrans {};

struct trace_event_data_offsets_btrfs__prelim_ref {};

struct trace_event_data_offsets_btrfs_inode_mod_outstanding_extents {};

struct trace_event_data_offsets_btrfs__block_group {};

struct trace_event_data_offsets_btrfs_set_extent_bit {};

struct trace_event_data_offsets_btrfs_clear_extent_bit {};

struct trace_event_data_offsets_btrfs_convert_extent_bit {};

struct trace_event_data_offsets_btrfs_dump_space_info {};

struct trace_event_data_offsets_btrfs_reserve_ticket {};

struct trace_event_data_offsets_btrfs_sleep_tree_lock {};

struct trace_event_data_offsets_btrfs_locking_events {};

struct trace_event_data_offsets_btrfs__space_info_update {};

typedef void (*btf_trace_btrfs_transaction_commit)(void *, const struct btrfs_root *);

typedef void (*btf_trace_btrfs_inode_new)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_inode_request)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_inode_evict)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_get_extent)(void *, const struct btrfs_root *, const struct btrfs_inode *, const struct extent_map *);

typedef void (*btf_trace_btrfs_handle_em_exist)(void *, const struct btrfs_fs_info *, const struct extent_map *, const struct extent_map *, u64, u64);

typedef void (*btf_trace_btrfs_get_extent_show_fi_regular)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, u64);

typedef void (*btf_trace_btrfs_truncate_show_fi_regular)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, u64);

typedef void (*btf_trace_btrfs_get_extent_show_fi_inline)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, int, u64);

typedef void (*btf_trace_btrfs_truncate_show_fi_inline)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, int, u64);

typedef void (*btf_trace_btrfs_ordered_extent_add)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_remove)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_start)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_put)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace___extent_writepage)(void *, const struct page *, const struct inode *, const struct writeback_control *);

typedef void (*btf_trace_btrfs_writepage_end_io_hook)(void *, const struct btrfs_inode *, u64, u64, int);

typedef void (*btf_trace_btrfs_sync_file)(void *, const struct file *, int);

typedef void (*btf_trace_btrfs_sync_fs)(void *, const struct btrfs_fs_info *, int);

typedef void (*btf_trace_btrfs_add_block_group)(void *, const struct btrfs_fs_info *, const struct btrfs_block_group *, int);

typedef void (*btf_trace_add_delayed_tree_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_tree_ref *, int);

typedef void (*btf_trace_run_delayed_tree_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_tree_ref *, int);

typedef void (*btf_trace_add_delayed_data_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_data_ref *, int);

typedef void (*btf_trace_run_delayed_data_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_data_ref *, int);

typedef void (*btf_trace_add_delayed_ref_head)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_head *, int);

typedef void (*btf_trace_run_delayed_ref_head)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_head *, int);

typedef void (*btf_trace_btrfs_chunk_alloc)(void *, const struct btrfs_fs_info *, const struct map_lookup *, u64, u64);

typedef void (*btf_trace_btrfs_chunk_free)(void *, const struct btrfs_fs_info *, const struct map_lookup *, u64, u64);

typedef void (*btf_trace_btrfs_cow_block)(void *, const struct btrfs_root *, const struct extent_buffer *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_space_reservation)(void *, const struct btrfs_fs_info *, const char *, u64, u64, int);

typedef void (*btf_trace_btrfs_trigger_flush)(void *, const struct btrfs_fs_info *, u64, u64, int, const char *);

typedef void (*btf_trace_btrfs_flush_space)(void *, const struct btrfs_fs_info *, u64, u64, int, int, bool);

typedef void (*btf_trace_btrfs_reserved_extent_alloc)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_btrfs_reserved_extent_free)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_find_free_extent)(void *, const struct btrfs_root *, u64, u64, u64);

typedef void (*btf_trace_btrfs_reserve_extent)(void *, const struct btrfs_block_group *, u64, u64);

typedef void (*btf_trace_btrfs_reserve_extent_cluster)(void *, const struct btrfs_block_group *, u64, u64);

typedef void (*btf_trace_btrfs_find_cluster)(void *, const struct btrfs_block_group *, u64, u64, u64, u64);

typedef void (*btf_trace_btrfs_failed_cluster_setup)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_setup_cluster)(void *, const struct btrfs_block_group *, const struct btrfs_free_cluster *, u64, int);

typedef void (*btf_trace_alloc_extent_state)(void *, const struct extent_state *, gfp_t, long unsigned int);

typedef void (*btf_trace_free_extent_state)(void *, const struct extent_state *, long unsigned int);

typedef void (*btf_trace_btrfs_work_queued)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_work_sched)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_all_work_done)(void *, const struct btrfs_fs_info *, const void *);

typedef void (*btf_trace_btrfs_ordered_sched)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_workqueue_alloc)(void *, const struct __btrfs_workqueue *, const char *, int);

typedef void (*btf_trace_btrfs_workqueue_destroy)(void *, const struct __btrfs_workqueue *);

typedef void (*btf_trace_btrfs_qgroup_reserve_data)(void *, const struct inode *, u64, u64, u64, int);

typedef void (*btf_trace_btrfs_qgroup_release_data)(void *, const struct inode *, u64, u64, u64, int);

typedef void (*btf_trace_btrfs_qgroup_account_extents)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup_extent_record *);

typedef void (*btf_trace_btrfs_qgroup_trace_extent)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup_extent_record *);

typedef void (*btf_trace_qgroup_num_dirty_extents)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_btrfs_qgroup_account_extent)(void *, const struct btrfs_fs_info *, u64, u64, u64, u64, u64);

typedef void (*btf_trace_qgroup_update_counters)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup *, u64, u64);

typedef void (*btf_trace_qgroup_update_reserve)(void *, struct btrfs_fs_info *, struct btrfs_qgroup *, s64, int);

typedef void (*btf_trace_qgroup_meta_reserve)(void *, struct btrfs_root *, s64, int);

typedef void (*btf_trace_qgroup_meta_convert)(void *, struct btrfs_root *, s64);

typedef void (*btf_trace_qgroup_meta_free_all_pertrans)(void *, struct btrfs_root *);

typedef void (*btf_trace_btrfs_prelim_ref_merge)(void *, const struct btrfs_fs_info *, const struct prelim_ref *, const struct prelim_ref *, u64);

typedef void (*btf_trace_btrfs_prelim_ref_insert)(void *, const struct btrfs_fs_info *, const struct prelim_ref *, const struct prelim_ref *, u64);

typedef void (*btf_trace_btrfs_inode_mod_outstanding_extents)(void *, const struct btrfs_root *, u64, int);

typedef void (*btf_trace_btrfs_remove_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_add_unused_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_add_reclaim_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_reclaim_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_skip_unused_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_set_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int);

typedef void (*btf_trace_btrfs_clear_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int);

typedef void (*btf_trace_btrfs_convert_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int, unsigned int);

typedef void (*btf_trace_btrfs_done_preemptive_reclaim)(void *, struct btrfs_fs_info *, const struct btrfs_space_info *);

typedef void (*btf_trace_btrfs_fail_all_tickets)(void *, struct btrfs_fs_info *, const struct btrfs_space_info *);

typedef void (*btf_trace_btrfs_reserve_ticket)(void *, const struct btrfs_fs_info *, u64, u64, u64, int, int);

typedef void (*btf_trace_btrfs_tree_read_lock)(void *, const struct extent_buffer *, u64);

typedef void (*btf_trace_btrfs_tree_lock)(void *, const struct extent_buffer *, u64);

typedef void (*btf_trace_btrfs_tree_unlock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_unlock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_unlock_blocking)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_set_lock_blocking_read)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_set_lock_blocking_write)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_try_tree_read_lock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_try_tree_write_lock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_lock_atomic)(void *, const struct extent_buffer *);

typedef void (*btf_trace_update_bytes_may_use)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

typedef void (*btf_trace_update_bytes_pinned)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

enum {
	Opt_acl___2 = 0,
	Opt_noacl___2 = 1,
	Opt_clear_cache = 2,
	Opt_commit_interval = 3,
	Opt_compress = 4,
	Opt_compress_force = 5,
	Opt_compress_force_type = 6,
	Opt_compress_type = 7,
	Opt_degraded = 8,
	Opt_device = 9,
	Opt_fatal_errors = 10,
	Opt_flushoncommit = 11,
	Opt_noflushoncommit = 12,
	Opt_max_inline = 13,
	Opt_barrier___2 = 14,
	Opt_nobarrier___2 = 15,
	Opt_datacow = 16,
	Opt_nodatacow = 17,
	Opt_datasum = 18,
	Opt_nodatasum = 19,
	Opt_defrag = 20,
	Opt_nodefrag = 21,
	Opt_discard___4 = 22,
	Opt_nodiscard___3 = 23,
	Opt_discard_mode = 24,
	Opt_norecovery___2 = 25,
	Opt_ratio = 26,
	Opt_rescan_uuid_tree = 27,
	Opt_skip_balance = 28,
	Opt_space_cache = 29,
	Opt_no_space_cache = 30,
	Opt_space_cache_version = 31,
	Opt_ssd = 32,
	Opt_nossd = 33,
	Opt_ssd_spread = 34,
	Opt_nossd_spread = 35,
	Opt_subvol = 36,
	Opt_subvol_empty = 37,
	Opt_subvolid = 38,
	Opt_thread_pool = 39,
	Opt_treelog = 40,
	Opt_notreelog = 41,
	Opt_user_subvol_rm_allowed = 42,
	Opt_rescue = 43,
	Opt_usebackuproot = 44,
	Opt_nologreplay = 45,
	Opt_ignorebadroots = 46,
	Opt_ignoredatacsums = 47,
	Opt_rescue_all = 48,
	Opt_recovery = 49,
	Opt_inode_cache = 50,
	Opt_noinode_cache = 51,
	Opt_check_integrity = 52,
	Opt_check_integrity_including_extent_data = 53,
	Opt_check_integrity_print_mask = 54,
	Opt_enospc_debug = 55,
	Opt_noenospc_debug = 56,
	Opt_err___7 = 57,
};

enum btrfs_csum_type {
	BTRFS_CSUM_TYPE_CRC32 = 0,
	BTRFS_CSUM_TYPE_XXHASH = 1,
	BTRFS_CSUM_TYPE_SHA256 = 2,
	BTRFS_CSUM_TYPE_BLAKE2 = 3,
};

enum {
	EXTENT_BUFFER_UPTODATE = 0,
	EXTENT_BUFFER_DIRTY = 1,
	EXTENT_BUFFER_CORRUPT = 2,
	EXTENT_BUFFER_READAHEAD = 3,
	EXTENT_BUFFER_TREE_REF = 4,
	EXTENT_BUFFER_STALE = 5,
	EXTENT_BUFFER_WRITEBACK = 6,
	EXTENT_BUFFER_READ_ERR = 7,
	EXTENT_BUFFER_UNMAPPED = 8,
	EXTENT_BUFFER_IN_TREE = 9,
	EXTENT_BUFFER_WRITE_ERR = 10,
	EXTENT_BUFFER_NO_CHECK = 11,
};

struct btrfs_key_ptr {
	struct btrfs_disk_key key;
	__le64 blockptr;
	__le64 generation;
} __attribute__((packed));

enum {
	READA_NONE = 0,
	READA_BACK = 1,
	READA_FORWARD = 2,
	READA_FORWARD_ALWAYS = 3,
};

enum {
	BTRFS_ROOT_IN_TRANS_SETUP = 0,
	BTRFS_ROOT_SHAREABLE = 1,
	BTRFS_ROOT_TRACK_DIRTY = 2,
	BTRFS_ROOT_IN_RADIX = 3,
	BTRFS_ROOT_ORPHAN_ITEM_INSERTED = 4,
	BTRFS_ROOT_DEFRAG_RUNNING = 5,
	BTRFS_ROOT_FORCE_COW = 6,
	BTRFS_ROOT_MULTI_LOG_TASKS = 7,
	BTRFS_ROOT_DIRTY = 8,
	BTRFS_ROOT_DELETING = 9,
	BTRFS_ROOT_DEAD_RELOC_TREE = 10,
	BTRFS_ROOT_DEAD_TREE = 11,
	BTRFS_ROOT_HAS_LOG_TREE = 12,
	BTRFS_ROOT_QGROUP_FLUSHING = 13,
	BTRFS_ROOT_UNFINISHED_DROP = 14,
	BTRFS_ROOT_RESET_LOCKDEP_CLASS = 15,
};

struct btrfs_map_token {
	struct extent_buffer *eb;
	char *kaddr;
	long unsigned int offset;
};

enum btrfs_mod_log_op {
	BTRFS_MOD_LOG_KEY_REPLACE = 0,
	BTRFS_MOD_LOG_KEY_ADD = 1,
	BTRFS_MOD_LOG_KEY_REMOVE = 2,
	BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING = 3,
	BTRFS_MOD_LOG_KEY_REMOVE_WHILE_MOVING = 4,
	BTRFS_MOD_LOG_MOVE_KEYS = 5,
	BTRFS_MOD_LOG_ROOT_REPLACE = 6,
};

struct btrfs_csums {
	u16 size;
	const char name[10];
	const char driver[12];
};

struct btrfs_extent_item {
	__le64 refs;
	__le64 generation;
	__le64 flags;
};

struct btrfs_tree_block_info {
	struct btrfs_disk_key key;
	__u8 level;
};

struct btrfs_extent_data_ref {
	__le64 root;
	__le64 objectid;
	__le64 offset;
	__le32 count;
} __attribute__((packed));

struct btrfs_shared_data_ref {
	__le32 count;
};

struct btrfs_extent_inline_ref {
	__u8 type;
	__le64 offset;
} __attribute__((packed));

struct extent_changeset {
	u64 bytes_changed;
	struct ulist range_changed;
};

enum btrfs_caching_type {
	BTRFS_CACHE_NO = 0,
	BTRFS_CACHE_STARTED = 1,
	BTRFS_CACHE_FINISHED = 2,
	BTRFS_CACHE_ERROR = 3,
};

enum btrfs_inline_ref_type {
	BTRFS_REF_TYPE_INVALID = 0,
	BTRFS_REF_TYPE_BLOCK = 1,
	BTRFS_REF_TYPE_DATA = 2,
	BTRFS_REF_TYPE_ANY = 3,
};

enum btrfs_ref_type {
	BTRFS_REF_NOT_SET = 0,
	BTRFS_REF_DATA = 1,
	BTRFS_REF_METADATA = 2,
	BTRFS_REF_LAST = 3,
};

struct btrfs_data_ref {
	u64 ref_root;
	u64 ino;
	u64 offset;
};

struct btrfs_tree_ref {
	int level;
	u64 root;
};

struct btrfs_ref {
	enum btrfs_ref_type type;
	int action;
	bool skip_qgroup;
	u64 real_root;
	u64 bytenr;
	u64 len;
	u64 parent;
	union {
		struct btrfs_data_ref data_ref;
		struct btrfs_tree_ref tree_ref;
	};
};

struct btrfs_io_context {
	refcount_t refs;
	atomic_t stripes_pending;
	struct btrfs_fs_info *fs_info;
	u64 map_type;
	bio_end_io_t *end_io;
	struct bio *orig_bio;
	void *private;
	atomic_t error;
	int max_errors;
	int num_stripes;
	int mirror_num;
	int num_tgtdevs;
	int *tgtdev_map;
	u64 *raid_map;
	struct btrfs_io_stripe stripes[0];
};

enum btrfs_map_op {
	BTRFS_MAP_READ = 0,
	BTRFS_MAP_WRITE = 1,
	BTRFS_MAP_DISCARD = 2,
	BTRFS_MAP_GET_READ_MIRRORS = 3,
};

enum btrfs_chunk_alloc_enum {
	CHUNK_ALLOC_NO_FORCE = 0,
	CHUNK_ALLOC_LIMITED = 1,
	CHUNK_ALLOC_FORCE = 2,
};

enum btrfs_loop_type {
	LOOP_CACHING_NOWAIT = 0,
	LOOP_CACHING_WAIT = 1,
	LOOP_ALLOC_CHUNK = 2,
	LOOP_NO_EMPTY_SIZE = 3,
};

enum btrfs_extent_allocation_policy {
	BTRFS_EXTENT_ALLOC_CLUSTERED = 0,
	BTRFS_EXTENT_ALLOC_ZONED = 1,
};

struct find_free_extent_ctl {
	u64 num_bytes;
	u64 empty_size;
	u64 flags;
	int delalloc;
	u64 search_start;
	u64 empty_cluster;
	struct btrfs_free_cluster *last_ptr;
	bool use_cluster;
	bool have_caching_bg;
	bool orig_have_caching_bg;
	bool for_treelog;
	bool for_data_reloc;
	int index;
	int loop;
	bool retry_clustered;
	bool retry_unclustered;
	int cached;
	u64 max_extent_size;
	u64 total_free_space;
	u64 found_offset;
	u64 hint_byte;
	enum btrfs_extent_allocation_policy policy;
};

struct walk_control {
	u64 refs[8];
	u64 flags[8];
	struct btrfs_key update_progress;
	struct btrfs_key drop_progress;
	int drop_level;
	int stage;
	int level;
	int shared_level;
	int update_ref;
	int keep_locks;
	int reada_slot;
	int reada_count;
	int restarted;
};

struct btrfs_stripe {
	__le64 devid;
	__le64 offset;
	__u8 dev_uuid[16];
};

struct btrfs_chunk {
	__le64 length;
	__le64 owner;
	__le64 stripe_len;
	__le64 type;
	__le32 io_align;
	__le32 io_width;
	__le32 sector_size;
	__le16 num_stripes;
	__le16 sub_stripes;
	struct btrfs_stripe stripe;
};

struct btrfs_dev_extent {
	__le64 chunk_tree;
	__le64 chunk_objectid;
	__le64 chunk_offset;
	__le64 length;
	__u8 chunk_tree_uuid[16];
};

struct btrfs_block_group_item {
	__le64 used;
	__le64 chunk_objectid;
	__le64 flags;
};

struct root_name_map {
	u64 id;
	char name[16];
};

struct btrfs_csum_item {
	__u8 csum;
};

struct btrfs_ordered_sum {
	u64 bytenr;
	int len;
	struct list_head list;
	u8 sums[0];
};

struct btrfs_io_bio {
	unsigned int mirror_num;
	struct btrfs_device *device;
	u64 logical;
	u8 *csum;
	u8 csum_inline[64];
	struct bvec_iter iter;
	struct bio bio;
};

struct btrfs_inode_extref {
	__le64 parent_objectid;
	__le64 index;
	__le16 name_len;
	__u8 name[0];
} __attribute__((packed));

typedef struct {
	__u8 b[16];
} guid_t;

typedef blk_status_t extent_submit_bio_start_t(struct inode *, struct bio *, u64);

enum {
	BTRFS_BLOCK_RSV_GLOBAL = 0,
	BTRFS_BLOCK_RSV_DELALLOC = 1,
	BTRFS_BLOCK_RSV_TRANS = 2,
	BTRFS_BLOCK_RSV_CHUNK = 3,
	BTRFS_BLOCK_RSV_DELOPS = 4,
	BTRFS_BLOCK_RSV_DELREFS = 5,
	BTRFS_BLOCK_RSV_EMPTY = 6,
	BTRFS_BLOCK_RSV_TEMP = 7,
};

enum btrfs_wq_endio_type {
	BTRFS_WQ_ENDIO_DATA = 0,
	BTRFS_WQ_ENDIO_METADATA = 1,
	BTRFS_WQ_ENDIO_FREE_SPACE = 2,
	BTRFS_WQ_ENDIO_RAID56 = 3,
};

enum {
	BTRFS_INODE_FLUSH_ON_CLOSE = 0,
	BTRFS_INODE_DUMMY = 1,
	BTRFS_INODE_IN_DEFRAG = 2,
	BTRFS_INODE_HAS_ASYNC_EXTENT = 3,
	BTRFS_INODE_NEEDS_FULL_SYNC = 4,
	BTRFS_INODE_COPY_EVERYTHING = 5,
	BTRFS_INODE_IN_DELALLOC_LIST = 6,
	BTRFS_INODE_HAS_PROPS = 7,
	BTRFS_INODE_SNAPSHOT_FLUSH = 8,
	BTRFS_INODE_NO_XATTRS = 9,
	BTRFS_INODE_NO_DELALLOC_FLUSH = 10,
	BTRFS_INODE_VERITY_IN_PROGRESS = 11,
};

enum btrfs_disk_cache_state {
	BTRFS_DC_WRITTEN = 0,
	BTRFS_DC_ERROR = 1,
	BTRFS_DC_CLEAR = 2,
	BTRFS_DC_SETUP = 3,
};

struct btrfs_end_io_wq {
	struct bio *bio;
	bio_end_io_t *end_io;
	void *private;
	struct btrfs_fs_info *info;
	blk_status_t status;
	enum btrfs_wq_endio_type metadata;
	struct btrfs_work work;
};

struct async_submit_bio {
	struct inode *inode;
	struct bio *bio;
	extent_submit_bio_start_t *submit_bio_start;
	int mirror_num;
	u64 dio_file_offset;
	struct btrfs_work work;
	blk_status_t status;
};

enum btrfs_delayed_ref_flags {
	BTRFS_DELAYED_REFS_FLUSHING = 0,
};

struct btrfs_async_commit {
	struct btrfs_trans_handle *newtrans;
	struct work_struct work;
};

typedef blk_status_t submit_bio_hook_t(struct inode *, struct bio *, int, long unsigned int);

struct btrfs_bio_ctrl {
	struct bio *bio;
	long unsigned int bio_flags;
	u32 len_to_stripe_boundary;
	u32 len_to_oe_boundary;
};

enum btrfs_orphan_cleanup_state {
	ORPHAN_CLEANUP_STARTED = 1,
	ORPHAN_CLEANUP_DONE = 2,
};

struct btrfs_swapfile_pin {
	struct rb_node node;
	void *ptr;
	struct inode *inode;
	bool is_block_group;
	int bg_extent_count;
};

struct btrfs_replace_extent_info {
	u64 disk_offset;
	u64 disk_len;
	u64 data_offset;
	u64 data_len;
	u64 file_offset;
	char *extent_buf;
	bool is_new_extent;
	int qgroup_reserved;
	int insertions;
};

struct btrfs_drop_extents_args {
	struct btrfs_path *path;
	u64 start;
	u64 end;
	bool drop_cache;
	bool replace_extent;
	u32 extent_item_size;
	u64 drop_end;
	u64 bytes_found;
	bool extent_inserted;
};

struct btrfs_file_private {
	void *filldir_buf;
};

struct btrfs_dio_private {
	struct inode *inode;
	u64 logical_offset;
	u64 disk_bytenr;
	u32 bytes;
	refcount_t refs;
	struct bio *dio_bio;
	u8 csums[0];
};

struct btrfs_io_geometry {
	u64 len;
	u64 offset;
	u64 stripe_len;
	u64 stripe_nr;
	u64 stripe_offset;
	u64 raid56_stripe_offset;
};

struct btrfs_subpage {
	spinlock_t lock;
	u16 uptodate_bitmap;
	u16 error_bitmap;
	u16 dirty_bitmap;
	u16 writeback_bitmap;
	atomic_t readers;
	union {
		atomic_t eb_refs;
		struct {
			atomic_t writers;
			u16 ordered_bitmap;
		};
	};
};

struct btrfs_iget_args {
	u64 ino;
	struct btrfs_root *root;
};

struct btrfs_dio_data {
	ssize_t submitted;
	struct extent_changeset *data_reserved;
};

struct async_extent {
	u64 start;
	u64 ram_size;
	u64 compressed_size;
	struct page **pages;
	long unsigned int nr_pages;
	int compress_type;
	struct list_head list;
};

struct async_chunk {
	struct inode *inode;
	struct page *locked_page;
	u64 start;
	u64 end;
	unsigned int write_flags;
	struct list_head extents;
	struct cgroup_subsys_state *blkcg_css;
	struct btrfs_work work;
	atomic_t *pending;
};

struct async_cow {
	atomic_t num_chunks;
	struct async_chunk chunks[0];
};

struct btrfs_writepage_fixup {
	struct page *page;
	struct inode *inode;
	struct btrfs_work work;
};

struct dir_entry___2 {
	u64 ino;
	u64 offset;
	unsigned int type;
	int name_len;
};

struct btrfs_delalloc_work {
	struct inode *inode;
	struct completion completion;
	struct list_head list;
	struct btrfs_work work;
};

struct btrfs_swap_info {
	u64 start;
	u64 block_start;
	u64 block_len;
	u64 lowest_ppage;
	u64 highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

struct btrfs_ioctl_defrag_range_args {
	__u64 start;
	__u64 len;
	__u64 flags;
	__u32 extent_thresh;
	__u32 compress_type;
	__u32 unused[4];
};

struct btrfs_log_ctx {
	int log_ret;
	int log_transid;
	bool log_new_dentries;
	bool logging_new_name;
	struct inode *inode;
	struct list_head list;
	struct list_head ordered_extents;
};

struct inode_defrag {
	struct rb_node rb_node;
	u64 ino;
	u64 transid;
	u64 root;
	u64 last_offset;
	int cycled;
};

struct falloc_range {
	struct list_head list;
	u64 start;
	u64 len;
};

enum {
	RANGE_BOUNDARY_WRITTEN_EXTENT = 0,
	RANGE_BOUNDARY_PREALLOC_EXTENT = 1,
	RANGE_BOUNDARY_HOLE = 2,
};

enum btrfs_feature_set {
	FEAT_COMPAT = 0,
	FEAT_COMPAT_RO = 1,
	FEAT_INCOMPAT = 2,
	FEAT_MAX = 3,
};

struct btrfs_feature_attr {
	struct kobj_attribute kobj_attr;
	enum btrfs_feature_set feature_set;
	u64 feature_bit;
};

struct raid_kobject {
	u64 flags;
	struct kobject kobj;
};

enum btrfs_subpage_type {
	BTRFS_SUBPAGE_METADATA = 0,
	BTRFS_SUBPAGE_DATA = 1,
};

struct tree_entry {
	u64 start;
	u64 end;
	struct rb_node rb_node;
};

struct extent_page_data {
	struct btrfs_bio_ctrl bio_ctrl;
	unsigned int extent_locked: 1;
	unsigned int sync_io: 1;
};

struct processed_extent {
	struct btrfs_inode *inode;
	u64 start;
	u64 end;
	bool uptodate;
};

struct fiemap_cache {
	u64 offset;
	u64 phys;
	u64 len;
	u32 flags;
	bool cached;
};

struct btrfs_ioctl_balance_args {
	__u64 flags;
	__u64 state;
	struct btrfs_balance_args data;
	struct btrfs_balance_args meta;
	struct btrfs_balance_args sys;
	struct btrfs_balance_progress stat;
	__u64 unused[72];
};

struct btrfs_ioctl_get_dev_stats {
	__u64 devid;
	__u64 nr_items;
	__u64 flags;
	__u64 values[5];
	__u64 unused[121];
};

enum btrfs_err_code {
	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET = 1,
	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET = 2,
	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET = 3,
	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET = 4,
	BTRFS_ERROR_DEV_TGT_REPLACE = 5,
	BTRFS_ERROR_DEV_MISSING_NOT_FOUND = 6,
	BTRFS_ERROR_DEV_ONLY_WRITABLE = 7,
	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS = 8,
	BTRFS_ERROR_DEV_RAID1C3_MIN_NOT_MET = 9,
	BTRFS_ERROR_DEV_RAID1C4_MIN_NOT_MET = 10,
};

struct btrfs_disk_balance_args {
	__le64 profiles;
	union {
		__le64 usage;
		struct {
			__le32 usage_min;
			__le32 usage_max;
		};
	};
	__le64 devid;
	__le64 pstart;
	__le64 pend;
	__le64 vstart;
	__le64 vend;
	__le64 target;
	__le64 flags;
	union {
		__le64 limit;
		struct {
			__le32 limit_min;
			__le32 limit_max;
		};
	};
	__le32 stripes_min;
	__le32 stripes_max;
	__le64 unused[6];
};

struct btrfs_balance_item {
	__le64 flags;
	struct btrfs_disk_balance_args data;
	struct btrfs_disk_balance_args meta;
	struct btrfs_disk_balance_args sys;
	__le64 unused[4];
};

struct btrfs_dev_stats_item {
	__le64 values[5];
};

struct btrfs_dev_lookup_args {
	u64 devid;
	u8 *uuid;
	u8 *fsid;
	bool missing;
};

struct alloc_chunk_ctl {
	u64 start;
	u64 type;
	int num_stripes;
	int sub_stripes;
	int dev_stripes;
	int devs_max;
	int devs_min;
	int devs_increment;
	int ncopies;
	int nparity;
	u64 max_stripe_size;
	u64 max_chunk_size;
	u64 dev_extent_min;
	u64 stripe_size;
	u64 chunk_size;
	int ndevs;
};

struct btrfs_workqueue {
	struct __btrfs_workqueue *normal;
	struct __btrfs_workqueue *high;
};

enum {
	WORK_DONE_BIT = 0,
	WORK_ORDER_DONE_BIT = 1,
	WORK_HIGH_PRIO_BIT = 2,
};

struct btrfs_ioctl_qgroup_limit_args {
	__u64 qgroupid;
	struct btrfs_qgroup_limit lim;
};

struct btrfs_ioctl_vol_args_v2 {
	__s64 fd;
	__u64 transid;
	__u64 flags;
	union {
		struct {
			__u64 size;
			struct btrfs_qgroup_inherit *qgroup_inherit;
		};
		__u64 unused[4];
	};
	union {
		char name[4040];
		__u64 devid;
		__u64 subvolid;
	};
};

struct btrfs_ioctl_scrub_args {
	__u64 devid;
	__u64 start;
	__u64 end;
	__u64 flags;
	struct btrfs_scrub_progress progress;
	__u64 unused[109];
};

struct btrfs_ioctl_dev_replace_start_params {
	__u64 srcdevid;
	__u64 cont_reading_from_srcdev_mode;
	__u8 srcdev_name[1025];
	__u8 tgtdev_name[1025];
};

struct btrfs_ioctl_dev_replace_status_params {
	__u64 replace_state;
	__u64 progress_1000;
	__u64 time_started;
	__u64 time_stopped;
	__u64 num_write_errors;
	__u64 num_uncorrectable_read_errors;
};

struct btrfs_ioctl_dev_replace_args {
	__u64 cmd;
	__u64 result;
	union {
		struct btrfs_ioctl_dev_replace_start_params start;
		struct btrfs_ioctl_dev_replace_status_params status;
	};
	__u64 spare[64];
};

struct btrfs_ioctl_dev_info_args {
	__u64 devid;
	__u8 uuid[16];
	__u64 bytes_used;
	__u64 total_bytes;
	__u64 unused[379];
	__u8 path[1024];
};

struct btrfs_ioctl_fs_info_args {
	__u64 max_id;
	__u64 num_devices;
	__u8 fsid[16];
	__u32 nodesize;
	__u32 sectorsize;
	__u32 clone_alignment;
	__u16 csum_type;
	__u16 csum_size;
	__u64 flags;
	__u64 generation;
	__u8 metadata_uuid[16];
	__u8 reserved[944];
};

struct btrfs_ioctl_feature_flags {
	__u64 compat_flags;
	__u64 compat_ro_flags;
	__u64 incompat_flags;
};

struct btrfs_ioctl_ino_lookup_args {
	__u64 treeid;
	__u64 objectid;
	char name[4080];
};

struct btrfs_ioctl_ino_lookup_user_args {
	__u64 dirid;
	__u64 treeid;
	char name[256];
	char path[3824];
};

struct btrfs_ioctl_search_key {
	__u64 tree_id;
	__u64 min_objectid;
	__u64 max_objectid;
	__u64 min_offset;
	__u64 max_offset;
	__u64 min_transid;
	__u64 max_transid;
	__u32 min_type;
	__u32 max_type;
	__u32 nr_items;
	__u32 unused;
	__u64 unused1;
	__u64 unused2;
	__u64 unused3;
	__u64 unused4;
};

struct btrfs_ioctl_search_header {
	__u64 transid;
	__u64 objectid;
	__u64 offset;
	__u32 type;
	__u32 len;
};

struct btrfs_ioctl_search_args {
	struct btrfs_ioctl_search_key key;
	char buf[3992];
};

struct btrfs_ioctl_search_args_v2 {
	struct btrfs_ioctl_search_key key;
	__u64 buf_size;
	__u64 buf[0];
};

struct btrfs_ioctl_space_info {
	__u64 flags;
	__u64 total_bytes;
	__u64 used_bytes;
};

struct btrfs_ioctl_space_args {
	__u64 space_slots;
	__u64 total_spaces;
	struct btrfs_ioctl_space_info spaces[0];
};

struct btrfs_data_container {
	__u32 bytes_left;
	__u32 bytes_missing;
	__u32 elem_cnt;
	__u32 elem_missed;
	__u64 val[0];
};

struct btrfs_ioctl_ino_path_args {
	__u64 inum;
	__u64 size;
	__u64 reserved[4];
	__u64 fspath;
};

struct btrfs_ioctl_logical_ino_args {
	__u64 logical;
	__u64 size;
	__u64 reserved[3];
	__u64 flags;
	__u64 inodes;
};

struct btrfs_ioctl_quota_ctl_args {
	__u64 cmd;
	__u64 status;
};

struct btrfs_ioctl_quota_rescan_args {
	__u64 flags;
	__u64 progress;
	__u64 reserved[6];
};

struct btrfs_ioctl_qgroup_assign_args {
	__u64 assign;
	__u64 src;
	__u64 dst;
};

struct btrfs_ioctl_qgroup_create_args {
	__u64 create;
	__u64 qgroupid;
};

struct btrfs_ioctl_timespec {
	__u64 sec;
	__u32 nsec;
};

struct btrfs_ioctl_received_subvol_args {
	char uuid[16];
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec stime;
	struct btrfs_ioctl_timespec rtime;
	__u64 flags;
	__u64 reserved[16];
};

struct btrfs_ioctl_send_args {
	__s64 send_fd;
	__u64 clone_sources_count;
	__u64 *clone_sources;
	__u64 parent_root;
	__u64 flags;
	__u64 reserved[4];
};

struct btrfs_ioctl_get_subvol_info_args {
	__u64 treeid;
	char name[256];
	__u64 parent_id;
	__u64 dirid;
	__u64 generation;
	__u64 flags;
	__u8 uuid[16];
	__u8 parent_uuid[16];
	__u8 received_uuid[16];
	__u64 ctransid;
	__u64 otransid;
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec ctime;
	struct btrfs_ioctl_timespec otime;
	struct btrfs_ioctl_timespec stime;
	struct btrfs_ioctl_timespec rtime;
	__u64 reserved[8];
};

struct btrfs_ioctl_get_subvol_rootref_args {
	__u64 min_treeid;
	struct {
		__u64 treeid;
		__u64 dirid;
	} rootref[255];
	__u8 num_items;
	__u8 align[7];
};

struct inode_fs_paths {
	struct btrfs_path *btrfs_path;
	struct btrfs_root *fs_root;
	struct btrfs_data_container *fspath;
};

struct btrfs_ioctl_timespec_32 {
	__u64 sec;
	__u32 nsec;
} __attribute__((packed));

struct btrfs_ioctl_received_subvol_args_32 {
	char uuid[16];
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec_32 stime;
	struct btrfs_ioctl_timespec_32 rtime;
	__u64 flags;
	__u64 reserved[16];
};

struct btrfs_fid {
	u64 objectid;
	u64 root_objectid;
	u32 gen;
	u64 parent_objectid;
	u32 parent_gen;
	u64 parent_root_objectid;
} __attribute__((packed));

struct btrfs_dir_log_item {
	__le64 end;
};

enum {
	LOG_INODE_ALL = 0,
	LOG_INODE_EXISTS = 1,
	LOG_OTHER_INODE = 2,
	LOG_OTHER_INODE_ALL = 3,
};

enum {
	LOG_WALK_PIN_ONLY = 0,
	LOG_WALK_REPLAY_INODES = 1,
	LOG_WALK_REPLAY_DIR_INDEX = 2,
	LOG_WALK_REPLAY_ALL = 3,
};

struct walk_control___2 {
	int free;
	int write;
	int wait;
	int pin;
	int stage;
	bool ignore_cur_inode;
	struct btrfs_root *replay_dest;
	struct btrfs_trans_handle *trans;
	int (*process_func)(struct btrfs_root *, struct extent_buffer *, struct walk_control___2 *, u64, int);
};

struct btrfs_ino_list {
	u64 ino;
	u64 parent;
	struct list_head list;
};

struct btrfs_dir_list {
	u64 ino;
	struct list_head list;
};

struct btrfs_free_space_entry {
	__le64 offset;
	__le64 bytes;
	__u8 type;
} __attribute__((packed));

struct btrfs_free_space_header {
	struct btrfs_disk_key location;
	__le64 generation;
	__le64 num_entries;
	__le64 num_bitmaps;
} __attribute__((packed));

struct btrfs_trim_range {
	u64 start;
	u64 bytes;
	struct list_head list;
};

struct compressed_bio {
	refcount_t pending_bios;
	unsigned int nr_pages;
	struct page **compressed_pages;
	struct inode *inode;
	u64 start;
	unsigned int len;
	unsigned int compressed_len;
	u8 compress_type;
	u8 errors;
	int mirror_num;
	struct bio *orig_bio;
	u8 sums[0];
};

struct workspace_manager {
	struct list_head idle_ws;
	spinlock_t ws_lock;
	int free_ws;
	atomic_t total_ws;
	wait_queue_head_t ws_wait;
};

struct btrfs_compress_op {
	struct workspace_manager *workspace_manager;
	unsigned int max_level;
	unsigned int default_level;
};

struct workspace {
	z_stream strm;
	char *buf;
	unsigned int buf_size;
	struct list_head list;
	int level;
};

struct workspace___2 {
	void *mem;
	void *buf;
	void *cbuf;
	struct list_head list;
};

enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 2,
	ZSTD_error_version_unsupported = 3,
	ZSTD_error_parameter_unknown = 4,
	ZSTD_error_frameParameter_unsupported = 5,
	ZSTD_error_frameParameter_unsupportedBy32bits = 6,
	ZSTD_error_frameParameter_windowTooLarge = 7,
	ZSTD_error_compressionParameter_unsupported = 8,
	ZSTD_error_init_missing = 9,
	ZSTD_error_memory_allocation = 10,
	ZSTD_error_stage_wrong = 11,
	ZSTD_error_dstSize_tooSmall = 12,
	ZSTD_error_srcSize_wrong = 13,
	ZSTD_error_corruption_detected = 14,
	ZSTD_error_checksum_wrong = 15,
	ZSTD_error_tableLog_tooLarge = 16,
	ZSTD_error_maxSymbolValue_tooLarge = 17,
	ZSTD_error_maxSymbolValue_tooSmall = 18,
	ZSTD_error_dictionary_corrupted = 19,
	ZSTD_error_dictionary_wrong = 20,
	ZSTD_error_dictionaryCreation_failed = 21,
	ZSTD_error_maxCode = 22,
};

typedef enum {
	ZSTD_fast = 0,
	ZSTD_dfast = 1,
	ZSTD_greedy = 2,
	ZSTD_lazy = 3,
	ZSTD_lazy2 = 4,
	ZSTD_btlazy2 = 5,
	ZSTD_btopt = 6,
	ZSTD_btopt2 = 7,
} ZSTD_strategy;

typedef struct {
	unsigned int windowLog;
	unsigned int chainLog;
	unsigned int hashLog;
	unsigned int searchLog;
	unsigned int searchLength;
	unsigned int targetLength;
	ZSTD_strategy strategy;
} ZSTD_compressionParameters;

typedef struct {
	unsigned int contentSizeFlag;
	unsigned int checksumFlag;
	unsigned int noDictIDFlag;
} ZSTD_frameParameters;

typedef struct {
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
} ZSTD_parameters;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

typedef enum {
	zcss_init = 0,
	zcss_load = 1,
	zcss_flush = 2,
	zcss_final = 3,
} ZSTD_cStreamStage;

typedef uint32_t U32;

typedef uint64_t U64;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

struct ZSTD_CCtx_s;

typedef struct ZSTD_CCtx_s ZSTD_CCtx;

struct ZSTD_CDict_s;

typedef struct ZSTD_CDict_s ZSTD_CDict;

struct ZSTD_CStream_s {
	ZSTD_CCtx *cctx;
	ZSTD_CDict *cdictLocal;
	const ZSTD_CDict *cdict;
	char *inBuff;
	size_t inBuffSize;
	size_t inToCompress;
	size_t inBuffPos;
	size_t inBuffTarget;
	size_t blockSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outBuffContentSize;
	size_t outBuffFlushedSize;
	ZSTD_cStreamStage stage;
	U32 checksum;
	U32 frameEnded;
	U64 pledgedSrcSize;
	U64 inputProcessed;
	ZSTD_parameters params;
	ZSTD_customMem customMem;
};

typedef struct ZSTD_CStream_s ZSTD_CStream;

typedef struct {
	long long unsigned int frameContentSize;
	unsigned int windowSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameParams;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

typedef uint8_t BYTE;

struct ZSTD_DCtx_s;

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

struct ZSTD_DDict_s;

typedef struct ZSTD_DDict_s ZSTD_DDict;

struct ZSTD_DStream_s {
	ZSTD_DCtx *dctx;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	ZSTD_frameParams fParams;
	ZSTD_dStreamStage stage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t blockSize;
	BYTE headerBuffer[18];
	size_t lhSize;
	ZSTD_customMem customMem;
	void *legacyContext;
	U32 previousLegacyVersion;
	U32 legacyVersion;
	U32 hostageByte;
};

typedef struct ZSTD_DStream_s ZSTD_DStream;

struct workspace___3 {
	void *mem;
	size_t size;
	char *buf;
	unsigned int level;
	unsigned int req_level;
	long unsigned int last_used;
	struct list_head list;
	struct list_head lru_list;
	ZSTD_inBuffer in_buf;
	ZSTD_outBuffer out_buf;
};

struct zstd_workspace_manager {
	const struct btrfs_compress_op *ops;
	spinlock_t lock;
	struct list_head lru_list;
	struct list_head idle_ws[15];
	long unsigned int active_map;
	wait_queue_head_t wait;
	struct timer_list timer;
};

struct bucket_item {
	u32 count;
};

struct heuristic_ws {
	u8 *sample;
	u32 sample_size;
	struct bucket_item *bucket;
	struct bucket_item *bucket_b;
	struct list_head list;
};

struct ulist_iterator {
	struct list_head *cur_list;
};

struct ulist_node {
	u64 val;
	u64 aux;
	struct list_head list;
	struct rb_node rb_node;
};

struct btrfs_backref_node;

struct btrfs_backref_cache {
	struct rb_root rb_root;
	struct btrfs_backref_node *path[8];
	struct list_head pending[8];
	struct list_head leaves;
	struct list_head changed;
	struct list_head detached;
	u64 last_trans;
	int nr_nodes;
	int nr_edges;
	struct list_head pending_edge;
	struct list_head useless_node;
	struct btrfs_fs_info *fs_info;
	unsigned int is_reloc;
};

struct file_extent_cluster {
	u64 start;
	u64 end;
	u64 boundary[128];
	unsigned int nr;
};

struct mapping_tree {
	struct rb_root rb_root;
	spinlock_t lock;
};

struct reloc_control {
	struct btrfs_block_group *block_group;
	struct btrfs_root *extent_root;
	struct inode *data_inode;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_backref_cache backref_cache;
	struct file_extent_cluster cluster;
	struct extent_io_tree processed_blocks;
	struct mapping_tree reloc_root_tree;
	struct list_head reloc_roots;
	struct list_head dirty_subvol_roots;
	u64 merging_rsv_size;
	u64 nodes_relocated;
	u64 reserved_bytes;
	u64 search_start;
	u64 extents_found;
	unsigned int stage: 8;
	unsigned int create_reloc_tree: 1;
	unsigned int merge_reloc_tree: 1;
	unsigned int found_file_extent: 1;
};

struct btrfs_backref_iter {
	u64 bytenr;
	struct btrfs_path *path;
	struct btrfs_fs_info *fs_info;
	struct btrfs_key cur_key;
	u32 item_ptr;
	u32 cur_ptr;
	u32 end_ptr;
};

struct btrfs_backref_node {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	u64 new_bytenr;
	u64 owner;
	struct list_head list;
	struct list_head upper;
	struct list_head lower;
	struct btrfs_root *root;
	struct extent_buffer *eb;
	unsigned int level: 8;
	unsigned int cowonly: 1;
	unsigned int lowest: 1;
	unsigned int locked: 1;
	unsigned int processed: 1;
	unsigned int checked: 1;
	unsigned int pending: 1;
	unsigned int detached: 1;
	unsigned int is_reloc_root: 1;
};

struct btrfs_backref_edge {
	struct list_head list[2];
	struct btrfs_backref_node *node[2];
};

struct rb_simple_node {
	struct rb_node rb_node;
	u64 bytenr;
};

struct mapping_node {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	void *data;
};

struct tree_block {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	u64 owner;
	struct btrfs_key key;
	unsigned int level: 8;
	unsigned int key_ready: 1;
};

struct btrfs_delayed_item {
	struct rb_node rb_node;
	struct btrfs_key key;
	struct list_head tree_list;
	struct list_head readdir_list;
	u64 bytes_reserved;
	struct btrfs_delayed_node *delayed_node;
	refcount_t refs;
	int ins_or_del;
	u32 data_len;
	char data[0];
};

struct btrfs_async_delayed_work {
	struct btrfs_delayed_root *delayed_root;
	int nr;
	struct btrfs_work work;
};

struct reada_control {
	struct btrfs_fs_info *fs_info;
	struct btrfs_key key_start;
	struct btrfs_key key_end;
	atomic_t elems;
	struct kref refcnt;
	wait_queue_head_t wait;
};

struct scrub_bio;

struct scrub_ctx {
	struct scrub_bio *bios[64];
	struct btrfs_fs_info *fs_info;
	int first_free;
	int curr;
	atomic_t bios_in_flight;
	atomic_t workers_pending;
	spinlock_t list_lock;
	wait_queue_head_t list_wait;
	struct list_head csum_list;
	atomic_t cancel_req;
	int readonly;
	int pages_per_rd_bio;
	ktime_t throttle_deadline;
	u64 throttle_sent;
	int is_dev_replace;
	u64 write_pointer;
	struct scrub_bio *wr_curr_bio;
	struct mutex wr_lock;
	int pages_per_wr_bio;
	struct btrfs_device *wr_tgtdev;
	bool flush_all_writes;
	struct btrfs_scrub_progress stat;
	spinlock_t stat_lock;
	refcount_t refs;
};

typedef int iterate_extent_inodes_t(u64, u64, u64, void *);

struct scrub_recover {
	refcount_t refs;
	struct btrfs_io_context *bioc;
	u64 map_length;
};

struct scrub_block;

struct scrub_page {
	struct scrub_block *sblock;
	struct page *page;
	struct btrfs_device *dev;
	struct list_head list;
	u64 flags;
	u64 generation;
	u64 logical;
	u64 physical;
	u64 physical_for_dev_replace;
	atomic_t refs;
	u8 mirror_num;
	unsigned int have_csum: 1;
	unsigned int io_error: 1;
	u8 csum[32];
	struct scrub_recover *recover;
};

struct scrub_parity;

struct scrub_block {
	struct scrub_page *pagev[16];
	int page_count;
	atomic_t outstanding_pages;
	refcount_t refs;
	struct scrub_ctx *sctx;
	struct scrub_parity *sparity;
	struct {
		unsigned int header_error: 1;
		unsigned int checksum_error: 1;
		unsigned int no_io_error_seen: 1;
		unsigned int generation_error: 1;
		unsigned int data_corrected: 1;
	};
	struct btrfs_work work;
};

struct scrub_bio {
	int index;
	struct scrub_ctx *sctx;
	struct btrfs_device *dev;
	struct bio *bio;
	blk_status_t status;
	u64 logical;
	u64 physical;
	struct scrub_page *pagev[32];
	int page_count;
	int next_free;
	struct btrfs_work work;
};

struct scrub_parity {
	struct scrub_ctx *sctx;
	struct btrfs_device *scrub_dev;
	u64 logic_start;
	u64 logic_end;
	int nsectors;
	u32 stripe_len;
	refcount_t refs;
	struct list_head spages;
	struct btrfs_work work;
	long unsigned int *dbitmap;
	long unsigned int *ebitmap;
	long unsigned int bitmap[0];
};

struct scrub_warning {
	struct btrfs_path *path;
	u64 extent_item_size;
	const char *errstr;
	u64 physical;
	u64 logical;
	struct btrfs_device *dev;
};

struct full_stripe_lock {
	struct rb_node node;
	u64 logical;
	u64 refs;
	struct mutex mutex;
};

struct reada_zone {
	u64 start;
	u64 end;
	u64 elems;
	struct list_head list;
	spinlock_t lock;
	int locked;
	struct btrfs_device *device;
	struct btrfs_device *devs[5];
	int ndevs;
	struct kref refcnt;
};

struct reada_extctl {
	struct list_head list;
	struct reada_control *rc;
	u64 generation;
};

struct reada_extent {
	u64 logical;
	u64 owner_root;
	struct btrfs_key top;
	struct list_head extctl;
	int refcnt;
	spinlock_t lock;
	struct reada_zone *zones[5];
	int nzones;
	int scheduled;
	int level;
};

struct reada_machine_work {
	struct btrfs_work work;
	struct btrfs_fs_info *fs_info;
};

struct extent_inode_elem {
	u64 inum;
	u64 offset;
	struct extent_inode_elem *next;
};

struct btrfs_seq_list {
	struct list_head list;
	u64 seq;
};

struct preftree {
	struct rb_root_cached root;
	unsigned int count;
};

struct preftrees {
	struct preftree direct;
	struct preftree indirect;
	struct preftree indirect_missing_keys;
};

struct share_check {
	u64 root_objectid;
	u64 inum;
	int share_count;
	bool have_delayed_delete_refs;
};

typedef int iterate_irefs_t(u64, u32, long unsigned int, struct extent_buffer *, void *);

struct btrfs_qgroup_status_item {
	__le64 version;
	__le64 generation;
	__le64 flags;
	__le64 rescan;
};

struct btrfs_qgroup_info_item {
	__le64 generation;
	__le64 rfer;
	__le64 rfer_cmpr;
	__le64 excl;
	__le64 excl_cmpr;
};

struct btrfs_qgroup_limit_item {
	__le64 flags;
	__le64 max_rfer;
	__le64 max_excl;
	__le64 rsv_rfer;
	__le64 rsv_excl;
};

struct btrfs_qgroup_swapped_block {
	struct rb_node node;
	int level;
	bool trace_leaf;
	u64 subvol_bytenr;
	u64 subvol_generation;
	u64 reloc_bytenr;
	u64 reloc_generation;
	u64 last_snapshot;
	struct btrfs_key first_key;
};

struct btrfs_qgroup_list {
	struct list_head next_group;
	struct list_head next_member;
	struct btrfs_qgroup *group;
	struct btrfs_qgroup *member;
};

struct btrfs_stream_header {
	char magic[13];
	__le32 version;
} __attribute__((packed));

struct btrfs_cmd_header {
	__le32 len;
	__le16 cmd;
	__le32 crc;
} __attribute__((packed));

struct btrfs_tlv_header {
	__le16 tlv_type;
	__le16 tlv_len;
};

enum btrfs_send_cmd {
	BTRFS_SEND_C_UNSPEC = 0,
	BTRFS_SEND_C_SUBVOL = 1,
	BTRFS_SEND_C_SNAPSHOT = 2,
	BTRFS_SEND_C_MKFILE = 3,
	BTRFS_SEND_C_MKDIR = 4,
	BTRFS_SEND_C_MKNOD = 5,
	BTRFS_SEND_C_MKFIFO = 6,
	BTRFS_SEND_C_MKSOCK = 7,
	BTRFS_SEND_C_SYMLINK = 8,
	BTRFS_SEND_C_RENAME = 9,
	BTRFS_SEND_C_LINK = 10,
	BTRFS_SEND_C_UNLINK = 11,
	BTRFS_SEND_C_RMDIR = 12,
	BTRFS_SEND_C_SET_XATTR = 13,
	BTRFS_SEND_C_REMOVE_XATTR = 14,
	BTRFS_SEND_C_WRITE = 15,
	BTRFS_SEND_C_CLONE = 16,
	BTRFS_SEND_C_TRUNCATE = 17,
	BTRFS_SEND_C_CHMOD = 18,
	BTRFS_SEND_C_CHOWN = 19,
	BTRFS_SEND_C_UTIMES = 20,
	BTRFS_SEND_C_END = 21,
	BTRFS_SEND_C_UPDATE_EXTENT = 22,
	__BTRFS_SEND_C_MAX = 23,
};

enum {
	BTRFS_SEND_A_UNSPEC = 0,
	BTRFS_SEND_A_UUID = 1,
	BTRFS_SEND_A_CTRANSID = 2,
	BTRFS_SEND_A_INO = 3,
	BTRFS_SEND_A_SIZE = 4,
	BTRFS_SEND_A_MODE = 5,
	BTRFS_SEND_A_UID = 6,
	BTRFS_SEND_A_GID = 7,
	BTRFS_SEND_A_RDEV = 8,
	BTRFS_SEND_A_CTIME = 9,
	BTRFS_SEND_A_MTIME = 10,
	BTRFS_SEND_A_ATIME = 11,
	BTRFS_SEND_A_OTIME = 12,
	BTRFS_SEND_A_XATTR_NAME = 13,
	BTRFS_SEND_A_XATTR_DATA = 14,
	BTRFS_SEND_A_PATH = 15,
	BTRFS_SEND_A_PATH_TO = 16,
	BTRFS_SEND_A_PATH_LINK = 17,
	BTRFS_SEND_A_FILE_OFFSET = 18,
	BTRFS_SEND_A_DATA = 19,
	BTRFS_SEND_A_CLONE_UUID = 20,
	BTRFS_SEND_A_CLONE_CTRANSID = 21,
	BTRFS_SEND_A_CLONE_PATH = 22,
	BTRFS_SEND_A_CLONE_OFFSET = 23,
	BTRFS_SEND_A_CLONE_LEN = 24,
	__BTRFS_SEND_A_MAX = 25,
};

struct fs_path {
	union {
		struct {
			char *start;
			char *end;
			char *buf;
			short unsigned int buf_len: 15;
			short unsigned int reversed: 1;
			char inline_buf[0];
		};
		char pad[256];
	};
};

struct clone_root {
	struct btrfs_root *root;
	u64 ino;
	u64 offset;
	u64 found_refs;
};

struct send_ctx {
	struct file *send_filp;
	loff_t send_off;
	char *send_buf;
	u32 send_size;
	u32 send_max_size;
	u64 total_send_size;
	u64 cmd_send_size[23];
	u64 flags;
	struct btrfs_root *send_root;
	struct btrfs_root *parent_root;
	struct clone_root *clone_roots;
	int clone_roots_cnt;
	struct btrfs_path *left_path;
	struct btrfs_path *right_path;
	struct btrfs_key *cmp_key;
	u64 last_reloc_trans;
	u64 cur_ino;
	u64 cur_inode_gen;
	int cur_inode_new;
	int cur_inode_new_gen;
	int cur_inode_deleted;
	u64 cur_inode_size;
	u64 cur_inode_mode;
	u64 cur_inode_rdev;
	u64 cur_inode_last_extent;
	u64 cur_inode_next_write_offset;
	bool ignore_cur_inode;
	u64 send_progress;
	struct list_head new_refs;
	struct list_head deleted_refs;
	struct xarray name_cache;
	struct list_head name_cache_list;
	int name_cache_size;
	struct file_ra_state ra;
	struct rb_root pending_dir_moves;
	struct rb_root waiting_dir_moves;
	struct rb_root orphan_dirs;
};

struct pending_dir_move {
	struct rb_node node;
	struct list_head list;
	u64 parent_ino;
	u64 ino;
	u64 gen;
	struct list_head update_refs;
};

struct waiting_dir_move {
	struct rb_node node;
	u64 ino;
	u64 rmdir_ino;
	u64 rmdir_gen;
	bool orphanized;
};

struct orphan_dir_info {
	struct rb_node node;
	u64 ino;
	u64 gen;
	u64 last_dir_index_offset;
};

struct name_cache_entry {
	struct list_head list;
	struct list_head radix_list;
	u64 ino;
	u64 gen;
	u64 parent_ino;
	u64 parent_gen;
	int ret;
	int need_later_update;
	int name_len;
	char name[0];
};

enum btrfs_compare_tree_result {
	BTRFS_COMPARE_TREE_NEW = 0,
	BTRFS_COMPARE_TREE_DELETED = 1,
	BTRFS_COMPARE_TREE_CHANGED = 2,
	BTRFS_COMPARE_TREE_SAME = 3,
};

typedef int (*iterate_inode_ref_t)(int, u64, int, struct fs_path *, void *);

typedef int (*iterate_dir_item_t)(int, struct btrfs_key *, const char *, int, const char *, int, u8, void *);

struct backref_ctx {
	struct send_ctx *sctx;
	u64 found;
	u64 cur_objectid;
	u64 cur_offset;
	u64 extent_len;
	int found_itself;
};

enum inode_state {
	inode_state_no_change = 0,
	inode_state_will_create = 1,
	inode_state_did_create = 2,
	inode_state_will_delete = 3,
	inode_state_did_delete = 4,
};

struct recorded_ref {
	struct list_head list;
	char *name;
	struct fs_path *full_path;
	u64 dir;
	u64 dir_gen;
	int name_len;
};

struct find_ref_ctx {
	u64 dir;
	u64 dir_gen;
	struct btrfs_root *root;
	struct fs_path *name;
	int found_idx;
};

struct find_xattr_ctx {
	const char *name;
	int name_len;
	int found_idx;
	char *found_data;
	int found_data_len;
};

struct parent_paths_ctx {
	struct list_head *refs;
	struct send_ctx *sctx;
};

struct btrfs_dev_replace_item {
	__le64 src_devid;
	__le64 cursor_left;
	__le64 cursor_right;
	__le64 cont_reading_from_srcdev_mode;
	__le64 replace_state;
	__le64 time_started;
	__le64 time_stopped;
	__le64 num_write_errors;
	__le64 num_uncorrectable_read_errors;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

struct raid6_calls {
	void (*gen_syndrome)(int, size_t, void **);
	void (*xor_syndrome)(int, int, int, size_t, void **);
	int (*valid)();
	const char *name;
	int prefer;
};

struct btrfs_stripe_hash {
	struct list_head hash_list;
	spinlock_t lock;
};

struct btrfs_stripe_hash_table {
	struct list_head stripe_cache;
	spinlock_t cache_lock;
	int cache_size;
	struct btrfs_stripe_hash table[0];
};

enum btrfs_rbio_ops {
	BTRFS_RBIO_WRITE = 0,
	BTRFS_RBIO_READ_REBUILD = 1,
	BTRFS_RBIO_PARITY_SCRUB = 2,
	BTRFS_RBIO_REBUILD_MISSING = 3,
};

struct btrfs_raid_bio {
	struct btrfs_fs_info *fs_info;
	struct btrfs_io_context *bioc;
	struct list_head hash_list;
	struct list_head stripe_cache;
	struct btrfs_work work;
	struct bio_list bio_list;
	spinlock_t bio_list_lock;
	struct list_head plug_list;
	long unsigned int flags;
	int stripe_len;
	int nr_data;
	int real_stripes;
	int stripe_npages;
	enum btrfs_rbio_ops operation;
	int faila;
	int failb;
	int scrubp;
	int nr_pages;
	int bio_list_bytes;
	int generic_bio_cnt;
	refcount_t refs;
	atomic_t stripes_pending;
	atomic_t error;
	struct page **stripe_pages;
	struct page **bio_pages;
	long unsigned int *dbitmap;
	void **finish_pointers;
	long unsigned int *finish_pbitmap;
};

struct btrfs_plug_cb {
	struct blk_plug_cb cb;
	struct btrfs_fs_info *info;
	struct list_head rbio_list;
	struct btrfs_work work;
};

struct prop_handler {
	struct hlist_node node;
	const char *xattr_name;
	int (*validate)(const char *, size_t);
	int (*apply)(struct inode *, const char *, size_t);
	const char * (*extract)(struct inode *);
	int inheritable;
};

struct btrfs_free_space_info {
	__le32 extent_count;
	__le32 flags;
};

struct reserve_ticket {
	u64 bytes;
	int error;
	bool steal;
	struct list_head list;
	wait_queue_head_t wait;
};

struct tree_mod_root {
	u64 logical;
	u8 level;
};

struct tree_mod_elem {
	struct rb_node node;
	u64 logical;
	u64 seq;
	enum btrfs_mod_log_op op;
	int slot;
	u64 generation;
	struct btrfs_disk_key key;
	u64 blockptr;
	struct {
		int dst_slot;
		int nr_items;
	} move;
	struct tree_mod_root old_root;
};

struct f2fs_device {
	__u8 path[64];
	__le32 total_segments;
};

struct f2fs_super_block {
	__le32 magic;
	__le16 major_ver;
	__le16 minor_ver;
	__le32 log_sectorsize;
	__le32 log_sectors_per_block;
	__le32 log_blocksize;
	__le32 log_blocks_per_seg;
	__le32 segs_per_sec;
	__le32 secs_per_zone;
	__le32 checksum_offset;
	__le64 block_count;
	__le32 section_count;
	__le32 segment_count;
	__le32 segment_count_ckpt;
	__le32 segment_count_sit;
	__le32 segment_count_nat;
	__le32 segment_count_ssa;
	__le32 segment_count_main;
	__le32 segment0_blkaddr;
	__le32 cp_blkaddr;
	__le32 sit_blkaddr;
	__le32 nat_blkaddr;
	__le32 ssa_blkaddr;
	__le32 main_blkaddr;
	__le32 root_ino;
	__le32 node_ino;
	__le32 meta_ino;
	__u8 uuid[16];
	__le16 volume_name[512];
	__le32 extension_count;
	__u8 extension_list[512];
	__le32 cp_payload;
	__u8 version[256];
	__u8 init_version[256];
	__le32 feature;
	__u8 encryption_level;
	__u8 encrypt_pw_salt[16];
	struct f2fs_device devs[8];
	__le32 qf_ino[3];
	__u8 hot_ext_count;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__u8 reserved[306];
	__le32 crc;
} __attribute__((packed));

struct f2fs_checkpoint {
	__le64 checkpoint_ver;
	__le64 user_block_count;
	__le64 valid_block_count;
	__le32 rsvd_segment_count;
	__le32 overprov_segment_count;
	__le32 free_segment_count;
	__le32 cur_node_segno[8];
	__le16 cur_node_blkoff[8];
	__le32 cur_data_segno[8];
	__le16 cur_data_blkoff[8];
	__le32 ckpt_flags;
	__le32 cp_pack_total_block_count;
	__le32 cp_pack_start_sum;
	__le32 valid_node_count;
	__le32 valid_inode_count;
	__le32 next_free_nid;
	__le32 sit_ver_bitmap_bytesize;
	__le32 nat_ver_bitmap_bytesize;
	__le32 checksum_offset;
	__le64 elapsed_time;
	unsigned char alloc_type[16];
	unsigned char sit_nat_version_bitmap[0];
};

struct f2fs_extent {
	__le32 fofs;
	__le32 blk;
	__le32 len;
};

struct f2fs_inode {
	__le16 i_mode;
	__u8 i_advise;
	__u8 i_inline;
	__le32 i_uid;
	__le32 i_gid;
	__le32 i_links;
	__le64 i_size;
	__le64 i_blocks;
	__le64 i_atime;
	__le64 i_ctime;
	__le64 i_mtime;
	__le32 i_atime_nsec;
	__le32 i_ctime_nsec;
	__le32 i_mtime_nsec;
	__le32 i_generation;
	union {
		__le32 i_current_depth;
		__le16 i_gc_failures;
	};
	__le32 i_xattr_nid;
	__le32 i_flags;
	__le32 i_pino;
	__le32 i_namelen;
	__u8 i_name[255];
	__u8 i_dir_level;
	struct f2fs_extent i_ext;
	union {
		struct {
			__le16 i_extra_isize;
			__le16 i_inline_xattr_size;
			__le32 i_projid;
			__le32 i_inode_checksum;
			__le64 i_crtime;
			__le32 i_crtime_nsec;
			__le64 i_compr_blocks;
			__u8 i_compress_algorithm;
			__u8 i_log_cluster_size;
			__le16 i_compress_flag;
			__le32 i_extra_end[0];
		} __attribute__((packed));
		__le32 i_addr[923];
	};
	__le32 i_nid[5];
};

struct direct_node {
	__le32 addr[1018];
};

struct indirect_node {
	__le32 nid[1018];
};

struct node_footer {
	__le32 nid;
	__le32 ino;
	__le32 flag;
	__le64 cp_ver;
	__le32 next_blkaddr;
} __attribute__((packed));

struct f2fs_node {
	union {
		struct f2fs_inode i;
		struct direct_node dn;
		struct indirect_node in;
	};
	struct node_footer footer;
};

typedef __le32 f2fs_hash_t;

struct f2fs_dir_entry {
	__le32 hash_code;
	__le32 ino;
	__le16 name_len;
	__u8 file_type;
} __attribute__((packed));

struct f2fs_dentry_block {
	__u8 dentry_bitmap[27];
	__u8 reserved[3];
	struct f2fs_dir_entry dentry[214];
	__u8 filename[1712];
};

enum {
	F2FS_FT_UNKNOWN = 0,
	F2FS_FT_REG_FILE = 1,
	F2FS_FT_DIR = 2,
	F2FS_FT_CHRDEV = 3,
	F2FS_FT_BLKDEV = 4,
	F2FS_FT_FIFO = 5,
	F2FS_FT_SOCK = 6,
	F2FS_FT_SYMLINK = 7,
	F2FS_FT_MAX = 8,
};

enum {
	FAULT_KMALLOC = 0,
	FAULT_KVMALLOC = 1,
	FAULT_PAGE_ALLOC = 2,
	FAULT_PAGE_GET = 3,
	FAULT_ALLOC_BIO = 4,
	FAULT_ALLOC_NID = 5,
	FAULT_ORPHAN = 6,
	FAULT_BLOCK = 7,
	FAULT_DIR_DEPTH = 8,
	FAULT_EVICT_INODE = 9,
	FAULT_TRUNCATE = 10,
	FAULT_READ_IO = 11,
	FAULT_CHECKPOINT = 12,
	FAULT_DISCARD = 13,
	FAULT_WRITE_IO = 14,
	FAULT_SLAB_ALLOC = 15,
	FAULT_DQUOT_INIT = 16,
	FAULT_MAX = 17,
};

typedef u32 block_t;

typedef u32 nid_t;

struct f2fs_mount_info {
	unsigned int opt;
	int write_io_size_bits;
	block_t root_reserved_blocks;
	kuid_t s_resuid;
	kgid_t s_resgid;
	int active_logs;
	int inline_xattr_size;
	char *s_qf_names[3];
	int s_jquota_fmt;
	int whint_mode;
	int alloc_mode;
	int fsync_mode;
	int fs_mode;
	int bggc_mode;
	int discard_unit;
	struct fscrypt_dummy_policy dummy_enc_policy;
	block_t unusable_cap_perc;
	block_t unusable_cap;
	unsigned char compress_algorithm;
	unsigned char compress_log_size;
	unsigned char compress_level;
	bool compress_chksum;
	unsigned char compress_ext_cnt;
	unsigned char nocompress_ext_cnt;
	int compress_mode;
	unsigned char extensions[128];
	unsigned char noextensions[128];
};

enum {
	META_CP = 0,
	META_NAT = 1,
	META_SIT = 2,
	META_SSA = 3,
	META_MAX = 4,
	META_POR = 5,
	DATA_GENERIC = 6,
	DATA_GENERIC_ENHANCE = 7,
	DATA_GENERIC_ENHANCE_READ = 8,
	DATA_GENERIC_ENHANCE_UPDATE = 9,
	META_GENERIC = 10,
};

enum {
	ORPHAN_INO = 0,
	APPEND_INO = 1,
	UPDATE_INO = 2,
	TRANS_DIR_INO = 3,
	FLUSH_INO = 4,
	MAX_INO_ENTRY = 5,
};

struct ckpt_req_control {
	struct task_struct *f2fs_issue_ckpt;
	int ckpt_thread_ioprio;
	wait_queue_head_t ckpt_wait_queue;
	atomic_t issued_ckpt;
	atomic_t total_ckpt;
	atomic_t queued_ckpt;
	struct llist_head issue_list;
	spinlock_t stat_lock;
	unsigned int cur_time;
	unsigned int peak_time;
};

struct discard_cmd_control {
	struct task_struct *f2fs_issue_discard;
	struct list_head entry_list;
	struct list_head pend_list[512];
	struct list_head wait_list;
	struct list_head fstrim_list;
	wait_queue_head_t discard_wait_queue;
	unsigned int discard_wake;
	struct mutex cmd_lock;
	unsigned int nr_discards;
	unsigned int max_discards;
	unsigned int discard_granularity;
	unsigned int undiscard_blks;
	unsigned int next_pos;
	atomic_t issued_discard;
	atomic_t queued_discard;
	atomic_t discard_cmd_cnt;
	struct rb_root_cached root;
	bool rbtree_check;
};

struct f2fs_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	f2fs_hash_t hash;
};

struct f2fs_dentry_ptr {
	struct inode *inode;
	void *bitmap;
	struct f2fs_dir_entry *dentry;
	__u8 (*filename)[8];
	int max;
	int nr_bitmap;
};

struct extent_info {
	unsigned int fofs;
	unsigned int len;
	u32 blk;
};

struct extent_tree;

struct extent_node {
	struct rb_node rb_node;
	struct extent_info ei;
	struct list_head list;
	struct extent_tree *et;
};

struct extent_tree {
	nid_t ino;
	struct rb_root_cached root;
	struct extent_node *cached_en;
	struct extent_info largest;
	struct list_head list;
	rwlock_t lock;
	atomic_t node_cnt;
	bool largest_updated;
};

enum {
	GC_FAILURE_PIN = 0,
	GC_FAILURE_ATOMIC = 1,
	MAX_GC_FAILURE = 2,
};

enum {
	FI_NEW_INODE = 0,
	FI_DIRTY_INODE = 1,
	FI_AUTO_RECOVER = 2,
	FI_DIRTY_DIR = 3,
	FI_INC_LINK = 4,
	FI_ACL_MODE = 5,
	FI_NO_ALLOC = 6,
	FI_FREE_NID = 7,
	FI_NO_EXTENT = 8,
	FI_INLINE_XATTR = 9,
	FI_INLINE_DATA = 10,
	FI_INLINE_DENTRY = 11,
	FI_APPEND_WRITE = 12,
	FI_UPDATE_WRITE = 13,
	FI_NEED_IPU = 14,
	FI_ATOMIC_FILE = 15,
	FI_ATOMIC_COMMIT = 16,
	FI_VOLATILE_FILE = 17,
	FI_FIRST_BLOCK_WRITTEN = 18,
	FI_DROP_CACHE = 19,
	FI_DATA_EXIST = 20,
	FI_INLINE_DOTS = 21,
	FI_DO_DEFRAG = 22,
	FI_DIRTY_FILE = 23,
	FI_NO_PREALLOC = 24,
	FI_HOT_DATA = 25,
	FI_EXTRA_ATTR = 26,
	FI_PROJ_INHERIT = 27,
	FI_PIN_FILE = 28,
	FI_ATOMIC_REVOKE_REQUEST = 29,
	FI_VERITY_IN_PROGRESS = 30,
	FI_COMPRESSED_FILE = 31,
	FI_COMPRESS_CORRUPT = 32,
	FI_MMAP_FILE = 33,
	FI_ENABLE_COMPRESS = 34,
	FI_COMPRESS_RELEASED = 35,
	FI_ALIGNED_WRITE = 36,
	FI_MAX = 37,
};

struct f2fs_inode_info {
	struct inode vfs_inode;
	long unsigned int i_flags;
	unsigned char i_advise;
	unsigned char i_dir_level;
	unsigned int i_current_depth;
	unsigned int i_gc_failures[2];
	unsigned int i_pino;
	umode_t i_acl_mode;
	long unsigned int flags[1];
	struct rw_semaphore i_sem;
	atomic_t dirty_pages;
	f2fs_hash_t chash;
	unsigned int clevel;
	struct task_struct *task;
	struct task_struct *cp_task;
	struct task_struct *wb_task;
	nid_t i_xattr_nid;
	loff_t last_disk_size;
	spinlock_t i_size_lock;
	struct dquot *i_dquot[3];
	qsize_t i_reserved_quota;
	struct list_head dirty_list;
	struct list_head gdirty_list;
	struct list_head inmem_ilist;
	struct list_head inmem_pages;
	struct task_struct *inmem_task;
	struct mutex inmem_lock;
	struct extent_tree *extent_tree;
	struct rw_semaphore i_gc_rwsem[2];
	struct rw_semaphore i_xattr_sem;
	int i_extra_isize;
	kprojid_t i_projid;
	int i_inline_xattr_size;
	struct timespec64 i_crtime;
	struct timespec64 i_disk_time[4];
	atomic_t i_compr_blocks;
	unsigned char i_compress_algorithm;
	unsigned char i_log_cluster_size;
	unsigned char i_compress_level;
	short unsigned int i_compress_flag;
	unsigned int i_cluster_size;
};

enum nid_state {
	FREE_NID = 0,
	PREALLOC_NID = 1,
	MAX_NID_STATE = 2,
};

enum nat_state {
	TOTAL_NAT = 0,
	DIRTY_NAT = 1,
	RECLAIMABLE_NAT = 2,
	MAX_NAT_STATE = 3,
};

struct f2fs_nm_info {
	block_t nat_blkaddr;
	nid_t max_nid;
	nid_t available_nids;
	nid_t next_scan_nid;
	unsigned int ram_thresh;
	unsigned int ra_nid_pages;
	unsigned int dirty_nats_ratio;
	struct xarray nat_root;
	struct xarray nat_set_root;
	struct rw_semaphore nat_tree_lock;
	struct list_head nat_entries;
	spinlock_t nat_list_lock;
	unsigned int nat_cnt[3];
	unsigned int nat_blocks;
	struct xarray free_nid_root;
	struct list_head free_nid_list;
	unsigned int nid_cnt[2];
	spinlock_t nid_list_lock;
	struct mutex build_lock;
	unsigned char **free_nid_bitmap;
	unsigned char *nat_block_bitmap;
	short unsigned int *free_nid_count;
	char *nat_bitmap;
	unsigned int nat_bits_blocks;
	unsigned char *nat_bits;
	unsigned char *full_nat_bits;
	unsigned char *empty_nat_bits;
	int bitmap_size;
};

struct flush_cmd_control {
	struct task_struct *f2fs_issue_flush;
	wait_queue_head_t flush_wait_queue;
	atomic_t issued_flush;
	atomic_t queued_flush;
	struct llist_head issue_list;
	struct llist_node *dispatch_list;
};

struct sit_info;

struct free_segmap_info;

struct dirty_seglist_info;

struct curseg_info;

struct f2fs_sm_info {
	struct sit_info *sit_info;
	struct free_segmap_info *free_info;
	struct dirty_seglist_info *dirty_info;
	struct curseg_info *curseg_array;
	struct rw_semaphore curseg_lock;
	block_t seg0_blkaddr;
	block_t main_blkaddr;
	block_t ssa_blkaddr;
	unsigned int segment_count;
	unsigned int main_segments;
	unsigned int reserved_segments;
	unsigned int additional_reserved_segments;
	unsigned int ovp_segments;
	unsigned int rec_prefree_segments;
	unsigned int trim_sections;
	struct list_head sit_entry_set;
	unsigned int ipu_policy;
	unsigned int min_ipu_util;
	unsigned int min_fsync_blocks;
	unsigned int min_seq_blocks;
	unsigned int min_hot_blocks;
	unsigned int min_ssr_sections;
	struct flush_cmd_control *fcc_info;
	struct discard_cmd_control *dcc_info;
};

enum count_type {
	F2FS_DIRTY_DENTS = 0,
	F2FS_DIRTY_DATA = 1,
	F2FS_DIRTY_QDATA = 2,
	F2FS_DIRTY_NODES = 3,
	F2FS_DIRTY_META = 4,
	F2FS_INMEM_PAGES = 5,
	F2FS_DIRTY_IMETA = 6,
	F2FS_WB_CP_DATA = 7,
	F2FS_WB_DATA = 8,
	F2FS_RD_DATA = 9,
	F2FS_RD_NODE = 10,
	F2FS_RD_META = 11,
	F2FS_DIO_WRITE = 12,
	F2FS_DIO_READ = 13,
	NR_COUNT_TYPE = 14,
};

enum page_type {
	DATA = 0,
	NODE = 1,
	META = 2,
	NR_PAGE_TYPE = 3,
	META_FLUSH = 4,
	INMEM = 5,
	INMEM_DROP = 6,
	INMEM_INVALIDATE = 7,
	INMEM_REVOKE = 8,
	IPU = 9,
	OPU = 10,
};

enum temp_type {
	HOT = 0,
	WARM = 1,
	COLD = 2,
	NR_TEMP_TYPE = 3,
};

enum iostat_type {
	APP_DIRECT_IO = 0,
	APP_BUFFERED_IO = 1,
	APP_WRITE_IO = 2,
	APP_MAPPED_IO = 3,
	FS_DATA_IO = 4,
	FS_NODE_IO = 5,
	FS_META_IO = 6,
	FS_GC_DATA_IO = 7,
	FS_GC_NODE_IO = 8,
	FS_CP_DATA_IO = 9,
	FS_CP_NODE_IO = 10,
	FS_CP_META_IO = 11,
	APP_DIRECT_READ_IO = 12,
	APP_BUFFERED_READ_IO = 13,
	APP_READ_IO = 14,
	APP_MAPPED_READ_IO = 15,
	FS_DATA_READ_IO = 16,
	FS_GDATA_READ_IO = 17,
	FS_CDATA_READ_IO = 18,
	FS_NODE_READ_IO = 19,
	FS_META_READ_IO = 20,
	FS_DISCARD = 21,
	NR_IO_TYPE = 22,
};

struct f2fs_sb_info;

struct f2fs_io_info {
	struct f2fs_sb_info *sbi;
	nid_t ino;
	enum page_type type;
	enum temp_type temp;
	int op;
	int op_flags;
	block_t new_blkaddr;
	block_t old_blkaddr;
	struct page *page;
	struct page *encrypted_page;
	struct page *compressed_page;
	struct list_head list;
	bool submitted;
	int need_lock;
	bool in_list;
	bool is_por;
	bool retry;
	int compr_blocks;
	bool encrypted;
	enum iostat_type io_type;
	struct writeback_control *io_wbc;
	struct bio **bio;
	sector_t *last_block;
	unsigned char version;
};

struct inode_management {
	struct xarray ino_root;
	spinlock_t ino_lock;
	struct list_head ino_list;
	long unsigned int ino_num;
};

struct atgc_management {
	bool atgc_enabled;
	struct rb_root_cached root;
	struct list_head victim_list;
	unsigned int victim_count;
	unsigned int candidate_ratio;
	unsigned int max_candidate_count;
	unsigned int age_weight;
	long long unsigned int age_threshold;
};

struct f2fs_bio_info;

struct f2fs_gc_kthread;

struct f2fs_stat_info;

struct f2fs_dev_info;

struct f2fs_sb_info {
	struct super_block *sb;
	struct proc_dir_entry *s_proc;
	struct f2fs_super_block *raw_super;
	struct rw_semaphore sb_lock;
	int valid_super_block;
	long unsigned int s_flag;
	struct mutex writepages;
	struct f2fs_nm_info *nm_info;
	struct inode *node_inode;
	struct f2fs_sm_info *sm_info;
	struct f2fs_bio_info *write_io[3];
	struct rw_semaphore io_order_lock;
	mempool_t *write_io_dummy;
	struct f2fs_checkpoint *ckpt;
	int cur_cp_pack;
	spinlock_t cp_lock;
	struct inode *meta_inode;
	struct rw_semaphore cp_global_sem;
	struct rw_semaphore cp_rwsem;
	struct rw_semaphore node_write;
	struct rw_semaphore node_change;
	wait_queue_head_t cp_wait;
	long unsigned int last_time[6];
	long int interval_time[6];
	struct ckpt_req_control cprc_info;
	struct inode_management im[5];
	spinlock_t fsync_node_lock;
	struct list_head fsync_node_list;
	unsigned int fsync_seg_id;
	unsigned int fsync_node_num;
	unsigned int max_orphans;
	struct list_head inode_list[4];
	spinlock_t inode_lock[4];
	struct mutex flush_lock;
	struct xarray extent_tree_root;
	struct mutex extent_tree_lock;
	struct list_head extent_list;
	spinlock_t extent_lock;
	atomic_t total_ext_tree;
	struct list_head zombie_list;
	atomic_t total_zombie_tree;
	atomic_t total_ext_node;
	unsigned int log_sectors_per_block;
	unsigned int log_blocksize;
	unsigned int blocksize;
	unsigned int root_ino_num;
	unsigned int node_ino_num;
	unsigned int meta_ino_num;
	unsigned int log_blocks_per_seg;
	unsigned int blocks_per_seg;
	unsigned int unusable_blocks_per_sec;
	unsigned int segs_per_sec;
	unsigned int secs_per_zone;
	unsigned int total_sections;
	unsigned int total_node_count;
	unsigned int total_valid_node_count;
	int dir_level;
	int readdir_ra;
	u64 max_io_bytes;
	block_t user_block_count;
	block_t total_valid_block_count;
	block_t discard_blks;
	block_t last_valid_block_count;
	block_t reserved_blocks;
	block_t current_reserved_blocks;
	block_t unusable_block_count;
	unsigned int nquota_files;
	struct rw_semaphore quota_sem;
	atomic_t nr_pages[14];
	struct percpu_counter alloc_valid_block_count;
	atomic_t wb_sync_req[2];
	struct percpu_counter total_valid_inode_count;
	struct f2fs_mount_info mount_opt;
	struct rw_semaphore gc_lock;
	struct f2fs_gc_kthread *gc_thread;
	struct atgc_management am;
	unsigned int cur_victim_sec;
	unsigned int gc_mode;
	unsigned int next_victim_seg[2];
	unsigned int atomic_files;
	long long unsigned int skipped_atomic_files[2];
	long long unsigned int skipped_gc_rwsem;
	u64 gc_pin_file_threshold;
	struct rw_semaphore pin_sem;
	unsigned int max_victim_search;
	unsigned int migration_granularity;
	struct f2fs_stat_info *stat_info;
	atomic_t meta_count[4];
	unsigned int segment_count[2];
	unsigned int block_count[2];
	atomic_t inplace_count;
	atomic64_t total_hit_ext;
	atomic64_t read_hit_rbtree;
	atomic64_t read_hit_largest;
	atomic64_t read_hit_cached;
	atomic_t inline_xattr;
	atomic_t inline_inode;
	atomic_t inline_dir;
	atomic_t compr_inode;
	atomic64_t compr_blocks;
	atomic_t vw_cnt;
	atomic_t max_aw_cnt;
	atomic_t max_vw_cnt;
	unsigned int io_skip_bggc;
	unsigned int other_skip_bggc;
	unsigned int ndirty_inode[4];
	spinlock_t stat_lock;
	unsigned int data_io_flag;
	unsigned int node_io_flag;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct kobject s_stat_kobj;
	struct completion s_stat_kobj_unregister;
	struct kobject s_feature_list_kobj;
	struct completion s_feature_list_kobj_unregister;
	struct list_head s_list;
	int s_ndevs;
	struct f2fs_dev_info *devs;
	unsigned int dirty_device;
	spinlock_t dev_lock;
	struct mutex umount_mutex;
	unsigned int shrinker_run_no;
	u64 sectors_written_start;
	u64 kbytes_written;
	struct crypto_shash *s_chksum_driver;
	__u32 s_chksum_seed;
	struct workqueue_struct *post_read_wq;
	struct kmem_cache *inline_xattr_slab;
	unsigned int inline_xattr_slab_size;
	unsigned int gc_segment_mode;
	unsigned int gc_reclaimed_segs[6];
	long unsigned int seq_file_ra_mul;
};

struct f2fs_bio_info {
	struct f2fs_sb_info *sbi;
	struct bio *bio;
	sector_t last_block_in_bio;
	struct f2fs_io_info fio;
	struct rw_semaphore io_rwsem;
	spinlock_t io_lock;
	struct list_head io_list;
	struct list_head bio_list;
	struct rw_semaphore bio_list_lock;
};

struct f2fs_dev_info {
	struct block_device *bdev;
	char path[64];
	unsigned int total_segments;
	block_t start_blk;
	block_t end_blk;
};

enum inode_type {
	DIR_INODE = 0,
	FILE_INODE = 1,
	DIRTY_META = 2,
	ATOMIC_FILE = 3,
	NR_INODE_TYPE = 4,
};

enum {
	SBI_IS_DIRTY = 0,
	SBI_IS_CLOSE = 1,
	SBI_NEED_FSCK = 2,
	SBI_POR_DOING = 3,
	SBI_NEED_SB_WRITE = 4,
	SBI_NEED_CP = 5,
	SBI_IS_SHUTDOWN = 6,
	SBI_IS_RECOVERED = 7,
	SBI_CP_DISABLED = 8,
	SBI_CP_DISABLED_QUICK = 9,
	SBI_QUOTA_NEED_FLUSH = 10,
	SBI_QUOTA_SKIP_FLUSH = 11,
	SBI_QUOTA_NEED_REPAIR = 12,
	SBI_IS_RESIZEFS = 13,
	SBI_IS_FREEZING = 14,
};

enum {
	CP_TIME = 0,
	REQ_TIME = 1,
	DISCARD_TIME = 2,
	GC_TIME = 3,
	DISABLE_TIME = 4,
	UMOUNT_DISCARD_TIMEOUT = 5,
	MAX_TIME = 6,
};

enum {
	GC_NORMAL = 0,
	GC_IDLE_CB = 1,
	GC_IDLE_GREEDY = 2,
	GC_IDLE_AT = 3,
	GC_URGENT_HIGH = 4,
	GC_URGENT_LOW = 5,
	MAX_GC_MODE = 6,
};

enum fsync_mode {
	FSYNC_MODE_POSIX = 0,
	FSYNC_MODE_STRICT = 1,
	FSYNC_MODE_NOBARRIER = 2,
};

enum {
	PAGE_PRIVATE_NOT_POINTER = 0,
	PAGE_PRIVATE_ATOMIC_WRITE = 1,
	PAGE_PRIVATE_DUMMY_WRITE = 2,
	PAGE_PRIVATE_ONGOING_MIGRATION = 3,
	PAGE_PRIVATE_INLINE_INODE = 4,
	PAGE_PRIVATE_REF_RESOURCE = 5,
	PAGE_PRIVATE_MAX = 6,
};

struct f2fs_stat_info {
	struct list_head stat_list;
	struct f2fs_sb_info *sbi;
	int all_area_segs;
	int sit_area_segs;
	int nat_area_segs;
	int ssa_area_segs;
	int main_area_segs;
	int main_area_sections;
	int main_area_zones;
	long long unsigned int hit_largest;
	long long unsigned int hit_cached;
	long long unsigned int hit_rbtree;
	long long unsigned int hit_total;
	long long unsigned int total_ext;
	int ext_tree;
	int zombie_tree;
	int ext_node;
	int ndirty_node;
	int ndirty_dent;
	int ndirty_meta;
	int ndirty_imeta;
	int ndirty_data;
	int ndirty_qdata;
	int inmem_pages;
	unsigned int ndirty_dirs;
	unsigned int ndirty_files;
	unsigned int nquota_files;
	unsigned int ndirty_all;
	int nats;
	int dirty_nats;
	int sits;
	int dirty_sits;
	int free_nids;
	int avail_nids;
	int alloc_nids;
	int total_count;
	int utilization;
	int bg_gc;
	int nr_wb_cp_data;
	int nr_wb_data;
	int nr_rd_data;
	int nr_rd_node;
	int nr_rd_meta;
	int nr_dio_read;
	int nr_dio_write;
	unsigned int io_skip_bggc;
	unsigned int other_skip_bggc;
	int nr_flushing;
	int nr_flushed;
	int flush_list_empty;
	int nr_discarding;
	int nr_discarded;
	int nr_discard_cmd;
	unsigned int undiscard_blks;
	int nr_issued_ckpt;
	int nr_total_ckpt;
	int nr_queued_ckpt;
	unsigned int cur_ckpt_time;
	unsigned int peak_ckpt_time;
	int inline_xattr;
	int inline_inode;
	int inline_dir;
	int append;
	int update;
	int orphans;
	int compr_inode;
	long long unsigned int compr_blocks;
	int aw_cnt;
	int max_aw_cnt;
	int vw_cnt;
	int max_vw_cnt;
	unsigned int valid_count;
	unsigned int valid_node_count;
	unsigned int valid_inode_count;
	unsigned int discard_blks;
	unsigned int bimodal;
	unsigned int avg_vblocks;
	int util_free;
	int util_valid;
	int util_invalid;
	int rsvd_segs;
	int overp_segs;
	int dirty_count;
	int node_pages;
	int meta_pages;
	int compress_pages;
	int compress_page_hit;
	int prefree_count;
	int call_count;
	int cp_count;
	int bg_cp_count;
	int tot_segs;
	int node_segs;
	int data_segs;
	int free_segs;
	int free_secs;
	int bg_node_segs;
	int bg_data_segs;
	int tot_blks;
	int data_blks;
	int node_blks;
	int bg_data_blks;
	int bg_node_blks;
	long long unsigned int skipped_atomic_files[2];
	int curseg[8];
	int cursec[8];
	int curzone[8];
	unsigned int dirty_seg[8];
	unsigned int full_seg[8];
	unsigned int valid_blks[8];
	unsigned int meta_count[4];
	unsigned int segment_count[2];
	unsigned int block_count[2];
	unsigned int inplace_count;
	long long unsigned int base_mem;
	long long unsigned int cache_mem;
	long long unsigned int page_mem;
};

enum {
	COLD_BIT_SHIFT = 0,
	FSYNC_BIT_SHIFT = 1,
	DENT_BIT_SHIFT = 2,
	OFFSET_BIT_SHIFT = 3,
};

struct f2fs_nat_entry {
	__u8 version;
	__le32 ino;
	__le32 block_addr;
} __attribute__((packed));

struct f2fs_sit_entry {
	__le16 vblocks;
	__u8 valid_map[64];
	__le64 mtime;
} __attribute__((packed));

struct f2fs_summary {
	__le32 nid;
	union {
		__u8 reserved[3];
		struct {
			__u8 version;
			__le16 ofs_in_node;
		} __attribute__((packed));
	};
} __attribute__((packed));

struct summary_footer {
	unsigned char entry_type;
	__le32 check_sum;
} __attribute__((packed));

struct nat_journal_entry {
	__le32 nid;
	struct f2fs_nat_entry ne;
} __attribute__((packed));

struct nat_journal {
	struct nat_journal_entry entries[38];
	__u8 reserved[11];
};

struct sit_journal_entry {
	__le32 segno;
	struct f2fs_sit_entry se;
} __attribute__((packed));

struct sit_journal {
	struct sit_journal_entry entries[6];
	__u8 reserved[37];
};

struct f2fs_extra_info {
	__le64 kbytes_written;
	__u8 reserved[497];
} __attribute__((packed));

struct f2fs_journal {
	union {
		__le16 n_nats;
		__le16 n_sits;
	};
	union {
		struct nat_journal nat_j;
		struct sit_journal sit_j;
		struct f2fs_extra_info info;
	};
} __attribute__((packed));

struct f2fs_summary_block {
	struct f2fs_summary entries[512];
	struct f2fs_journal journal;
	struct summary_footer footer;
};

enum {
	ALLOC_NODE = 0,
	LOOKUP_NODE = 1,
	LOOKUP_NODE_RA = 2,
};

struct f2fs_map_blocks {
	block_t m_pblk;
	block_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
	long unsigned int *m_next_pgofs;
	long unsigned int *m_next_extent;
	int m_seg_type;
	bool m_may_create;
};

enum {
	F2FS_GET_BLOCK_DEFAULT = 0,
	F2FS_GET_BLOCK_FIEMAP = 1,
	F2FS_GET_BLOCK_BMAP = 2,
	F2FS_GET_BLOCK_DIO = 3,
	F2FS_GET_BLOCK_PRE_DIO = 4,
	F2FS_GET_BLOCK_PRE_AIO = 5,
	F2FS_GET_BLOCK_PRECACHE = 6,
};

struct dnode_of_data {
	struct inode *inode;
	struct page *inode_page;
	struct page *node_page;
	nid_t nid;
	unsigned int ofs_in_node;
	bool inode_page_locked;
	bool node_changed;
	char cur_level;
	char max_level;
	block_t data_blkaddr;
};

enum {
	CURSEG_HOT_DATA = 0,
	CURSEG_WARM_DATA = 1,
	CURSEG_COLD_DATA = 2,
	CURSEG_HOT_NODE = 3,
	CURSEG_WARM_NODE = 4,
	CURSEG_COLD_NODE = 5,
	NR_PERSISTENT_LOG = 6,
	CURSEG_COLD_DATA_PINNED = 6,
	CURSEG_ALL_DATA_ATGC = 7,
	NO_CHECK_TYPE = 8,
};

struct segment_allocation;

struct seg_entry;

struct sec_entry;

struct sit_info {
	const struct segment_allocation *s_ops;
	block_t sit_base_addr;
	block_t sit_blocks;
	block_t written_valid_blocks;
	char *bitmap;
	char *sit_bitmap;
	unsigned int bitmap_size;
	long unsigned int *tmp_map;
	long unsigned int *dirty_sentries_bitmap;
	unsigned int dirty_sentries;
	unsigned int sents_per_block;
	struct rw_semaphore sentry_lock;
	struct seg_entry *sentries;
	struct sec_entry *sec_entries;
	long long unsigned int elapsed_time;
	long long unsigned int mounted_time;
	long long unsigned int min_mtime;
	long long unsigned int max_mtime;
	long long unsigned int dirty_min_mtime;
	long long unsigned int dirty_max_mtime;
	unsigned int last_victim[5];
};

struct free_segmap_info {
	unsigned int start_segno;
	unsigned int free_segments;
	unsigned int free_sections;
	spinlock_t segmap_lock;
	long unsigned int *free_segmap;
	long unsigned int *free_secmap;
};

struct victim_selection;

struct dirty_seglist_info {
	const struct victim_selection *v_ops;
	long unsigned int *dirty_segmap[8];
	long unsigned int *dirty_secmap;
	struct mutex seglist_lock;
	int nr_dirty[8];
	long unsigned int *victim_secmap;
};

struct curseg_info {
	struct mutex curseg_mutex;
	struct f2fs_summary_block *sum_blk;
	struct rw_semaphore journal_rwsem;
	struct f2fs_journal *journal;
	unsigned char alloc_type;
	short unsigned int seg_type;
	unsigned int segno;
	short unsigned int next_blkoff;
	unsigned int zone;
	unsigned int next_segno;
	bool inited;
};

enum cp_reason_type {
	CP_NO_NEEDED = 0,
	CP_NON_REGULAR = 1,
	CP_COMPRESSED = 2,
	CP_HARDLINK = 3,
	CP_SB_NEED_CP = 4,
	CP_WRONG_PINO = 5,
	CP_NO_SPC_ROLL = 6,
	CP_NODE_NEED_CP = 7,
	CP_FASTBOOT_MODE = 8,
	CP_SPEC_LOG_NUM = 9,
	CP_RECOVER_DIR = 10,
};

enum {
	FS_MODE_ADAPTIVE = 0,
	FS_MODE_LFS = 1,
};

enum {
	COMPR_MODE_FS = 0,
	COMPR_MODE_USER = 1,
};

enum compress_algorithm_type {
	COMPRESS_LZO = 0,
	COMPRESS_LZ4 = 1,
	COMPRESS_ZSTD = 2,
	COMPRESS_LZORLE = 3,
	COMPRESS_MAX = 4,
};

enum compress_flag {
	COMPRESS_CHKSUM = 0,
	COMPRESS_MAX_FLAG = 1,
};

struct f2fs_gc_kthread {
	struct task_struct *f2fs_gc_task;
	wait_queue_head_t gc_wait_queue_head;
	unsigned int urgent_sleep_time;
	unsigned int min_sleep_time;
	unsigned int max_sleep_time;
	unsigned int no_gc_sleep_time;
	unsigned int gc_wake;
	wait_queue_head_t fggc_wq;
};

struct node_info {
	nid_t nid;
	nid_t ino;
	block_t blk_addr;
	unsigned char version;
	unsigned char flag;
};

enum {
	GC_CB = 0,
	GC_GREEDY = 1,
	GC_AT = 2,
	ALLOC_NEXT = 3,
	FLUSH_DEVICE = 4,
	MAX_GC_POLICY = 5,
};

struct seg_entry {
	unsigned int type: 6;
	unsigned int valid_blocks: 10;
	unsigned int ckpt_valid_blocks: 10;
	unsigned int padding: 6;
	unsigned char *cur_valid_map;
	unsigned char *ckpt_valid_map;
	unsigned char *discard_map;
	long long unsigned int mtime;
};

struct sec_entry {
	unsigned int valid_blocks;
};

struct segment_allocation {
	void (*allocate_segment)(struct f2fs_sb_info *, int, bool);
};

enum dirty_type {
	DIRTY_HOT_DATA = 0,
	DIRTY_WARM_DATA = 1,
	DIRTY_COLD_DATA = 2,
	DIRTY_HOT_NODE = 3,
	DIRTY_WARM_NODE = 4,
	DIRTY_COLD_NODE = 5,
	DIRTY = 6,
	PRE = 7,
	NR_DIRTY_TYPE = 8,
};

struct victim_selection {
	int (*get_victim)(struct f2fs_sb_info *, unsigned int *, int, int, char, long long unsigned int);
};

struct f2fs_gc_range {
	__u32 sync;
	__u64 start;
	__u64 len;
};

struct f2fs_defragment {
	__u64 start;
	__u64 len;
};

struct f2fs_move_range {
	__u32 dst_fd;
	__u64 pos_in;
	__u64 pos_out;
	__u64 len;
};

struct f2fs_flush_device {
	__u32 dev_num;
	__u32 segments;
};

struct f2fs_sectrim_range {
	__u64 start;
	__u64 len;
	__u64 flags;
};

struct f2fs_comp_option {
	__u8 algorithm;
	__u8 log_cluster_size;
};

struct cp_control {
	int reason;
	__u64 trim_start;
	__u64 trim_end;
	__u64 trim_minlen;
};

enum {
	BGGC_MODE_ON = 0,
	BGGC_MODE_OFF = 1,
	BGGC_MODE_SYNC = 2,
};

enum {
	WHINT_MODE_OFF = 0,
	WHINT_MODE_USER = 1,
	WHINT_MODE_FS = 2,
};

enum {
	ALLOC_MODE_DEFAULT = 0,
	ALLOC_MODE_REUSE = 1,
};

enum {
	DISCARD_UNIT_BLOCK = 0,
	DISCARD_UNIT_SEGMENT = 1,
	DISCARD_UNIT_SECTION = 2,
};

enum {
	LFS = 0,
	SSR = 1,
	AT_SSR = 2,
};

enum {
	BG_GC = 0,
	FG_GC = 1,
};

struct victim_sel_policy {
	int alloc_mode;
	int gc_mode;
	long unsigned int *dirty_bitmap;
	unsigned int max_search;
	unsigned int offset;
	unsigned int ofs_unit;
	unsigned int min_cost;
	long long unsigned int oldest_age;
	unsigned int min_segno;
	long long unsigned int age;
	long long unsigned int age_threshold;
};

enum {
	F2FS_IPU_FORCE = 0,
	F2FS_IPU_SSR = 1,
	F2FS_IPU_UTIL = 2,
	F2FS_IPU_SSR_UTIL = 3,
	F2FS_IPU_FSYNC = 4,
	F2FS_IPU_ASYNC = 5,
	F2FS_IPU_NOCACHE = 6,
};

struct trace_event_raw_f2fs__inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t pino;
	umode_t mode;
	loff_t size;
	unsigned int nlink;
	blkcnt_t blocks;
	__u8 advise;
	char __data[0];
};

struct trace_event_raw_f2fs__inode_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int cp_reason;
	int datasync;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int dirty;
	int wait;
	char __data[0];
};

struct trace_event_raw_f2fs_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t size;
	blkcnt_t blocks;
	const char *name;
	char __data[0];
};

struct trace_event_raw_f2fs_truncate_data_blocks_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	nid_t nid;
	unsigned int ofs;
	int free;
	char __data[0];
};

struct trace_event_raw_f2fs__truncate_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t size;
	blkcnt_t blocks;
	u64 from;
	char __data[0];
};

struct trace_event_raw_f2fs__truncate_node {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	nid_t nid;
	block_t blk_addr;
	char __data[0];
};

struct trace_event_raw_f2fs_truncate_partial_nodes {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	nid_t nid[3];
	int depth;
	int err;
	char __data[0];
};

struct trace_event_raw_f2fs_file_write_iter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int offset;
	long unsigned int length;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_map_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	block_t m_lblk;
	block_t m_pblk;
	unsigned int m_len;
	unsigned int m_flags;
	int m_seg_type;
	bool m_may_create;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_background_gc {
	struct trace_entry ent;
	dev_t dev;
	unsigned int wait_ms;
	unsigned int prefree;
	unsigned int free;
	char __data[0];
};

struct trace_event_raw_f2fs_gc_begin {
	struct trace_entry ent;
	dev_t dev;
	bool sync;
	bool background;
	long long int dirty_nodes;
	long long int dirty_dents;
	long long int dirty_imeta;
	unsigned int free_sec;
	unsigned int free_seg;
	int reserved_seg;
	unsigned int prefree_seg;
	char __data[0];
};

struct trace_event_raw_f2fs_gc_end {
	struct trace_entry ent;
	dev_t dev;
	int ret;
	int seg_freed;
	int sec_freed;
	long long int dirty_nodes;
	long long int dirty_dents;
	long long int dirty_imeta;
	unsigned int free_sec;
	unsigned int free_seg;
	int reserved_seg;
	unsigned int prefree_seg;
	char __data[0];
};

struct trace_event_raw_f2fs_get_victim {
	struct trace_entry ent;
	dev_t dev;
	int type;
	int gc_type;
	int alloc_mode;
	int gc_mode;
	unsigned int victim;
	unsigned int cost;
	unsigned int ofs_unit;
	unsigned int pre_victim;
	unsigned int prefree;
	unsigned int free;
	char __data[0];
};

struct trace_event_raw_f2fs_lookup_start {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	u32 __data_loc_name;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_f2fs_lookup_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	u32 __data_loc_name;
	nid_t cino;
	int err;
	char __data[0];
};

struct trace_event_raw_f2fs_readdir {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t start;
	loff_t end;
	int err;
	char __data[0];
};

struct trace_event_raw_f2fs_fallocate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int mode;
	loff_t offset;
	loff_t len;
	loff_t size;
	blkcnt_t blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_direct_IO_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	char __data[0];
};

struct trace_event_raw_f2fs_direct_IO_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_reserve_new_blocks {
	struct trace_entry ent;
	dev_t dev;
	nid_t nid;
	unsigned int ofs_in_node;
	blkcnt_t count;
	char __data[0];
};

struct trace_event_raw_f2fs__submit_page_bio {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	block_t old_blkaddr;
	block_t new_blkaddr;
	int op;
	int op_flags;
	int temp;
	int type;
	char __data[0];
};

struct trace_event_raw_f2fs__bio {
	struct trace_entry ent;
	dev_t dev;
	dev_t target;
	int op;
	int op_flags;
	int type;
	sector_t sector;
	unsigned int size;
	char __data[0];
};

struct trace_event_raw_f2fs_write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_f2fs_write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_f2fs__page {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int type;
	int dir;
	long unsigned int index;
	int dirty;
	int uptodate;
	char __data[0];
};

struct trace_event_raw_f2fs_filemap_fault {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	long unsigned int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int type;
	int dir;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char for_background;
	char tagged_writepages;
	char for_reclaim;
	char range_cyclic;
	char for_sync;
	char __data[0];
};

struct trace_event_raw_f2fs_readpages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int start;
	unsigned int nrpage;
	char __data[0];
};

struct trace_event_raw_f2fs_write_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int reason;
	char *msg;
	char __data[0];
};

struct trace_event_raw_f2fs_discard {
	struct trace_entry ent;
	dev_t dev;
	block_t blkstart;
	block_t blklen;
	char __data[0];
};

struct trace_event_raw_f2fs_issue_reset_zone {
	struct trace_entry ent;
	dev_t dev;
	block_t blkstart;
	char __data[0];
};

struct trace_event_raw_f2fs_issue_flush {
	struct trace_entry ent;
	dev_t dev;
	unsigned int nobarrier;
	unsigned int flush_merge;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_lookup_extent_tree_start {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int pgofs;
	char __data[0];
};

struct trace_event_raw_f2fs_lookup_extent_tree_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int pgofs;
	unsigned int fofs;
	u32 blk;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_f2fs_update_extent_tree_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int pgofs;
	u32 blk;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_f2fs_shrink_extent_tree {
	struct trace_entry ent;
	dev_t dev;
	unsigned int node_cnt;
	unsigned int tree_cnt;
	char __data[0];
};

struct trace_event_raw_f2fs_destroy_extent_tree {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int node_cnt;
	char __data[0];
};

struct trace_event_raw_f2fs_sync_dirty_inodes {
	struct trace_entry ent;
	dev_t dev;
	int type;
	s64 count;
	char __data[0];
};

struct trace_event_raw_f2fs_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int mode;
	int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_zip_start {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int idx;
	unsigned int size;
	unsigned int algtype;
	char __data[0];
};

struct trace_event_raw_f2fs_zip_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int idx;
	unsigned int size;
	unsigned int ret;
	char __data[0];
};

struct trace_event_raw_f2fs_bmap {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	sector_t lblock;
	sector_t pblock;
	char __data[0];
};

struct trace_event_raw_f2fs_fiemap {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	sector_t lblock;
	sector_t pblock;
	long long unsigned int len;
	unsigned int flags;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_f2fs__inode {};

struct trace_event_data_offsets_f2fs__inode_exit {};

struct trace_event_data_offsets_f2fs_sync_file_exit {};

struct trace_event_data_offsets_f2fs_sync_fs {};

struct trace_event_data_offsets_f2fs_unlink_enter {};

struct trace_event_data_offsets_f2fs_truncate_data_blocks_range {};

struct trace_event_data_offsets_f2fs__truncate_op {};

struct trace_event_data_offsets_f2fs__truncate_node {};

struct trace_event_data_offsets_f2fs_truncate_partial_nodes {};

struct trace_event_data_offsets_f2fs_file_write_iter {};

struct trace_event_data_offsets_f2fs_map_blocks {};

struct trace_event_data_offsets_f2fs_background_gc {};

struct trace_event_data_offsets_f2fs_gc_begin {};

struct trace_event_data_offsets_f2fs_gc_end {};

struct trace_event_data_offsets_f2fs_get_victim {};

struct trace_event_data_offsets_f2fs_lookup_start {
	u32 name;
};

struct trace_event_data_offsets_f2fs_lookup_end {
	u32 name;
};

struct trace_event_data_offsets_f2fs_readdir {};

struct trace_event_data_offsets_f2fs_fallocate {};

struct trace_event_data_offsets_f2fs_direct_IO_enter {};

struct trace_event_data_offsets_f2fs_direct_IO_exit {};

struct trace_event_data_offsets_f2fs_reserve_new_blocks {};

struct trace_event_data_offsets_f2fs__submit_page_bio {};

struct trace_event_data_offsets_f2fs__bio {};

struct trace_event_data_offsets_f2fs_write_begin {};

struct trace_event_data_offsets_f2fs_write_end {};

struct trace_event_data_offsets_f2fs__page {};

struct trace_event_data_offsets_f2fs_filemap_fault {};

struct trace_event_data_offsets_f2fs_writepages {};

struct trace_event_data_offsets_f2fs_readpages {};

struct trace_event_data_offsets_f2fs_write_checkpoint {};

struct trace_event_data_offsets_f2fs_discard {};

struct trace_event_data_offsets_f2fs_issue_reset_zone {};

struct trace_event_data_offsets_f2fs_issue_flush {};

struct trace_event_data_offsets_f2fs_lookup_extent_tree_start {};

struct trace_event_data_offsets_f2fs_lookup_extent_tree_end {};

struct trace_event_data_offsets_f2fs_update_extent_tree_range {};

struct trace_event_data_offsets_f2fs_shrink_extent_tree {};

struct trace_event_data_offsets_f2fs_destroy_extent_tree {};

struct trace_event_data_offsets_f2fs_sync_dirty_inodes {};

struct trace_event_data_offsets_f2fs_shutdown {};

struct trace_event_data_offsets_f2fs_zip_start {};

struct trace_event_data_offsets_f2fs_zip_end {};

struct trace_event_data_offsets_f2fs_bmap {};

struct trace_event_data_offsets_f2fs_fiemap {};

typedef void (*btf_trace_f2fs_sync_file_enter)(void *, struct inode *);

typedef void (*btf_trace_f2fs_sync_file_exit)(void *, struct inode *, int, int, int);

typedef void (*btf_trace_f2fs_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_f2fs_iget)(void *, struct inode *);

typedef void (*btf_trace_f2fs_iget_exit)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_f2fs_new_inode)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_f2fs_unlink_exit)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_truncate)(void *, struct inode *);

typedef void (*btf_trace_f2fs_truncate_data_blocks_range)(void *, struct inode *, nid_t, unsigned int, int);

typedef void (*btf_trace_f2fs_truncate_blocks_enter)(void *, struct inode *, u64);

typedef void (*btf_trace_f2fs_truncate_blocks_exit)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_truncate_inode_blocks_enter)(void *, struct inode *, u64);

typedef void (*btf_trace_f2fs_truncate_inode_blocks_exit)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_truncate_nodes_enter)(void *, struct inode *, nid_t, block_t);

typedef void (*btf_trace_f2fs_truncate_nodes_exit)(void *, struct inode *, int);

typedef void (*btf_trace_f2fs_truncate_node)(void *, struct inode *, nid_t, block_t);

typedef void (*btf_trace_f2fs_truncate_partial_nodes)(void *, struct inode *, nid_t *, int, int);

typedef void (*btf_trace_f2fs_file_write_iter)(void *, struct inode *, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_f2fs_map_blocks)(void *, struct inode *, struct f2fs_map_blocks *, int);

typedef void (*btf_trace_f2fs_background_gc)(void *, struct super_block *, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_f2fs_gc_begin)(void *, struct super_block *, bool, bool, long long int, long long int, long long int, unsigned int, unsigned int, int, unsigned int);

typedef void (*btf_trace_f2fs_gc_end)(void *, struct super_block *, int, int, int, long long int, long long int, long long int, unsigned int, unsigned int, int, unsigned int);

typedef void (*btf_trace_f2fs_get_victim)(void *, struct super_block *, int, int, struct victim_sel_policy *, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_f2fs_lookup_start)(void *, struct inode *, struct dentry *, unsigned int);

typedef void (*btf_trace_f2fs_lookup_end)(void *, struct inode *, struct dentry *, nid_t, int);

typedef void (*btf_trace_f2fs_readdir)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_f2fs_fallocate)(void *, struct inode *, int, loff_t, loff_t, int);

typedef void (*btf_trace_f2fs_direct_IO_enter)(void *, struct inode *, loff_t, long unsigned int, int);

typedef void (*btf_trace_f2fs_direct_IO_exit)(void *, struct inode *, loff_t, long unsigned int, int, int);

typedef void (*btf_trace_f2fs_reserve_new_blocks)(void *, struct inode *, nid_t, unsigned int, blkcnt_t);

typedef void (*btf_trace_f2fs_submit_page_bio)(void *, struct page *, struct f2fs_io_info *);

typedef void (*btf_trace_f2fs_submit_page_write)(void *, struct page *, struct f2fs_io_info *);

typedef void (*btf_trace_f2fs_prepare_write_bio)(void *, struct super_block *, int, struct bio *);

typedef void (*btf_trace_f2fs_prepare_read_bio)(void *, struct super_block *, int, struct bio *);

typedef void (*btf_trace_f2fs_submit_read_bio)(void *, struct super_block *, int, struct bio *);

typedef void (*btf_trace_f2fs_submit_write_bio)(void *, struct super_block *, int, struct bio *);

typedef void (*btf_trace_f2fs_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_f2fs_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_f2fs_writepage)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_do_write_data_page)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_readpage)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_set_page_dirty)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_vm_page_mkwrite)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_register_inmem_page)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_commit_inmem_page)(void *, struct page *, int);

typedef void (*btf_trace_f2fs_filemap_fault)(void *, struct inode *, long unsigned int, long unsigned int);

typedef void (*btf_trace_f2fs_writepages)(void *, struct inode *, struct writeback_control *, int);

typedef void (*btf_trace_f2fs_readpages)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_f2fs_write_checkpoint)(void *, struct super_block *, int, char *);

typedef void (*btf_trace_f2fs_queue_discard)(void *, struct block_device *, block_t, block_t);

typedef void (*btf_trace_f2fs_issue_discard)(void *, struct block_device *, block_t, block_t);

typedef void (*btf_trace_f2fs_remove_discard)(void *, struct block_device *, block_t, block_t);

typedef void (*btf_trace_f2fs_issue_reset_zone)(void *, struct block_device *, block_t);

typedef void (*btf_trace_f2fs_issue_flush)(void *, struct block_device *, unsigned int, unsigned int, int);

typedef void (*btf_trace_f2fs_lookup_extent_tree_start)(void *, struct inode *, unsigned int);

typedef void (*btf_trace_f2fs_lookup_extent_tree_end)(void *, struct inode *, unsigned int, struct extent_info *);

typedef void (*btf_trace_f2fs_update_extent_tree_range)(void *, struct inode *, unsigned int, block_t, unsigned int);

typedef void (*btf_trace_f2fs_shrink_extent_tree)(void *, struct f2fs_sb_info *, unsigned int, unsigned int);

typedef void (*btf_trace_f2fs_destroy_extent_tree)(void *, struct inode *, unsigned int);

typedef void (*btf_trace_f2fs_sync_dirty_inodes_enter)(void *, struct super_block *, int, s64);

typedef void (*btf_trace_f2fs_sync_dirty_inodes_exit)(void *, struct super_block *, int, s64);

typedef void (*btf_trace_f2fs_shutdown)(void *, struct f2fs_sb_info *, unsigned int, int);

typedef void (*btf_trace_f2fs_compress_pages_start)(void *, struct inode *, long unsigned int, unsigned int, unsigned char);

typedef void (*btf_trace_f2fs_decompress_pages_start)(void *, struct inode *, long unsigned int, unsigned int, unsigned char);

typedef void (*btf_trace_f2fs_compress_pages_end)(void *, struct inode *, long unsigned int, unsigned int, int);

typedef void (*btf_trace_f2fs_decompress_pages_end)(void *, struct inode *, long unsigned int, unsigned int, int);

typedef void (*btf_trace_f2fs_bmap)(void *, struct inode *, sector_t, sector_t);

typedef void (*btf_trace_f2fs_fiemap)(void *, struct inode *, sector_t, sector_t, long long unsigned int, unsigned int, int);

enum {
	Opt_gc_background = 0,
	Opt_disable_roll_forward = 1,
	Opt_norecovery___3 = 2,
	Opt_discard___5 = 3,
	Opt_nodiscard___4 = 4,
	Opt_noheap = 5,
	Opt_heap = 6,
	Opt_user_xattr___2 = 7,
	Opt_nouser_xattr___2 = 8,
	Opt_acl___3 = 9,
	Opt_noacl___3 = 10,
	Opt_active_logs = 11,
	Opt_disable_ext_identify = 12,
	Opt_inline_xattr = 13,
	Opt_noinline_xattr = 14,
	Opt_inline_xattr_size = 15,
	Opt_inline_data = 16,
	Opt_inline_dentry = 17,
	Opt_noinline_dentry = 18,
	Opt_flush_merge = 19,
	Opt_noflush_merge = 20,
	Opt_nobarrier___3 = 21,
	Opt_fastboot = 22,
	Opt_extent_cache = 23,
	Opt_noextent_cache = 24,
	Opt_noinline_data = 25,
	Opt_data_flush = 26,
	Opt_reserve_root = 27,
	Opt_resgid___2 = 28,
	Opt_resuid___2 = 29,
	Opt_mode___6 = 30,
	Opt_io_size_bits = 31,
	Opt_fault_injection = 32,
	Opt_fault_type = 33,
	Opt_lazytime___2 = 34,
	Opt_nolazytime___2 = 35,
	Opt_quota___3 = 36,
	Opt_noquota___3 = 37,
	Opt_usrquota___3 = 38,
	Opt_grpquota___3 = 39,
	Opt_prjquota___3 = 40,
	Opt_usrjquota___2 = 41,
	Opt_grpjquota___2 = 42,
	Opt_prjjquota = 43,
	Opt_offusrjquota___2 = 44,
	Opt_offgrpjquota___2 = 45,
	Opt_offprjjquota = 46,
	Opt_jqfmt_vfsold___2 = 47,
	Opt_jqfmt_vfsv0___2 = 48,
	Opt_jqfmt_vfsv1___2 = 49,
	Opt_whint = 50,
	Opt_alloc = 51,
	Opt_fsync = 52,
	Opt_test_dummy_encryption___2 = 53,
	Opt_inlinecrypt___2 = 54,
	Opt_checkpoint_disable = 55,
	Opt_checkpoint_disable_cap = 56,
	Opt_checkpoint_disable_cap_perc = 57,
	Opt_checkpoint_enable = 58,
	Opt_checkpoint_merge = 59,
	Opt_nocheckpoint_merge = 60,
	Opt_compress_algorithm = 61,
	Opt_compress_log_size = 62,
	Opt_compress_extension = 63,
	Opt_nocompress_extension = 64,
	Opt_compress_chksum = 65,
	Opt_compress_mode = 66,
	Opt_compress_cache = 67,
	Opt_atgc = 68,
	Opt_gc_merge = 69,
	Opt_nogc_merge = 70,
	Opt_discard_unit = 71,
	Opt_err___8 = 72,
};

struct f2fs_orphan_block {
	__le32 ino[1020];
	__le32 reserved;
	__le16 blk_addr;
	__le16 blk_count;
	__le32 entry_count;
	__le32 check_sum;
};

enum {
	NAT_BITMAP = 0,
	SIT_BITMAP = 1,
};

struct ino_entry {
	struct list_head list;
	nid_t ino;
	unsigned int dirty_device;
};

struct ckpt_req {
	struct completion wait;
	struct llist_node llnode;
	int ret;
	ktime_t queue_time;
};

struct free_nid {
	struct list_head list;
	nid_t nid;
	int state;
};

struct inode_entry {
	struct list_head list;
	struct inode *inode;
};

struct rb_entry {
	struct rb_node rb_node;
	union {
		struct {
			unsigned int ofs;
			unsigned int len;
		};
		long long unsigned int key;
	};
};

enum need_lock_type {
	LOCK_REQ = 0,
	LOCK_DONE = 1,
	LOCK_RETRY = 2,
};

struct gc_inode_list {
	struct list_head ilist;
	struct xarray iroot;
};

struct victim_info {
	long long unsigned int mtime;
	unsigned int segno;
};

struct victim_entry {
	struct rb_node rb_node;
	union {
		struct {
			long long unsigned int mtime;
			unsigned int segno;
		};
		struct victim_info vi;
	};
	struct list_head list;
};

struct bio_entry {
	struct bio *bio;
	struct list_head list;
};

struct f2fs_private_dio {
	struct inode *inode;
	void *orig_private;
	bio_end_io_t *orig_end_io;
	bool write;
};

enum mem_type {
	FREE_NIDS = 0,
	NAT_ENTRIES = 1,
	DIRTY_DENTS = 2,
	INO_ENTRIES = 3,
	EXTENT_CACHE = 4,
	INMEM_PAGES = 5,
	DISCARD_CACHE = 6,
	COMPRESS_PAGE = 7,
	BASE_CHECK = 8,
};

struct inmem_pages {
	struct list_head list;
	struct page *page;
	block_t old_addr;
};

enum bio_post_read_step___2 {
	STEP_DECRYPT___2 = 0,
	STEP_DECOMPRESS = 0,
	STEP_VERITY___2 = 0,
};

struct bio_post_read_ctx___2 {
	struct bio *bio;
	struct f2fs_sb_info *sbi;
	struct work_struct work;
	unsigned int enabled_steps;
	block_t fs_blkaddr;
};

struct f2fs_nat_block {
	struct f2fs_nat_entry entries[455];
};

enum {
	NAT_JOURNAL = 0,
	SIT_JOURNAL = 1,
};

struct fsync_node_entry {
	struct list_head list;
	struct page *page;
	unsigned int seq_id;
};

enum {
	IS_CHECKPOINTED = 0,
	HAS_FSYNCED_INODE = 1,
	HAS_LAST_FSYNC = 2,
	IS_DIRTY = 3,
	IS_PREALLOC = 4,
};

struct nat_entry {
	struct list_head list;
	struct node_info ni;
};

struct nat_entry_set {
	struct list_head set_list;
	struct list_head entry_list;
	nid_t set;
	unsigned int entry_cnt;
};

struct f2fs_sit_block {
	struct f2fs_sit_entry entries[55];
};

struct discard_entry {
	struct list_head list;
	block_t start_blkaddr;
	unsigned char discard_map[64];
};

enum {
	D_PREP = 0,
	D_PARTIAL = 1,
	D_SUBMIT = 2,
	D_DONE = 3,
};

struct discard_info {
	block_t lstart;
	block_t len;
	block_t start;
};

struct discard_cmd {
	struct rb_node rb_node;
	union {
		struct {
			block_t lstart;
			block_t len;
			block_t start;
		};
		struct discard_info di;
	};
	struct list_head list;
	struct completion wait;
	struct block_device *bdev;
	short unsigned int ref;
	unsigned char state;
	unsigned char queued;
	int error;
	spinlock_t lock;
	short unsigned int bio_ref;
};

enum {
	DPOLICY_BG = 0,
	DPOLICY_FORCE = 1,
	DPOLICY_FSTRIM = 2,
	DPOLICY_UMOUNT = 3,
	MAX_DPOLICY = 4,
};

struct discard_policy {
	int type;
	unsigned int min_interval;
	unsigned int mid_interval;
	unsigned int max_interval;
	unsigned int max_requests;
	unsigned int io_aware_gran;
	bool io_aware;
	bool sync;
	bool ordered;
	bool timeout;
	unsigned int granularity;
};

struct flush_cmd {
	struct completion wait;
	struct llist_node llnode;
	nid_t ino;
	int ret;
};

enum {
	ALLOC_RIGHT = 0,
	ALLOC_LEFT = 1,
};

struct sit_entry_set {
	struct list_head set_list;
	unsigned int start_segno;
	unsigned int entry_cnt;
};

struct fsync_inode_entry {
	struct list_head list;
	struct inode *inode;
	block_t blkaddr;
	block_t last_dentry;
};

enum {
	GC_THREAD = 0,
	SM_INFO = 1,
	DCC_INFO = 2,
	NM_INFO = 3,
	F2FS_SBI = 4,
	STAT_INFO = 5,
	RESERVED_BLOCKS = 6,
	CPRC_INFO = 7,
	ATGC_INFO = 8,
};

struct f2fs_attr {
	struct attribute attr;
	ssize_t (*show)(struct f2fs_attr *, struct f2fs_sb_info *, char *);
	ssize_t (*store)(struct f2fs_attr *, struct f2fs_sb_info *, const char *, size_t);
	int struct_type;
	int offset;
	int id;
};

struct f2fs_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__u32 h_reserved[4];
};

struct f2fs_xattr_entry {
	__u8 e_name_index;
	__u8 e_name_len;
	__le16 e_value_size;
	char e_name[0];
};

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef int __kernel_ipc_pid_t;

typedef __kernel_long_t __kernel_old_time_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long int msg_stime;
	long int msg_rtime;
	long int msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sembuf;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	long int sem_otime;
	long int sem_ctime;
	long unsigned int sem_nsems;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	size_t shm_segsz;
	long int shm_atime;
	long int shm_dtime;
	long int shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct ucounts *mlock_ucounts;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	long: 64;
	long: 64;
	long: 64;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
	bool newns;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct ucounts *ucounts;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 0;
	char data[0];
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_engine {
	char name[30];
	bool idling;
	bool busy;
	bool running;
	bool retry_support;
	struct list_head list;
	spinlock_t queue_lock;
	struct crypto_queue queue;
	struct device *dev;
	bool rt;
	int (*prepare_crypt_hardware)(struct crypto_engine *);
	int (*unprepare_crypt_hardware)(struct crypto_engine *);
	int (*do_batch_requests)(struct crypto_engine *);
	struct kthread_worker *kworker;
	struct kthread_work pump_requests;
	void *priv_data;
	struct crypto_async_request *cur_req;
};

struct crypto_engine_op {
	int (*prepare_request)(struct crypto_engine *, void *);
	int (*unprepare_request)(struct crypto_engine *, void *);
	int (*do_one_request)(struct crypto_engine *, void *);
};

struct crypto_engine_ctx {
	struct crypto_engine_op op;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
	NAPI_STATE_THREADED = 8,
	NAPI_STATE_SCHED_THREADED = 9,
};

enum xps_map_type {
	XPS_CPUS = 0,
	XPS_RXQS = 1,
	XPS_MAPS_MAX = 2,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	__CRYPTOA_MAX = 3,
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_ahash;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hash_alg_common halg;
};

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[256];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *ubuf[0];
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[256];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
};

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	long: 64;
	long: 64;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	struct {
		struct rtattr attr;
		struct crypto_attr_alg data;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

enum blake2b_lengths {
	BLAKE2B_BLOCK_SIZE = 128,
	BLAKE2B_HASH_SIZE = 64,
	BLAKE2B_KEY_SIZE = 64,
	BLAKE2B_160_HASH_SIZE = 20,
	BLAKE2B_256_HASH_SIZE = 32,
	BLAKE2B_384_HASH_SIZE = 48,
	BLAKE2B_512_HASH_SIZE = 64,
};

struct blake2b_state {
	u64 h[8];
	u64 t[2];
	u64 f[2];
	u8 buf[128];
	unsigned int buflen;
	unsigned int outlen;
};

enum blake2b_iv {
	BLAKE2B_IV0 = 4089235720,
	BLAKE2B_IV1 = 2227873595,
	BLAKE2B_IV2 = 4271175723,
	BLAKE2B_IV3 = 1595750129,
	BLAKE2B_IV4 = 2917565137,
	BLAKE2B_IV5 = 725511199,
	BLAKE2B_IV6 = 4215389547,
	BLAKE2B_IV7 = 327033209,
} __attribute__((mode(word)));

typedef void (*blake2b_compress_t)(struct blake2b_state *, const u8 *, size_t, u32);

struct blake2b_tfm_ctx {
	u8 key[64];
	unsigned int keylen;
};

typedef struct {
	u64 a;
	u64 b;
} u128;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct xts_tfm_ctx {
	struct crypto_skcipher *child;
	struct crypto_cipher *tweak;
};

struct xts_instance_ctx {
	struct crypto_skcipher_spawn spawn;
	char name[128];
};

struct xts_request_ctx {
	le128 t;
	struct scatterlist *tail;
	struct scatterlist sg[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request subreq;
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request subreq;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct aead_request subreq;
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher *null;
	u8 nonce[4];
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct ccm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn mac;
};

struct crypto_ccm_ctx {
	struct crypto_ahash *mac;
	struct crypto_skcipher *ctr;
};

struct crypto_rfc4309_ctx {
	struct crypto_aead *child;
	u8 nonce[3];
};

struct crypto_rfc4309_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct aead_request subreq;
};

struct crypto_ccm_req_priv_ctx {
	u8 odata[16];
	u8 idata[16];
	u8 auth_tag[16];
	u32 flags;
	struct scatterlist src[3];
	struct scatterlist dst[3];
	long: 64;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	};
};

struct cbcmac_tfm_ctx {
	struct crypto_cipher *child;
};

struct cbcmac_desc_ctx {
	unsigned int len;
};

struct pcrypt_request {
	struct padata_priv padata;
	void *data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct pcrypt_instance_ctx {
	struct crypto_aead_spawn spawn;
	struct padata_shell *psenc;
	struct padata_shell *psdec;
	atomic_t tfm_count;
};

struct pcrypt_aead_ctx {
	struct crypto_aead *child;
	unsigned int cb_cpu;
};

struct cryptd_skcipher {
	struct crypto_skcipher base;
};

struct cryptd_ahash {
	struct crypto_ahash base;
};

struct cryptd_aead {
	struct crypto_aead base;
};

struct cryptd_cpu_queue {
	struct crypto_queue queue;
	struct work_struct work;
};

struct cryptd_queue {
	struct cryptd_cpu_queue *cpu_queue;
};

struct cryptd_instance_ctx {
	struct crypto_spawn spawn;
	struct cryptd_queue *queue;
};

struct skcipherd_instance_ctx {
	struct crypto_skcipher_spawn spawn;
	struct cryptd_queue *queue;
};

struct hashd_instance_ctx {
	struct crypto_shash_spawn spawn;
	struct cryptd_queue *queue;
};

struct aead_instance_ctx {
	struct crypto_aead_spawn aead_spawn;
	struct cryptd_queue *queue;
};

struct cryptd_skcipher_ctx {
	refcount_t refcnt;
	struct crypto_skcipher *child;
};

struct cryptd_skcipher_request_ctx {
	crypto_completion_t complete;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request req;
};

struct cryptd_hash_ctx {
	refcount_t refcnt;
	struct crypto_shash *child;
};

struct cryptd_hash_request_ctx {
	crypto_completion_t complete;
	struct shash_desc desc;
};

struct cryptd_aead_ctx {
	refcount_t refcnt;
	struct crypto_aead *child;
};

struct cryptd_aead_request_ctx {
	crypto_completion_t complete;
};

struct des_ctx {
	u32 expkey[32];
};

struct des3_ede_ctx {
	u32 expkey[96];
};

struct deflate_ctx {
	struct z_stream_s comp_stream;
	struct z_stream_s decomp_stream;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct chksum_desc_ctx___2 {
	__u16 crc;
};

enum {
	CRYPTO_AUTHENC_KEYA_UNSPEC = 0,
	CRYPTO_AUTHENC_KEYA_PARAM = 1,
};

struct crypto_authenc_key_param {
	__be32 enckeylen;
};

struct crypto_authenc_keys {
	const u8 *authkey;
	const u8 *enckey;
	unsigned int authkeylen;
	unsigned int enckeylen;
};

struct authenc_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
	unsigned int reqoff;
};

struct crypto_authenc_ctx {
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct authenc_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct authenc_esn_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
};

struct crypto_authenc_esn_ctx {
	unsigned int reqoff;
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct authenc_esn_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct xxhash64_tfm_ctx {
	u64 seed;
};

struct xxhash64_desc_ctx {
	struct xxh64_state xxhstate;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx___2 {
	u8 buffer[16];
	u32 bytes;
};

typedef enum {
	ZSTDcs_created = 0,
	ZSTDcs_init = 1,
	ZSTDcs_ongoing = 2,
	ZSTDcs_ending = 3,
} ZSTD_compressionStage_e;

typedef struct {
	U32 price;
	U32 off;
	U32 mlen;
	U32 litlen;
	U32 rep[3];
} ZSTD_optimal_t;

typedef struct {
	U32 off;
	U32 len;
} ZSTD_match_t;

struct seqDef_s;

typedef struct seqDef_s seqDef;

typedef struct {
	seqDef *sequencesStart;
	seqDef *sequences;
	BYTE *litStart;
	BYTE *lit;
	BYTE *llCode;
	BYTE *mlCode;
	BYTE *ofCode;
	U32 longLengthID;
	U32 longLengthPos;
	ZSTD_optimal_t *priceTable;
	ZSTD_match_t *matchTable;
	U32 *matchLengthFreq;
	U32 *litLengthFreq;
	U32 *litFreq;
	U32 *offCodeFreq;
	U32 matchLengthSum;
	U32 matchSum;
	U32 litLengthSum;
	U32 litSum;
	U32 offCodeSum;
	U32 log2matchLengthSum;
	U32 log2matchSum;
	U32 log2litLengthSum;
	U32 log2litSum;
	U32 log2offCodeSum;
	U32 factor;
	U32 staticPrices;
	U32 cachedPrice;
	U32 cachedLitLength;
	const BYTE *cachedLiterals;
} seqStore_t;

typedef enum {
	HUF_repeat_none = 0,
	HUF_repeat_check = 1,
	HUF_repeat_valid = 2,
} HUF_repeat;

typedef unsigned int FSE_CTable;

struct HUF_CElt_s;

typedef struct HUF_CElt_s HUF_CElt;

struct ZSTD_CCtx_s {
	const BYTE *nextSrc;
	const BYTE *base;
	const BYTE *dictBase;
	U32 dictLimit;
	U32 lowLimit;
	U32 nextToUpdate;
	U32 nextToUpdate3;
	U32 hashLog3;
	U32 loadedDictEnd;
	U32 forceWindow;
	U32 forceRawDict;
	ZSTD_compressionStage_e stage;
	U32 rep[3];
	U32 repToConfirm[3];
	U32 dictID;
	ZSTD_parameters params;
	void *workSpace;
	size_t workSpaceSize;
	size_t blockSize;
	U64 frameContentSize;
	struct xxh64_state xxhState;
	ZSTD_customMem customMem;
	seqStore_t seqStore;
	U32 *hashTable;
	U32 *hashTable3;
	U32 *chainTable;
	HUF_CElt *hufTable;
	U32 flagStaticTables;
	HUF_repeat flagStaticHufTable;
	FSE_CTable offcodeCTable[187];
	FSE_CTable matchlengthCTable[363];
	FSE_CTable litlengthCTable[329];
	unsigned int tmpCounters[1536];
};

typedef unsigned int FSE_DTable;

typedef U32 HUF_DTable;

typedef struct {
	FSE_DTable LLTable[513];
	FSE_DTable OFTable[257];
	FSE_DTable MLTable[513];
	HUF_DTable hufTable[4097];
	U64 workspace[384];
	U32 rep[3];
} ZSTD_entropyTables_t;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

struct ZSTD_DCtx_s {
	const FSE_DTable *LLTptr;
	const FSE_DTable *MLTptr;
	const FSE_DTable *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyTables_t entropy;
	const void *previousDstEnd;
	const void *base;
	const void *vBase;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameParams fParams;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	U32 dictID;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	BYTE litBuffer[131080];
	BYTE headerBuffer[18];
};

struct zstd_ctx {
	ZSTD_CCtx *cctx;
	ZSTD_DCtx *dctx;
	void *cwksp;
	void *dwksp;
};

struct xor_block_template {
	struct xor_block_template *next;
	const char *name;
	int speed;
	void (*do_2)(long unsigned int, long unsigned int *, long unsigned int *);
	void (*do_3)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	void (*do_4)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
	void (*do_5)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
};

struct simd_skcipher_alg {
	const char *ialg_name;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_alg alg;
};

struct simd_skcipher_ctx {
	struct cryptd_skcipher *cryptd_tfm;
};

struct simd_aead_alg {
	const char *ialg_name;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct aead_alg alg;
};

struct simd_aead_ctx {
	struct cryptd_aead *cryptd_tfm;
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	long unsigned int rq_dispatched[2];
	long unsigned int rq_merged;
	long unsigned int rq_completed[2];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	unsigned int cmd_flags;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_flush_queue {
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	spinlock_t mq_flush_lock;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue *bitmap_tags;
	struct sbitmap_queue *breserved_tags;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	bool multi_bio: 1;
	bool should_dirty: 1;
	bool is_sync: 1;
	struct bio bio;
};

struct bio_alloc_cache {
	struct bio_list free_list;
	unsigned int nr;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
	RQ_QOS_IOPRIO = 3,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
};

enum {
	sysctl_hung_task_timeout_secs = 0,
};

struct blk_mq_debugfs_attr;

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 128,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_complete {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, int, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 500,
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct rq_map_data {
	struct page **pages;
	int page_order;
	int nr_entries;
	long unsigned int offset;
	int null_mapped;
	int from_user;
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

typedef bool busy_iter_fn(struct blk_mq_hw_ctx *, struct request *, void *, bool);

typedef bool busy_tag_iter_fn(struct request *, void *, bool);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	busy_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	bool enable_accounting;
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct parsed_partitions {
	struct gendisk *disk;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct page *v;
} Sector;

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	FIT_PARTITION = 46,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

typedef guid_t efi_guid_t;

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

typedef int bsg_sg_io_fn(struct request_queue *, struct sg_io_v4 *, fmode_t, unsigned int);

struct bsg_device {
	struct request_queue *queue;
	struct device device;
	struct cdev cdev;
	int max_queue;
	unsigned int timeout;
	unsigned int reserved_size;
	bsg_sg_io_fn *sg_io_fn;
};

struct bsg_job;

typedef int bsg_job_fn(struct bsg_job *);

struct bsg_buffer {
	unsigned int payload_len;
	int sg_cnt;
	struct scatterlist *sg_list;
};

struct bsg_job {
	struct device *dev;
	struct kref kref;
	unsigned int timeout;
	void *request;
	void *reply;
	unsigned int request_len;
	unsigned int reply_len;
	struct bsg_buffer request_payload;
	struct bsg_buffer reply_payload;
	int result;
	unsigned int reply_payload_rcv_len;
	struct request *bidi_rq;
	struct bio *bidi_bio;
	void *dd_data;
};

typedef enum blk_eh_timer_return bsg_timeout_fn(struct request *);

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct bsg_set {
	struct blk_mq_tag_set tag_set;
	struct bsg_device *bd;
	bsg_job_fn *job_fn;
	bsg_timeout_fn *timeout_fn;
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_init_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_bind_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(gfp_t, struct request_queue *, struct blkcg *);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef bool blkcg_pol_stat_pd_fn(struct blkg_policy_data *, struct seq_file *);

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_init_cpd_fn *cpd_init_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_bind_cpd_fn *cpd_bind_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
};

struct blkg_conf_ctx {
	struct block_device *bdev;
	struct blkcg_gq *blkg;
	char *body;
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

struct blkg_rwstat {
	struct percpu_counter cpu_cnt[5];
	atomic64_t aux_cnt[5];
};

struct blkg_rwstat_sample {
	u64 cnt[5];
};

struct throtl_service_queue {
	struct throtl_service_queue *parent_sq;
	struct list_head queued[2];
	unsigned int nr_queued[2];
	struct rb_root_cached pending_tree;
	unsigned int nr_pending;
	long unsigned int first_pending_disptime;
	struct timer_list pending_timer;
};

struct latency_bucket {
	long unsigned int total_latency;
	int samples;
};

struct avg_latency_bucket {
	long unsigned int latency;
	bool valid;
};

struct throtl_data {
	struct throtl_service_queue service_queue;
	struct request_queue *queue;
	unsigned int nr_queued[2];
	unsigned int throtl_slice;
	struct work_struct dispatch_work;
	unsigned int limit_index;
	bool limit_valid[2];
	long unsigned int low_upgrade_time;
	long unsigned int low_downgrade_time;
	unsigned int scale;
	struct latency_bucket tmp_buckets[18];
	struct avg_latency_bucket avg_buckets[18];
	struct latency_bucket *latency_buckets[2];
	long unsigned int last_calculate_time;
	long unsigned int filtered_latency;
	bool track_bio_latency;
};

struct throtl_grp;

struct throtl_qnode {
	struct list_head node;
	struct bio_list bios;
	struct throtl_grp *tg;
};

struct throtl_grp {
	struct blkg_policy_data pd;
	struct rb_node rb_node;
	struct throtl_data *td;
	struct throtl_service_queue service_queue;
	struct throtl_qnode qnode_on_self[2];
	struct throtl_qnode qnode_on_parent[2];
	long unsigned int disptime;
	unsigned int flags;
	bool has_rules[2];
	uint64_t bps[4];
	uint64_t bps_conf[4];
	unsigned int iops[4];
	unsigned int iops_conf[4];
	uint64_t bytes_disp[2];
	unsigned int io_disp[2];
	long unsigned int last_low_overflow_time[2];
	uint64_t last_bytes_disp[2];
	unsigned int last_io_disp[2];
	long unsigned int last_check_time;
	long unsigned int latency_target;
	long unsigned int latency_target_conf;
	long unsigned int slice_start[2];
	long unsigned int slice_end[2];
	long unsigned int last_finish_time;
	long unsigned int checked_last_finish_time;
	long unsigned int avg_idletime;
	long unsigned int idletime_threshold;
	long unsigned int idletime_threshold_conf;
	unsigned int bio_cnt;
	unsigned int bad_bio_cnt;
	long unsigned int bio_cnt_reset_time;
	atomic_t io_split_cnt[2];
	atomic_t last_io_split_cnt[2];
	struct blkg_rwstat stat_bytes;
	struct blkg_rwstat stat_ios;
};

enum tg_state_flags {
	THROTL_TG_PENDING = 1,
	THROTL_TG_WAS_EMPTY = 2,
};

enum {
	LIMIT_LOW = 0,
	LIMIT_MAX = 1,
	LIMIT_CNT = 2,
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum blk_integrity_flags {
	BLK_INTEGRITY_VERIFY = 1,
	BLK_INTEGRITY_GENERATE = 2,
	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
	BLK_INTEGRITY_IP_CHECKSUM = 8,
};

struct integrity_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_integrity *, char *);
	ssize_t (*store)(struct blk_integrity *, const char *, size_t);
};

typedef __u16 __sum16;

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

struct t10_pi_tuple {
	__be16 guard_tag;
	__be16 app_tag;
	__be32 ref_tag;
};

typedef __be16 csum_fn(void *, unsigned int);

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_device;

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	void *priv;
};

struct vringh_config_ops;

struct virtio_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	spinlock_t vqs_list_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct xa_limit {
	u32 max;
	u32 min;
};

struct io_wq_work_node;

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

struct io_ring_ctx;

struct io_wq;

struct io_uring_task {
	int cached_refs;
	struct xarray xa;
	struct wait_queue_head wait;
	const struct io_ring_ctx *last;
	struct io_wq *io_wq;
	struct percpu_counter inflight;
	atomic_t inflight_tracked;
	atomic_t in_idle;
	spinlock_t task_lock;
	struct io_wq_work_list task_list;
	struct callback_head task_work;
	bool task_running;
};

struct iov_iter_state {
	size_t iov_offset;
	size_t count;
	long unsigned int nr_segs;
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

typedef u32 compat_size_t;

typedef s32 compat_int_t;

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 consumed;
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	bool eventfd;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	int fd;
	char __data[0];
};

struct io_wq_work;

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	int rw;
	void *req;
	struct io_wq_work *work;
	unsigned int flags;
	char __data[0];
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work {
	struct io_wq_work_node list;
	unsigned int flags;
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *req;
	void *link;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	u64 user_data;
	int res;
	unsigned int cflags;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_sqe {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u8 opcode;
	u64 user_data;
	u32 flags;
	bool force_nonblock;
	bool sq_thread;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u8 opcode;
	u64 user_data;
	int mask;
	int events;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_wake {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_run {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u8 opcode;
	u64 user_data;
	char __data[0];
};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_queue_async_work {};

struct trace_event_data_offsets_io_uring_defer {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_fail_link {};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_submit_sqe {};

struct trace_event_data_offsets_io_uring_poll_arm {};

struct trace_event_data_offsets_io_uring_poll_wake {};

struct trace_event_data_offsets_io_uring_task_add {};

struct trace_event_data_offsets_io_uring_task_run {};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, bool, long int);

typedef void (*btf_trace_io_uring_file_get)(void *, void *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, void *, int, void *, struct io_wq_work *, unsigned int);

typedef void (*btf_trace_io_uring_defer)(void *, void *, void *, long long unsigned int);

typedef void (*btf_trace_io_uring_link)(void *, void *, void *, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, void *, void *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, u64, int, unsigned int);

typedef void (*btf_trace_io_uring_submit_sqe)(void *, void *, void *, u8, u64, u32, bool, bool);

typedef void (*btf_trace_io_uring_poll_arm)(void *, void *, void *, u8, u64, int, int);

typedef void (*btf_trace_io_uring_poll_wake)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_add)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_run)(void *, void *, void *, u8, u64);

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
		__u32 hardlink_flags;
	};
	__u64 user_data;
	union {
		__u16 buf_index;
		__u16 buf_group;
	};
	__u16 personality;
	union {
		__s32 splice_fd_in;
		__u32 file_index;
	};
	__u64 __pad2[2];
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
};

enum {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_MKDIRAT = 37,
	IORING_OP_SYMLINKAT = 38,
	IORING_OP_LINKAT = 39,
	IORING_OP_LAST = 40,
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
};

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 resv2;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_FILES2 = 13,
	IORING_REGISTER_FILES_UPDATE2 = 14,
	IORING_REGISTER_BUFFERS2 = 15,
	IORING_REGISTER_BUFFERS_UPDATE = 16,
	IORING_REGISTER_IOWQ_AFF = 17,
	IORING_UNREGISTER_IOWQ_AFF = 18,
	IORING_REGISTER_IOWQ_MAX_WORKERS = 19,
	IORING_REGISTER_LAST = 20,
};

struct io_uring_rsrc_register {
	__u32 nr;
	__u32 resv;
	__u64 resv2;
	__u64 data;
	__u64 tags;
};

struct io_uring_rsrc_update2 {
	__u32 offset;
	__u32 resv;
	__u64 data;
	__u64 tags;
	__u32 nr;
	__u32 resv2;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad;
	__u64 ts;
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_HASH_SHIFT = 24,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

typedef struct io_wq_work *free_work_fn(struct io_wq_work *);

typedef void io_wq_work_fn(struct io_wq_work *);

struct io_wq_hash {
	refcount_t refs;
	long unsigned int map;
	struct wait_queue_head wait;
};

struct io_wq_data {
	struct io_wq_hash *hash;
	struct task_struct *task;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

typedef bool work_cancel_fn(struct io_wq_work *, void *);

struct io_uring {
	u32 head;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 tail;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	u32 sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

enum io_uring_cmd_flags {
	IO_URING_F_NONBLOCK = 1,
	IO_URING_F_COMPLETE_DEFER = 2,
};

struct io_mapped_ubuf {
	u64 ubuf;
	u64 ubuf_end;
	unsigned int nr_bvecs;
	long unsigned int acct_pages;
	struct bio_vec bvec[0];
};

struct io_overflow_cqe {
	struct io_uring_cqe cqe;
	struct list_head list;
};

struct io_fixed_file {
	long unsigned int file_ptr;
};

struct io_rsrc_put {
	struct list_head list;
	u64 tag;
	union {
		void *rsrc;
		struct file *file;
		struct io_mapped_ubuf *buf;
	};
};

struct io_file_table {
	struct io_fixed_file *files;
};

struct io_rsrc_data;

struct io_rsrc_node {
	struct percpu_ref refs;
	struct list_head node;
	struct list_head rsrc_list;
	struct io_rsrc_data *rsrc_data;
	struct llist_node llist;
	bool done;
};

typedef void rsrc_put_fn(struct io_ring_ctx *, struct io_rsrc_put *);

struct io_rsrc_data {
	struct io_ring_ctx *ctx;
	u64 **tags;
	unsigned int nr;
	rsrc_put_fn *do_put;
	atomic_t refs;
	struct completion done;
	bool quiesce;
};

struct io_kiocb;

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_submit_state {
	struct blk_plug plug;
	struct io_submit_link link;
	void *reqs[32];
	unsigned int free_reqs;
	bool plug_started;
	struct io_kiocb *compl_reqs[32];
	unsigned int compl_nr;
	struct list_head free_list;
	unsigned int ios_left;
};

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_sq_data;

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		struct io_rings *rings;
		unsigned int flags;
		unsigned int compat: 1;
		unsigned int drain_next: 1;
		unsigned int eventfd_async: 1;
		unsigned int restricted: 1;
		unsigned int off_timeout_used: 1;
		unsigned int drain_active: 1;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		u32 *sq_array;
		struct io_uring_sqe *sq_sqes;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		struct list_head defer_list;
		struct io_rsrc_node *rsrc_node;
		struct io_file_table file_table;
		unsigned int nr_user_files;
		unsigned int nr_user_bufs;
		struct io_mapped_ubuf **user_bufs;
		struct io_submit_state submit_state;
		struct list_head timeout_list;
		struct list_head ltimeout_list;
		struct list_head cq_overflow_list;
		struct xarray io_buffers;
		struct xarray personalities;
		u32 pers_next;
		unsigned int sq_thread_idle;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct list_head locked_free_list;
	unsigned int locked_free_nr;
	const struct cred *sq_creds;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	long unsigned int check_cq_overflow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		struct eventfd_ctx *cq_ev_fd;
		struct wait_queue_head poll_wait;
		struct wait_queue_head cq_wait;
		unsigned int cq_extra;
		atomic_t cq_timeouts;
		unsigned int cq_last_tm_flush;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t completion_lock;
		spinlock_t timeout_lock;
		struct list_head iopoll_list;
		struct hlist_head *cancel_hash;
		unsigned int cancel_hash_bits;
		bool poll_multi_queue;
		long: 64;
		long: 64;
		long: 64;
	};
	struct io_restriction restrictions;
	struct {
		struct io_rsrc_node *rsrc_backup_node;
		struct io_mapped_ubuf *dummy_ubuf;
		struct io_rsrc_data *file_data;
		struct io_rsrc_data *buf_data;
		struct delayed_work rsrc_put_work;
		struct llist_head rsrc_put_llist;
		struct list_head rsrc_ref_list;
		spinlock_t rsrc_ref_lock;
	};
	struct {
		struct socket *ring_sock;
		struct io_wq_hash *hash_map;
		struct user_struct *user;
		struct mm_struct *mm_account;
		struct llist_head fallback_llist;
		struct delayed_work fallback_work;
		struct work_struct exit_work;
		struct list_head tctx_list;
		struct completion ref_comp;
		u32 iowq_limits[2];
		bool iowq_limits_set;
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
};

enum {
	IO_SQ_THREAD_SHOULD_STOP = 0,
	IO_SQ_THREAD_SHOULD_PARK = 1,
};

struct io_sq_data {
	refcount_t refs;
	atomic_t park_pending;
	struct mutex lock;
	struct list_head ctx_list;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
	int sq_cpu;
	pid_t task_pid;
	pid_t task_tgid;
	long unsigned int state;
	struct completion exited;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u64 len;
};

struct io_poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	int retries;
	struct wait_queue_entry wait;
};

struct io_poll_update {
	struct file *file;
	u64 old_user_data;
	u64 new_user_data;
	__poll_t events;
	bool update_events;
	bool update_user_data;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_cancel {
	struct file *file;
	u64 addr;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	struct list_head list;
	struct io_kiocb *head;
	struct io_kiocb *prev;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
	bool ltimeout;
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
};

struct io_sr_msg {
	struct file *file;
	union {
		struct compat_msghdr *umsg_compat;
		struct user_msghdr *umsg;
		void *buf;
	};
	int msg_flags;
	int bgid;
	size_t len;
	size_t done_io;
	struct io_buffer *kbuf;
	void *msg_control;
};

struct io_open {
	struct file *file;
	int dfd;
	u32 file_slot;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
};

struct io_close {
	struct file *file;
	int fd;
	u32 file_slot;
};

struct io_rsrc_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_splice {
	struct file *file_out;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	int splice_fd_in;
	unsigned int flags;
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u16 nbufs;
	__u16 bid;
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	const char *filename;
	struct statx *buffer;
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_mkdir {
	struct file *file;
	int dfd;
	umode_t mode;
	struct filename *filename;
};

struct io_symlink {
	struct file *file;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
};

struct io_hardlink {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_completion {
	struct file *file;
	u32 cflags;
};

typedef void (*io_req_tw_func_t)(struct io_kiocb *, bool *);

struct io_task_work {
	union {
		struct io_wq_work_node node;
		struct llist_node fallback_node;
	};
	io_req_tw_func_t func;
};

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_rw rw;
		struct io_poll_iocb poll;
		struct io_poll_update poll_update;
		struct io_accept accept;
		struct io_sync sync;
		struct io_cancel cancel;
		struct io_timeout timeout;
		struct io_timeout_rem timeout_rem;
		struct io_connect connect;
		struct io_sr_msg sr_msg;
		struct io_open open;
		struct io_close close;
		struct io_rsrc_update rsrc_update;
		struct io_fadvise fadvise;
		struct io_madvise madvise;
		struct io_epoll epoll;
		struct io_splice splice;
		struct io_provide_buf pbuf;
		struct io_statx statx;
		struct io_shutdown shutdown;
		struct io_rename rename;
		struct io_unlink unlink;
		struct io_mkdir mkdir;
		struct io_symlink symlink;
		struct io_hardlink hardlink;
		struct io_completion compl;
	};
	void *async_data;
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	u32 result;
	struct io_ring_ctx *ctx;
	unsigned int flags;
	atomic_t refs;
	struct task_struct *task;
	u64 user_data;
	struct io_kiocb *link;
	struct percpu_ref *fixed_rsrc_refs;
	struct list_head inflight_entry;
	struct io_task_work io_task_work;
	struct hlist_node hash_node;
	struct async_poll *apoll;
	struct io_wq_work work;
	const struct cred *creds;
	struct io_mapped_ubuf *imu;
	struct io_buffer *kbuf;
	atomic_t poll_refs;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
	u32 flags;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

struct io_async_msghdr {
	struct iovec fast_iov[8];
	struct iovec *free_iov;
	struct sockaddr *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_rw {
	struct iovec fast_iov[8];
	const struct iovec *free_iovec;
	struct iov_iter iter;
	struct iov_iter_state iter_state;
	size_t bytes_done;
	struct wait_page_queue wpq;
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_FAIL_BIT = 8,
	REQ_F_INFLIGHT_BIT = 9,
	REQ_F_CUR_POS_BIT = 10,
	REQ_F_NOWAIT_BIT = 11,
	REQ_F_LINK_TIMEOUT_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_BUFFER_SELECTED_BIT = 15,
	REQ_F_COMPLETE_INLINE_BIT = 16,
	REQ_F_REISSUE_BIT = 17,
	REQ_F_CREDS_BIT = 18,
	REQ_F_REFCOUNT_BIT = 19,
	REQ_F_ARM_LTIMEOUT_BIT = 20,
	REQ_F_PARTIAL_IO_BIT = 21,
	REQ_F_NOWAIT_READ_BIT = 22,
	REQ_F_NOWAIT_WRITE_BIT = 23,
	REQ_F_ISREG_BIT = 24,
	__REQ_F_LAST_BIT = 25,
};

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_FAIL = 256,
	REQ_F_INFLIGHT = 512,
	REQ_F_CUR_POS = 1024,
	REQ_F_NOWAIT = 2048,
	REQ_F_LINK_TIMEOUT = 4096,
	REQ_F_NEED_CLEANUP = 8192,
	REQ_F_POLLED = 16384,
	REQ_F_BUFFER_SELECTED = 32768,
	REQ_F_COMPLETE_INLINE = 65536,
	REQ_F_REISSUE = 131072,
	REQ_F_NOWAIT_READ = 4194304,
	REQ_F_NOWAIT_WRITE = 8388608,
	REQ_F_ISREG = 16777216,
	REQ_F_CREDS = 262144,
	REQ_F_REFCOUNT = 524288,
	REQ_F_ARM_LTIMEOUT = 1048576,
	REQ_F_PARTIAL_IO = 2097152,
};

struct async_poll {
	struct io_poll_iocb poll;
	struct io_poll_iocb *double_poll;
};

enum {
	IORING_RSRC_FILE = 0,
	IORING_RSRC_BUFFER = 1,
};

struct io_tctx_node {
	struct list_head ctx_node;
	struct task_struct *task;
	struct io_ring_ctx *ctx;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_op_def {
	unsigned int needs_file: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int not_supported: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int buffer_select: 1;
	unsigned int needs_async_setup: 1;
	unsigned int plug: 1;
	short unsigned int async_size;
};

struct req_batch {
	struct task_struct *task;
	int task_refs;
	int ctx_refs;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
};

enum {
	IO_APOLL_OK = 0,
	IO_APOLL_ABORTED = 1,
	IO_APOLL_READY = 2,
};

struct io_cancel_data {
	struct io_ring_ctx *ctx;
	u64 user_data;
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int cq_tail;
	unsigned int nr_timeouts;
};

struct io_tctx_exit {
	struct callback_head task_work;
	struct completion completion;
	struct io_ring_ctx *ctx;
};

struct io_task_cancel {
	struct task_struct *task;
	bool all;
};

struct creds;

enum {
	IO_WQ_BOUND = 0,
	IO_WQ_UNBOUND = 1,
};

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_BOUND = 8,
};

enum {
	IO_WQ_BIT_EXIT = 0,
};

enum {
	IO_ACCT_STALLED_BIT = 0,
};

struct io_wqe;

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wqe *wqe;
	struct io_wq_work *cur_work;
	spinlock_t lock;
	struct completion ref_done;
	long unsigned int create_state;
	struct callback_head create_work;
	int create_index;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct io_wqe_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	int index;
	atomic_t nr_running;
	struct io_wq_work_list work_list;
	long unsigned int flags;
};

struct io_wqe {
	raw_spinlock_t lock;
	struct io_wqe_acct acct[2];
	int node;
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct wait_queue_entry wait;
	struct io_wq *wq;
	struct io_wq_work *hash_tail[64];
	cpumask_var_t cpu_mask;
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
	IO_WQ_ACCT_NR = 2,
};

struct io_wq {
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct io_wq_hash *hash;
	atomic_t worker_refs;
	struct completion worker_done;
	struct hlist_node cpuhp_node;
	struct task_struct *task;
	struct io_wqe *wqes[0];
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct online_data {
	unsigned int cpu;
	bool online;
};

typedef long unsigned int uint64x2_t[2];

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct siprand_state {
	long unsigned int v0;
	long unsigned int v1;
	long unsigned int v2;
	long unsigned int v3;
};

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
	unsigned int nbits;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

struct sg_append_table {
	struct sg_table sgt;
	struct scatterlist *prv;
	unsigned int total_nents;
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

struct csum_state {
	__wsum csum;
	size_t off;
};

typedef s32 compat_ssize_t;

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct rhltable {
	struct rhashtable ht;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
	struct module *module;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[512];
		u8 data[4096];
	};
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

struct arc4_ctx {
	u32 S[256];
	u32 x;
	u32 y;
};

enum blake2s_lengths {
	BLAKE2S_BLOCK_SIZE = 64,
	BLAKE2S_HASH_SIZE = 32,
	BLAKE2S_KEY_SIZE = 32,
	BLAKE2S_128_HASH_SIZE = 16,
	BLAKE2S_160_HASH_SIZE = 20,
	BLAKE2S_224_HASH_SIZE = 28,
	BLAKE2S_256_HASH_SIZE = 32,
};

struct blake2s_state {
	u32 h[8];
	u32 t[2];
	u32 f[2];
	u8 buf[64];
	unsigned int buflen;
	unsigned int outlen;
};

enum blake2s_iv {
	BLAKE2S_IV0 = 1779033703,
	BLAKE2S_IV1 = 3144134277,
	BLAKE2S_IV2 = 1013904242,
	BLAKE2S_IV3 = 2773480762,
	BLAKE2S_IV4 = 1359893119,
	BLAKE2S_IV5 = 2600822924,
	BLAKE2S_IV6 = 528734635,
	BLAKE2S_IV7 = 1541459225,
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
	DEVM_IOREMAP_NP = 3,
};

struct pcim_iomap_devres {
	void *table[6];
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

enum packing_op {
	PACK = 0,
	UNPACK = 1,
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

// typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

typedef uint16_t U16;

typedef struct {
	size_t bitContainer;
	int bitPos;
	char *startPtr;
	char *ptr;
	char *endPtr;
} BIT_CStream_t;

typedef struct {
	ptrdiff_t value;
	const void *stateTable;
	const void *symbolTT;
	unsigned int stateLog;
} FSE_CState_t;

typedef struct {
	int deltaFindState;
	U32 deltaNbBits;
} FSE_symbolCompressionTransform;

typedef int16_t S16;

struct HUF_CElt_s {
	U16 val;
	BYTE nbBits;
};

struct nodeElt_s {
	U32 count;
	U16 parent;
	BYTE byte;
	BYTE nbBits;
};

typedef struct nodeElt_s nodeElt;

typedef struct {
	U32 base;
	U32 curr;
} rankPos;

struct ZSTD_CDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictContentSize;
	ZSTD_CCtx *refContext;
};

typedef int32_t S32;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

struct seqDef_s {
	U32 offset;
	U16 litLength;
	U16 matchLength;
};

typedef enum {
	ZSTDcrp_continue = 0,
	ZSTDcrp_noMemset = 1,
	ZSTDcrp_fullReset = 2,
} ZSTD_compResetPolicy_e;

typedef void (*ZSTD_blockCompressor)(ZSTD_CCtx *, const void *, size_t);

typedef enum {
	zsf_gather = 0,
	zsf_flush = 1,
	zsf_end = 2,
} ZSTD_flush_e;

typedef size_t (*searchMax_f)(ZSTD_CCtx *, const BYTE *, const BYTE *, size_t *, U32, U32);

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	void *ptr;
	const void *end;
} ZSTD_stack;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	BYTE byte;
	BYTE nbBits;
} HUF_DEltX2;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX4;

typedef struct {
	BYTE symbol;
	BYTE weight;
} sortedSymbol_t;

typedef U32 rankValCol_t[13];

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef uintptr_t uPtrDiff;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef union {
	FSE_decode_t realData;
	U32 alignedBy4;
} FSE_decode_t4;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
	const BYTE *match;
} seq_t;

typedef struct {
	BIT_DStream_t DStream;
	FSE_DState_t stateLL;
	FSE_DState_t stateOffb;
	FSE_DState_t stateML;
	size_t prevOffset[3];
	const BYTE *base;
	size_t pos;
	uPtrDiff gotoDict;
} seqState_t;

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct raid6_recov_calls {
	void (*data2)(int, size_t, int, int, void **);
	void (*datap)(int, size_t, int, void **);
	int (*valid)();
	const char *name;
	int priority;
};

typedef u64 unative_t;

typedef unsigned char uint8_t___2;

typedef signed char int8x16_t[16];

typedef unsigned char __Poly8_t;

typedef __Poly8_t poly8x16_t[16];

typedef unsigned char uint8x16_t[16];

typedef uint8x16_t unative_t___2;

typedef int Int32;

typedef struct {
	SRes (*Read)(void *, void *, size_t *);
} ISeqInStream;

typedef UInt32 CLzRef;

struct _CMatchFinder {
	Byte *buffer;
	UInt32 pos;
	UInt32 posLimit;
	UInt32 streamPos;
	UInt32 lenLimit;
	UInt32 cyclicBufferPos;
	UInt32 cyclicBufferSize;
	UInt32 matchMaxLen;
	CLzRef *hash;
	CLzRef *son;
	UInt32 hashMask;
	UInt32 cutValue;
	Byte *bufferBase;
	ISeqInStream *stream;
	int streamEndWasReached;
	UInt32 blockSize;
	UInt32 keepSizeBefore;
	UInt32 keepSizeAfter;
	UInt32 numHashBytes;
	int directInput;
	size_t directInputRem;
	int btMode;
	int bigHash;
	UInt32 historySize;
	UInt32 fixedHashSize;
	UInt32 hashSizeSum;
	UInt32 numSons;
	SRes result;
	UInt32 crc[256];
};

typedef struct _CMatchFinder CMatchFinder;

typedef void (*Mf_Init_Func)(void *);

typedef Byte (*Mf_GetIndexByte_Func)(void *, Int32);

typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *);

typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *);

typedef UInt32 (*Mf_GetMatches_Func)(void *, UInt32 *);

typedef void (*Mf_Skip_Func)(void *, UInt32);

struct _IMatchFinder {
	Mf_Init_Func Init;
	Mf_GetIndexByte_Func GetIndexByte;
	Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
	Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
	Mf_GetMatches_Func GetMatches;
	Mf_Skip_Func Skip;
};

typedef struct _IMatchFinder IMatchFinder;

typedef short unsigned int UInt16;

typedef int Bool;

typedef struct {
	size_t (*Write)(void *, const void *, size_t);
} ISeqOutStream;

typedef unsigned int CState;

typedef struct {
	UInt32 price;
	CState state;
	int prev1IsChar;
	int prev2;
	UInt32 posPrev2;
	UInt32 backPrev2;
	UInt32 posPrev;
	UInt32 backPrev;
	UInt32 backs[4];
} COptimal;

typedef struct {
	UInt16 choice;
	UInt16 choice2;
	UInt16 low[128];
	UInt16 mid[128];
	UInt16 high[256];
} CLenEnc;

typedef struct {
	CLenEnc p;
	UInt32 prices[4352];
	UInt32 tableSize;
	UInt32 counters[16];
} CLenPriceEnc;

typedef struct {
	UInt32 range;
	Byte cache;
	UInt64 low;
	UInt64 cacheSize;
	Byte *buf;
	Byte *bufLim;
	Byte *bufBase;
	ISeqOutStream *outStream;
	UInt64 processed;
	SRes res;
} CRangeEnc;

typedef struct {
	UInt16 *litProbs;
	UInt16 isMatch[192];
	UInt16 isRep[12];
	UInt16 isRepG0[12];
	UInt16 isRepG1[12];
	UInt16 isRepG2[12];
	UInt16 isRep0Long[192];
	UInt16 posSlotEncoder[256];
	UInt16 posEncoders[114];
	UInt16 posAlignEncoder[16];
	CLenPriceEnc lenEnc;
	CLenPriceEnc repLenEnc;
	UInt32 reps[4];
	UInt32 state;
} CSaveState;

typedef struct {
	IMatchFinder matchFinder;
	void *matchFinderObj;
	CMatchFinder matchFinderBase;
	UInt32 optimumEndIndex;
	UInt32 optimumCurrentIndex;
	UInt32 longestMatchLength;
	UInt32 numPairs;
	UInt32 numAvail;
	COptimal opt[4096];
	Byte g_FastPos[8192];
	UInt32 ProbPrices[128];
	UInt32 matches[549];
	UInt32 numFastBytes;
	UInt32 additionalOffset;
	UInt32 reps[4];
	UInt32 state;
	UInt32 posSlotPrices[256];
	UInt32 distancesPrices[512];
	UInt32 alignPrices[16];
	UInt32 alignPriceCount;
	UInt32 distTableSize;
	unsigned int lc;
	unsigned int lp;
	unsigned int pb;
	unsigned int lpMask;
	unsigned int pbMask;
	UInt16 *litProbs;
	UInt16 isMatch[192];
	UInt16 isRep[12];
	UInt16 isRepG0[12];
	UInt16 isRepG1[12];
	UInt16 isRepG2[12];
	UInt16 isRep0Long[192];
	UInt16 posSlotEncoder[256];
	UInt16 posEncoders[114];
	UInt16 posAlignEncoder[16];
	CLenPriceEnc lenEnc;
	CLenPriceEnc repLenEnc;
	unsigned int lclp;
	Bool fastMode;
	CRangeEnc rc;
	Bool writeEndMark;
	UInt64 nowPos64;
	UInt32 matchPriceCount;
	Bool finished;
	Bool multiThread;
	SRes result;
	UInt32 dictSize;
	UInt32 matchFinderCycles;
	int needInit;
	CSaveState saveState;
} CLzmaEnc;

typedef struct {
	ISeqOutStream funcTable;
	Byte *data;
	SizeT rem;
	Bool overflow;
} CSeqOutStreamBuf;

struct _CLzmaProps {
	unsigned int lc;
	unsigned int lp;
	unsigned int pb;
	UInt32 dicSize;
};

typedef struct _CLzmaProps CLzmaProps;

typedef struct {
	CLzmaProps prop;
	UInt16 *probs;
	Byte *dic;
	const Byte *buf;
	UInt32 range;
	UInt32 code;
	SizeT dicPos;
	SizeT dicBufSize;
	UInt32 processedPos;
	UInt32 checkDicSize;
	unsigned int state;
	UInt32 reps[4];
	unsigned int remainLen;
	int needFlush;
	int needInitState;
	UInt32 numProbs;
	unsigned int tempBufSize;
	Byte tempBuf[20];
} CLzmaDec;

typedef enum {
	DUMMY_ERROR = 0,
	DUMMY_LIT = 1,
	DUMMY_MATCH = 2,
	DUMMY_REP = 3,
} ELzmaDummy;

struct ts_state {
	unsigned int offset;
	char cb[48];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_linear_state {
	unsigned int len;
	const void *data;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	__NLA_TYPE_MAX = 18,
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef mpi_limb_t UWtype;

typedef unsigned int UHWtype;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct gcry_mpi_point *MPI_POINT;

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct barrett_ctx_s {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

typedef long unsigned int cycles_t;

enum aarch64_insn_prfm_type {
	AARCH64_INSN_PRFM_TYPE_PLD = 0,
	AARCH64_INSN_PRFM_TYPE_PLI = 1,
	AARCH64_INSN_PRFM_TYPE_PST = 2,
};

enum aarch64_insn_prfm_target {
	AARCH64_INSN_PRFM_TARGET_L1 = 0,
	AARCH64_INSN_PRFM_TARGET_L2 = 1,
	AARCH64_INSN_PRFM_TARGET_L3 = 2,
};

enum aarch64_insn_prfm_policy {
	AARCH64_INSN_PRFM_POLICY_KEEP = 0,
	AARCH64_INSN_PRFM_POLICY_STRM = 1,
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

typedef struct elf64_phdr Elf64_Phdr;

typedef struct elf32_note Elf32_Nhdr;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum {
	ASSUME_PERFECT = 255,
	ASSUME_VALID_DTB = 1,
	ASSUME_VALID_INPUT = 2,
	ASSUME_LATEST = 4,
	ASSUME_NO_ROLLBACK = 8,
	ASSUME_LIBFDT_ORDER = 16,
	ASSUME_LIBFDT_FLAWLESS = 32,
};

typedef __be64 fdt64_t;

struct fdt_reserve_entry {
	fdt64_t address;
	fdt64_t size;
};

struct fdt_node_header {
	fdt32_t tag;
	char name[0];
};

struct fdt_property {
	fdt32_t tag;
	fdt32_t len;
	fdt32_t nameoff;
	char data[0];
};

struct fdt_errtabent {
	const char *str;
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

struct clk_core;

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct in_addr {
	__be32 s_addr;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct page_flags_fields {
	int width;
	int shift;
	int mask;
	const struct printf_spec *spec;
	const char *name;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);

typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);

enum gic_type {
	GIC_V2 = 0,
	GIC_V3 = 1,
};

struct gic_kvm_info {
	enum gic_type type;
	struct resource vcpu;
	unsigned int maint_irq;
	bool no_maint_irq_mask;
	struct resource vctrl;
	bool has_v4;
	bool has_v4_1;
	bool no_hw_deactivation;
};

struct gic_quirk {
	const char *desc;
	const char *compatible;
	const char *property;
	bool (*init)(void *);
	u32 iidr;
	u32 mask;
};

union gic_base {
	void *common_base;
	void **percpu_base;
};

struct gic_chip_data {
	struct irq_chip chip;
	union gic_base dist_base;
	union gic_base cpu_base;
	void *raw_dist_base;
	void *raw_cpu_base;
	u32 percpu_offset;
	u32 saved_spi_enable[32];
	u32 saved_spi_active[32];
	u32 saved_spi_conf[64];
	u32 saved_spi_target[255];
	u32 *saved_ppi_enable;
	u32 *saved_ppi_active;
	u32 *saved_ppi_conf;
	struct irq_domain *domain;
	unsigned int gic_irqs;
};

struct v2m_data {
	struct list_head entry;
	struct fwnode_handle *fwnode;
	struct resource res;
	void *base;
	u32 spi_start;
	u32 nr_spis;
	u32 spi_offset;
	long unsigned int *bm;
	u32 flags;
};

struct rdists {
	struct {
		raw_spinlock_t rd_lock;
		void *rd_base;
		struct page *pend_page;
		phys_addr_t phys_base;
		bool lpi_enabled;
		cpumask_t *vpe_table_mask;
		void *vpe_l1_base;
	} *rdist;
	phys_addr_t prop_table_pa;
	void *prop_table_va;
	u64 flags;
	u32 gicd_typer;
	u32 gicd_typer2;
	bool has_vlpis;
	bool has_rvpeid;
	bool has_direct_lpi;
	bool has_vpend_valid_dirty;
};

struct partition_affinity {
	cpumask_t mask;
	void *partition_id;
};

struct redist_region {
	void *redist_base;
	phys_addr_t phys_base;
	bool single_redist;
};

struct partition_desc;

struct gic_chip_data___2 {
	struct fwnode_handle *fwnode;
	void *dist_base;
	struct redist_region *redist_regions;
	struct rdists rdists;
	struct irq_domain *domain;
	u64 redist_stride;
	u32 nr_redist_regions;
	u64 flags;
	bool has_rss;
	unsigned int ppi_nr;
	struct partition_desc **ppi_descs;
};

enum gic_intid_range {
	SGI_RANGE = 0,
	PPI_RANGE = 1,
	SPI_RANGE = 2,
	EPPI_RANGE = 3,
	ESPI_RANGE = 4,
	LPI_RANGE = 5,
	__INVALID_RANGE__ = 6,
};

struct mbi_range {
	u32 spi_start;
	u32 nr_spis;
	long unsigned int *bm;
};

struct its_vpe;

struct its_vm {
	struct fwnode_handle *fwnode;
	struct irq_domain *domain;
	struct page *vprop_page;
	struct its_vpe **vpes;
	int nr_vpes;
	irq_hw_number_t db_lpi_base;
	long unsigned int *db_bitmap;
	int nr_db_lpis;
	u32 vlpi_count[16];
};

struct its_vpe {
	struct page *vpt_page;
	struct its_vm *its_vm;
	atomic_t vlpi_count;
	int irq;
	irq_hw_number_t vpe_db_lpi;
	bool resident;
	bool ready;
	union {
		struct {
			int vpe_proxy_event;
			bool idai;
		};
		struct {
			struct fwnode_handle *fwnode;
			struct irq_domain *sgi_domain;
			struct {
				u8 priority;
				bool enabled;
				bool group;
			} sgi_config[16];
			atomic_t vmapp_count;
		};
	};
	raw_spinlock_t vpe_lock;
	u16 col_idx;
	u16 vpe_id;
	bool pending_last;
};

struct its_vlpi_map {
	struct its_vm *vm;
	struct its_vpe *vpe;
	u32 vintid;
	u8 properties;
	bool db_enabled;
};

enum its_vcpu_info_cmd_type {
	MAP_VLPI = 0,
	GET_VLPI = 1,
	PROP_UPDATE_VLPI = 2,
	PROP_UPDATE_AND_INV_VLPI = 3,
	SCHEDULE_VPE = 4,
	DESCHEDULE_VPE = 5,
	COMMIT_VPE = 6,
	INVALL_VPE = 7,
	PROP_UPDATE_VSGI = 8,
};

struct its_cmd_info {
	enum its_vcpu_info_cmd_type cmd_type;
	union {
		struct its_vlpi_map *map;
		u8 config;
		bool req_db;
		struct {
			bool g0en;
			bool g1en;
		};
		struct {
			u8 priority;
			bool group;
		};
	};
};

struct its_collection {
	u64 target_address;
	u16 col_id;
};

struct its_baser {
	void *base;
	u64 val;
	u32 order;
	u32 psz;
};

struct its_cmd_block;

struct its_device;

struct its_node {
	raw_spinlock_t lock;
	struct mutex dev_alloc_lock;
	struct list_head entry;
	void *base;
	void *sgir_base;
	phys_addr_t phys_base;
	struct its_cmd_block *cmd_base;
	struct its_cmd_block *cmd_write;
	struct its_baser tables[8];
	struct its_collection *collections;
	struct fwnode_handle *fwnode_handle;
	u64 (*get_msi_base)(struct its_device *);
	u64 typer;
	u64 cbaser_save;
	u32 ctlr_save;
	u32 mpidr;
	struct list_head its_device_list;
	u64 flags;
	long unsigned int list_nr;
	int numa_node;
	unsigned int msi_domain_flags;
	u32 pre_its_base;
	int vlpi_redist_offset;
};

struct its_cmd_block {
	union {
		u64 raw_cmd[4];
		__le64 raw_cmd_le[4];
	};
};

struct event_lpi_map {
	long unsigned int *lpi_map;
	u16 *col_map;
	irq_hw_number_t lpi_base;
	int nr_lpis;
	raw_spinlock_t vlpi_lock;
	struct its_vm *vm;
	struct its_vlpi_map *vlpi_maps;
	int nr_vlpis;
};

struct its_device {
	struct list_head entry;
	struct its_node *its;
	struct event_lpi_map event_map;
	void *itt;
	u32 nr_ites;
	u32 device_id;
	bool shared;
};

struct cpu_lpi_count {
	atomic_t managed;
	atomic_t unmanaged;
};

struct its_cmd_desc {
	union {
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_inv_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_clear_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_int_cmd;
		struct {
			struct its_device *dev;
			int valid;
		} its_mapd_cmd;
		struct {
			struct its_collection *col;
			int valid;
		} its_mapc_cmd;
		struct {
			struct its_device *dev;
			u32 phys_id;
			u32 event_id;
		} its_mapti_cmd;
		struct {
			struct its_device *dev;
			struct its_collection *col;
			u32 event_id;
		} its_movi_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_discard_cmd;
		struct {
			struct its_collection *col;
		} its_invall_cmd;
		struct {
			struct its_vpe *vpe;
		} its_vinvall_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection *col;
			bool valid;
		} its_vmapp_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device *dev;
			u32 virt_id;
			u32 event_id;
			bool db_enabled;
		} its_vmapti_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device *dev;
			u32 event_id;
			bool db_enabled;
		} its_vmovi_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection *col;
			u16 seq_num;
			u16 its_list;
		} its_vmovp_cmd;
		struct {
			struct its_vpe *vpe;
		} its_invdb_cmd;
		struct {
			struct its_vpe *vpe;
			u8 sgi;
			u8 priority;
			bool enable;
			bool group;
			bool clear;
		} its_vsgi_cmd;
	};
};

typedef struct its_collection * (*its_cmd_builder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

typedef struct its_vpe * (*its_cmd_vbuilder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

struct lpi_range {
	struct list_head entry;
	u32 base_id;
	u32 span;
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct work_struct rm_work;
	bool supplier_preactivated;
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	char *driver_override;
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	struct msi_desc *msi_desc;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct partition_desc {
	int nr_parts;
	struct partition_affinity *parts;
	struct irq_domain *domain;
	struct irq_desc *chained_desc;
	long unsigned int *bitmap;
	struct irq_domain_ops ops;
};

struct regmap;

struct ls_extirq_data {
	struct regmap *syscon;
	u32 intpcr;
	bool is_ls1021a_or_ls1043a;
	u32 nirq;
	struct irq_fwspec map[12];
};

struct ls_scfg_msi_cfg {
	u32 ibs_shift;
	u32 msir_irqs;
	u32 msir_base;
};

struct ls_scfg_msi;

struct ls_scfg_msir {
	struct ls_scfg_msi *msi_data;
	unsigned int index;
	unsigned int gic_irq;
	unsigned int bit_start;
	unsigned int bit_end;
	unsigned int srs;
	void *reg;
};

struct ls_scfg_msi {
	spinlock_t lock;
	struct platform_device *pdev;
	struct irq_domain *parent;
	struct irq_domain *msi_domain;
	void *regs;
	phys_addr_t msiir_addr;
	struct ls_scfg_msi_cfg *cfg;
	u32 msir_num;
	struct ls_scfg_msir *msir;
	u32 irqs_num;
	long unsigned int *used;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

struct fsl_mc_device_id {
	__u16 vendor;
	const char obj_type[16];
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct fsl_mc_command {
	__le64 header;
	__le64 params[7];
};

struct fsl_mc_driver {
	struct device_driver driver;
	const struct fsl_mc_device_id *match_id_table;
	int (*probe)(struct fsl_mc_device *);
	int (*remove)(struct fsl_mc_device *);
	void (*shutdown)(struct fsl_mc_device *);
	int (*suspend)(struct fsl_mc_device *, pm_message_t);
	int (*resume)(struct fsl_mc_device *);
};

struct fsl_mc_bus;

struct fsl_mc_resource_pool {
	enum fsl_mc_pool_type type;
	int max_count;
	int free_count;
	struct mutex mutex;
	struct list_head free_list;
	struct fsl_mc_bus *mc_bus;
};

struct mc_cmd_header {
	u8 src_id;
	u8 flags_hw;
	u8 status;
	u8 flags_sw;
	__le16 token;
	__le16 cmd_id;
};

enum mc_cmd_status {
	MC_CMD_STATUS_OK = 0,
	MC_CMD_STATUS_READY = 1,
	MC_CMD_STATUS_AUTH_ERR = 3,
	MC_CMD_STATUS_NO_PRIVILEGE = 4,
	MC_CMD_STATUS_DMA_ERR = 5,
	MC_CMD_STATUS_CONFIG_ERR = 6,
	MC_CMD_STATUS_TIMEOUT = 7,
	MC_CMD_STATUS_NO_RESOURCE = 8,
	MC_CMD_STATUS_NO_MEMORY = 9,
	MC_CMD_STATUS_BUSY = 10,
	MC_CMD_STATUS_UNSUPPORTED_OP = 11,
	MC_CMD_STATUS_INVALID_STATE = 12,
};

struct fsl_mc_version {
	u32 major;
	u32 minor;
	u32 revision;
};

struct dpmng_rsp_get_version {
	__le32 revision;
	__le32 version_major;
	__le32 version_minor;
};

struct dprc_attributes {
	int container_id;
	u32 icid;
	int portal_id;
	u64 options;
};

enum dprc_region_type {
	DPRC_REGION_TYPE_MC_PORTAL = 0,
	DPRC_REGION_TYPE_QBMAN_PORTAL = 1,
	DPRC_REGION_TYPE_QBMAN_MEM_BACKED_PORTAL = 2,
};

struct dprc_region_desc {
	u32 base_offset;
	u32 size;
	u32 flags;
	enum dprc_region_type type;
	u64 base_address;
};

struct dprc_endpoint {
	char type[16];
	int id;
	u16 if_id;
};

struct fsl_mc_uapi {
	struct miscdevice misc;
	struct device *device;
	struct mutex mutex;
	u32 local_instance_in_use;
	struct fsl_mc_io *static_mc_io;
};

struct fsl_mc_bus {
	struct fsl_mc_device mc_dev;
	struct fsl_mc_resource_pool resource_pools[4];
	struct fsl_mc_device_irq *irq_resources;
	struct mutex scan_mutex;
	struct dprc_attributes dprc_attr;
	struct fsl_mc_uapi uapi_misc;
	int irq_enabled;
};

struct fsl_mc_addr_translation_range;

struct fsl_mc {
	struct fsl_mc_device *root_mc_bus_dev;
	u8 num_translation_ranges;
	struct fsl_mc_addr_translation_range *translation_ranges;
	void *fsl_mc_regs;
};

struct fsl_mc_addr_translation_range {
	enum dprc_region_type mc_region_type;
	u64 start_mc_offset;
	u64 end_mc_offset;
	phys_addr_t start_phys_addr;
};

struct dpbp_attr {
	int id;
	u16 bpid;
};

struct dpbp_cmd_open {
	__le32 dpbp_id;
};

struct dpbp_rsp_get_attributes {
	__le16 pad;
	__le16 bpid;
	__le32 id;
	__le16 version_major;
	__le16 version_minor;
};

struct dpcon_attr {
	int id;
	u16 qbman_ch_id;
	u8 num_priorities;
};

struct dpcon_notification_cfg {
	int dpio_id;
	u8 priority;
	u64 user_ctx;
};

struct dpcon_cmd_open {
	__le32 dpcon_id;
};

struct dpcon_rsp_get_attr {
	__le32 id;
	__le16 qbman_ch_id;
	u8 num_priorities;
	u8 pad;
};

struct dpcon_cmd_set_notification {
	__le32 dpio_id;
	u8 priority;
	u8 pad[3];
	__le64 user_ctx;
};

struct mc_rsp_create {
	__le32 object_id;
};

struct mc_rsp_api_ver {
	__le16 major_ver;
	__le16 minor_ver;
};

struct dprc_cmd_open {
	__le32 container_id;
};

struct dprc_cmd_reset_container {
	__le32 child_container_id;
	__le32 options;
};

struct dprc_cmd_set_irq {
	__le32 irq_val;
	u8 irq_index;
	u8 pad[3];
	__le64 irq_addr;
	__le32 irq_num;
};

struct dprc_cmd_set_irq_enable {
	u8 enable;
	u8 pad[3];
	u8 irq_index;
};

struct dprc_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
};

struct dprc_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dprc_rsp_get_irq_status {
	__le32 status;
};

struct dprc_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dprc_rsp_get_attributes {
	__le32 container_id;
	__le32 icid;
	__le32 options;
	__le32 portal_id;
};

struct dprc_rsp_get_obj_count {
	__le32 pad;
	__le32 obj_count;
};

struct dprc_cmd_get_obj {
	__le32 obj_index;
};

struct dprc_rsp_get_obj {
	__le32 pad0;
	__le32 id;
	__le16 vendor;
	u8 irq_count;
	u8 region_count;
	__le32 state;
	__le16 version_major;
	__le16 version_minor;
	__le16 flags;
	__le16 pad1;
	u8 type[16];
	u8 label[16];
};

struct dprc_cmd_get_obj_region {
	__le32 obj_id;
	__le16 pad0;
	u8 region_index;
	u8 pad1;
	__le64 pad2[2];
	u8 obj_type[16];
};

struct dprc_rsp_get_obj_region {
	__le64 pad0;
	__le64 base_offset;
	__le32 size;
	u8 type;
	u8 pad2[3];
	__le32 flags;
	__le32 pad3;
	__le64 base_addr;
};

struct dprc_cmd_set_obj_irq {
	__le32 irq_val;
	u8 irq_index;
	u8 pad[3];
	__le64 irq_addr;
	__le32 irq_num;
	__le32 obj_id;
	u8 obj_type[16];
};

struct dprc_cmd_get_connection {
	__le32 ep1_id;
	__le16 ep1_interface_id;
	u8 pad[2];
	u8 ep1_type[16];
};

struct dprc_rsp_get_connection {
	__le64 pad[3];
	__le32 ep2_id;
	__le16 ep2_interface_id;
	__le16 pad1;
	u8 ep2_type[16];
	__le32 state;
};

struct dprc_irq_cfg {
	phys_addr_t paddr;
	u32 val;
	int irq_num;
};

struct fsl_mc_child_objs {
	int child_count;
	struct fsl_mc_obj_desc *child_array;
};

struct dpmcp_cmd_open {
	__le32 dpmcp_id;
};

struct uapi_priv_data {
	struct fsl_mc_uapi *uapi;
	struct fsl_mc_io *mc_io;
};

struct fsl_mc_cmd_desc {
	u16 cmdid_value;
	u16 cmdid_mask;
	int size;
	bool token;
	int flags;
};

enum fsl_mc_cmd_index {
	DPDBG_DUMP = 0,
	DPDBG_SET = 1,
	DPRC_GET_CONTAINER_ID = 2,
	DPRC_CREATE_CONT = 3,
	DPRC_DESTROY_CONT = 4,
	DPRC_ASSIGN = 5,
	DPRC_UNASSIGN = 6,
	DPRC_GET_OBJ_COUNT = 7,
	DPRC_GET_OBJ = 8,
	DPRC_GET_RES_COUNT = 9,
	DPRC_GET_RES_IDS = 10,
	DPRC_SET_OBJ_LABEL = 11,
	DPRC_SET_LOCKED = 12,
	DPRC_CONNECT = 13,
	DPRC_DISCONNECT = 14,
	DPRC_GET_POOL = 15,
	DPRC_GET_POOL_COUNT = 16,
	DPRC_GET_CONNECTION = 17,
	DPCI_GET_LINK_STATE = 18,
	DPCI_GET_PEER_ATTR = 19,
	DPAIOP_GET_SL_VERSION = 20,
	DPAIOP_GET_STATE = 21,
	DPMNG_GET_VERSION = 22,
	DPSECI_GET_TX_QUEUE = 23,
	DPMAC_GET_COUNTER = 24,
	DPMAC_GET_MAC_ADDR = 25,
	DPNI_SET_PRIM_MAC = 26,
	DPNI_GET_PRIM_MAC = 27,
	DPNI_GET_STATISTICS = 28,
	DPNI_GET_LINK_STATE = 29,
	DPNI_GET_MAX_FRAME_LENGTH = 30,
	DPSW_GET_TAILDROP = 31,
	DPSW_SET_TAILDROP = 32,
	DPSW_IF_GET_COUNTER = 33,
	DPSW_IF_GET_MAX_FRAME_LENGTH = 34,
	DPDMUX_GET_COUNTER = 35,
	DPDMUX_IF_GET_MAX_FRAME_LENGTH = 36,
	GET_ATTR = 37,
	GET_IRQ_MASK = 38,
	GET_IRQ_STATUS = 39,
	CLOSE = 40,
	OPEN = 41,
	GET_API_VERSION = 42,
	DESTROY = 43,
	CREATE = 44,
};

struct of_dev_auxdata {
	char *compatible;
	resource_size_t phys_addr;
	char *name;
	void *platform_data;
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_COMPRESSED = 2,
	REGCACHE_FLAT = 3,
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int reg_downshift;
	unsigned int reg_base;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	bool fast_io;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool use_relaxed_mmio;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	bool use_raw_spinlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

typedef void (*regmap_hw_free_context)(void *);

struct regmap_bus {
	bool fast_io;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
	bool free_on_exit;
};

struct vexpress_syscfg {
	struct device *dev;
	void *base;
	struct list_head funcs;
};

struct vexpress_syscfg_func {
	struct list_head list;
	struct vexpress_syscfg *syscfg;
	struct regmap *regmap;
	int num_templates;
	u32 template[0];
};

struct vexpress_config_bridge_ops {
	struct regmap * (*regmap_init)(struct device *, void *);
	void (*regmap_exit)(struct regmap *, void *);
};

struct vexpress_config_bridge {
	struct vexpress_config_bridge_ops *ops;
	void *context;
};

struct regulator;

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

enum phy_media {
	PHY_MEDIA_DEFAULT = 0,
	PHY_MEDIA_SR = 1,
	PHY_MEDIA_DAC = 2,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*set_media)(struct phy *, enum phy_media);
	int (*set_speed)(struct phy *, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

enum cmu_type_t {
	REF_CMU = 0,
	PHY_CMU = 1,
};

enum clk_type_t {
	CLK_EXT_DIFF = 0,
	CLK_INT_DIFF = 1,
	CLK_INT_SING = 2,
};

enum xgene_phy_mode {
	MODE_SATA = 0,
	MODE_SGMII = 1,
	MODE_PCIE = 2,
	MODE_USB = 3,
	MODE_XFI = 4,
	MODE_MAX = 5,
};

struct xgene_sata_override_param {
	u32 speed[2];
	u32 txspeed[3];
	u32 txboostgain[6];
	u32 txeyetuning[6];
	u32 txeyedirection[6];
	u32 txamplitude[6];
	u32 txprecursor_cn1[6];
	u32 txprecursor_cn2[6];
	u32 txpostcursor_cp1[6];
};

struct xgene_phy_ctx {
	struct device *dev;
	struct phy *phy;
	enum xgene_phy_mode mode;
	enum clk_type_t clk_type;
	void *sds_base;
	struct clk *clk;
	struct xgene_sata_override_param sata_param;
};

struct gpio_chip;

struct gpio_irq_chip {
	struct irq_chip *chip;
	struct irq_domain *domain;
	const struct irq_domain_ops *domain_ops;
	struct fwnode_handle *fwnode;
	struct irq_domain *parent_domain;
	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
	void * (*populate_parent_alloc_arg)(struct gpio_chip *, unsigned int, unsigned int);
	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
	struct irq_domain_ops child_irq_domain_ops;
	irq_flow_handler_t handler;
	unsigned int default_type;
	struct lock_class_key *lock_key;
	struct lock_class_key *request_key;
	irq_flow_handler_t parent_handler;
	union {
		void *parent_handler_data;
		void **parent_handler_data_array;
	};
	unsigned int num_parents;
	unsigned int *parents;
	unsigned int *map;
	bool threaded;
	bool per_parent_data;
	int (*init_hw)(struct gpio_chip *);
	void (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	bool initialized;
	long unsigned int *valid_mask;
	unsigned int first;
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int base;
	u16 ngpio;
	u16 offset;
	const char * const *names;
	bool can_sleep;
	long unsigned int (*read_reg)(void *);
	void (*write_reg)(void *, long unsigned int);
	bool be_bits;
	void *reg_dat;
	void *reg_set;
	void *reg_clr;
	void *reg_dir_out;
	void *reg_dir_in;
	bool bgpio_dir_unreadable;
	int bgpio_bits;
	raw_spinlock_t bgpio_lock;
	long unsigned int bgpio_data;
	long unsigned int bgpio_dir;
	struct gpio_irq_chip irq;
	long unsigned int *valid_mask;
	struct device_node *of_node;
	unsigned int of_gpio_n_cells;
	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
	int (*of_gpio_ranges_fallback)(struct gpio_chip *, struct device_node *);
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_MODE_LOW_POWER = 15,
	PIN_CONFIG_MODE_PWM = 16,
	PIN_CONFIG_OUTPUT = 17,
	PIN_CONFIG_OUTPUT_ENABLE = 18,
	PIN_CONFIG_PERSIST_STATE = 19,
	PIN_CONFIG_POWER_SOURCE = 20,
	PIN_CONFIG_SKEW_DELAY = 21,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 22,
	PIN_CONFIG_SLEW_RATE = 23,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct gpio_desc;

struct gpio_device {
	int id;
	struct device dev;
	struct cdev chrdev;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head notifier;
	struct rw_semaphore sem;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc *desc[0];
};

struct gpio_array {
	struct gpio_desc **desc;
	unsigned int size;
	struct gpio_chip *chip;
	long unsigned int *get_mask;
	long unsigned int *set_mask;
	long unsigned int invert_mask[0];
};

struct gpio_desc {
	struct gpio_device *gdev;
	long unsigned int flags;
	const char *label;
	const char *name;
	unsigned int debounce_period_us;
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	long unsigned int lflags;
	int dflags;
};

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct acpi_device;

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	unsigned int debounce;
	unsigned int quirks;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

struct gpio {
	unsigned int gpio;
	long unsigned int flags;
	const char *label;
};

enum of_gpio_flags {
	OF_GPIO_ACTIVE_LOW = 1,
	OF_GPIO_SINGLE_ENDED = 2,
	OF_GPIO_OPEN_DRAIN = 4,
	OF_GPIO_TRANSITORY = 8,
	OF_GPIO_PULL_UP = 16,
	OF_GPIO_PULL_DOWN = 32,
};

struct of_mm_gpio_chip {
	struct gpio_chip gc;
	void (*save_regs)(struct of_mm_gpio_chip *);
	void *regs;
};

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME = 2048,
};

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

typedef __poll_t (*poll_fn)(struct file *, struct poll_table_struct *);

typedef long int (*ioctl_fn___2)(struct file *, unsigned int, long unsigned int);

typedef ssize_t (*read_fn)(struct file *, char *, size_t, loff_t *);

struct linereq;

struct line {
	struct gpio_desc *desc;
	struct linereq *req;
	unsigned int irq;
	u64 eflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	u32 event_buffer_size;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	long unsigned int *watched_lines;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct gpiod_data {
	struct gpio_desc *desc;
	struct mutex mutex;
	struct kernfs_node *value_kn;
	int irq;
	unsigned char irq_flags;
	bool direction_can_change;
};

struct bgpio_pdata {
	const char *label;
	int base;
	int ngpio;
};

struct mpc8xxx_gpio_chip {
	struct gpio_chip gc;
	void *regs;
	raw_spinlock_t lock;
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	struct irq_domain *irq;
	int irqn;
};

struct mpc8xxx_gpio_devtype {
	int (*gpio_dir_out)(struct gpio_chip *, unsigned int, int);
	int (*gpio_get)(struct gpio_chip *, unsigned int);
	int (*irq_set_type)(struct irq_data *, unsigned int);
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

enum i2c_slave_event {
	I2C_SLAVE_READ_REQUESTED = 0,
	I2C_SLAVE_WRITE_REQUESTED = 1,
	I2C_SLAVE_READ_PROCESSED = 2,
	I2C_SLAVE_WRITE_RECEIVED = 3,
	I2C_SLAVE_STOP = 4,
};

struct i2c_client;

typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);

struct i2c_adapter;

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	i2c_slave_cb_t slave_cb;
	void *devres_group_id;
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);
	int (*probe_new)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct software_node *swnode;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
	struct regulator *bus_regulator;
};

struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
	int (*reg_slave)(struct i2c_client *);
	int (*unreg_slave)(struct i2c_client *);
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct pinctrl;

struct pinctrl_state;

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
};

struct pca953x_platform_data {
	unsigned int gpio_base;
	u32 invert;
	int irq_base;
	void *context;
	int (*setup)(struct i2c_client *, unsigned int, unsigned int, void *);
	int (*teardown)(struct i2c_client *, unsigned int, unsigned int, void *);
	const char * const *names;
};

struct pca953x_reg_config {
	int direction;
	int output;
	int input;
	int invert;
};

struct pca953x_chip {
	unsigned int gpio_start;
	struct mutex i2c_lock;
	struct regmap *regmap;
	struct mutex irq_lock;
	long unsigned int irq_mask[1];
	long unsigned int irq_stat[1];
	long unsigned int irq_trig_raise[1];
	long unsigned int irq_trig_fall[1];
	struct irq_chip irq_chip;
	atomic_t wakeup_path;
	struct i2c_client *client;
	struct gpio_chip gpio_chip;
	const char * const *names;
	long unsigned int driver_data;
	struct regulator *regulator;
	const struct pca953x_reg_config *regs;
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
};

struct rcec_ea {
	u8 nextbusn;
	u8 lastbusn;
	u32 bitmap;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

typedef u64 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
	PCI_DEV_FLAGS_HAS_MSI_MASKING = 4096,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	int domain_nr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int no_inc_mrrs: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	unsigned int msi_domain: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, bool);
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

struct pci_platform_pm_ops {
	bool (*bridge_d3)(struct pci_dev *);
	bool (*is_manageable)(struct pci_dev *);
	int (*set_state)(struct pci_dev *, pci_power_t);
	pci_power_t (*get_state)(struct pci_dev *);
	void (*refresh_state)(struct pci_dev *);
	pci_power_t (*choose_state)(struct pci_dev *);
	int (*set_wakeup)(struct pci_dev *, bool);
	bool (*need_resume)(struct pci_dev *);
};

struct pci_reset_fn_method {
	int (*reset_fn)(struct pci_dev *, bool);
	char *name;
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	int (*slot_reset)(struct pcie_device *);
	void (*error_resume)(struct pci_dev *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum enable_type {
	undefined = 4294967295,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

typedef int (*pcie_callback_t)(struct pcie_device *);

struct walk_rcec_data {
	struct pci_dev *rcec;
	int (*user_callback)(struct pci_dev *, void *);
	void *user_data;
};

struct aspm_latency {
	u32 l0s;
	u32 l1;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	int: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
	struct aspm_latency latency_up;
	struct aspm_latency latency_dw;
	struct aspm_latency acceptable[8];
};

struct aer_stats {
	u64 dev_cor_errs[16];
	u64 dev_fatal_errs[27];
	u64 dev_nonfatal_errs[27];
	u64 dev_total_cor_errs;
	u64 dev_total_fatal_errs;
	u64 dev_total_nonfatal_errs;
	u64 rootport_total_cor_errs;
	u64 rootport_total_fatal_errs;
	u64 rootport_total_nonfatal_errs;
};

struct aer_header_log_regs {
	unsigned int dw0;
	unsigned int dw1;
	unsigned int dw2;
	unsigned int dw3;
};

struct aer_err_info {
	struct pci_dev *dev[5];
	int error_dev_num;
	unsigned int id: 16;
	unsigned int severity: 2;
	unsigned int __pad1: 5;
	unsigned int multi_error_valid: 1;
	unsigned int first_error: 5;
	unsigned int __pad2: 2;
	unsigned int tlp_header_valid: 1;
	unsigned int status;
	unsigned int mask;
	struct aer_header_log_regs tlp;
};

struct aer_err_source {
	unsigned int status;
	unsigned int id;
};

struct aer_rpc {
	struct pci_dev *rpd;
	struct {
		union {
			struct __kfifo kfifo;
			struct aer_err_source *type;
			const struct aer_err_source *const_type;
			char (*rectype)[0];
			struct aer_err_source *ptr;
			const struct aer_err_source *ptr_const;
		};
		struct aer_err_source buf[128];
	} aer_fifo;
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct of_bus;

struct of_pci_range_parser {
	struct device_node *node;
	struct of_bus *bus;
	const __be32 *range;
	const __be32 *end;
	int na;
	int ns;
	int pna;
	bool dma;
};

struct of_pci_range {
	union {
		u64 pci_addr;
		u64 bus_addr;
	};
	u64 cpu_addr;
	u64 size;
	u32 flags;
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CAP_CSS_NVM = 1,
	NVME_CAP_CSS_CSI = 64,
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
	NVME_CMBMSC_CRE = 1,
	NVME_CMBMSC_CMSE = 2,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, bool);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct pci_config_window;

struct pci_ecam_ops {
	unsigned int bus_shift;
	struct pci_ops pci_ops;
	int (*init)(struct pci_config_window *);
};

struct pci_config_window {
	struct resource res;
	struct resource busr;
	unsigned int bus_shift;
	void *priv;
	const struct pci_ecam_ops *ops;
	union {
		void *win;
		void **winp;
	};
	struct device *parent;
};

enum pci_interrupt_pin {
	PCI_INTERRUPT_UNKNOWN = 0,
	PCI_INTERRUPT_INTA = 1,
	PCI_INTERRUPT_INTB = 2,
	PCI_INTERRUPT_INTC = 3,
	PCI_INTERRUPT_INTD = 4,
};

enum pci_barno {
	NO_BAR = 4294967295,
	BAR_0 = 0,
	BAR_1 = 1,
	BAR_2 = 2,
	BAR_3 = 3,
	BAR_4 = 4,
	BAR_5 = 5,
};

struct pci_epf_header {
	u16 vendorid;
	u16 deviceid;
	u8 revid;
	u8 progif_code;
	u8 subclass_code;
	u8 baseclass_code;
	u8 cache_line_size;
	u16 subsys_vendor_id;
	u16 subsys_id;
	enum pci_interrupt_pin interrupt_pin;
};

struct pci_epf_bar {
	dma_addr_t phys_addr;
	void *addr;
	size_t size;
	enum pci_barno barno;
	int flags;
};

struct pci_epc_ops;

struct pci_epc_mem;

struct pci_epc {
	struct device dev;
	struct list_head pci_epf;
	const struct pci_epc_ops *ops;
	struct pci_epc_mem **windows;
	struct pci_epc_mem *mem;
	unsigned int num_windows;
	u8 max_functions;
	u8 *max_vfs;
	struct config_group *group;
	struct mutex lock;
	long unsigned int function_num_map;
	struct atomic_notifier_head notifier;
};

enum pci_epc_irq_type {
	PCI_EPC_IRQ_UNKNOWN = 0,
	PCI_EPC_IRQ_LEGACY = 1,
	PCI_EPC_IRQ_MSI = 2,
	PCI_EPC_IRQ_MSIX = 3,
};

struct pci_epc_features;

struct pci_epc_ops {
	int (*write_header)(struct pci_epc *, u8, u8, struct pci_epf_header *);
	int (*set_bar)(struct pci_epc *, u8, u8, struct pci_epf_bar *);
	void (*clear_bar)(struct pci_epc *, u8, u8, struct pci_epf_bar *);
	int (*map_addr)(struct pci_epc *, u8, u8, phys_addr_t, u64, size_t);
	void (*unmap_addr)(struct pci_epc *, u8, u8, phys_addr_t);
	int (*set_msi)(struct pci_epc *, u8, u8, u8);
	int (*get_msi)(struct pci_epc *, u8, u8);
	int (*set_msix)(struct pci_epc *, u8, u8, u16, enum pci_barno, u32);
	int (*get_msix)(struct pci_epc *, u8, u8);
	int (*raise_irq)(struct pci_epc *, u8, u8, enum pci_epc_irq_type, u16);
	int (*map_msi_irq)(struct pci_epc *, u8, u8, phys_addr_t, u8, u32, u32 *, u32 *);
	int (*start)(struct pci_epc *);
	void (*stop)(struct pci_epc *);
	const struct pci_epc_features * (*get_features)(struct pci_epc *, u8, u8);
	struct module *owner;
};

struct pci_epc_features {
	unsigned int linkup_notifier: 1;
	unsigned int core_init_notifier: 1;
	unsigned int msi_capable: 1;
	unsigned int msix_capable: 1;
	u8 reserved_bar;
	u8 bar_fixed_64bit;
	u64 bar_fixed_size[6];
	size_t align;
};

struct pci_epc_mem_window {
	phys_addr_t phys_base;
	size_t size;
	size_t page_size;
};

struct pci_epc_mem {
	struct pci_epc_mem_window window;
	long unsigned int *bitmap;
	int pages;
	struct mutex lock;
};

enum dw_pcie_region_type {
	DW_PCIE_REGION_UNKNOWN = 0,
	DW_PCIE_REGION_INBOUND = 1,
	DW_PCIE_REGION_OUTBOUND = 2,
};

struct pcie_port;

struct dw_pcie_host_ops {
	int (*host_init)(struct pcie_port *);
	int (*msi_host_init)(struct pcie_port *);
};

struct pcie_port {
	bool has_msi_ctrl: 1;
	u64 cfg0_base;
	void *va_cfg0_base;
	u32 cfg0_size;
	resource_size_t io_base;
	phys_addr_t io_bus_addr;
	u32 io_size;
	int irq;
	const struct dw_pcie_host_ops *ops;
	int msi_irq;
	struct irq_domain *irq_domain;
	struct irq_domain *msi_domain;
	u16 msi_msg;
	dma_addr_t msi_data;
	struct irq_chip *msi_irq_chip;
	u32 num_vectors;
	u32 irq_mask[8];
	struct pci_host_bridge *bridge;
	raw_spinlock_t lock;
	long unsigned int msi_irq_in_use[4];
};

enum dw_pcie_as_type {
	DW_PCIE_AS_UNKNOWN = 0,
	DW_PCIE_AS_MEM = 1,
	DW_PCIE_AS_IO = 2,
};

struct dw_pcie_ep;

struct dw_pcie_ep_ops {
	void (*ep_init)(struct dw_pcie_ep *);
	int (*raise_irq)(struct dw_pcie_ep *, u8, enum pci_epc_irq_type, u16);
	const struct pci_epc_features * (*get_features)(struct dw_pcie_ep *);
	unsigned int (*func_conf_select)(struct dw_pcie_ep *, u8);
};

struct dw_pcie_ep {
	struct pci_epc *epc;
	struct list_head func_list;
	const struct dw_pcie_ep_ops *ops;
	phys_addr_t phys_base;
	size_t addr_size;
	size_t page_size;
	u8 bar_to_atu[6];
	phys_addr_t *outbound_addr;
	long unsigned int *ib_window_map;
	long unsigned int *ob_window_map;
	void *msi_mem;
	phys_addr_t msi_mem_phys;
	struct pci_epf_bar *epf_bar[6];
};

struct dw_pcie;

struct dw_pcie_ops {
	u64 (*cpu_addr_fixup)(struct dw_pcie *, u64);
	u32 (*read_dbi)(struct dw_pcie *, void *, u32, size_t);
	void (*write_dbi)(struct dw_pcie *, void *, u32, size_t, u32);
	void (*write_dbi2)(struct dw_pcie *, void *, u32, size_t, u32);
	int (*link_up)(struct dw_pcie *);
	int (*start_link)(struct dw_pcie *);
	void (*stop_link)(struct dw_pcie *);
};

struct dw_pcie {
	struct device *dev;
	void *dbi_base;
	void *dbi_base2;
	void *atu_base;
	size_t atu_size;
	u32 num_ib_windows;
	u32 num_ob_windows;
	struct pcie_port pp;
	struct dw_pcie_ep ep;
	const struct dw_pcie_ops *ops;
	unsigned int version;
	int num_lanes;
	int link_gen;
	u8 n_fts[2];
	bool iatu_unroll_enabled: 1;
	bool io_cfg_atu_shared: 1;
};

struct ls_pcie_drvdata {
	u32 lut_offset;
	u32 ltssm_shift;
	u32 lut_dbg;
	const struct dw_pcie_host_ops *ops;
	const struct dw_pcie_ops *dw_pcie_ops;
};

struct ls_pcie {
	struct dw_pcie *pci;
	void *lut;
	struct regmap *scfg;
	const struct ls_pcie_drvdata *drvdata;
	int index;
};

struct mobiveil_msi {
	struct mutex lock;
	struct irq_domain *msi_domain;
	struct irq_domain *dev_domain;
	phys_addr_t msi_pages_phys;
	int num_of_vectors;
	long unsigned int msi_irq_in_use[1];
};

struct mobiveil_pcie;

struct mobiveil_rp_ops {
	int (*interrupt_init)(struct mobiveil_pcie *);
};

struct mobiveil_root_port {
	void *config_axi_slave_base;
	struct resource *ob_io_res;
	struct mobiveil_rp_ops *ops;
	int irq;
	raw_spinlock_t intx_mask_lock;
	struct irq_domain *intx_domain;
	struct mobiveil_msi msi;
	struct pci_host_bridge *bridge;
};

struct mobiveil_pab_ops;

struct mobiveil_pcie {
	struct platform_device *pdev;
	void *csr_axi_slave_base;
	void *apb_csr_base;
	phys_addr_t pcie_reg_base;
	int apio_wins;
	int ppio_wins;
	int ob_wins_configured;
	int ib_wins_configured;
	const struct mobiveil_pab_ops *ops;
	struct mobiveil_root_port rp;
};

struct mobiveil_pab_ops {
	int (*link_up)(struct mobiveil_pcie *);
};

struct ls_pcie_g4 {
	struct mobiveil_pcie pci;
	struct delayed_work dwork;
	int irq;
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedir;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[4];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc;
	struct uni_screen *vc_uni_screen;
};

struct linux_logo {
	int type;
	unsigned int width;
	unsigned int height;
	unsigned int clutsize;
	const unsigned char *clut;
	const unsigned char *data;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_info;

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct fb_deferred_io;

struct fb_ops;

struct apertures_struct;

struct fb_info {
	refcount_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct work_struct queue;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
	bool forced_out;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io {
	long unsigned int delay;
	struct mutex lock;
	struct list_head pagelist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_notification {
	BACKLIGHT_REGISTERED = 0,
	BACKLIGHT_UNREGISTERED = 1,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

struct backlight_device;

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	int (*check_fb)(struct backlight_device *, struct fb_info *);
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	int fb_blank;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct logo_data {
	int depth;
	int needs_directpalette;
	int needs_truepalette;
	int needs_cmapreset;
	const struct linux_logo *logo;
};

struct dmt_videomode {
	u32 dmt_id;
	u32 std_2byte_code;
	u32 cvt_3byte_code;
	const struct fb_videomode *mode;
};

enum display_flags {
	DISPLAY_FLAGS_HSYNC_LOW = 1,
	DISPLAY_FLAGS_HSYNC_HIGH = 2,
	DISPLAY_FLAGS_VSYNC_LOW = 4,
	DISPLAY_FLAGS_VSYNC_HIGH = 8,
	DISPLAY_FLAGS_DE_LOW = 16,
	DISPLAY_FLAGS_DE_HIGH = 32,
	DISPLAY_FLAGS_PIXDATA_POSEDGE = 64,
	DISPLAY_FLAGS_PIXDATA_NEGEDGE = 128,
	DISPLAY_FLAGS_INTERLACED = 256,
	DISPLAY_FLAGS_DOUBLESCAN = 512,
	DISPLAY_FLAGS_DOUBLECLK = 1024,
	DISPLAY_FLAGS_SYNC_POSEDGE = 2048,
	DISPLAY_FLAGS_SYNC_NEGEDGE = 4096,
};

struct videomode {
	long unsigned int pixelclock;
	u32 hactive;
	u32 hfront_porch;
	u32 hback_porch;
	u32 hsync_len;
	u32 vactive;
	u32 vfront_porch;
	u32 vback_porch;
	u32 vsync_len;
	enum display_flags flags;
};

struct broken_edid {
	u8 manufacturer[4];
	u32 model;
	u32 fix;
};

struct __fb_timings {
	u32 dclk;
	u32 hfreq;
	u32 vfreq;
	u32 hactive;
	u32 vactive;
	u32 hblank;
	u32 vblank;
	u32 htotal;
	u32 vtotal;
};

typedef unsigned int u_int;

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef short unsigned int u_short;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct timer_list cursor_timer;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	int flags;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

struct amba_id {
	unsigned int id;
	unsigned int mask;
	void *data;
};

struct amba_cs_uci_id {
	unsigned int devarch;
	unsigned int devarch_mask;
	unsigned int devtype;
	void *data;
};

struct amba_device {
	struct device dev;
	struct resource res;
	struct clk *pclk;
	struct device_dma_parameters dma_parms;
	unsigned int periphid;
	unsigned int cid;
	struct amba_cs_uci_id uci;
	unsigned int irq[9];
	char *driver_override;
};

struct amba_driver {
	struct device_driver drv;
	int (*probe)(struct amba_device *, const struct amba_id *);
	void (*remove)(struct amba_device *);
	void (*shutdown)(struct amba_device *);
	const struct amba_id *id_table;
};

enum {
	CLCD_CAP_RGB444 = 1,
	CLCD_CAP_RGB5551 = 2,
	CLCD_CAP_RGB565 = 4,
	CLCD_CAP_RGB888 = 8,
	CLCD_CAP_BGR444 = 16,
	CLCD_CAP_BGR5551 = 32,
	CLCD_CAP_BGR565 = 64,
	CLCD_CAP_BGR888 = 128,
	CLCD_CAP_444 = 17,
	CLCD_CAP_5551 = 34,
	CLCD_CAP_565 = 68,
	CLCD_CAP_888 = 136,
	CLCD_CAP_RGB = 15,
	CLCD_CAP_BGR = 240,
	CLCD_CAP_ALL = 255,
};

struct clcd_panel {
	struct fb_videomode mode;
	short int width;
	short int height;
	u32 tim2;
	u32 tim3;
	u32 cntl;
	u32 caps;
	unsigned int bpp: 8;
	unsigned int fixedtimings: 1;
	unsigned int grayscale: 1;
	unsigned int connector;
	struct backlight_device *backlight;
	bool bgr_connection;
};

struct clcd_regs {
	u32 tim0;
	u32 tim1;
	u32 tim2;
	u32 tim3;
	u32 cntl;
	long unsigned int pixclock;
};

struct clcd_fb;

struct clcd_board {
	const char *name;
	u32 caps;
	int (*check)(struct clcd_fb *, struct fb_var_screeninfo *);
	void (*decode)(struct clcd_fb *, struct clcd_regs *);
	void (*disable)(struct clcd_fb *);
	void (*enable)(struct clcd_fb *);
	int (*setup)(struct clcd_fb *);
	int (*mmap)(struct clcd_fb *, struct vm_area_struct *);
	void (*remove)(struct clcd_fb *);
};

struct clcd_fb {
	struct fb_info fb;
	struct amba_device *dev;
	struct clk *clk;
	struct clcd_panel *panel;
	struct clcd_board *board;
	void *board_data;
	void *regs;
	u16 off_ienb;
	u16 off_cntl;
	u32 clcd_cntl;
	u32 cmap[16];
	bool clk_enabled;
};

struct timing_entry {
	u32 min;
	u32 typ;
	u32 max;
};

struct display_timing {
	struct timing_entry pixelclock;
	struct timing_entry hactive;
	struct timing_entry hfront_porch;
	struct timing_entry hback_porch;
	struct timing_entry hsync_len;
	struct timing_entry vactive;
	struct timing_entry vfront_porch;
	struct timing_entry vback_porch;
	struct timing_entry vsync_len;
	enum display_flags flags;
};

typedef uint32_t evtchn_port_t;

struct xenfb_update {
	uint8_t type;
	int32_t x;
	int32_t y;
	int32_t width;
	int32_t height;
};

struct xenfb_resize {
	uint8_t type;
	int32_t width;
	int32_t height;
	int32_t stride;
	int32_t depth;
	int32_t offset;
};

union xenfb_out_event {
	uint8_t type;
	struct xenfb_update update;
	struct xenfb_resize resize;
	char pad[40];
};

struct xenfb_page {
	uint32_t in_cons;
	uint32_t in_prod;
	uint32_t out_cons;
	uint32_t out_prod;
	int32_t width;
	int32_t height;
	uint32_t line_length;
	uint32_t mem_length;
	uint8_t depth;
	long unsigned int pd[256];
};

enum xenbus_state {
	XenbusStateUnknown = 0,
	XenbusStateInitialising = 1,
	XenbusStateInitWait = 2,
	XenbusStateInitialised = 3,
	XenbusStateConnected = 4,
	XenbusStateClosing = 5,
	XenbusStateClosed = 6,
	XenbusStateReconfiguring = 7,
	XenbusStateReconfigured = 8,
};

struct xenbus_watch {
	struct list_head list;
	const char *node;
	unsigned int nr_pending;
	bool (*will_handle)(struct xenbus_watch *, const char *, const char *);
	void (*callback)(struct xenbus_watch *, const char *, const char *);
};

struct xenbus_device {
	const char *devicetype;
	const char *nodename;
	const char *otherend;
	int otherend_id;
	struct xenbus_watch otherend_watch;
	struct device dev;
	enum xenbus_state state;
	struct completion down;
	struct work_struct work;
	struct semaphore reclaim_sem;
	atomic_t event_channels;
	atomic_t events;
	atomic_t spurious_events;
	atomic_t jiffies_eoi_delayed;
	unsigned int spurious_threshold;
};

struct xenbus_device_id {
	char devicetype[32];
};

struct xenbus_driver {
	const char *name;
	const struct xenbus_device_id *ids;
	bool allow_rebind;
	int (*probe)(struct xenbus_device *, const struct xenbus_device_id *);
	void (*otherend_changed)(struct xenbus_device *, enum xenbus_state);
	int (*remove)(struct xenbus_device *);
	int (*suspend)(struct xenbus_device *);
	int (*resume)(struct xenbus_device *);
	int (*uevent)(struct xenbus_device *, struct kobj_uevent_env *);
	struct device_driver driver;
	int (*read_otherend_details)(struct xenbus_device *);
	int (*is_ready)(struct xenbus_device *);
	void (*reclaim_memory)(struct xenbus_device *);
};

struct xenbus_transaction {
	u32 id;
};

struct xenfb_info {
	unsigned char *fb;
	struct fb_info *fb_info;
	int x1;
	int y1;
	int x2;
	int y2;
	spinlock_t dirty_lock;
	int nr_pages;
	int irq;
	struct xenfb_page *page;
	long unsigned int *gfns;
	int update_wanted;
	int feature_resize;
	struct xenfb_resize resize;
	int resize_dpy;
	spinlock_t resize_lock;
	struct xenbus_device *xbdev;
};

enum {
	KPARAM_MEM = 0,
	KPARAM_WIDTH = 1,
	KPARAM_HEIGHT = 2,
	KPARAM_CNT = 3,
};

struct display_timings {
	unsigned int num_timings;
	unsigned int native_mode;
	struct display_timing **timings;
};

struct deferred_device {
	struct amba_device *dev;
	struct resource *parent;
	struct list_head node;
};

struct find_data {
	struct amba_device *dev;
	struct device *parent;
	const char *busid;
	unsigned int id;
	unsigned int mask;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct devm_clk_state {
	struct clk *clk;
	void (*exit)(struct clk *);
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_hw;

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_onecell_data {
	struct clk **clks;
	unsigned int clk_num;
};

struct clk_hw_onecell_data {
	unsigned int num;
	struct clk_hw *hws[0];
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_rate_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int min;
	long unsigned int max;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_rate_range {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_min_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_max_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_range)(void *, struct clk_core *, long unsigned int, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_notifier_devres {
	struct clk *clk;
	struct notifier_block *nb;
};

struct of_clk_provider {
	struct list_head link;
	struct device_node *node;
	struct clk * (*get)(struct of_phandle_args *, void *);
	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
	void *data;
};

struct clock_provider {
	void (*clk_init_cb)(struct device_node *);
	struct device_node *np;
	struct list_head node;
};

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

typedef void (*of_init_fn_1)(struct device_node *);

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
	long unsigned int flags;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

struct cs2000_priv {
	struct clk_hw hw;
	struct i2c_client *client;
	struct clk *clk_in;
	struct clk *ref_clk;
	long unsigned int saved_rate;
	long unsigned int saved_parent_rate;
};

struct clk_plldig {
	struct clk_hw hw;
	void *regs;
	unsigned int vco_freq;
};

struct ccsr_guts {
	u32 porpllsr;
	u32 porbmsr;
	u32 porimpscr;
	u32 pordevsr;
	u32 pordbgmsr;
	u32 pordevsr2;
	u8 res018[8];
	u32 porcir;
	u8 res024[12];
	u32 gpiocr;
	u8 res034[12];
	u32 gpoutdr;
	u8 res044[12];
	u32 gpindr;
	u8 res054[12];
	u32 pmuxcr;
	u32 pmuxcr2;
	u32 dmuxcr;
	u8 res06c[4];
	u32 devdisr;
	u32 devdisr2;
	u8 res078[4];
	u32 pmjcr;
	u32 powmgtcsr;
	u32 pmrccr;
	u32 pmpdccr;
	u32 pmcdr;
	u32 mcpsumr;
	u32 rstrscr;
	u32 ectrstcr;
	u32 autorstsr;
	u32 pvr;
	u32 svr;
	u8 res0a8[8];
	u32 rstcr;
	u8 res0b4[12];
	u32 iovselsr;
	u8 res0c4[60];
	u32 rcwsr[16];
	u8 res140[228];
	u32 iodelay1;
	u32 iodelay2;
	u8 res22c[984];
	u32 pamubypenr;
	u8 res608[504];
	u32 clkdvdr;
	u8 res804[252];
	u32 ircr;
	u8 res904[4];
	u32 dmacr;
	u8 res90c[8];
	u32 elbccr;
	u8 res918[520];
	u32 ddr1clkdr;
	u32 ddr2clkdr;
	u32 ddrclkdr;
	u8 resb2c[724];
	u32 clkocr;
	u8 rese04[12];
	u32 ddrdllcr;
	u8 rese14[12];
	u32 lbcdllcr;
	u32 cpfor;
	u8 rese28[220];
	u32 srds1cr0;
	u32 srds1cr1;
	u8 resf0c[32];
	u32 itcr;
	u8 resf30[16];
	u32 srds2cr0;
	u32 srds2cr1;
};

struct clockgen_pll_div {
	struct clk *clk;
	char name[32];
};

struct clockgen_pll {
	struct clockgen_pll_div div[32];
};

struct clockgen_sourceinfo {
	u32 flags;
	int pll;
	int div;
};

struct clockgen_muxinfo {
	struct clockgen_sourceinfo clksel[16];
};

struct clockgen;

struct clockgen_chipinfo {
	const char *compat;
	const char *guts_compat;
	const struct clockgen_muxinfo *cmux_groups[2];
	const struct clockgen_muxinfo *hwaccel[5];
	void (*init_periph)(struct clockgen *);
	int cmux_to_group[9];
	u32 pll_mask;
	u32 flags;
};

struct clockgen {
	struct device_node *node;
	void *regs;
	struct clockgen_chipinfo info;
	struct clk *sysclk;
	struct clk *coreclk;
	struct clockgen_pll pll[6];
	struct clk *cmux[8];
	struct clk *hwaccel[5];
	struct clk *fman[2];
	struct ccsr_guts *guts;
};

struct mux_hwclock {
	struct clk_hw hw;
	struct clockgen *cg;
	const struct clockgen_muxinfo *info;
	u32 *reg;
	u8 parent_to_clksel[16];
	s8 clksel_to_parent[16];
	int num_parents;
};

enum xgene_pll_type {
	PLL_TYPE_PCP = 0,
	PLL_TYPE_SOC = 1,
};

struct xgene_clk_pll {
	struct clk_hw hw;
	void *reg;
	spinlock_t *lock;
	u32 pll_offset;
	enum xgene_pll_type type;
	int version;
};

struct xgene_clk_pmd {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u32 mask;
	u64 denom;
	u32 flags;
	spinlock_t *lock;
};

struct xgene_dev_parameters {
	void *csr_reg;
	u32 reg_clk_offset;
	u32 reg_clk_mask;
	u32 reg_csr_offset;
	u32 reg_csr_mask;
	void *divider_reg;
	u32 reg_divider_offset;
	u32 reg_divider_shift;
	u32 reg_divider_width;
};

struct xgene_clk {
	struct clk_hw hw;
	spinlock_t *lock;
	struct xgene_dev_parameters param;
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
	DMAENGINE_ALIGN_128_BYTES = 7,
	DMAENGINE_ALIGN_256_BYTES = 8,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	struct mutex chan_mutex;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
	DMA_SLAVE_BUSWIDTH_128_BYTES = 128,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	unsigned int slave_id;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
	struct dma_async_tx_descriptor *next;
	struct dma_async_tx_descriptor *parent;
	spinlock_t lock;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct of_dma {
	struct list_head of_dma_controllers;
	struct device_node *of_node;
	struct dma_chan * (*of_dma_xlate)(struct of_phandle_args *, struct of_dma *);
	void * (*of_dma_route_allocate)(struct of_phandle_args *, struct of_dma *);
	struct dma_router *dma_router;
	void *of_dma_data;
};

struct of_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct dmatest_params {
	unsigned int buf_size;
	char channel[20];
	char device[32];
	unsigned int threads_per_chan;
	unsigned int max_channels;
	unsigned int iterations;
	unsigned int xor_sources;
	unsigned int pq_sources;
	int timeout;
	bool noverify;
	bool norandom;
	int alignment;
	unsigned int transfer_size;
	bool polled;
};

struct dmatest_info {
	struct dmatest_params params;
	struct list_head channels;
	unsigned int nr_channels;
	int last_error;
	struct mutex lock;
	bool did_init;
};

struct dmatest_done {
	bool done;
	wait_queue_head_t *wait;
};

struct dmatest_data {
	u8 **raw;
	u8 **aligned;
	unsigned int cnt;
	unsigned int off;
};

struct dmatest_thread {
	struct list_head node;
	struct dmatest_info *info;
	struct task_struct *task;
	struct dma_chan *chan;
	struct dmatest_data src;
	struct dmatest_data dst;
	enum dma_transaction_type type;
	wait_queue_head_t done_wait;
	struct dmatest_done test_done;
	bool done;
	bool pending;
};

struct dmatest_chan {
	struct list_head node;
	struct dma_chan *chan;
	struct list_head threads;
};

enum fsl_edma_pm_state {
	RUNNING = 0,
	SUSPENDED = 1,
};

struct fsl_edma_hw_tcd {
	__le32 saddr;
	__le16 soff;
	__le16 attr;
	__le32 nbytes;
	__le32 slast;
	__le32 daddr;
	__le16 doff;
	__le16 citer;
	__le32 dlast_sga;
	__le16 csr;
	__le16 biter;
};

struct edma_regs {
	void *cr;
	void *es;
	void *erqh;
	void *erql;
	void *eeih;
	void *eeil;
	void *seei;
	void *ceei;
	void *serq;
	void *cerq;
	void *cint;
	void *cerr;
	void *ssrt;
	void *cdne;
	void *inth;
	void *intl;
	void *errh;
	void *errl;
	struct fsl_edma_hw_tcd *tcd;
};

struct fsl_edma_sw_tcd {
	dma_addr_t ptcd;
	struct fsl_edma_hw_tcd *vtcd;
};

struct fsl_edma_engine;

struct fsl_edma_desc;

struct fsl_edma_chan {
	struct virt_dma_chan vchan;
	enum dma_status status;
	enum fsl_edma_pm_state pm_state;
	bool idle;
	u32 slave_id;
	struct fsl_edma_engine *edma;
	struct fsl_edma_desc *edesc;
	struct dma_slave_config cfg;
	u32 attr;
	struct dma_pool *tcd_pool;
	dma_addr_t dma_dev_addr;
	u32 dma_dev_size;
	enum dma_data_direction dma_dir;
	char chan_name[16];
};

struct fsl_edma_drvdata;

struct fsl_edma_engine {
	struct dma_device dma_dev;
	void *membase;
	void *muxbase[2];
	struct clk *muxclk[2];
	struct clk *dmaclk;
	struct mutex fsl_edma_mutex;
	const struct fsl_edma_drvdata *drvdata;
	u32 n_chans;
	int txirq;
	int errirq;
	bool big_endian;
	struct edma_regs regs;
	struct fsl_edma_chan chans[0];
};

struct fsl_edma_desc {
	struct virt_dma_desc vdesc;
	struct fsl_edma_chan *echan;
	bool iscyclic;
	enum dma_transfer_direction dirn;
	unsigned int n_tcds;
	struct fsl_edma_sw_tcd tcd[0];
};

enum edma_version {
	v1 = 0,
	v2 = 1,
	v3 = 2,
};

struct fsl_edma_drvdata {
	enum edma_version version;
	u32 dmamuxs;
	bool has_dmaclk;
	bool mux_swap;
	int (*setup_irq)(struct platform_device *, struct fsl_edma_engine *);
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct mv_xor_v2_descriptor {
	u16 desc_id;
	u16 flags;
	u32 crc32_result;
	u32 desc_ctrl;
	u32 buff_size;
	u32 fill_pattern_src_addr[4];
	u32 data_buff_addr[12];
	u32 reserved[12];
};

struct mv_xor_v2_sw_desc;

struct mv_xor_v2_device {
	spinlock_t lock;
	void *dma_base;
	void *glob_base;
	struct clk *clk;
	struct clk *reg_clk;
	struct tasklet_struct irq_tasklet;
	struct list_head free_sw_desc;
	struct dma_device dmadev;
	struct dma_chan dmachan;
	dma_addr_t hw_desq;
	struct mv_xor_v2_descriptor *hw_desq_virt;
	struct mv_xor_v2_sw_desc *sw_desq;
	int desc_size;
	unsigned int npendings;
	unsigned int hw_queue_idx;
	struct msi_desc *msi_desc;
};

struct mv_xor_v2_sw_desc {
	int idx;
	struct dma_async_tx_descriptor async_tx;
	struct mv_xor_v2_descriptor hw_desc;
	struct list_head free_list;
};

enum pl330_cachectrl {
	CCTRL0 = 0,
	CCTRL1 = 1,
	CCTRL2 = 2,
	CCTRL3 = 3,
	INVALID1 = 4,
	INVALID2 = 5,
	CCTRL6 = 6,
	CCTRL7 = 7,
};

enum pl330_byteswap {
	SWAP_NO = 0,
	SWAP_2 = 1,
	SWAP_4 = 2,
	SWAP_8 = 3,
	SWAP_16 = 4,
};

struct pl330_config {
	u32 periph_id;
	unsigned int mode;
	unsigned int data_bus_width: 10;
	unsigned int data_buf_dep: 11;
	unsigned int num_chan: 4;
	unsigned int num_peri: 6;
	u32 peri_ns;
	unsigned int num_events: 6;
	u32 irq_ns;
};

struct pl330_reqcfg {
	unsigned int dst_inc: 1;
	unsigned int src_inc: 1;
	bool nonsecure;
	bool privileged;
	bool insnaccess;
	unsigned int brst_len: 5;
	unsigned int brst_size: 3;
	enum pl330_cachectrl dcctl;
	enum pl330_cachectrl scctl;
	enum pl330_byteswap swap;
	struct pl330_config *pcfg;
};

struct pl330_xfer {
	u32 src_addr;
	u32 dst_addr;
	u32 bytes;
};

enum pl330_op_err {
	PL330_ERR_NONE = 0,
	PL330_ERR_ABORT = 1,
	PL330_ERR_FAIL = 2,
};

enum dmamov_dst {
	SAR = 0,
	CCR = 1,
	DAR = 2,
};

enum pl330_cond {
	SINGLE = 0,
	BURST = 1,
	ALWAYS = 2,
};

struct dma_pl330_desc;

struct _pl330_req {
	u32 mc_bus;
	void *mc_cpu;
	struct dma_pl330_desc *desc;
};

enum desc_status {
	FREE = 0,
	PREP = 1,
	BUSY = 2,
	PAUSED = 3,
	DONE___2 = 4,
};

struct dma_pl330_chan;

struct dma_pl330_desc {
	struct list_head node;
	struct dma_async_tx_descriptor txd;
	struct pl330_xfer px;
	struct pl330_reqcfg rqcfg;
	enum desc_status status;
	int bytes_requested;
	bool last;
	struct dma_pl330_chan *pchan;
	enum dma_transfer_direction rqtype;
	unsigned int peri: 5;
	struct list_head rqd;
};

struct _pl330_tbd {
	bool reset_dmac;
	bool reset_mngr;
	u8 reset_chan;
};

struct pl330_dmac;

struct pl330_thread {
	u8 id;
	int ev;
	bool free;
	struct pl330_dmac *dmac;
	struct _pl330_req req[2];
	unsigned int lstenq;
	int req_running;
};

enum pl330_dmac_state {
	UNINIT = 0,
	INIT = 1,
	DYING = 2,
};

struct reset_control;

struct pl330_dmac {
	struct dma_device ddma;
	struct list_head desc_pool;
	spinlock_t pool_lock;
	unsigned int mcbufsz;
	void *base;
	struct pl330_config pcfg;
	spinlock_t lock;
	int events[32];
	dma_addr_t mcode_bus;
	void *mcode_cpu;
	struct pl330_thread *channels;
	struct pl330_thread *manager;
	struct tasklet_struct tasks;
	struct _pl330_tbd dmac_tbd;
	enum pl330_dmac_state state;
	struct list_head req_done;
	unsigned int num_peripherals;
	struct dma_pl330_chan *peripherals;
	int quirks;
	struct reset_control *rstc;
	struct reset_control *rstc_ocp;
};

struct dma_pl330_chan {
	struct tasklet_struct task;
	struct dma_chan chan;
	struct list_head submitted_list;
	struct list_head work_list;
	struct list_head completed_list;
	struct pl330_dmac *dmac;
	spinlock_t lock;
	struct pl330_thread *thread;
	int burst_sz;
	int burst_len;
	phys_addr_t fifo_addr;
	dma_addr_t fifo_dma;
	enum dma_data_direction dir;
	struct dma_slave_config slave_config;
	bool cyclic;
	bool active;
};

struct pl330_of_quirks {
	char *quirk;
	int id;
};

struct _xfer_spec {
	u32 ccr;
	struct dma_pl330_desc *desc;
};

struct _arg_LPEND {
	enum pl330_cond cond;
	bool forever;
	unsigned int loop;
	u8 bjump;
};

struct _arg_GO {
	u8 chan;
	u32 addr;
	unsigned int ns;
};

struct hidma_mgmt_dev {
	u8 hw_version_major;
	u8 hw_version_minor;
	u32 max_wr_xactions;
	u32 max_rd_xactions;
	u32 max_write_request;
	u32 max_read_request;
	u32 dma_channels;
	u32 chreset_timeout_cycles;
	u32 hw_version;
	u32 *priority;
	u32 *weight;
	void *virtaddr;
	resource_size_t addrsize;
	struct kobject **chroots;
	struct platform_device *pdev;
};

struct hidma_chan_attr {
	struct hidma_mgmt_dev *mdev;
	int index;
	struct kobj_attribute attr;
};

struct hidma_mgmt_fileinfo {
	char *name;
	int mode;
	int (*get)(struct hidma_mgmt_dev *);
	int (*set)(struct hidma_mgmt_dev *, u64);
};

struct hidma_lldev;

struct hidma_tre {
	atomic_t allocated;
	bool queued;
	u16 status;
	u32 idx;
	u32 dma_sig;
	const char *dev_name;
	void (*callback)(void *);
	void *data;
	struct hidma_lldev *lldev;
	u32 tre_local[9];
	u32 tre_index;
	u32 int_flags;
	u8 err_info;
	u8 err_code;
};

struct hidma_lldev {
	bool msi_support;
	bool initialized;
	u8 trch_state;
	u8 evch_state;
	u8 chidx;
	u32 nr_tres;
	spinlock_t lock;
	struct hidma_tre *trepool;
	struct device *dev;
	void *trca;
	void *evca;
	struct hidma_tre **pending_tre_list;
	atomic_t pending_tre_count;
	void *tre_ring;
	dma_addr_t tre_dma;
	u32 tre_ring_size;
	u32 tre_processed_off;
	void *evre_ring;
	dma_addr_t evre_dma;
	u32 evre_ring_size;
	u32 evre_processed_off;
	u32 tre_write_offset;
	struct tasklet_struct task;
	struct {
		union {
			struct __kfifo kfifo;
			struct hidma_tre **type;
			const struct hidma_tre **const_type;
			char (*rectype)[0];
			struct hidma_tre **ptr;
			struct hidma_tre * const *ptr_const;
		};
		struct hidma_tre *buf[0];
	} handoff_fifo;
};

enum ch_command {
	HIDMA_CH_DISABLE = 0,
	HIDMA_CH_ENABLE = 1,
	HIDMA_CH_SUSPEND = 2,
	HIDMA_CH_RESET = 9,
};

enum ch_state {
	HIDMA_CH_DISABLED = 0,
	HIDMA_CH_ENABLED = 1,
	HIDMA_CH_RUNNING = 2,
	HIDMA_CH_SUSPENDED = 3,
	HIDMA_CH_STOPPED = 4,
};

enum err_code {
	HIDMA_EVRE_STATUS_COMPLETE = 1,
	HIDMA_EVRE_STATUS_ERROR = 4,
};

enum tre_type {
	HIDMA_TRE_MEMCPY = 3,
	HIDMA_TRE_MEMSET = 4,
};

struct hidma_desc {
	struct dma_async_tx_descriptor desc;
	struct list_head node;
	u32 tre_ch;
};

struct hidma_dev;

struct hidma_chan {
	bool paused;
	bool allocated;
	char dbg_name[16];
	u32 dma_sig;
	dma_cookie_t last_success;
	struct hidma_dev *dmadev;
	struct hidma_desc *running;
	struct dma_chan chan;
	struct list_head free;
	struct list_head prepared;
	struct list_head queued;
	struct list_head active;
	struct list_head completed;
	spinlock_t lock;
};

struct hidma_dev {
	int irq;
	int chidx;
	u32 nr_descriptors;
	int msi_virqbase;
	struct hidma_lldev *lldev;
	void *dev_trca;
	struct resource *trca_resource;
	void *dev_evca;
	struct resource *evca_resource;
	spinlock_t lock;
	struct dma_device ddev;
	struct dentry *debugfs;
	struct device_attribute *chid_attrs;
	struct tasklet_struct task;
};

enum hidma_cap {
	HIDMA_MSI_CAP = 1,
	HIDMA_IDENTITY_CAP = 2,
};

struct bman_hwerr_txt {
	u32 mask;
	const char *txt;
};

enum qm_wq_class {
	qm_wq_portal = 0,
	qm_wq_pool = 1,
	qm_wq_fman0 = 2,
	qm_wq_fman1 = 3,
	qm_wq_caam = 4,
	qm_wq_pme = 5,
	qm_wq_first = 0,
	qm_wq_last = 5,
};

enum qm_memory {
	qm_memory_fqd = 0,
	qm_memory_pfdr = 1,
};

struct qm_ecir {
	u32 info;
};

struct qm_ecir2 {
	u32 info;
};

struct qm_eadr {
	u32 info;
};

struct qman_hwerr_txt {
	u32 mask;
	const char *txt;
};

struct qman_error_info_mdata {
	u16 addr_mask;
	u16 bits;
	const char *txt;
};

enum qm_dc_portal {
	qm_dc_portal_fman0 = 0,
	qm_dc_portal_fman1 = 1,
};

struct bm_portal_config {
	void *addr_virt_ce;
	void *addr_virt_ci;
	struct list_head list;
	struct device *dev;
	int cpu;
	int irq;
};

struct bm_addr {
	void *ce;
	__be32 *ce_be;
	void *ci;
};

struct bm_rcr_entry;

struct bm_rcr {
	struct bm_rcr_entry *ring;
	struct bm_rcr_entry *cursor;
	u8 ci;
	u8 available;
	u8 ithresh;
	u8 vbit;
};

struct bm_mc_command;

union bm_mc_result;

struct bm_mc {
	struct bm_mc_command *cr;
	union bm_mc_result *rr;
	u8 rridx;
	u8 vbit;
};

struct bm_portal {
	struct bm_addr addr;
	struct bm_rcr rcr;
	struct bm_mc mc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bman_portal {
	struct bm_portal p;
	long unsigned int irq_sources;
	const struct bm_portal_config *config;
	char irqname[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __qm_mcr_querycongestion {
	u32 state[8];
};

struct qman_cgrs {
	struct __qm_mcr_querycongestion q;
};

struct qm_portal_config {
	void *addr_virt_ce;
	void *addr_virt_ci;
	struct device *dev;
	struct iommu_domain *iommu_domain;
	struct list_head list;
	int cpu;
	int irq;
	u16 channel;
	u32 pools;
};

struct bm_buffer {
	union {
		struct {
			__be16 bpid;
			__be16 hi;
			__be32 lo;
		};
		__be64 data;
	};
};

enum bm_rcr_pmode {
	bm_rcr_pci = 0,
	bm_rcr_pce = 1,
	bm_rcr_pvb = 2,
};

enum bm_rcr_cmode {
	bm_rcr_cci = 0,
	bm_rcr_cce = 1,
};

struct bm_rcr_entry {
	union {
		struct {
			u8 _ncw_verb;
			u8 bpid;
			u8 __reserved1[62];
		};
		struct bm_buffer bufs[8];
	};
};

struct bm_mc_command {
	u8 _ncw_verb;
	u8 bpid;
	u8 __reserved[62];
};

union bm_mc_result {
	struct {
		u8 verb;
		u8 bpid;
		u8 __reserved[62];
	};
	struct bm_buffer bufs[8];
};

struct bman_pool {
	u32 bpid;
	struct bman_portal *portal;
	struct bman_pool *next;
};

struct qm_fd {
	union {
		struct {
			u8 cfg8b_w1;
			u8 bpid;
			u8 cfg8b_w3;
			u8 addr_hi;
			__be32 addr_lo;
		};
		__be64 data;
	};
	__be32 cfg;
	union {
		__be32 cmd;
		__be32 status;
	};
};

struct qm_dqrr_entry {
	u8 verb;
	u8 stat;
	__be16 seqnum;
	u8 tok;
	u8 __reserved2[3];
	__be32 fqid;
	__be32 context_b;
	struct qm_fd fd;
	u8 __reserved4[32];
};

union qm_mr_entry {
	struct {
		u8 verb;
		u8 __reserved[63];
	};
	struct {
		u8 verb;
		u8 dca;
		__be16 seqnum;
		u8 rc;
		u8 __reserved[3];
		__be32 fqid;
		__be32 tag;
		struct qm_fd fd;
		u8 __reserved1[32];
	} ern;
	struct {
		u8 verb;
		u8 fqs;
		u8 __reserved1[6];
		__be32 fqid;
		__be32 context_b;
		u8 __reserved2[48];
	} fq;
};

struct qm_fqd_stashing {
	u8 exclusive;
	u8 cl;
};

struct qm_fqd_oac {
	u8 oac;
	s8 oal;
};

struct qm_fqd {
	u8 orpc;
	u8 cgid;
	__be16 fq_ctrl;
	__be16 dest_wq;
	__be16 ics_cred;
	union {
		__be16 td;
		struct qm_fqd_oac oac_init;
	};
	__be32 context_b;
	union {
		__be64 opaque;
		struct {
			__be32 hi;
			__be32 lo;
		};
		struct {
			struct qm_fqd_stashing stashing;
			__be16 context_hi;
			__be32 context_lo;
		};
	} context_a;
	struct qm_fqd_oac oac_query;
} __attribute__((packed));

struct qm_cgr_wr_parm {
	__be32 word;
};

struct qm_cgr_cs_thres {
	__be16 word;
};

struct __qm_mc_cgr {
	struct qm_cgr_wr_parm wr_parm_g;
	struct qm_cgr_wr_parm wr_parm_y;
	struct qm_cgr_wr_parm wr_parm_r;
	u8 wr_en_g;
	u8 wr_en_y;
	u8 wr_en_r;
	u8 cscn_en;
	union {
		struct {
			__be16 cscn_targ_upd_ctrl;
			__be16 cscn_targ_dcp_low;
		};
		__be32 cscn_targ;
	};
	u8 cstd_en;
	u8 cs;
	struct qm_cgr_cs_thres cs_thres;
	u8 mode;
} __attribute__((packed));

struct qm_mcc_initfq {
	u8 __reserved1[2];
	__be16 we_mask;
	__be32 fqid;
	__be16 count;
	struct qm_fqd fqd;
	u8 __reserved2[30];
};

struct qm_mcc_initcgr {
	u8 __reserve1[2];
	__be16 we_mask;
	struct __qm_mc_cgr cgr;
	u8 __reserved2[2];
	u8 cgid;
	u8 __reserved3[32];
};

enum qman_cb_dqrr_result {
	qman_cb_dqrr_consume = 0,
	qman_cb_dqrr_park = 1,
	qman_cb_dqrr_defer = 2,
	qman_cb_dqrr_stop = 3,
	qman_cb_dqrr_consume_stop = 4,
};

struct qman_portal;

struct qman_fq;

typedef enum qman_cb_dqrr_result (*qman_cb_dqrr)(struct qman_portal *, struct qman_fq *, const struct qm_dqrr_entry *, bool);

struct qm_addr {
	void *ce;
	__be32 *ce_be;
	void *ci;
};

struct qm_eqcr_entry;

struct qm_eqcr {
	struct qm_eqcr_entry *ring;
	struct qm_eqcr_entry *cursor;
	u8 ci;
	u8 available;
	u8 ithresh;
	u8 vbit;
};

struct qm_dqrr {
	const struct qm_dqrr_entry *ring;
	const struct qm_dqrr_entry *cursor;
	u8 pi;
	u8 ci;
	u8 fill;
	u8 ithresh;
	u8 vbit;
};

struct qm_mr {
	union qm_mr_entry *ring;
	union qm_mr_entry *cursor;
	u8 pi;
	u8 ci;
	u8 fill;
	u8 ithresh;
	u8 vbit;
};

union qm_mc_command;

union qm_mc_result;

struct qm_mc {
	union qm_mc_command *cr;
	union qm_mc_result *rr;
	u8 rridx;
	u8 vbit;
};

struct qm_portal {
	struct qm_addr addr;
	struct qm_eqcr eqcr;
	struct qm_dqrr dqrr;
	struct qm_mr mr;
	struct qm_mc mc;
	long: 64;
};

struct qman_portal {
	struct qm_portal p;
	long unsigned int bits;
	long unsigned int irq_sources;
	u32 use_eqcr_ci_stashing;
	struct qman_fq *vdqcr_owned;
	u32 sdqcr;
	const struct qm_portal_config *config;
	struct qman_cgrs *cgrs;
	struct list_head cgr_cbs;
	spinlock_t cgr_lock;
	struct work_struct congestion_work;
	struct work_struct mr_work;
	char irqname[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef void (*qman_cb_mr)(struct qman_portal *, struct qman_fq *, const union qm_mr_entry *);

struct qman_fq_cb {
	qman_cb_dqrr dqrr;
	qman_cb_mr ern;
	qman_cb_mr fqs;
};

enum qman_fq_state {
	qman_fq_state_oos = 0,
	qman_fq_state_parked = 1,
	qman_fq_state_sched = 2,
	qman_fq_state_retired = 3,
};

struct qman_fq {
	struct qman_fq_cb cb;
	u32 fqid;
	u32 idx;
	long unsigned int flags;
	enum qman_fq_state state;
	int cgr_groupid;
};

struct qman_cgr;

typedef void (*qman_cb_cgr)(struct qman_portal *, struct qman_cgr *, int);

struct qman_cgr {
	u32 cgrid;
	qman_cb_cgr cb;
	u16 chan;
	struct list_head node;
};

struct qm_mcr_queryfq_np {
	u8 verb;
	u8 result;
	u8 __reserved1;
	u8 state;
	u32 fqd_link;
	u16 odp_seq;
	u16 orp_nesn;
	u16 orp_ea_hseq;
	u16 orp_ea_tseq;
	u32 orp_ea_hptr;
	u32 orp_ea_tptr;
	u32 pfdr_hptr;
	u32 pfdr_tptr;
	u8 __reserved2[5];
	u8 is;
	u16 ics_surp;
	u32 byte_cnt;
	u32 frm_cnt;
	u32 __reserved3;
	u16 ra1_sfdr;
	u16 ra2_sfdr;
	u16 __reserved4;
	u16 od1_sfdr;
	u16 od2_sfdr;
	u16 od3_sfdr;
};

struct qm_mcr_querywq {
	u8 verb;
	u8 result;
	u16 channel_wq;
	u8 __reserved[28];
	u32 wq_len[8];
};

struct qm_mcr_querycongestion {
	u8 verb;
	u8 result;
	u8 __reserved[30];
	struct __qm_mcr_querycongestion state;
};

struct qm_mcr_querycgr {
	u8 verb;
	u8 result;
	u16 __reserved1;
	struct __qm_mc_cgr cgr;
	u8 __reserved2[6];
	u8 i_bcnt_hi;
	__be32 i_bcnt_lo;
	u8 __reserved3[3];
	u8 a_bcnt_hi;
	__be32 a_bcnt_lo;
	__be32 cscn_targ_swp[4];
};

enum qm_eqcr_pmode {
	qm_eqcr_pci = 0,
	qm_eqcr_pce = 1,
	qm_eqcr_pvb = 2,
};

enum qm_dqrr_dmode {
	qm_dqrr_dpush = 0,
	qm_dqrr_dpull = 1,
};

enum qm_dqrr_pmode {
	qm_dqrr_pci = 0,
	qm_dqrr_pce = 1,
	qm_dqrr_pvb = 2,
};

enum qm_dqrr_cmode {
	qm_dqrr_cci = 0,
	qm_dqrr_cce = 1,
	qm_dqrr_cdc = 2,
};

enum qm_mr_pmode {
	qm_mr_pci = 0,
	qm_mr_pce = 1,
	qm_mr_pvb = 2,
};

enum qm_mr_cmode {
	qm_mr_cci = 0,
	qm_mr_cce = 1,
};

struct qm_eqcr_entry {
	u8 _ncw_verb;
	u8 dca;
	__be16 seqnum;
	u8 __reserved[4];
	__be32 fqid;
	__be32 tag;
	struct qm_fd fd;
	u8 __reserved3[32];
};

struct qm_mcc_fq {
	u8 _ncw_verb;
	u8 __reserved1[3];
	__be32 fqid;
	u8 __reserved2[56];
};

struct qm_mcc_cgr {
	u8 _ncw_verb;
	u8 __reserved1[30];
	u8 cgid;
	u8 __reserved2[32];
};

union qm_mc_command {
	struct {
		u8 _ncw_verb;
		u8 __reserved[63];
	};
	struct qm_mcc_initfq initfq;
	struct qm_mcc_initcgr initcgr;
	struct qm_mcc_fq fq;
	struct qm_mcc_cgr cgr;
};

struct qm_mcr_queryfq {
	u8 verb;
	u8 result;
	u8 __reserved1[8];
	struct qm_fqd fqd;
	u8 __reserved2[30];
};

struct qm_mcr_alterfq {
	u8 verb;
	u8 result;
	u8 fqs;
	u8 __reserved1[61];
};

union qm_mc_result {
	struct {
		u8 verb;
		u8 result;
		u8 __reserved1[62];
	};
	struct qm_mcr_queryfq queryfq;
	struct qm_mcr_alterfq alterfq;
	struct qm_mcr_querycgr querycgr;
	struct qm_mcr_querycongestion querycongestion;
	struct qm_mcr_querywq querywq;
	struct qm_mcr_queryfq_np queryfq_np;
};

struct rcpm {
	unsigned int wakeup_cells;
	void *ippdexpcr_base;
	bool little_endian;
};

struct soc_device_attribute {
	const char *machine;
	const char *family;
	const char *revision;
	const char *serial_number;
	const char *soc_id;
	const void *data;
	const struct attribute_group *custom_attr_group;
};

struct guts {
	struct ccsr_guts *regs;
	bool little_endian;
};

struct fsl_soc_die_attr {
	char *die;
	u32 svr;
	u32 mask;
};

enum dpio_channel_mode {
	DPIO_NO_CHANNEL = 0,
	DPIO_LOCAL_CHANNEL = 1,
};

struct dpio_attr {
	int id;
	u64 qbman_portal_ce_offset;
	u64 qbman_portal_ci_offset;
	u16 qbman_portal_id;
	enum dpio_channel_mode channel_mode;
	u8 num_priorities;
	u32 qbman_version;
};

struct dpio_cmd_open {
	__le32 dpio_id;
};

struct dpio_rsp_get_attr {
	__le32 id;
	__le16 qbman_portal_id;
	u8 num_priorities;
	u8 channel_mode;
	__le64 qbman_portal_ce_addr;
	__le64 qbman_portal_ci_addr;
	__le32 qbman_version;
};

struct dpio_stashing_dest {
	u8 sdest;
};

struct dpaa2_fd_simple {
	__le64 addr;
	__le32 len;
	__le16 bpid;
	__le16 format_offset;
	__le32 frc;
	__le32 ctrl;
	__le64 flc;
};

struct dpaa2_fd {
	union {
		u32 words[8];
		struct dpaa2_fd_simple simple;
	};
};

struct common {
	u8 verb;
	u8 reserved[63];
};

struct dq {
	u8 verb;
	u8 stat;
	__le16 seqnum;
	__le16 oprid;
	u8 reserved;
	u8 tok;
	__le32 fqid;
	u32 reserved2;
	__le32 fq_byte_cnt;
	__le32 fq_frm_cnt;
	__le64 fqd_ctx;
	u8 fd[32];
};

struct scn {
	u8 verb;
	u8 stat;
	u8 state;
	u8 reserved;
	__le32 rid_tok;
	__le64 ctx;
};

struct dpaa2_dq {
	union {
		struct common common;
		struct dq dq;
		struct scn scn;
	};
};

struct qbman_swp_desc {
	void *cena_bar;
	void *cinh_bar;
	u32 qman_version;
};

struct qbman_pull_desc {
	u8 verb;
	u8 numf;
	u8 tok;
	u8 reserved;
	__le32 dq_src;
	__le64 rsp_addr;
	u64 rsp_addr_virt;
	u8 padding[40];
};

enum qbman_pull_type_e {
	qbman_pull_type_prio = 1,
	qbman_pull_type_active = 2,
	qbman_pull_type_active_noics = 3,
};

struct qbman_eq_desc {
	u8 verb;
	u8 dca;
	__le16 seqnum;
	__le16 orpid;
	__le16 reserved1;
	__le32 tgtid;
	__le32 tag;
	__le16 qdbin;
	u8 qpri;
	u8 reserved[3];
	u8 wae;
	u8 rspid;
	__le64 rsp_addr;
};

struct qbman_release_desc {
	u8 verb;
	u8 reserved;
	__le16 bpid;
	__le32 reserved2;
	__le64 buf[7];
};

struct qbman_swp {
	const struct qbman_swp_desc *desc;
	void *addr_cena;
	void *addr_cinh;
	struct {
		u32 valid_bit;
	} mc;
	struct {
		u32 valid_bit;
	} mr;
	u32 sdq;
	struct {
		atomic_t available;
		u32 valid_bit;
		struct dpaa2_dq *storage;
	} vdq;
	struct {
		u32 next_idx;
		u32 valid_bit;
		u8 dqrr_size;
		int reset_bug;
	} dqrr;
	struct {
		u32 pi;
		u32 pi_vb;
		u32 pi_ring_size;
		u32 pi_ci_mask;
		u32 ci;
		int available;
		u32 pend;
		u32 no_pfdr;
	} eqcr;
	spinlock_t access_spinlock;
};

struct qbman_fq_query_np_rslt {
	u8 verb;
	u8 rslt;
	u8 st1;
	u8 st2;
	u8 reserved[2];
	__le16 od1_sfdr;
	__le16 od2_sfdr;
	__le16 od3_sfdr;
	__le16 ra1_sfdr;
	__le16 ra2_sfdr;
	__le32 pfdr_hptr;
	__le32 pfdr_tptr;
	__le32 frm_cnt;
	__le32 byte_cnt;
	__le16 ics_surp;
	u8 is;
	u8 reserved2[29];
};

struct qbman_bp_query_rslt {
	u8 verb;
	u8 rslt;
	u8 reserved[4];
	u8 bdi;
	u8 state;
	__le32 fill;
	__le32 hdotr;
	__le16 swdet;
	__le16 swdxt;
	__le16 hwdet;
	__le16 hwdxt;
	__le16 swset;
	__le16 swsxt;
	__le16 vbpid;
	__le16 icid;
	__le64 bpscn_addr;
	__le64 bpscn_ctx;
	__le16 hw_targ;
	u8 dbe;
	u8 reserved2;
	u8 sdcnt;
	u8 hdcnt;
	u8 sscnt;
	u8 reserved3[9];
};

enum qbman_sdqcr_dct {
	qbman_sdqcr_dct_null = 0,
	qbman_sdqcr_dct_prio_ics = 1,
	qbman_sdqcr_dct_active_ics = 2,
	qbman_sdqcr_dct_active = 3,
};

enum qbman_sdqcr_fc {
	qbman_sdqcr_fc_one = 0,
	qbman_sdqcr_fc_up_to_3 = 1,
};

enum qb_enqueue_commands {
	enqueue_empty = 0,
	enqueue_response_always = 1,
	enqueue_rejects_to_fq = 2,
};

enum qb_pull_dt_e {
	qb_pull_dt_channel = 0,
	qb_pull_dt_workqueue = 1,
	qb_pull_dt_framequeue = 2,
};

struct qbman_acquire_desc {
	u8 verb;
	u8 reserved;
	__le16 bpid;
	u8 num;
	u8 reserved2[59];
};

struct qbman_acquire_rslt {
	u8 verb;
	u8 rslt;
	__le16 reserved;
	u8 num;
	u8 reserved2[3];
	__le64 buf[7];
};

struct qbman_alt_fq_state_desc {
	u8 verb;
	u8 reserved[3];
	__le32 fqid;
	u8 reserved2[56];
};

struct qbman_alt_fq_state_rslt {
	u8 verb;
	u8 rslt;
	u8 reserved[62];
};

struct qbman_cdan_ctrl_desc {
	u8 verb;
	u8 reserved;
	__le16 ch;
	u8 we;
	u8 ctrl;
	__le16 reserved2;
	__le64 cdan_ctx;
	u8 reserved3[48];
};

struct qbman_cdan_ctrl_rslt {
	u8 verb;
	u8 rslt;
	__le16 ch;
	u8 reserved[60];
};

struct qbman_fq_query_desc {
	u8 verb;
	u8 reserved[3];
	__le32 fqid;
	u8 reserved2[56];
};

struct qbman_bp_query_desc {
	u8 verb;
	u8 reserved;
	__le16 bpid;
	u8 reserved2[60];
};

struct dpaa2_io_desc {
	int receives_notifications;
	int has_8prio;
	int cpu;
	void *regs_cena;
	void *regs_cinh;
	int dpio_id;
	u32 qman_version;
};

struct dpaa2_io_notification_ctx {
	void (*cb)(struct dpaa2_io_notification_ctx *);
	int is_cdan;
	u32 id;
	int desired_cpu;
	int dpio_id;
	u64 qman64;
	struct list_head node;
	void *dpio_private;
};

struct dpaa2_io {
	struct dpaa2_io_desc dpio_desc;
	struct qbman_swp_desc swp_desc;
	struct qbman_swp *swp;
	struct list_head node;
	spinlock_t lock_mgmt_cmd;
	spinlock_t lock_notifications;
	struct list_head notifications;
	struct device *dev;
};

struct dpaa2_io_store {
	unsigned int max;
	dma_addr_t paddr;
	struct dpaa2_dq *vaddr;
	void *alloced_addr;
	unsigned int idx;
	struct qbman_swp *swp;
	struct device *dev;
};

struct dpio_priv {
	struct dpaa2_io *io;
};

struct log_header {
	__le32 magic_word;
	char reserved[4];
	__le32 buf_start;
	__le32 buf_length;
	__le32 last_byte;
};

struct console_data {
	void *map_addr;
	struct log_header *hdr;
	void *start_addr;
	void *end_addr;
	void *end_of_data;
	void *cur_ptr;
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

typedef struct vring_desc vring_desc_t;

typedef struct vring_avail vring_avail_t;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 last;
};

struct vring_desc_extra {
	dma_addr_t addr;
	u32 len;
	u16 flags;
	u16 next;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	bool event_triggered;
	union {
		struct {
			struct vring vring;
			u16 avail_flags_shadow;
			u16 avail_idx_shadow;
			struct vring_desc_state_split *desc_state;
			struct vring_desc_extra *desc_extra;
			dma_addr_t queue_dma_addr;
			size_t queue_size_in_bytes;
		} split;
		struct {
			struct {
				unsigned int num;
				struct vring_packed_desc *desc;
				struct vring_packed_desc_event *driver;
				struct vring_packed_desc_event *device;
			} vring;
			bool avail_wrap_counter;
			bool used_wrap_counter;
			u16 avail_used_flags;
			u16 next_avail_idx;
			u16 event_flags_shadow;
			struct vring_desc_state_packed *desc_state;
			struct vring_desc_extra *desc_extra;
			dma_addr_t ring_dma_addr;
			dma_addr_t driver_event_dma_addr;
			dma_addr_t device_event_dma_addr;
			size_t ring_size_in_bytes;
			size_t event_size_in_bytes;
		} packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_modern_device {
	struct pci_dev *pci_dev;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	resource_size_t notify_pa;
	u8 *isr;
	size_t notify_len;
	size_t device_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	struct virtio_device_id id;
};

struct virtio_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	struct virtio_pci_modern_device mdev;
	u8 *isr;
	void *ioaddr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct virtio_pci_vq_info **vqs;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

struct virtio_balloon_config {
	__le32 num_pages;
	__le32 actual;
	union {
		__le32 free_page_hint_cmd_id;
		__le32 free_page_report_cmd_id;
	};
	__le32 poison_val;
};

struct virtio_balloon_stat {
	__virtio16 tag;
	__virtio64 val;
} __attribute__((packed));

enum virtio_balloon_vq {
	VIRTIO_BALLOON_VQ_INFLATE = 0,
	VIRTIO_BALLOON_VQ_DEFLATE = 1,
	VIRTIO_BALLOON_VQ_STATS = 2,
	VIRTIO_BALLOON_VQ_FREE_PAGE = 3,
	VIRTIO_BALLOON_VQ_REPORTING = 4,
	VIRTIO_BALLOON_VQ_MAX = 5,
};

enum virtio_balloon_config_read {
	VIRTIO_BALLOON_CONFIG_READ_CMD_ID = 0,
};

struct virtio_balloon {
	struct virtio_device *vdev;
	struct virtqueue *inflate_vq;
	struct virtqueue *deflate_vq;
	struct virtqueue *stats_vq;
	struct virtqueue *free_page_vq;
	struct workqueue_struct *balloon_wq;
	struct work_struct report_free_page_work;
	struct work_struct update_balloon_stats_work;
	struct work_struct update_balloon_size_work;
	spinlock_t stop_update_lock;
	bool stop_update;
	long unsigned int config_read_bitmap;
	struct list_head free_page_list;
	spinlock_t free_page_list_lock;
	long unsigned int num_free_page_blocks;
	u32 cmd_id_received_cache;
	__virtio32 cmd_id_active;
	__virtio32 cmd_id_stop;
	wait_queue_head_t acked;
	unsigned int num_pages;
	struct balloon_dev_info vb_dev_info;
	struct mutex balloon_lock;
	unsigned int num_pfns;
	__virtio32 pfns[256];
	struct virtio_balloon_stat stats[10];
	struct shrinker shrinker;
	struct notifier_block oom_nb;
	struct virtqueue *reporting_vq;
	struct page_reporting_dev_info pr_dev_info;
};

typedef struct {
	union {
		xen_pfn_t *p;
		uint64_t q;
	};
} __guest_handle_xen_pfn_t;

struct grant_entry_v1 {
	uint16_t flags;
	domid_t domid;
	uint32_t frame;
};

struct grant_entry_header {
	uint16_t flags;
	domid_t domid;
};

union grant_entry_v2 {
	struct grant_entry_header hdr;
	struct {
		struct grant_entry_header hdr;
		uint32_t pad0;
		uint64_t frame;
	} full_page;
	struct {
		struct grant_entry_header hdr;
		uint16_t page_off;
		uint16_t length;
		uint64_t frame;
	} sub_page;
	struct {
		struct grant_entry_header hdr;
		domid_t trans_domid;
		uint16_t pad0;
		grant_ref_t gref;
	} transitive;
	uint32_t __spacer[4];
};

struct gnttab_setup_table {
	domid_t dom;
	uint32_t nr_frames;
	int16_t status;
	__guest_handle_xen_pfn_t frame_list;
};

struct gnttab_copy {
	struct {
		union {
			grant_ref_t ref;
			xen_pfn_t gmfn;
		} u;
		domid_t domid;
		uint16_t offset;
	} source;
	struct {
		union {
			grant_ref_t ref;
			xen_pfn_t gmfn;
		} u;
		domid_t domid;
		uint16_t offset;
	} dest;
	uint16_t len;
	uint16_t flags;
	int16_t status;
};

struct gnttab_query_size {
	domid_t dom;
	uint32_t nr_frames;
	uint32_t max_nr_frames;
	int16_t status;
};

struct gnttab_set_version {
	uint32_t version;
};

struct gnttab_get_status_frames {
	uint32_t nr_frames;
	domid_t dom;
	int16_t status;
	__guest_handle_uint64_t frame_list;
};

struct gnttab_free_callback {
	struct gnttab_free_callback *next;
	void (*fn)(void *);
	void *arg;
	u16 count;
};

struct gntab_unmap_queue_data;

typedef void (*gnttab_unmap_refs_done)(int, struct gntab_unmap_queue_data *);

struct gntab_unmap_queue_data {
	struct delayed_work gnttab_work;
	void *data;
	gnttab_unmap_refs_done done;
	struct gnttab_unmap_grant_ref *unmap_ops;
	struct gnttab_unmap_grant_ref *kunmap_ops;
	struct page **pages;
	unsigned int count;
	unsigned int age;
};

struct gnttab_page_cache {
	spinlock_t lock;
	struct list_head pages;
	unsigned int num_pages;
};

struct xen_page_foreign {
	domid_t domid;
	grant_ref_t gref;
};

typedef void (*xen_grant_fn_t)(long unsigned int, unsigned int, unsigned int, void *);

struct gnttab_ops {
	unsigned int version;
	unsigned int grefs_per_grant_frame;
	int (*map_frames)(xen_pfn_t *, unsigned int);
	void (*unmap_frames)();
	void (*update_entry)(grant_ref_t, domid_t, long unsigned int, unsigned int);
	int (*end_foreign_access_ref)(grant_ref_t, int);
	long unsigned int (*end_foreign_transfer_ref)(grant_ref_t);
	long unsigned int (*read_frame)(grant_ref_t);
};

struct unmap_refs_callback_data {
	struct completion completion;
	int result;
};

struct deferred_entry {
	struct list_head list;
	grant_ref_t ref;
	bool ro;
	uint16_t warn_delay;
	struct page *page;
};

struct xen_feature_info {
	unsigned int submap_idx;
	uint32_t submap;
};

struct balloon_stats {
	long unsigned int current_pages;
	long unsigned int target_pages;
	long unsigned int target_unpopulated;
	long unsigned int balloon_low;
	long unsigned int balloon_high;
	long unsigned int total_pages;
	long unsigned int schedule_delay;
	long unsigned int max_schedule_delay;
	long unsigned int retry_count;
	long unsigned int max_retry_count;
};

enum bp_state {
	BP_DONE = 0,
	BP_WAIT = 1,
	BP_EAGAIN = 2,
	BP_ECANCELED = 3,
};

enum shutdown_state {
	SHUTDOWN_INVALID = 4294967295,
	SHUTDOWN_POWEROFF = 0,
	SHUTDOWN_SUSPEND = 2,
	SHUTDOWN_HALT = 4,
};

struct suspend_info {
	int cancelled;
};

struct shutdown_handler {
	const char command[11];
	bool flag;
	void (*cb)();
};

struct vcpu_runstate_info {
	int state;
	uint64_t state_entry_time;
	uint64_t time[4];
};

typedef struct {
	union {
		struct vcpu_runstate_info *p;
		uint64_t q;
	};
} __guest_handle_vcpu_runstate_info;

struct vcpu_register_runstate_memory_area {
	union {
		__guest_handle_vcpu_runstate_info h;
		struct vcpu_runstate_info *v;
		uint64_t p;
	} addr;
};

struct xen_memory_reservation {
	__guest_handle_xen_pfn_t extent_start;
	xen_ulong_t nr_extents;
	unsigned int extent_order;
	unsigned int address_bits;
	domid_t domid;
};

typedef struct {
	union {
		evtchn_port_t *p;
		uint64_t q;
	};
} __guest_handle_evtchn_port_t;

struct evtchn_bind_interdomain {
	domid_t remote_dom;
	evtchn_port_t remote_port;
	evtchn_port_t local_port;
};

struct evtchn_bind_virq {
	uint32_t virq;
	uint32_t vcpu;
	evtchn_port_t port;
};

struct evtchn_bind_pirq {
	uint32_t pirq;
	uint32_t flags;
	evtchn_port_t port;
};

struct evtchn_bind_ipi {
	uint32_t vcpu;
	evtchn_port_t port;
};

struct evtchn_close {
	evtchn_port_t port;
};

struct evtchn_send {
	evtchn_port_t port;
};

struct evtchn_status {
	domid_t dom;
	evtchn_port_t port;
	uint32_t status;
	uint32_t vcpu;
	union {
		struct {
			domid_t dom;
		} unbound;
		struct {
			domid_t dom;
			evtchn_port_t port;
		} interdomain;
		uint32_t pirq;
		uint32_t virq;
	} u;
};

struct evtchn_bind_vcpu {
	evtchn_port_t port;
	uint32_t vcpu;
};

struct evtchn_set_priority {
	evtchn_port_t port;
	uint32_t priority;
};

struct sched_poll {
	__guest_handle_evtchn_port_t ports;
	unsigned int nr_ports;
	uint64_t timeout;
};

enum ipi_vector {
	XEN_PLACEHOLDER_VECTOR = 0,
	XEN_NR_IPIS = 1,
};

struct physdev_eoi {
	uint32_t irq;
};

struct physdev_irq_status_query {
	uint32_t irq;
	uint32_t flags;
};

struct physdev_irq {
	uint32_t irq;
	uint32_t vector;
};

struct physdev_map_pirq {
	domid_t domid;
	int type;
	int index;
	int pirq;
	int bus;
	int devfn;
	int entry_nr;
	uint64_t table_base;
};

struct physdev_unmap_pirq {
	domid_t domid;
	int pirq;
};

struct physdev_get_free_pirq {
	int type;
	uint32_t pirq;
};

struct evtchn_loop_ctrl;

struct evtchn_ops {
	unsigned int (*max_channels)();
	unsigned int (*nr_channels)();
	int (*setup)(evtchn_port_t);
	void (*remove)(evtchn_port_t, unsigned int);
	void (*bind_to_cpu)(evtchn_port_t, unsigned int, unsigned int);
	void (*clear_pending)(evtchn_port_t);
	void (*set_pending)(evtchn_port_t);
	bool (*is_pending)(evtchn_port_t);
	void (*mask)(evtchn_port_t);
	void (*unmask)(evtchn_port_t);
	void (*handle_events)(unsigned int, struct evtchn_loop_ctrl *);
	void (*resume)();
	int (*percpu_init)(unsigned int);
	int (*percpu_deinit)(unsigned int);
};

struct evtchn_loop_ctrl {
	ktime_t timeout;
	unsigned int count;
	bool defer_eoi;
};

enum xen_irq_type {
	IRQT_UNBOUND = 0,
	IRQT_PIRQ = 1,
	IRQT_VIRQ = 2,
	IRQT_IPI = 3,
	IRQT_EVTCHN = 4,
};

struct irq_info {
	struct list_head list;
	struct list_head eoi_list;
	short int refcnt;
	u8 spurious_cnt;
	u8 is_accounted;
	short int type;
	u8 mask_reason;
	u8 is_active;
	unsigned int irq;
	evtchn_port_t evtchn;
	short unsigned int cpu;
	short unsigned int eoi_cpu;
	unsigned int irq_epoch;
	u64 eoi_time;
	raw_spinlock_t lock;
	union {
		short unsigned int virq;
		enum ipi_vector ipi;
		struct {
			short unsigned int pirq;
			short unsigned int gsi;
			unsigned char vector;
			unsigned char flags;
			uint16_t domid;
		} pirq;
		struct xenbus_device *interdomain;
	} u;
};

struct lateeoi_work {
	struct delayed_work delayed;
	spinlock_t eoi_list_lock;
	struct list_head eoi_list;
};

struct evtchn_unmask {
	evtchn_port_t port;
};

struct evtchn_init_control {
	uint64_t control_gfn;
	uint32_t offset;
	uint32_t vcpu;
	uint8_t link_bits;
	uint8_t _pad[7];
};

struct evtchn_expand_array {
	uint64_t array_gfn;
};

typedef uint32_t event_word_t;

struct evtchn_fifo_control_block {
	uint32_t ready;
	uint32_t _rsvd;
	event_word_t head[16];
};

struct evtchn_fifo_queue {
	uint32_t head[16];
};

struct evtchn_alloc_unbound {
	domid_t dom;
	domid_t remote_dom;
	evtchn_port_t port;
};

struct xenbus_map_node {
	struct list_head next;
	union {
		struct {
			struct vm_struct *area;
		} pv;
		struct {
			struct page *pages[16];
			long unsigned int addrs[16];
			void *addr;
		} hvm;
	};
	grant_handle_t handles[16];
	unsigned int nr_handles;
};

struct map_ring_valloc {
	struct xenbus_map_node *node;
	long unsigned int addrs[16];
	phys_addr_t phys_addrs[16];
	struct gnttab_map_grant_ref map[16];
	struct gnttab_unmap_grant_ref unmap[16];
	unsigned int idx;
};

struct xenbus_ring_ops {
	int (*map)(struct xenbus_device *, struct map_ring_valloc *, grant_ref_t *, unsigned int, void **);
	int (*unmap)(struct xenbus_device *, void *);
};

struct unmap_ring_hvm {
	unsigned int idx;
	long unsigned int addrs[16];
};

enum xsd_sockmsg_type {
	XS_DEBUG = 0,
	XS_DIRECTORY = 1,
	XS_READ = 2,
	XS_GET_PERMS = 3,
	XS_WATCH = 4,
	XS_UNWATCH = 5,
	XS_TRANSACTION_START = 6,
	XS_TRANSACTION_END = 7,
	XS_INTRODUCE = 8,
	XS_RELEASE = 9,
	XS_GET_DOMAIN_PATH = 10,
	XS_WRITE = 11,
	XS_MKDIR = 12,
	XS_RM = 13,
	XS_SET_PERMS = 14,
	XS_WATCH_EVENT = 15,
	XS_ERROR = 16,
	XS_IS_DOMAIN_INTRODUCED = 17,
	XS_RESUME = 18,
	XS_SET_TARGET = 19,
	XS_RESTRICT = 20,
	XS_RESET_WATCHES = 21,
};

struct xsd_sockmsg {
	uint32_t type;
	uint32_t req_id;
	uint32_t tx_id;
	uint32_t len;
};

typedef uint32_t XENSTORE_RING_IDX;

struct xenstore_domain_interface {
	char req[1024];
	char rsp[1024];
	XENSTORE_RING_IDX req_cons;
	XENSTORE_RING_IDX req_prod;
	XENSTORE_RING_IDX rsp_cons;
	XENSTORE_RING_IDX rsp_prod;
};

struct xs_watch_event {
	struct list_head list;
	unsigned int len;
	struct xenbus_watch *handle;
	const char *path;
	const char *token;
	char body[0];
};

enum xb_req_state {
	xb_req_state_queued = 0,
	xb_req_state_wait_reply = 1,
	xb_req_state_got_reply = 2,
	xb_req_state_aborted = 3,
};

struct xb_req_data {
	struct list_head list;
	wait_queue_head_t wq;
	struct xsd_sockmsg msg;
	uint32_t caller_req_id;
	enum xsd_sockmsg_type type;
	char *body;
	const struct kvec *vec;
	int num_vecs;
	int err;
	enum xb_req_state state;
	bool user_req;
	void (*cb)(struct xb_req_data *);
	void *par;
};

enum xenstore_init {
	XS_UNKNOWN = 0,
	XS_PV = 1,
	XS_HVM = 2,
	XS_LOCAL = 3,
};

struct xen_hvm_param {
	domid_t domid;
	uint32_t index;
	uint64_t value;
};

struct xen_bus_type {
	char *root;
	unsigned int levels;
	int (*get_bus_id)(char *, const char *);
	int (*probe)(struct xen_bus_type *, const char *, const char *);
	bool (*otherend_will_handle)(struct xenbus_watch *, const char *, const char *);
	void (*otherend_changed)(struct xenbus_watch *, const char *, const char *);
	struct bus_type bus;
};

struct xb_find_info {
	struct xenbus_device *dev;
	const char *nodename;
};

struct xenbus_transaction_holder {
	struct list_head list;
	struct xenbus_transaction handle;
	unsigned int generation_id;
};

struct read_buffer {
	struct list_head list;
	unsigned int cons;
	unsigned int len;
	char msg[0];
};

struct xenbus_file_priv {
	struct mutex msgbuffer_mutex;
	struct list_head transactions;
	struct list_head watches;
	unsigned int len;
	union {
		struct xsd_sockmsg msg;
		char buffer[4096];
	} u;
	struct mutex reply_mutex;
	struct list_head read_buffers;
	wait_queue_head_t read_waitq;
	struct kref kref;
	struct work_struct wq;
};

struct watch_adapter {
	struct list_head list;
	struct xenbus_watch watch;
	struct xenbus_file_priv *dev_data;
	char *token;
};

struct physdev_manage_pci {
	uint8_t bus;
	uint8_t devfn;
};

struct physdev_manage_pci_ext {
	uint8_t bus;
	uint8_t devfn;
	unsigned int is_extfn;
	unsigned int is_virtfn;
	struct {
		uint8_t bus;
		uint8_t devfn;
	} physfn;
};

struct physdev_pci_device_add {
	uint16_t seg;
	uint8_t bus;
	uint8_t devfn;
	uint32_t flags;
	struct {
		uint8_t bus;
		uint8_t devfn;
	} physfn;
	uint32_t optarr[0];
};

struct physdev_pci_device {
	uint16_t seg;
	uint8_t bus;
	uint8_t devfn;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

enum usb_ssp_rate {
	USB_SSP_GEN_UNKNOWN = 0,
	USB_SSP_GEN_2x1 = 1,
	USB_SSP_GEN_1x2 = 2,
	USB_SSP_GEN_2x2 = 3,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	long: 0;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	long: 0;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[2];
};

struct usb_device;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
};

struct wusb_dev;

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	enum usb_ssp_rate ssp_rate;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int reset_in_progress: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct giveback_urb_bh {
	bool running;
	bool high_prio;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy;

struct usb_phy_roothub;

struct hc_driver;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
	int (*submit_single_step_set_feature)(struct usb_hcd *, struct urb *, int);
};

struct physdev_dbgp_op {
	uint8_t op;
	uint8_t bus;
	union {
		struct physdev_pci_device pci;
	} u;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct ioctl_evtchn_bind_virq {
	unsigned int virq;
};

struct ioctl_evtchn_bind_interdomain {
	unsigned int remote_domain;
	unsigned int remote_port;
};

struct ioctl_evtchn_bind_unbound_port {
	unsigned int remote_domain;
};

struct ioctl_evtchn_unbind {
	unsigned int port;
};

struct ioctl_evtchn_notify {
	unsigned int port;
};

struct ioctl_evtchn_restrict_domid {
	domid_t domid;
};

struct per_user_data {
	struct mutex bind_mutex;
	struct rb_root evtchns;
	unsigned int nr_evtchns;
	unsigned int ring_size;
	evtchn_port_t *ring;
	unsigned int ring_cons;
	unsigned int ring_prod;
	unsigned int ring_overflow;
	struct mutex ring_cons_mutex;
	spinlock_t ring_prod_lock;
	wait_queue_head_t evtchn_wait;
	struct fasync_struct *evtchn_async_queue;
	const char *name;
	domid_t restrict_domid;
};

struct user_evtchn {
	struct rb_node node;
	struct per_user_data *user;
	evtchn_port_t port;
	bool enabled;
};

struct xmaddr {
	phys_addr_t maddr;
};

typedef struct xmaddr xmaddr_t;

struct ioctl_gntdev_grant_ref {
	__u32 domid;
	__u32 ref;
};

struct ioctl_gntdev_map_grant_ref {
	__u32 count;
	__u32 pad;
	__u64 index;
	struct ioctl_gntdev_grant_ref refs[1];
};

struct ioctl_gntdev_unmap_grant_ref {
	__u64 index;
	__u32 count;
	__u32 pad;
};

struct ioctl_gntdev_get_offset_for_vaddr {
	__u64 vaddr;
	__u64 offset;
	__u32 count;
	__u32 pad;
};

struct ioctl_gntdev_unmap_notify {
	__u64 index;
	__u32 action;
	__u32 event_channel_port;
};

struct gntdev_grant_copy_segment {
	union {
		void *virt;
		struct {
			grant_ref_t ref;
			__u16 offset;
			domid_t domid;
		} foreign;
	} source;
	union {
		void *virt;
		struct {
			grant_ref_t ref;
			__u16 offset;
			domid_t domid;
		} foreign;
	} dest;
	__u16 len;
	__u16 flags;
	__s16 status;
};

struct ioctl_gntdev_grant_copy {
	unsigned int count;
	struct gntdev_grant_copy_segment *segments;
};

struct gntdev_priv {
	struct list_head maps;
	struct mutex lock;
};

struct gntdev_unmap_notify {
	int flags;
	int addr;
	evtchn_port_t event;
};

struct gntdev_grant_map {
	atomic_t in_use;
	struct mmu_interval_notifier notifier;
	bool notifier_init;
	struct list_head next;
	int index;
	int count;
	int flags;
	refcount_t users;
	struct gntdev_unmap_notify notify;
	struct ioctl_gntdev_grant_ref *grants;
	struct gnttab_map_grant_ref *map_ops;
	struct gnttab_unmap_grant_ref *unmap_ops;
	struct gnttab_map_grant_ref *kmap_ops;
	struct gnttab_unmap_grant_ref *kunmap_ops;
	bool *being_removed;
	struct page **pages;
	long unsigned int pages_vm_start;
	atomic_t live_grants;
	struct gntab_unmap_queue_data unmap_data;
};

struct gntdev_copy_batch {
	struct gnttab_copy ops[16];
	struct page *pages[16];
	s16 *status[16];
	unsigned int nr_ops;
	unsigned int nr_pages;
	bool writeable;
};

struct ioctl_gntalloc_alloc_gref {
	__u16 domid;
	__u16 flags;
	__u32 count;
	__u64 index;
	__u32 gref_ids[1];
};

struct ioctl_gntalloc_dealloc_gref {
	__u64 index;
	__u32 count;
};

struct ioctl_gntalloc_unmap_notify {
	__u64 index;
	__u32 action;
	__u32 event_channel_port;
};

struct notify_info {
	uint16_t pgoff: 12;
	uint16_t flags: 2;
	int event;
};

struct gntalloc_gref {
	struct list_head next_gref;
	struct list_head next_file;
	struct page *page;
	uint64_t file_index;
	unsigned int users;
	grant_ref_t gref_id;
	struct notify_info notify;
};

struct gntalloc_file_private_data {
	struct list_head list;
	uint64_t index;
};

struct gntalloc_vma_private_data {
	struct gntalloc_gref *gref;
	int users;
	int count;
};

typedef uint8_t xen_domain_handle_t[16];

struct xen_compile_info {
	char compiler[64];
	char compile_by[16];
	char compile_domain[32];
	char compile_date[32];
};

struct xen_platform_parameters {
	xen_ulong_t virt_start;
};

struct xen_build_id {
	uint32_t len;
	unsigned char buf[0];
};

struct hyp_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct hyp_sysfs_attr *, char *);
	ssize_t (*store)(struct hyp_sysfs_attr *, const char *, size_t);
	void *hyp_attr_data;
};

enum xen_swiotlb_err {
	XEN_SWIOTLB_UNKNOWN = 0,
	XEN_SWIOTLB_ENOMEM = 1,
	XEN_SWIOTLB_EFIXUP = 2,
};

struct privcmd_hypercall {
	__u64 op;
	__u64 arg[5];
};

struct privcmd_mmap_entry {
	__u64 va;
	__u64 mfn;
	__u64 npages;
};

struct privcmd_mmap {
	int num;
	domid_t dom;
	struct privcmd_mmap_entry *entry;
};

struct privcmd_mmapbatch_v2 {
	unsigned int num;
	domid_t dom;
	__u64 addr;
	const xen_pfn_t *arr;
	int *err;
};

struct privcmd_dm_op_buf {
	void *uptr;
	size_t size;
};

struct privcmd_dm_op {
	domid_t dom;
	__u16 num;
	const struct privcmd_dm_op_buf *ubufs;
};

struct privcmd_mmap_resource {
	domid_t dom;
	__u32 type;
	__u32 id;
	__u32 idx;
	__u64 num;
	__u64 addr;
};

struct xen_mem_acquire_resource {
	domid_t domid;
	uint16_t type;
	uint32_t id;
	uint32_t nr_frames;
	uint32_t flags;
	uint64_t frame;
	__guest_handle_xen_pfn_t frame_list;
};

struct xen_dm_op_buf {
	__guest_handle_void h;
	xen_ulong_t size;
};

struct privcmd_data {
	domid_t domid;
};

struct mmap_gfn_state {
	long unsigned int va;
	struct vm_area_struct *vma;
	domid_t domain;
};

struct mmap_batch_state {
	domid_t domain;
	long unsigned int va;
	struct vm_area_struct *vma;
	int index;
	int global_error;
	int version;
	xen_pfn_t *user_gfn;
	int *user_err;
};

struct privcmd_buf_private {
	struct mutex lock;
	struct list_head list;
};

struct privcmd_buf_vma_private {
	struct privcmd_buf_private *file_priv;
	struct list_head list;
	unsigned int users;
	unsigned int n_pages;
	struct page *pages[0];
};

typedef struct {
	union {
		int *p;
		uint64_t q;
	};
} __guest_handle_int;

typedef struct {
	union {
		xen_ulong_t *p;
		uint64_t q;
	};
} __guest_handle_xen_ulong_t;

struct xen_add_to_physmap_range {
	domid_t domid;
	uint16_t space;
	uint16_t size;
	domid_t foreign_domid;
	__guest_handle_xen_ulong_t idxs;
	__guest_handle_xen_pfn_t gpfns;
	__guest_handle_int errs;
};

struct xen_remove_from_physmap {
	domid_t domid;
	xen_pfn_t gpfn;
};

typedef void (*xen_gfn_fn_t)(long unsigned int, void *);

struct xen_remap_gfn_info;

struct remap_data {
	xen_pfn_t *fgfn;
	int nr_fgfn;
	pgprot_t prot;
	domid_t domid;
	struct vm_area_struct *vma;
	int index;
	struct page **pages;
	struct xen_remap_gfn_info *info;
	int *err_ptr;
	int mapped;
	int h_errs[1];
	xen_ulong_t h_idxs[1];
	xen_pfn_t h_gpfns[1];
	int h_iter;
};

struct map_balloon_pages {
	xen_pfn_t *pfns;
	unsigned int idx;
};

struct remap_pfn {
	struct mm_struct *mm;
	struct page **pages;
	pgprot_t prot;
	long unsigned int i;
};

struct reset_control_bulk_data {
	const char *id;
	struct reset_control *rstc;
};

struct reset_controller_dev;

struct reset_control {
	struct reset_controller_dev *rcdev;
	struct list_head list;
	unsigned int id;
	struct kref refcnt;
	bool acquired;
	bool shared;
	bool array;
	atomic_t deassert_count;
	atomic_t triggered_count;
};

struct reset_control_ops {
	int (*reset)(struct reset_controller_dev *, long unsigned int);
	int (*assert)(struct reset_controller_dev *, long unsigned int);
	int (*deassert)(struct reset_controller_dev *, long unsigned int);
	int (*status)(struct reset_controller_dev *, long unsigned int);
};

struct reset_controller_dev {
	const struct reset_control_ops *ops;
	struct module *owner;
	struct list_head list;
	struct list_head reset_control_head;
	struct device *dev;
	struct device_node *of_node;
	int of_reset_n_cells;
	int (*of_xlate)(struct reset_controller_dev *, const struct of_phandle_args *);
	unsigned int nr_resets;
};

struct reset_control_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
};

struct reset_control_array {
	struct reset_control base;
	unsigned int num_rstcs;
	struct reset_control *rstc[0];
};

struct reset_control_bulk_devres {
	int num_rstcs;
	struct reset_control_bulk_data *rstcs;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[64];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	int: 1;
	unsigned char modeflags: 5;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct uni_pagedir {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, int);
};

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	__u32 padding[5];
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef u64 upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int timeout;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	const struct serial_rs485 *rs485_supported;
	struct gpio_desc *rs485_term_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

typedef uint32_t XENCONS_RING_IDX;

struct xencons_interface {
	char in[1024];
	char out[2048];
	XENCONS_RING_IDX in_cons;
	XENCONS_RING_IDX in_prod;
	XENCONS_RING_IDX out_cons;
	XENCONS_RING_IDX out_prod;
};

struct xencons_info {
	struct list_head list;
	struct xenbus_device *xbdev;
	struct xencons_interface *intf;
	unsigned int evtchn;
	XENCONS_RING_IDX out_cons;
	unsigned int out_cons_same;
	struct hvc_struct *hvc;
	int irq;
	int vtermno;
	grant_ref_t gntref;
	spinlock_t ring_lock;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	upf_t flags;
	unsigned int type;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

enum {
	PLAT8250_DEV_LEGACY = 4294967295,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct uart_8250_port;

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
	void (*setup_timer)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	short unsigned int bugs;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char mcr_mask;
	unsigned char mcr_force;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	unsigned char lsr_saved_flags;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	int (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, int);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *);
	void (*rs485_stop_tx)(struct uart_8250_port *);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	void (*prepare_tx_dma)(struct uart_8250_port *);
	void (*prepare_rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct irq_info___2 {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u8 dlf_size;
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct serial_private;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct quatech_feature {
	u16 devid;
	bool amcc;
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_15625000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_oxsemi = 71,
	pbn_oxsemi_1_15625000 = 72,
	pbn_oxsemi_2_15625000 = 73,
	pbn_oxsemi_4_15625000 = 74,
	pbn_oxsemi_8_15625000 = 75,
	pbn_intel_i960 = 76,
	pbn_sgi_ioc3 = 77,
	pbn_computone_4 = 78,
	pbn_computone_6 = 79,
	pbn_computone_8 = 80,
	pbn_sbsxrsio = 81,
	pbn_pasemi_1682M = 82,
	pbn_ni8430_2 = 83,
	pbn_ni8430_4 = 84,
	pbn_ni8430_8 = 85,
	pbn_ni8430_16 = 86,
	pbn_ADDIDATA_PCIe_1_3906250 = 87,
	pbn_ADDIDATA_PCIe_2_3906250 = 88,
	pbn_ADDIDATA_PCIe_4_3906250 = 89,
	pbn_ADDIDATA_PCIe_8_3906250 = 90,
	pbn_ce4100_1_115200 = 91,
	pbn_omegapci = 92,
	pbn_NETMOS9900_2s_115200 = 93,
	pbn_brcm_trumanage = 94,
	pbn_fintek_4 = 95,
	pbn_fintek_8 = 96,
	pbn_fintek_12 = 97,
	pbn_fintek_F81504A = 98,
	pbn_fintek_F81508A = 99,
	pbn_fintek_F81512A = 100,
	pbn_wch382_2 = 101,
	pbn_wch384_4 = 102,
	pbn_wch384_8 = 103,
	pbn_pericom_PI7C9X7951 = 104,
	pbn_pericom_PI7C9X7952 = 105,
	pbn_pericom_PI7C9X7954 = 106,
	pbn_pericom_PI7C9X7958 = 107,
	pbn_sunix_pci_1s = 108,
	pbn_sunix_pci_2s = 109,
	pbn_sunix_pci_4s = 110,
	pbn_sunix_pci_8s = 111,
	pbn_sunix_pci_16s = 112,
	pbn_titan_1_4000000 = 113,
	pbn_titan_2_4000000 = 114,
	pbn_titan_4_4000000 = 115,
	pbn_titan_8_4000000 = 116,
	pbn_moxa8250_2p = 117,
	pbn_moxa8250_4p = 118,
	pbn_moxa8250_8p = 119,
};

struct dw8250_data {
	struct dw8250_port_data data;
	u8 usr_reg;
	int msr_mask_on;
	int msr_mask_off;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_notifier;
	struct work_struct clk_work;
	struct reset_control *rst;
	unsigned int skip_autocfg: 1;
	unsigned int uart_16550_compatible: 1;
};

struct of_serial_info {
	struct clk *clk;
	struct reset_control *rst;
	int type;
	int line;
};

enum amba_vendor {
	AMBA_VENDOR_ARM = 65,
	AMBA_VENDOR_ST = 128,
	AMBA_VENDOR_QCOM = 81,
	AMBA_VENDOR_LSI = 182,
	AMBA_VENDOR_LINUX = 254,
};

struct amba_pl011_data {
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	bool dma_rx_poll_enable;
	unsigned int dma_rx_poll_rate;
	unsigned int dma_rx_poll_timeout;
	void (*init)();
	void (*exit)();
};

enum {
	REG_DR = 0,
	REG_ST_DMAWM = 1,
	REG_ST_TIMEOUT = 2,
	REG_FR = 3,
	REG_LCRH_RX = 4,
	REG_LCRH_TX = 5,
	REG_IBRD = 6,
	REG_FBRD = 7,
	REG_CR = 8,
	REG_IFLS = 9,
	REG_IMSC = 10,
	REG_RIS = 11,
	REG_MIS = 12,
	REG_ICR = 13,
	REG_DMACR = 14,
	REG_ST_XFCR = 15,
	REG_ST_XON1 = 16,
	REG_ST_XON2 = 17,
	REG_ST_XOFF1 = 18,
	REG_ST_XOFF2 = 19,
	REG_ST_ITCR = 20,
	REG_ST_ITIP = 21,
	REG_ST_ABCR = 22,
	REG_ST_ABIMSC = 23,
	REG_ARRAY_SIZE = 24,
};

struct vendor_data {
	const u16 *reg_offset;
	unsigned int ifls;
	unsigned int fr_busy;
	unsigned int fr_dsr;
	unsigned int fr_cts;
	unsigned int fr_ri;
	unsigned int inv_fr;
	bool access_32b;
	bool oversampling;
	bool dma_threshold;
	bool cts_event_workaround;
	bool always_enabled;
	bool fixed_options;
	unsigned int (*get_fifosize)(struct amba_device *);
};

struct pl011_sgbuf {
	struct scatterlist sg;
	char *buf;
};

struct pl011_dmarx_data {
	struct dma_chan *chan;
	struct completion complete;
	bool use_buf_b;
	struct pl011_sgbuf sgbuf_a;
	struct pl011_sgbuf sgbuf_b;
	dma_cookie_t cookie;
	bool running;
	struct timer_list timer;
	unsigned int last_residue;
	long unsigned int last_jiffies;
	bool auto_poll_rate;
	unsigned int poll_rate;
	unsigned int poll_timeout;
};

struct pl011_dmatx_data {
	struct dma_chan *chan;
	struct scatterlist sg;
	char *buf;
	bool queued;
};

struct uart_amba_port {
	struct uart_port port;
	const u16 *reg_offset;
	struct clk *clk;
	const struct vendor_data *vendor;
	unsigned int dmacr;
	unsigned int im;
	unsigned int old_status;
	unsigned int fifosize;
	unsigned int old_cr;
	unsigned int fixed_baud;
	char type[12];
	bool rs485_tx_started;
	unsigned int rs485_tx_drain_interval;
	bool using_tx_dma;
	bool using_rx_dma;
	struct pl011_dmarx_data dmarx;
	struct pl011_dmatx_data dmatx;
	bool dma_probed;
};

struct spi_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct spi_statistics {
	spinlock_t lock;
	long unsigned int messages;
	long unsigned int transfers;
	long unsigned int errors;
	long unsigned int timedout;
	long unsigned int spi_sync;
	long unsigned int spi_sync_immediate;
	long unsigned int spi_async;
	long long unsigned int bytes;
	long long unsigned int bytes_rx;
	long long unsigned int bytes_tx;
	long unsigned int transfer_bytes_histo[17];
	long unsigned int transfers_split_maxsize;
};

struct spi_delay {
	u16 value;
	u8 unit;
};

struct spi_controller;

struct spi_device {
	struct device dev;
	struct spi_controller *controller;
	struct spi_controller *master;
	u32 max_speed_hz;
	u8 chip_select;
	u8 bits_per_word;
	bool rt;
	u32 mode;
	int irq;
	void *controller_state;
	void *controller_data;
	char modalias[32];
	const char *driver_override;
	int cs_gpio;
	struct gpio_desc *cs_gpiod;
	struct spi_delay word_delay;
	struct spi_delay cs_setup;
	struct spi_delay cs_hold;
	struct spi_delay cs_inactive;
	struct spi_statistics statistics;
};

struct spi_message;

struct spi_transfer;

struct spi_controller_mem_ops;

struct spi_controller {
	struct device dev;
	struct list_head list;
	s16 bus_num;
	u16 num_chipselect;
	u16 dma_alignment;
	u32 mode_bits;
	u32 buswidth_override_bits;
	u32 bits_per_word_mask;
	u32 min_speed_hz;
	u32 max_speed_hz;
	u16 flags;
	bool devm_allocated;
	bool slave;
	size_t (*max_transfer_size)(struct spi_device *);
	size_t (*max_message_size)(struct spi_device *);
	struct mutex io_mutex;
	struct mutex add_lock;
	spinlock_t bus_lock_spinlock;
	struct mutex bus_lock_mutex;
	bool bus_lock_flag;
	int (*setup)(struct spi_device *);
	int (*set_cs_timing)(struct spi_device *);
	int (*transfer)(struct spi_device *, struct spi_message *);
	void (*cleanup)(struct spi_device *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	struct device *dma_map_dev;
	bool queued;
	struct kthread_worker *kworker;
	struct kthread_work pump_messages;
	spinlock_t queue_lock;
	struct list_head queue;
	struct spi_message *cur_msg;
	bool idling;
	bool busy;
	bool running;
	bool rt;
	bool auto_runtime_pm;
	bool cur_msg_prepared;
	bool cur_msg_mapped;
	bool last_cs_enable;
	bool last_cs_mode_high;
	bool fallback;
	struct completion xfer_completion;
	size_t max_dma_len;
	int (*prepare_transfer_hardware)(struct spi_controller *);
	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_transfer_hardware)(struct spi_controller *);
	int (*prepare_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
	int (*slave_abort)(struct spi_controller *);
	void (*set_cs)(struct spi_device *, bool);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	void (*handle_err)(struct spi_controller *, struct spi_message *);
	const struct spi_controller_mem_ops *mem_ops;
	int *cs_gpios;
	struct gpio_desc **cs_gpiods;
	bool use_gpio_descriptors;
	s8 unused_native_cs;
	s8 max_native_cs;
	struct spi_statistics statistics;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	void *dummy_rx;
	void *dummy_tx;
	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
	bool ptp_sts_supported;
	long unsigned int irq_flags;
};

struct spi_driver {
	const struct spi_device_id *id_table;
	int (*probe)(struct spi_device *);
	int (*remove)(struct spi_device *);
	void (*shutdown)(struct spi_device *);
	struct device_driver driver;
};

struct spi_message {
	struct list_head transfers;
	struct spi_device *spi;
	unsigned int is_dma_mapped: 1;
	void (*complete)(void *);
	void *context;
	unsigned int frame_length;
	unsigned int actual_length;
	int status;
	struct list_head queue;
	void *state;
	struct list_head resources;
};

struct spi_transfer {
	const void *tx_buf;
	void *rx_buf;
	unsigned int len;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	struct sg_table tx_sg;
	struct sg_table rx_sg;
	unsigned int dummy_data: 1;
	unsigned int cs_change: 1;
	unsigned int tx_nbits: 3;
	unsigned int rx_nbits: 3;
	u8 bits_per_word;
	struct spi_delay delay;
	struct spi_delay cs_change_delay;
	struct spi_delay word_delay;
	u32 speed_hz;
	u32 effective_speed_hz;
	unsigned int ptp_sts_word_pre;
	unsigned int ptp_sts_word_post;
	struct ptp_system_timestamp *ptp_sts;
	bool timestamped;
	struct list_head transfer_list;
	u16 error;
};

struct spi_mem;

struct spi_mem_op;

struct spi_mem_dirmap_desc;

struct spi_controller_mem_ops {
	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
	const char * (*get_name)(struct spi_mem *);
	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
	int (*poll_status)(struct spi_mem *, const struct spi_mem_op *, u16, u16, long unsigned int, long unsigned int, long unsigned int);
};

struct sc16is7xx_devtype {
	char name[10];
	int nr_gpio;
	int nr_uart;
};

struct sc16is7xx_one_config {
	unsigned int flags;
	u8 ier_clear;
};

struct sc16is7xx_one {
	struct uart_port port;
	u8 line;
	struct kthread_work tx_work;
	struct kthread_work reg_work;
	struct sc16is7xx_one_config config;
	bool irda_mode;
};

struct sc16is7xx_port {
	const struct sc16is7xx_devtype *devtype;
	struct regmap *regmap;
	struct clk *clk;
	struct gpio_chip gpio;
	unsigned char buf[64];
	struct kthread_worker kworker;
	struct task_struct *kworker_task;
	struct mutex efr_lock;
	struct sc16is7xx_one p[0];
};

struct cdns_uart {
	struct uart_port *port;
	struct clk *uartclk;
	struct clk *pclk;
	struct uart_driver *cdns_uart_driver;
	unsigned int baud;
	struct notifier_block clk_rate_change_nb;
	u32 quirks;
	bool cts_override;
};

struct cdns_platform_data {
	u32 quirks;
};

enum lpuart_type {
	VF610_LPUART = 0,
	LS1021A_LPUART = 1,
	LS1028A_LPUART = 2,
	IMX7ULP_LPUART = 3,
	IMX8QXP_LPUART = 4,
	IMXRT1050_LPUART = 5,
};

struct lpuart_port {
	struct uart_port port;
	enum lpuart_type devtype;
	struct clk *ipg_clk;
	struct clk *baud_clk;
	unsigned int txfifo_size;
	unsigned int rxfifo_size;
	u8 rx_watermark;
	bool lpuart_dma_tx_use;
	bool lpuart_dma_rx_use;
	struct dma_chan *dma_tx_chan;
	struct dma_chan *dma_rx_chan;
	struct dma_async_tx_descriptor *dma_tx_desc;
	struct dma_async_tx_descriptor *dma_rx_desc;
	dma_cookie_t dma_tx_cookie;
	dma_cookie_t dma_rx_cookie;
	unsigned int dma_tx_bytes;
	unsigned int dma_rx_bytes;
	bool dma_tx_in_progress;
	unsigned int dma_rx_timeout;
	struct timer_list lpuart_timer;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	struct circ_buf rx_ring;
	int rx_dma_rng_buf_len;
	unsigned int dma_tx_nents;
	wait_queue_head_t dma_wait;
};

struct lpuart_soc_data {
	enum lpuart_type devtype;
	char iotype;
	u8 reg_off;
	u8 rx_watermark;
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

struct mctrl_gpios {
	struct uart_port *port;
	struct gpio_desc *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	long unsigned int last_time;
	long int last_delta;
	long int last_delta2;
};

enum chacha_constants {
	CHACHA_CONSTANT_EXPA = 1634760805,
	CHACHA_CONSTANT_ND_3 = 857760878,
	CHACHA_CONSTANT_2_BY = 2036477234,
	CHACHA_CONSTANT_TE_K = 1797285236,
};

enum {
	CRNG_EMPTY = 0,
	CRNG_EARLY = 1,
	CRNG_READY = 2,
};

enum {
	CRNG_RESEED_START_INTERVAL = 100,
	CRNG_RESEED_INTERVAL = 6000,
};

struct crng {
	u8 key[32];
	long unsigned int generation;
	local_lock_t lock;
};

struct batch_u64 {
	u64 entropy[12];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u32 {
	u32 entropy[24];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

enum {
	POOL_BITS = 256,
	POOL_READY_BITS = 256,
	POOL_EARLY_BITS = 128,
};

struct fast_pool {
	long unsigned int pool[4];
	long unsigned int last;
	unsigned int count;
	struct timer_list mix;
};

enum {
	MIX_INFLIGHT = 2147483648,
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct ports_driver_data {
	struct class *class;
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	unsigned int next_vtermno;
	struct list_head consoles;
};

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct port {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
};

enum io_pgtable_fmt {
	ARM_32_LPAE_S1 = 0,
	ARM_32_LPAE_S2 = 1,
	ARM_64_LPAE_S1 = 2,
	ARM_64_LPAE_S2 = 3,
	ARM_V7S = 4,
	ARM_MALI_LPAE = 5,
	AMD_IOMMU_V1 = 6,
	APPLE_DART = 7,
	IO_PGTABLE_NUM_FMTS = 8,
};

struct iommu_flush_ops {
	void (*tlb_flush_all)(void *);
	void (*tlb_flush_walk)(long unsigned int, size_t, size_t, void *);
	void (*tlb_add_page)(struct iommu_iotlb_gather *, long unsigned int, size_t, void *);
};

struct io_pgtable_cfg {
	long unsigned int quirks;
	long unsigned int pgsize_bitmap;
	unsigned int ias;
	unsigned int oas;
	bool coherent_walk;
	const struct iommu_flush_ops *tlb;
	struct device *iommu_dev;
	union {
		struct {
			u64 ttbr;
			struct {
				u32 ips: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 tsz: 6;
			} tcr;
			u64 mair;
		} arm_lpae_s1_cfg;
		struct {
			u64 vttbr;
			struct {
				u32 ps: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 sl: 2;
				u32 tsz: 6;
			} vtcr;
		} arm_lpae_s2_cfg;
		struct {
			u32 ttbr;
			u32 tcr;
			u32 nmrr;
			u32 prrr;
		} arm_v7s_cfg;
		struct {
			u64 transtab;
			u64 memattr;
		} arm_mali_lpae_cfg;
		struct {
			u64 ttbr[4];
			u32 n_ttbrs;
		} apple_dart_cfg;
	};
};

struct io_pgtable_ops {
	int (*map)(struct io_pgtable_ops *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	int (*map_pages)(struct io_pgtable_ops *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap)(struct io_pgtable_ops *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	size_t (*unmap_pages)(struct io_pgtable_ops *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *, long unsigned int);
};

enum arm_smmu_s2cr_privcfg {
	S2CR_PRIVCFG_DEFAULT = 0,
	S2CR_PRIVCFG_DIPAN = 1,
	S2CR_PRIVCFG_UNPRIV = 2,
	S2CR_PRIVCFG_PRIV = 3,
};

enum arm_smmu_s2cr_type {
	S2CR_TYPE_TRANS = 0,
	S2CR_TYPE_BYPASS = 1,
	S2CR_TYPE_FAULT = 2,
};

enum arm_smmu_cbar_type {
	CBAR_TYPE_S2_TRANS = 0,
	CBAR_TYPE_S1_TRANS_S2_BYPASS = 1,
	CBAR_TYPE_S1_TRANS_S2_FAULT = 2,
	CBAR_TYPE_S1_TRANS_S2_TRANS = 3,
};

enum arm_smmu_arch_version {
	ARM_SMMU_V1 = 0,
	ARM_SMMU_V1_64K = 1,
	ARM_SMMU_V2 = 2,
};

enum arm_smmu_implementation {
	GENERIC_SMMU = 0,
	ARM_MMU500 = 1,
	CAVIUM_SMMUV2 = 2,
	QCOM_SMMUV2 = 3,
};

struct arm_smmu_s2cr {
	struct iommu_group *group;
	int count;
	enum arm_smmu_s2cr_type type;
	enum arm_smmu_s2cr_privcfg privcfg;
	u8 cbndx;
};

struct arm_smmu_smr {
	u16 mask;
	u16 id;
	bool valid;
	bool pinned;
};

struct arm_smmu_impl;

struct arm_smmu_cb;

struct arm_smmu_device {
	struct device *dev;
	void *base;
	unsigned int numpage;
	unsigned int pgshift;
	u32 features;
	enum arm_smmu_arch_version version;
	enum arm_smmu_implementation model;
	const struct arm_smmu_impl *impl;
	u32 num_context_banks;
	u32 num_s2_context_banks;
	long unsigned int context_map[2];
	struct arm_smmu_cb *cbs;
	atomic_t irptndx;
	u32 num_mapping_groups;
	u16 streamid_mask;
	u16 smr_mask_mask;
	struct arm_smmu_smr *smrs;
	struct arm_smmu_s2cr *s2crs;
	struct mutex stream_map_mutex;
	long unsigned int va_size;
	long unsigned int ipa_size;
	long unsigned int pa_size;
	long unsigned int pgsize_bitmap;
	u32 num_global_irqs;
	u32 num_context_irqs;
	unsigned int *irqs;
	struct clk_bulk_data *clks;
	int num_clks;
	spinlock_t global_sync_lock;
	struct iommu_device iommu;
};

struct arm_smmu_domain;

struct arm_smmu_impl {
	u32 (*read_reg)(struct arm_smmu_device *, int, int);
	void (*write_reg)(struct arm_smmu_device *, int, int, u32);
	u64 (*read_reg64)(struct arm_smmu_device *, int, int);
	void (*write_reg64)(struct arm_smmu_device *, int, int, u64);
	int (*cfg_probe)(struct arm_smmu_device *);
	int (*reset)(struct arm_smmu_device *);
	int (*init_context)(struct arm_smmu_domain *, struct io_pgtable_cfg *, struct device *);
	void (*tlb_sync)(struct arm_smmu_device *, int, int, int);
	int (*def_domain_type)(struct device *);
	irqreturn_t (*global_fault)(int, void *);
	irqreturn_t (*context_fault)(int, void *);
	int (*alloc_context_bank)(struct arm_smmu_domain *, struct arm_smmu_device *, struct device *, int);
	void (*write_s2cr)(struct arm_smmu_device *, int);
	void (*write_sctlr)(struct arm_smmu_device *, int, u32);
	void (*probe_finalize)(struct arm_smmu_device *, struct device *);
};

struct arm_smmu_cfg;

struct arm_smmu_cb {
	u64 ttbr[2];
	u32 tcr[2];
	u32 mair[2];
	struct arm_smmu_cfg *cfg;
};

enum arm_smmu_context_fmt {
	ARM_SMMU_CTX_FMT_NONE = 0,
	ARM_SMMU_CTX_FMT_AARCH64 = 1,
	ARM_SMMU_CTX_FMT_AARCH32_L = 2,
	ARM_SMMU_CTX_FMT_AARCH32_S = 3,
};

struct arm_smmu_cfg {
	u8 cbndx;
	u8 irptndx;
	union {
		u16 asid;
		u16 vmid;
	};
	enum arm_smmu_cbar_type cbar;
	enum arm_smmu_context_fmt fmt;
	bool flush_walk_prefer_tlbiasid;
};

enum arm_smmu_domain_stage {
	ARM_SMMU_DOMAIN_S1 = 0,
	ARM_SMMU_DOMAIN_S2 = 1,
	ARM_SMMU_DOMAIN_NESTED = 2,
	ARM_SMMU_DOMAIN_BYPASS = 3,
};

struct arm_smmu_domain {
	struct arm_smmu_device *smmu;
	struct io_pgtable_ops *pgtbl_ops;
	long unsigned int pgtbl_quirks;
	const struct iommu_flush_ops *flush_ops;
	struct arm_smmu_cfg cfg;
	enum arm_smmu_domain_stage stage;
	struct mutex init_mutex;
	spinlock_t cb_lock;
	struct iommu_domain domain;
};

struct arm_smmu_master_cfg {
	struct arm_smmu_device *smmu;
	s16 smendx[0];
};

struct arm_smmu_match_data {
	enum arm_smmu_arch_version version;
	enum arm_smmu_implementation model;
};

struct cavium_smmu {
	struct arm_smmu_device smmu;
	u32 id_base;
};

struct icc_node;

struct icc_node_data {
	struct icc_node *node;
	u32 tag;
};

struct icc_provider;

struct icc_node {
	int id;
	const char *name;
	struct icc_node **links;
	size_t num_links;
	struct icc_provider *provider;
	struct list_head node_list;
	struct list_head search_list;
	struct icc_node *reverse;
	u8 is_traversed: 1;
	struct hlist_head req_list;
	u32 avg_bw;
	u32 peak_bw;
	u32 init_avg;
	u32 init_peak;
	void *data;
};

struct icc_provider {
	struct list_head provider_list;
	struct list_head nodes;
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	void (*pre_aggregate)(struct icc_node *);
	int (*get_bw)(struct icc_node *, u32 *, u32 *);
	struct icc_node * (*xlate)(struct of_phandle_args *, void *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
	struct device *dev;
	int users;
	bool inter_set;
	void *data;
};

struct tegra_mc_timing {
	long unsigned int rate;
	u32 *emem_data;
};

struct tegra_mc_client {
	unsigned int id;
	const char *name;
	union {
		unsigned int swgroup;
		unsigned int sid;
	};
	unsigned int fifo_size;
	struct {
		struct {
			unsigned int reg;
			unsigned int bit;
		} smmu;
		struct {
			unsigned int reg;
			unsigned int shift;
			unsigned int mask;
			unsigned int def;
		} la;
		struct {
			unsigned int override;
			unsigned int security;
		} sid;
	} regs;
};

struct tegra_smmu_swgroup {
	const char *name;
	unsigned int swgroup;
	unsigned int reg;
};

struct tegra_smmu_group_soc {
	const char *name;
	const unsigned int *swgroups;
	unsigned int num_swgroups;
};

struct tegra_smmu_soc {
	const struct tegra_mc_client *clients;
	unsigned int num_clients;
	const struct tegra_smmu_swgroup *swgroups;
	unsigned int num_swgroups;
	const struct tegra_smmu_group_soc *groups;
	unsigned int num_groups;
	bool supports_round_robin_arbitration;
	bool supports_request_limit;
	unsigned int num_tlb_lines;
	unsigned int num_asids;
};

struct tegra_mc_reset {
	const char *name;
	long unsigned int id;
	unsigned int control;
	unsigned int status;
	unsigned int reset;
	unsigned int bit;
};

struct tegra_mc;

struct tegra_mc_reset_ops {
	int (*hotreset_assert)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*hotreset_deassert)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*block_dma)(struct tegra_mc *, const struct tegra_mc_reset *);
	bool (*dma_idling)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*unblock_dma)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*reset_status)(struct tegra_mc *, const struct tegra_mc_reset *);
};

struct tegra_smmu;

struct gart_device;

struct tegra_mc_soc;

struct tegra_mc {
	struct device *dev;
	struct tegra_smmu *smmu;
	struct gart_device *gart;
	void *regs;
	struct clk *clk;
	int irq;
	const struct tegra_mc_soc *soc;
	long unsigned int tick;
	struct tegra_mc_timing *timings;
	unsigned int num_timings;
	struct reset_controller_dev reset;
	struct icc_provider provider;
	spinlock_t lock;
	struct {
		struct dentry *root;
	} debugfs;
};

struct tegra_mc_icc_ops {
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
};

struct tegra_mc_ops {
	int (*probe)(struct tegra_mc *);
	void (*remove)(struct tegra_mc *);
	int (*suspend)(struct tegra_mc *);
	int (*resume)(struct tegra_mc *);
	irqreturn_t (*handle_irq)(int, void *);
	int (*probe_device)(struct tegra_mc *, struct device *);
};

struct tegra_mc_soc {
	const struct tegra_mc_client *clients;
	unsigned int num_clients;
	const long unsigned int *emem_regs;
	unsigned int num_emem_regs;
	unsigned int num_address_bits;
	unsigned int atom_size;
	u8 client_id_mask;
	const struct tegra_smmu_soc *smmu;
	u32 intmask;
	const struct tegra_mc_reset_ops *reset_ops;
	const struct tegra_mc_reset *resets;
	unsigned int num_resets;
	const struct tegra_mc_icc_ops *icc_ops;
	const struct tegra_mc_ops *ops;
};

struct nvidia_smmu {
	struct arm_smmu_device smmu;
	void *bases[2];
	unsigned int num_instances;
	struct tegra_mc *mc;
};

enum iommu_fault_type {
	IOMMU_FAULT_DMA_UNRECOV = 1,
	IOMMU_FAULT_PAGE_REQ = 2,
};

enum iommu_fault_reason {
	IOMMU_FAULT_REASON_UNKNOWN = 0,
	IOMMU_FAULT_REASON_PASID_FETCH = 1,
	IOMMU_FAULT_REASON_BAD_PASID_ENTRY = 2,
	IOMMU_FAULT_REASON_PASID_INVALID = 3,
	IOMMU_FAULT_REASON_WALK_EABT = 4,
	IOMMU_FAULT_REASON_PTE_FETCH = 5,
	IOMMU_FAULT_REASON_PERMISSION = 6,
	IOMMU_FAULT_REASON_ACCESS = 7,
	IOMMU_FAULT_REASON_OOR_ADDRESS = 8,
};

enum iommu_page_response_code {
	IOMMU_PAGE_RESP_SUCCESS = 0,
	IOMMU_PAGE_RESP_INVALID = 1,
	IOMMU_PAGE_RESP_FAILURE = 2,
};

enum pri_resp {
	PRI_RESP_DENY = 0,
	PRI_RESP_FAIL = 1,
	PRI_RESP_SUCC = 2,
};

struct arm_smmu_cmdq_ent {
	u8 opcode;
	bool substream_valid;
	union {
		struct {
			u32 sid;
		} prefetch;
		struct {
			u32 sid;
			u32 ssid;
			union {
				bool leaf;
				u8 span;
			};
		} cfgi;
		struct {
			u8 num;
			u8 scale;
			u16 asid;
			u16 vmid;
			bool leaf;
			u8 ttl;
			u8 tg;
			u64 addr;
		} tlbi;
		struct {
			u32 sid;
			u32 ssid;
			u64 addr;
			u8 size;
			bool global;
		} atc;
		struct {
			u32 sid;
			u32 ssid;
			u16 grpid;
			enum pri_resp resp;
		} pri;
		struct {
			u32 sid;
			u16 stag;
			u8 resp;
		} resume;
		struct {
			u64 msiaddr;
		} sync;
	};
};

struct arm_smmu_ll_queue {
	union {
		u64 val;
		struct {
			u32 prod;
			u32 cons;
		};
		struct {
			atomic_t prod;
			atomic_t cons;
		} atomic;
		u8 __pad[64];
	};
	u32 max_n_shift;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_queue {
	struct arm_smmu_ll_queue llq;
	int irq;
	__le64 *base;
	dma_addr_t base_dma;
	u64 q_base;
	size_t ent_dwords;
	u32 *prod_reg;
	u32 *cons_reg;
	long: 64;
};

struct arm_smmu_queue_poll {
	ktime_t timeout;
	unsigned int delay;
	unsigned int spin_cnt;
	bool wfe;
};

struct arm_smmu_cmdq {
	struct arm_smmu_queue q;
	atomic_long_t *valid_map;
	atomic_t owner_prod;
	atomic_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_cmdq_batch {
	u64 cmds[128];
	int num;
};

struct iopf_queue;

struct arm_smmu_evtq {
	struct arm_smmu_queue q;
	struct iopf_queue *iopf;
	u32 max_stalls;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_priq {
	struct arm_smmu_queue q;
};

struct arm_smmu_strtab_l1_desc {
	u8 span;
	__le64 *l2ptr;
	dma_addr_t l2ptr_dma;
};

struct arm_smmu_ctx_desc {
	u16 asid;
	u64 ttbr;
	u64 tcr;
	u64 mair;
	refcount_t refs;
	struct mm_struct *mm;
};

struct arm_smmu_l1_ctx_desc {
	__le64 *l2ptr;
	dma_addr_t l2ptr_dma;
};

struct arm_smmu_ctx_desc_cfg {
	__le64 *cdtab;
	dma_addr_t cdtab_dma;
	struct arm_smmu_l1_ctx_desc *l1_desc;
	unsigned int num_l1_ents;
};

struct arm_smmu_s1_cfg {
	struct arm_smmu_ctx_desc_cfg cdcfg;
	struct arm_smmu_ctx_desc cd;
	u8 s1fmt;
	u8 s1cdmax;
};

struct arm_smmu_s2_cfg {
	u16 vmid;
	u64 vttbr;
	u64 vtcr;
};

struct arm_smmu_strtab_cfg {
	__le64 *strtab;
	dma_addr_t strtab_dma;
	struct arm_smmu_strtab_l1_desc *l1_desc;
	unsigned int num_l1_ents;
	u64 strtab_base;
	u32 strtab_base_cfg;
};

struct arm_smmu_device___2 {
	struct device *dev;
	void *base;
	void *page1;
	u32 features;
	u32 options;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct arm_smmu_cmdq cmdq;
	struct arm_smmu_evtq evtq;
	struct arm_smmu_priq priq;
	int gerr_irq;
	int combined_irq;
	long unsigned int ias;
	long unsigned int oas;
	long unsigned int pgsize_bitmap;
	unsigned int asid_bits;
	unsigned int vmid_bits;
	long unsigned int vmid_map[1024];
	unsigned int ssid_bits;
	unsigned int sid_bits;
	struct arm_smmu_strtab_cfg strtab_cfg;
	struct iommu_device iommu;
	struct rb_root streams;
	struct mutex streams_mutex;
	long: 64;
	long: 64;
};

struct arm_smmu_master;

struct arm_smmu_stream {
	u32 id;
	struct arm_smmu_master *master;
	struct rb_node node;
};

struct arm_smmu_domain___2;

struct arm_smmu_master {
	struct arm_smmu_device___2 *smmu;
	struct device *dev;
	struct arm_smmu_domain___2 *domain;
	struct list_head domain_head;
	struct arm_smmu_stream *streams;
	unsigned int num_streams;
	bool ats_enabled;
	bool stall_enabled;
	bool sva_enabled;
	bool iopf_enabled;
	struct list_head bonds;
	unsigned int ssid_bits;
};

struct arm_smmu_domain___2 {
	struct arm_smmu_device___2 *smmu;
	struct mutex init_mutex;
	struct io_pgtable_ops *pgtbl_ops;
	bool stall_enabled;
	atomic_t nr_ats_masters;
	enum arm_smmu_domain_stage stage;
	union {
		struct arm_smmu_s1_cfg s1_cfg;
		struct arm_smmu_s2_cfg s2_cfg;
	};
	struct iommu_domain domain;
	struct list_head devices;
	spinlock_t devices_lock;
	struct list_head mmu_notifiers;
};

enum arm_smmu_msi_index {
	EVTQ_MSI_INDEX = 0,
	GERROR_MSI_INDEX = 1,
	PRIQ_MSI_INDEX = 2,
	ARM_SMMU_MAX_MSIS = 3,
};

struct arm_smmu_option_prop {
	u32 opt;
	const char *prop;
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct mutex mutex;
	struct blocking_notifier_head notifier;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *domain;
	struct list_head entry;
};

typedef unsigned int ioasid_t;

enum iommu_inv_granularity {
	IOMMU_INV_GRANU_DOMAIN = 0,
	IOMMU_INV_GRANU_PASID = 1,
	IOMMU_INV_GRANU_ADDR = 2,
	IOMMU_INV_GRANU_NR = 3,
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct __group_domain_type {
	struct device *dev;
	unsigned int type;
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	u32 driver;
};

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_detach_device_from_domain)(void *, struct device *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

enum iommu_dma_cookie_type {
	IOMMU_DMA_IOVA_COOKIE = 0,
	IOMMU_DMA_MSI_COOKIE = 1,
};

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_magazine;

struct iova_cpu_rcache;

struct iova_rcache {
	spinlock_t lock;
	long unsigned int depot_size;
	struct iova_magazine *depot[32];
	struct iova_cpu_rcache *cpu_rcaches;
};

struct iova_domain;

typedef void (*iova_flush_cb)(struct iova_domain *);

typedef void (*iova_entry_dtor)(long unsigned int);

struct iova_fq;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova_fq *fq;
	atomic64_t fq_flush_start_cnt;
	atomic64_t fq_flush_finish_cnt;
	struct iova anchor;
	struct iova_rcache rcaches[6];
	iova_flush_cb flush_cb;
	iova_entry_dtor entry_dtor;
	struct timer_list fq_timer;
	atomic_t fq_timer_on;
	struct hlist_node cpuhp_dead;
};

struct iommu_dma_cookie {
	enum iommu_dma_cookie_type type;
	union {
		struct iova_domain iovad;
		dma_addr_t msi_iova;
	};
	struct list_head msi_page_list;
	struct iommu_domain *fq_domain;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	long unsigned int data;
	u64 counter;
};

struct iova_fq {
	struct iova_fq_entry entries[256];
	unsigned int head;
	unsigned int tail;
	spinlock_t lock;
};

struct iommu_dma_msi_page {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
};

struct io_pgtable {
	enum io_pgtable_fmt fmt;
	void *cookie;
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops ops;
};

struct io_pgtable_init_fns {
	struct io_pgtable * (*alloc)(struct io_pgtable_cfg *, void *);
	void (*free)(struct io_pgtable *);
};

struct arm_lpae_io_pgtable {
	struct io_pgtable iop;
	int pgd_bits;
	int start_level;
	int bits_per_level;
	void *pgd;
};

typedef u64 arm_lpae_iopte;

struct iova_magazine {
	long unsigned int size;
	long unsigned int pfns[128];
};

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct of_pci_iommu_alias_info {
	struct device *dev;
	struct device_node *np;
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	unsigned int (*set_decode)(struct pci_dev *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct master;

struct component {
	struct list_head node;
	struct master *master;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct master {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *parent;
	struct component_match *match;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

typedef void *acpi_handle;

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

struct devres_node {
	struct list_head entry;
	dr_release_t release;
	const char *name;
	size_t size;
};

struct devres {
	struct devres_node node;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

typedef void * (*devcon_match_fn_t)(struct fwnode_handle *, const char *, void *);

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct mii_bus;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
	PHY_CABLETEST = 6,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_REVRMII = 8,
	PHY_INTERFACE_MODE_RGMII = 9,
	PHY_INTERFACE_MODE_RGMII_ID = 10,
	PHY_INTERFACE_MODE_RGMII_RXID = 11,
	PHY_INTERFACE_MODE_RGMII_TXID = 12,
	PHY_INTERFACE_MODE_RTBI = 13,
	PHY_INTERFACE_MODE_SMII = 14,
	PHY_INTERFACE_MODE_XGMII = 15,
	PHY_INTERFACE_MODE_XLGMII = 16,
	PHY_INTERFACE_MODE_MOCA = 17,
	PHY_INTERFACE_MODE_QSGMII = 18,
	PHY_INTERFACE_MODE_TRGMII = 19,
	PHY_INTERFACE_MODE_100BASEX = 20,
	PHY_INTERFACE_MODE_1000BASEX = 21,
	PHY_INTERFACE_MODE_2500BASEX = 22,
	PHY_INTERFACE_MODE_5GBASER = 23,
	PHY_INTERFACE_MODE_RXAUI = 24,
	PHY_INTERFACE_MODE_XAUI = 25,
	PHY_INTERFACE_MODE_10GBASER = 26,
	PHY_INTERFACE_MODE_25GBASER = 27,
	PHY_INTERFACE_MODE_USXGMII = 28,
	PHY_INTERFACE_MODE_10GKR = 29,
	PHY_INTERFACE_MODE_2500SGMII = 30,
	PHY_INTERFACE_MODE_MAX = 31,
} phy_interface_t;

struct phy_driver;

struct phy_package_shared;

struct phylink;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int is_on_sfp_module: 1;
	unsigned int mac_managed_pm: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	unsigned int irq_suspended: 1;
	unsigned int irq_rerun: 1;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	u32 eee_broken_modes;
	struct list_head leds;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	u8 mdix;
	u8 mdix_ctrl;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 92,
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 reserved1[1];
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		u32 __link_ext_substate;
	};
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
	u32 lanes;
};

struct kernel_ethtool_coalesce {
	u8 use_cqe_mode_tx;
	u8 use_cqe_mode_rx;
};

struct ethtool_eth_mac_stats {
	u64 FramesTransmittedOK;
	u64 SingleCollisionFrames;
	u64 MultipleCollisionFrames;
	u64 FramesReceivedOK;
	u64 FrameCheckSequenceErrors;
	u64 AlignmentErrors;
	u64 OctetsTransmittedOK;
	u64 FramesWithDeferredXmissions;
	u64 LateCollisions;
	u64 FramesAbortedDueToXSColls;
	u64 FramesLostDueToIntMACXmitError;
	u64 CarrierSenseErrors;
	u64 OctetsReceivedOK;
	u64 FramesLostDueToIntMACRcvError;
	u64 MulticastFramesXmittedOK;
	u64 BroadcastFramesXmittedOK;
	u64 FramesWithExcessiveDeferral;
	u64 MulticastFramesReceivedOK;
	u64 BroadcastFramesReceivedOK;
	u64 InRangeLengthErrors;
	u64 OutOfRangeLengthField;
	u64 FrameTooLongErrors;
};

struct ethtool_eth_phy_stats {
	u64 SymbolErrorDuringCarrier;
};

struct ethtool_eth_ctrl_stats {
	u64 MACControlFramesTransmitted;
	u64 MACControlFramesReceived;
	u64 UnsupportedOpcodesReceived;
};

struct ethtool_pause_stats {
	u64 tx_pause_frames;
	u64 rx_pause_frames;
};

struct ethtool_fec_stat {
	u64 total;
	u64 lanes[8];
};

struct ethtool_fec_stats {
	struct ethtool_fec_stat corrected_blocks;
	struct ethtool_fec_stat uncorrectable_blocks;
	struct ethtool_fec_stat corrected_bits;
};

struct ethtool_rmon_hist_range {
	u16 low;
	u16 high;
};

struct ethtool_rmon_stats {
	u64 undersize_pkts;
	u64 oversize_pkts;
	u64 fragments;
	u64 jabbers;
	u64 hist[10];
	u64 hist_tx[10];
};

struct ethtool_module_eeprom {
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
	u8 *data;
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	enum {
		MDIOBUS_NO_CAP = 0,
		MDIOBUS_C22 = 1,
		MDIOBUS_C45 = 2,
		MDIOBUS_C22_C45 = 3,
	} probe_capabilities;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*detach)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
	int (*led_brightness_set)(struct phy_device *, u8, enum led_brightness);
	int (*led_blink_set)(struct phy_device *, u8, long unsigned int *, long unsigned int *);
};

struct cache_type_info {
	const char *size_prop;
	const char *line_size_props[2];
	const char *nr_sets_prop;
};

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct swnode {
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	int id;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
	unsigned int managed: 1;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

typedef int (*pm_callback_t)(struct device *);

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_PREPARED = 2,
	PCE_STATUS_ENABLED = 3,
	PCE_STATUS_ERROR = 4,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
	bool enabled_when_prepared;
};

struct firmware_fallback_config {
	unsigned int force_sysfs_fallback;
	unsigned int ignore_sysfs_fallback;
	int old_timeout;
	int loading_timeout;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	bool is_paged_buf;
	struct page **pages;
	int nr_pages;
	int page_array_size;
	bool need_uevent;
	struct list_head pending_list;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct fw_sysfs {
	bool nowait;
	struct device dev;
	struct fw_priv *fw_priv;
	struct firmware *fw;
};

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

struct regmap_async {
	struct list_head list;
	struct regmap *map;
	void *work_buf;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t reg_downshift;
	size_t val_bytes;
	void (*format_write)(struct regmap *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct hwspinlock;

struct regcache_ops;

struct regmap {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
		struct {
			raw_spinlock_t raw_spinlock;
			long unsigned int raw_spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	unsigned int reg_base;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap *);
	int (*exit)(struct regmap *);
	void (*debugfs_init)(struct regmap *);
	int (*read)(struct regmap *, unsigned int, unsigned int *);
	int (*write)(struct regmap *, unsigned int, unsigned int);
	int (*sync)(struct regmap *, unsigned int, unsigned int);
	int (*drop)(struct regmap *, unsigned int, unsigned int);
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_field {
	struct regmap *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);

struct regcache_rbtree_node {
	void *block;
	long int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_debugfs_node {
	struct regmap *map;
	struct list_head link;
};

struct regmap_async_spi {
	struct regmap_async core;
	struct spi_message m;
	struct spi_transfer t[2];
};

struct regmap_mmio_context {
	void *regs;
	unsigned int val_bytes;
	bool relaxed_mmio;
	bool attached_clk;
	struct clk *clk;
	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
};

struct soc_device {
	struct device dev;
	struct soc_device_attribute *attr;
	int soc_dev_num;
};

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	const struct attribute_group **msi_irq_groups;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

struct trace_event_raw_devres {
	struct trace_entry ent;
	u32 __data_loc_devname;
	struct device *dev;
	const char *op;
	void *node;
	const char *name;
	size_t size;
	char __data[0];
};

struct trace_event_data_offsets_devres {
	u32 devname;
};

typedef void (*btf_trace_devres_log)(void *, struct device *, const char *, void *, const char *, size_t);

struct brd_device {
	int brd_number;
	struct gendisk *brd_disk;
	struct list_head brd_list;
	spinlock_t brd_lock;
	struct xarray brd_pages;
	u64 brd_nr_pages;
};

typedef unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
	Lo_deleting = 3,
};

struct loop_func_table;

struct loop_device {
	int lo_number;
	atomic_t lo_refcnt;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	char lo_file_name[64];
	char lo_crypt_name[64];
	char lo_encrypt_key[32];
	int lo_encrypt_key_size;
	struct loop_func_table *lo_encryption;
	__u32 lo_init[2];
	kuid_t lo_key_owner;
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct file *lo_backing_file;
	struct block_device *lo_device;
	void *key_data;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	spinlock_t lo_work_lock;
	struct workqueue_struct *workqueue;
	struct work_struct rootcg_work;
	struct list_head rootcg_cmd_list;
	struct list_head idle_worker_list;
	struct rb_root worker_tree;
	struct timer_list timer;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
	struct mutex lo_mutex;
	bool idr_visible;
};

struct loop_func_table {
	int number;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	int (*init)(struct loop_device *, const struct loop_info64 *);
	int (*release)(struct loop_device *);
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct module *owner;
};

struct loop_cmd {
	struct list_head list_entry;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *blkcg_css;
	struct cgroup_subsys_state *memcg_css;
};

struct loop_worker {
	struct rb_node rb_node;
	struct work_struct work;
	struct list_head cmd_list;
	struct list_head idle_list;
	struct loop_device *lo;
	struct cgroup_subsys_state *blkcg_css;
	long unsigned int last_ran_at;
};

struct virtio_blk_geometry {
	__virtio16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_config {
	__virtio64 capacity;
	__virtio32 size_max;
	__virtio32 seg_max;
	struct virtio_blk_geometry geometry;
	__virtio32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__virtio16 min_io_size;
	__virtio32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__virtio16 num_queues;
	__virtio32 max_discard_sectors;
	__virtio32 max_discard_seg;
	__virtio32 discard_sector_alignment;
	__virtio32 max_write_zeroes_sectors;
	__virtio32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
} __attribute__((packed));

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	refcount_t refs;
	unsigned int sg_elems;
	int index;
	int num_vqs;
	struct virtio_blk_vq *vqs;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	u8 status;
	struct sg_table sg_table;
	struct scatterlist sg[0];
};

typedef unsigned int RING_IDX;

typedef uint16_t blkif_vdev_t;

typedef uint64_t blkif_sector_t;

struct blkif_request_segment {
	grant_ref_t gref;
	uint8_t first_sect;
	uint8_t last_sect;
};

struct blkif_request_rw {
	uint8_t nr_segments;
	blkif_vdev_t handle;
	uint32_t _pad1;
	uint64_t id;
	blkif_sector_t sector_number;
	struct blkif_request_segment seg[11];
} __attribute__((packed));

struct blkif_request_discard {
	uint8_t flag;
	blkif_vdev_t _pad1;
	uint32_t _pad2;
	uint64_t id;
	blkif_sector_t sector_number;
	uint64_t nr_sectors;
	uint8_t _pad3;
} __attribute__((packed));

struct blkif_request_other {
	uint8_t _pad1;
	blkif_vdev_t _pad2;
	uint32_t _pad3;
	uint64_t id;
} __attribute__((packed));

struct blkif_request_indirect {
	uint8_t indirect_op;
	uint16_t nr_segments;
	uint32_t _pad1;
	uint64_t id;
	blkif_sector_t sector_number;
	blkif_vdev_t handle;
	uint16_t _pad2;
	grant_ref_t indirect_grefs[8];
	uint32_t _pad3;
} __attribute__((packed));

struct blkif_request {
	uint8_t operation;
	union {
		struct blkif_request_rw rw;
		struct blkif_request_discard discard;
		struct blkif_request_other other;
		struct blkif_request_indirect indirect;
	} u;
};

struct blkif_response {
	uint64_t id;
	uint8_t operation;
	int16_t status;
};

union blkif_sring_entry {
	struct blkif_request req;
	struct blkif_response rsp;
};

struct blkif_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union blkif_sring_entry ring[1];
};

struct blkif_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct blkif_sring *sring;
};

enum blkif_state {
	BLKIF_STATE_DISCONNECTED = 0,
	BLKIF_STATE_CONNECTED = 1,
	BLKIF_STATE_SUSPENDED = 2,
	BLKIF_STATE_ERROR = 3,
};

struct grant {
	grant_ref_t gref;
	struct page *page;
	struct list_head node;
};

enum blk_req_status {
	REQ_PROCESSING = 0,
	REQ_WAITING = 1,
	REQ_DONE = 2,
	REQ_ERROR = 3,
	REQ_EOPNOTSUPP = 4,
};

struct blk_shadow {
	struct blkif_request req;
	struct request *request;
	struct grant **grants_used;
	struct grant **indirect_grants;
	struct scatterlist *sg;
	unsigned int num_sg;
	enum blk_req_status status;
	long unsigned int associated_id;
};

struct blkif_req {
	blk_status_t error;
};

struct blkfront_info;

struct blkfront_ring_info {
	spinlock_t ring_lock;
	struct blkif_front_ring ring;
	unsigned int ring_ref[16];
	unsigned int evtchn;
	unsigned int irq;
	struct work_struct work;
	struct gnttab_free_callback callback;
	struct list_head indirect_pages;
	struct list_head grants;
	unsigned int persistent_gnts_c;
	long unsigned int shadow_free;
	struct blkfront_info *dev_info;
	struct blk_shadow shadow[0];
};

struct blkfront_info {
	struct mutex mutex;
	struct xenbus_device *xbdev;
	struct gendisk *gd;
	u16 sector_size;
	unsigned int physical_sector_size;
	int vdevice;
	blkif_vdev_t handle;
	enum blkif_state connected;
	unsigned int nr_ring_pages;
	struct request_queue *rq;
	unsigned int feature_flush: 1;
	unsigned int feature_fua: 1;
	unsigned int feature_discard: 1;
	unsigned int feature_secdiscard: 1;
	unsigned int feature_persistent_parm: 1;
	unsigned int feature_persistent: 1;
	unsigned int bounce: 1;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int max_indirect_segments;
	int is_ready;
	struct blk_mq_tag_set tag_set;
	struct blkfront_ring_info *rinfo;
	unsigned int nr_rings;
	unsigned int rinfo_size;
	struct list_head requests;
	struct bio_list bio_list;
	struct list_head info_list;
};

struct setup_rw_req {
	unsigned int grant_idx;
	struct blkif_request_segment *segments;
	struct blkfront_ring_info *rinfo;
	struct blkif_request *ring_req;
	grant_ref_t gref_head;
	unsigned int id;
	bool need_copy;
	unsigned int bvec_off;
	char *bvec_data;
	bool require_extra_req;
	struct blkif_request *extra_ring_req;
};

struct copy_from_grant {
	const struct blk_shadow *s;
	unsigned int grant_idx;
	unsigned int bvec_offset;
	char *bvec_data;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_cell_post_process_t)(void *, const char *, int, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
	NVMEM_TYPE_FRAM = 4,
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	size_t raw_len;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
	struct device_node *np;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
};

struct nvmem_layout;

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	const struct nvmem_cell_info *cells;
	int ncells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool ignore_wp;
	struct nvmem_layout *layout;
	struct device_node *of_node;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_layout {
	const char *name;
	const struct of_device_id *of_match_table;
	int (*add_cells)(struct device *, struct nvmem_device *, struct nvmem_layout *);
	void (*fixup_cell_info)(struct nvmem_device *, struct nvmem_layout *, struct nvmem_cell_info *);
	struct module *owner;
	struct list_head node;
};

struct at24_client {
	struct i2c_client *client;
	struct regmap *regmap;
};

struct at24_data {
	struct mutex lock;
	unsigned int write_max;
	unsigned int num_addresses;
	unsigned int offset_adj;
	u32 byte_len;
	u16 page_size;
	u8 flags;
	struct nvmem_device *nvmem;
	struct regulator *vcc_reg;
	void (*read_post)(unsigned int, char *, size_t);
	struct at24_client client[0];
};

struct at24_chip_data {
	u32 byte_len;
	u8 flags;
	void (*read_post)(unsigned int, char *, size_t);
};

struct sram_config {
	int (*init)();
	bool map_only_reserved;
};

struct sram_partition {
	void *base;
	struct gen_pool *pool;
	struct bin_attribute battr;
	struct mutex lock;
	struct list_head list;
};

struct sram_dev {
	const struct sram_config *config;
	struct device *dev;
	void *virt_base;
	bool no_memory_wc;
	struct gen_pool *pool;
	struct clk *clk;
	struct sram_partition *partition;
	u32 partitions;
};

struct sram_reserve {
	struct list_head list;
	u32 start;
	u32 size;
	struct resource res;
	bool export;
	bool pool;
	bool protect_exec;
	const char *label;
};

struct syscon_platform_data {
	const char *label;
};

struct syscon {
	struct device_node *np;
	struct regmap *regmap;
	struct list_head list;
};

struct seqcount_ww_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_ww_mutex seqcount_ww_mutex_t;

struct dma_buf_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf;

struct dma_buf_attachment;

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct dma_buf_map *);
	void (*vunmap)(struct dma_buf *, struct dma_buf_map *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	struct dma_buf_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_in;
	struct dma_buf_poll_cb_t cb_out;
};

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	seqcount_ww_mutex_t seq;
	struct dma_fence *fence_excl;
	struct dma_resv_list *fence;
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 shared_count;
	u32 shared_max;
	struct dma_fence *shared[0];
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

struct dma_fence_chain {
	struct dma_fence base;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	union {
		struct dma_fence_cb cb;
		struct irq_work work;
	};
	spinlock_t lock;
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

enum seqno_fence_condition {
	SEQNO_FENCE_WAIT_GEQUAL = 0,
	SEQNO_FENCE_WAIT_NONZERO = 1,
};

struct seqno_fence {
	struct dma_fence base;
	const struct dma_fence_ops *ops;
	struct dma_buf *sync_buf;
	uint32_t seqno_ofs;
	enum seqno_fence_condition condition;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

enum sam_status {
	SAM_STAT_GOOD = 0,
	SAM_STAT_CHECK_CONDITION = 2,
	SAM_STAT_CONDITION_MET = 4,
	SAM_STAT_BUSY = 8,
	SAM_STAT_INTERMEDIATE = 16,
	SAM_STAT_INTERMEDIATE_CONDITION_MET = 20,
	SAM_STAT_RESERVATION_CONFLICT = 24,
	SAM_STAT_COMMAND_TERMINATED = 34,
	SAM_STAT_TASK_SET_FULL = 40,
	SAM_STAT_ACA_ACTIVE = 48,
	SAM_STAT_TASK_ABORTED = 64,
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

enum scsi_host_status {
	DID_OK = 0,
	DID_NO_CONNECT = 1,
	DID_BUS_BUSY = 2,
	DID_TIME_OUT = 3,
	DID_BAD_TARGET = 4,
	DID_ABORT = 5,
	DID_PARITY = 6,
	DID_ERROR = 7,
	DID_RESET = 8,
	DID_BAD_INTR = 9,
	DID_PASSTHROUGH = 10,
	DID_SOFT_ERROR = 11,
	DID_IMM_RETRY = 12,
	DID_REQUEUE = 13,
	DID_TRANSPORT_DISRUPTED = 14,
	DID_TRANSPORT_FAILFAST = 15,
	DID_TARGET_FAILURE = 16,
	DID_NEXUS_FAILURE = 17,
	DID_ALLOC_FAILURE = 18,
	DID_MEDIUM_ERROR = 19,
	DID_TRANSPORT_MARGINAL = 20,
};

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	struct sbitmap budget_map;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	unsigned int ignore_media_change: 1;
	unsigned int silence_suspend: 1;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	struct bsg_device *bsg_dev;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_abort_list;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int nr_maps;
	unsigned int active_mode: 2;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
};

struct scsi_host_cmd_pool;

struct scsi_cmnd;

struct scsi_host_template {
	unsigned int cmd_size;
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	int (*map_queues)(struct Scsi_Host *);
	int (*mq_poll)(struct Scsi_Host *, unsigned int);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	bool (*eh_should_retry_cmd)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int max_host_blocked;
	struct device_attribute **shost_attrs;
	struct device_attribute **sdev_attrs;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
	struct scsi_host_cmd_pool *cmd_pool;
	int rpm_autosuspend_delay;
};

struct scsi_request {
	unsigned char __cmd[16];
	unsigned char *cmd;
	short unsigned int cmd_len;
	int result;
	unsigned int sense_len;
	unsigned int resid_len;
	int retries;
	void *sense;
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_pointer {
	char *ptr;
	int this_residual;
	struct scatterlist *buffer;
	int buffers_residual;
	dma_addr_t dma_handle;
	volatile int Status;
	volatile int Message;
	volatile int have_data_in;
	volatile int sent_command;
	volatile int phase;
};

struct scsi_cmnd {
	struct scsi_request req;
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	int budget_token;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	unsigned char *sense_buffer;
	void (*scsi_done)(struct scsi_cmnd *);
	struct scsi_pointer SCp;
	unsigned char *host_scribble;
	int result;
	int flags;
	long unsigned int state;
	unsigned int extra_len;
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *, bool);
	void *priv;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

enum scsi_msg_byte {
	COMMAND_COMPLETE = 0,
	EXTENDED_MESSAGE = 1,
	SAVE_POINTERS = 2,
	RESTORE_POINTERS = 3,
	DISCONNECT = 4,
	INITIATOR_ERROR = 5,
	ABORT_TASK_SET = 6,
	MESSAGE_REJECT = 7,
	NOP = 8,
	MSG_PARITY_ERROR = 9,
	LINKED_CMD_COMPLETE = 10,
	LINKED_FLG_CMD_COMPLETE = 11,
	TARGET_RESET = 12,
	ABORT_TASK = 13,
	CLEAR_TASK_SET = 14,
	INITIATE_RECOVERY = 15,
	RELEASE_RECOVERY = 16,
	TERMINATE_IO_PROC = 17,
	CLEAR_ACA = 22,
	LOGICAL_UNIT_RESET = 23,
	SIMPLE_QUEUE_TAG = 32,
	HEAD_OF_QUEUE_TAG = 33,
	ORDERED_QUEUE_TAG = 34,
	IGNORE_WIDE_RESIDUE = 35,
	ACA = 36,
	QAS_REQUEST = 85,
	BUS_DEVICE_RESET = 12,
	ABORT = 6,
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

enum {
	OMAX_SB_LEN = 16,
};

enum scsi_disposition {
	NEEDS_RETRY = 8193,
	SUCCESS = 8194,
	FAILED = 8195,
	QUEUED = 8196,
	SOFT_ERROR = 8197,
	ADD_TO_MLQUEUE = 8198,
	TIMEOUT_ERROR = 8199,
	SCSI_RETURN_NOT_HANDLED = 8200,
	FAST_IO_FAIL = 8201,
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	enum scsi_disposition (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	unsigned char eh_cmnd[16];
	struct scatterlist sense_sgl;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_RETRY = 2,
	ACTION_DELAYED_RETRY = 3,
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 1000,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

enum sas_device_type {
	SAS_PHY_UNUSED = 0,
	SAS_END_DEVICE = 1,
	SAS_EDGE_EXPANDER_DEVICE = 2,
	SAS_FANOUT_EXPANDER_DEVICE = 3,
	SAS_HA = 4,
	SAS_SATA_DEV = 5,
	SAS_SATA_PM = 7,
	SAS_SATA_PM_PORT = 8,
	SAS_SATA_PENDING = 9,
};

enum sas_protocol {
	SAS_PROTOCOL_NONE = 0,
	SAS_PROTOCOL_SATA = 1,
	SAS_PROTOCOL_SMP = 2,
	SAS_PROTOCOL_STP = 4,
	SAS_PROTOCOL_SSP = 8,
	SAS_PROTOCOL_ALL = 14,
	SAS_PROTOCOL_STP_ALL = 5,
};

enum sas_linkrate {
	SAS_LINK_RATE_UNKNOWN = 0,
	SAS_PHY_DISABLED = 1,
	SAS_PHY_RESET_PROBLEM = 2,
	SAS_SATA_SPINUP_HOLD = 3,
	SAS_SATA_PORT_SELECTOR = 4,
	SAS_PHY_RESET_IN_PROGRESS = 5,
	SAS_LINK_RATE_1_5_GBPS = 8,
	SAS_LINK_RATE_G1 = 8,
	SAS_LINK_RATE_3_0_GBPS = 9,
	SAS_LINK_RATE_G2 = 9,
	SAS_LINK_RATE_6_0_GBPS = 10,
	SAS_LINK_RATE_12_0_GBPS = 11,
	SAS_LINK_RATE_FAILED = 16,
	SAS_PHY_VIRTUAL = 17,
};

struct sas_identify {
	enum sas_device_type device_type;
	enum sas_protocol initiator_port_protocols;
	enum sas_protocol target_port_protocols;
	u64 sas_address;
	u8 phy_identifier;
};

struct sas_phy {
	struct device dev;
	int number;
	int enabled;
	struct sas_identify identify;
	enum sas_linkrate negotiated_linkrate;
	enum sas_linkrate minimum_linkrate_hw;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate_hw;
	enum sas_linkrate maximum_linkrate;
	u32 invalid_dword_count;
	u32 running_disparity_error_count;
	u32 loss_of_dword_sync_count;
	u32 phy_reset_problem_count;
	struct list_head port_siblings;
	void *hostdata;
};

struct sas_rphy {
	struct device dev;
	struct sas_identify identify;
	struct list_head list;
	struct request_queue *q;
	u32 scsi_target_id;
};

struct sas_end_device {
	struct sas_rphy rphy;
	unsigned int ready_led_meaning: 1;
	unsigned int tlr_supported: 1;
	unsigned int tlr_enabled: 1;
	u16 I_T_nexus_loss_timeout;
	u16 initiator_response_timeout;
};

struct sas_expander_device {
	int level;
	int next_port_id;
	char vendor_id[9];
	char product_id[17];
	char product_rev[5];
	char component_vendor_id[9];
	u16 component_id;
	u8 component_revision_id;
	struct sas_rphy rphy;
};

struct sas_port {
	struct device dev;
	int port_identifier;
	int num_phys;
	unsigned int is_backlink: 1;
	struct sas_rphy *rphy;
	struct mutex phy_list_mutex;
	struct list_head phy_list;
	struct list_head del_list;
};

struct sas_phy_linkrates {
	enum sas_linkrate maximum_linkrate;
	enum sas_linkrate minimum_linkrate;
};

struct sas_function_template {
	int (*get_linkerrors)(struct sas_phy *);
	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
	int (*get_bay_identifier)(struct sas_rphy *);
	int (*phy_reset)(struct sas_phy *, int);
	int (*phy_enable)(struct sas_phy *, int);
	int (*phy_setup)(struct sas_phy *);
	void (*phy_release)(struct sas_phy *);
	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
	void (*smp_handler)(struct bsg_job *, struct Scsi_Host *, struct sas_rphy *);
};

struct sas_domain_function_template;

struct sas_internal {
	struct scsi_transport_template t;
	struct sas_function_template *f;
	struct sas_domain_function_template *dft;
	struct device_attribute private_host_attrs[0];
	struct device_attribute private_phy_attrs[17];
	struct device_attribute private_port_attrs[1];
	struct device_attribute private_rphy_attrs[8];
	struct device_attribute private_end_dev_attrs[5];
	struct device_attribute private_expander_attrs[7];
	struct transport_container phy_attr_cont;
	struct transport_container port_attr_cont;
	struct transport_container rphy_attr_cont;
	struct transport_container end_dev_attr_cont;
	struct transport_container expander_attr_cont;
	struct device_attribute *host_attrs[1];
	struct device_attribute *phy_attrs[18];
	struct device_attribute *port_attrs[2];
	struct device_attribute *rphy_attrs[9];
	struct device_attribute *end_dev_attrs[6];
	struct device_attribute *expander_attrs[8];
};

struct sas_host_attrs {
	struct list_head rphy_list;
	struct mutex lock;
	struct request_queue *q;
	u32 next_target_id;
	u32 next_expander_id;
	int next_port_id;
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = 2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = 4294967295,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_CFG_MASK = 4095,
	ATA_DFLAG_PIO = 4096,
	ATA_DFLAG_NCQ_OFF = 8192,
	ATA_DFLAG_SLEEPING = 32768,
	ATA_DFLAG_DUBIOUS_XFER = 65536,
	ATA_DFLAG_NO_UNLOAD = 131072,
	ATA_DFLAG_UNLOCK_HPA = 262144,
	ATA_DFLAG_NCQ_SEND_RECV = 524288,
	ATA_DFLAG_NCQ_PRIO = 1048576,
	ATA_DFLAG_NCQ_PRIO_ENABLE = 2097152,
	ATA_DFLAG_INIT_MASK = 16777215,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DFLAG_FEATURES_MASK = 202899712,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DB_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_FAILED = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 5000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_PERDEV_MASK = 33,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_PROBE_MAX_TRIES = 3,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 7,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_HORKAGE_NO_NCQ_ON_ATI = 134217728,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	union {
		u8 error;
		u8 feature;
	};
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	union {
		u8 status;
		u8 command;
	};
	u32 auxiliary;
};

struct ata_port;

struct ata_device;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_link;

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[14];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	struct ata_ering_entry ring[32];
};

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	long: 64;
	long: 64;
	long: 64;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	int spdn_cnt;
	struct ata_ering ering;
	long: 64;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	long: 64;
	long: 64;
	long: 64;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

enum sw_activity {
	OFF = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	bool (*qc_fill_rtf)(struct ata_queued_cmd *);
	int (*cable_detect)(struct ata_port *);
	long unsigned int (*mode_filter)(struct ata_device *, long unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, u16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	void (*phy_reset)(struct ata_port *);
	void (*eng_timeout)(struct ata_port *);
	const struct ata_port_operations *inherits;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	long unsigned int sas_tag_allocated;
	u64 qc_active;
	int nr_active_links;
	unsigned int sas_last_tag;
	long: 64;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct work_struct scsi_rescan_task;
	unsigned int hsm_task_state;
	u32 msg_enable;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	long unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	long: 64;
	long: 64;
	u8 sector_buf[512];
};

enum sas_oob_mode {
	OOB_NOT_CONNECTED = 0,
	SATA_OOB_MODE = 1,
	SAS_OOB_MODE = 2,
};

enum phy_func {
	PHY_FUNC_NOP = 0,
	PHY_FUNC_LINK_RESET = 1,
	PHY_FUNC_HARD_RESET = 2,
	PHY_FUNC_DISABLE = 3,
	PHY_FUNC_CLEAR_ERROR_LOG = 5,
	PHY_FUNC_CLEAR_AFFIL = 6,
	PHY_FUNC_TX_SATA_PS_SIGNAL = 7,
	PHY_FUNC_RELEASE_SPINUP_HOLD = 16,
	PHY_FUNC_SET_LINK_RATE = 17,
	PHY_FUNC_GET_EVENTS = 18,
};

enum sas_open_rej_reason {
	SAS_OREJ_UNKNOWN = 0,
	SAS_OREJ_BAD_DEST = 1,
	SAS_OREJ_CONN_RATE = 2,
	SAS_OREJ_EPROTO = 3,
	SAS_OREJ_RESV_AB0 = 4,
	SAS_OREJ_RESV_AB1 = 5,
	SAS_OREJ_RESV_AB2 = 6,
	SAS_OREJ_RESV_AB3 = 7,
	SAS_OREJ_WRONG_DEST = 8,
	SAS_OREJ_STP_NORES = 9,
	SAS_OREJ_NO_DEST = 10,
	SAS_OREJ_PATH_BLOCKED = 11,
	SAS_OREJ_RSVD_CONT0 = 12,
	SAS_OREJ_RSVD_CONT1 = 13,
	SAS_OREJ_RSVD_INIT0 = 14,
	SAS_OREJ_RSVD_INIT1 = 15,
	SAS_OREJ_RSVD_STOP0 = 16,
	SAS_OREJ_RSVD_STOP1 = 17,
	SAS_OREJ_RSVD_RETRY = 18,
};

struct dev_to_host_fis {
	u8 fis_type;
	u8 flags;
	u8 status;
	u8 error;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 _r_a;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_b;
	u8 _r_c;
	u32 _r_d;
};

struct host_to_dev_fis {
	u8 fis_type;
	u8 flags;
	u8 command;
	u8 features;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 features_exp;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_a;
	u8 control;
	u32 _r_b;
};

struct report_general_resp {
	__be16 change_count;
	__be16 route_indexes;
	u8 _r_a;
	u8 num_phys;
	u8 conf_route_table: 1;
	u8 configuring: 1;
	u8 config_others: 1;
	u8 orej_retry_supp: 1;
	u8 stp_cont_awt: 1;
	u8 self_config: 1;
	u8 zone_config: 1;
	u8 t2t_supp: 1;
	u8 _r_c;
	u8 enclosure_logical_id[8];
	u8 _r_d[12];
};

struct discover_resp {
	u8 _r_a[5];
	u8 phy_id;
	__be16 _r_b;
	u8 _r_c: 4;
	u8 attached_dev_type: 3;
	u8 _r_d: 1;
	u8 linkrate: 4;
	u8 _r_e: 4;
	u8 attached_sata_host: 1;
	u8 iproto: 3;
	u8 _r_f: 4;
	u8 attached_sata_dev: 1;
	u8 tproto: 3;
	u8 _r_g: 3;
	u8 attached_sata_ps: 1;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	u8 _r_h[7];
	u8 hmin_linkrate: 4;
	u8 pmin_linkrate: 4;
	u8 hmax_linkrate: 4;
	u8 pmax_linkrate: 4;
	u8 change_count;
	u8 pptv: 4;
	u8 _r_i: 3;
	u8 virtual: 1;
	u8 routing_attr: 4;
	u8 _r_j: 4;
	u8 conn_type;
	u8 conn_el_index;
	u8 conn_phy_link;
	u8 _r_k[8];
};

struct report_phy_sata_resp {
	u8 _r_a[5];
	u8 phy_id;
	u8 _r_b;
	u8 affil_valid: 1;
	u8 affil_supp: 1;
	u8 _r_c: 6;
	u32 _r_d;
	u8 stp_sas_addr[8];
	struct dev_to_host_fis fis;
	u32 _r_e;
	u8 affil_stp_ini_addr[8];
	__be32 crc;
};

struct smp_resp {
	u8 frame_type;
	u8 function;
	u8 result;
	u8 reserved;
	union {
		struct report_general_resp rg;
		struct discover_resp disc;
		struct report_phy_sata_resp rps;
	};
};

enum sas_class {
	SAS = 0,
	EXPANDER = 1,
};

enum sas_phy_role {
	PHY_ROLE_NONE = 0,
	PHY_ROLE_TARGET = 64,
	PHY_ROLE_INITIATOR = 128,
};

enum sas_phy_type {
	PHY_TYPE_PHYSICAL = 0,
	PHY_TYPE_VIRTUAL = 1,
};

enum port_event {
	PORTE_BYTES_DMAED = 0,
	PORTE_BROADCAST_RCVD = 1,
	PORTE_LINK_RESET_ERR = 2,
	PORTE_TIMER_EVENT = 3,
	PORTE_HARD_RESET = 4,
	PORT_NUM_EVENTS = 5,
};

enum phy_event {
	PHYE_LOSS_OF_SIGNAL = 0,
	PHYE_OOB_DONE = 1,
	PHYE_OOB_ERROR = 2,
	PHYE_SPINUP_HOLD = 3,
	PHYE_RESUME_TIMEOUT = 4,
	PHYE_SHUTDOWN = 5,
	PHY_NUM_EVENTS = 6,
};

enum discover_event {
	DISCE_DISCOVER_DOMAIN = 0,
	DISCE_REVALIDATE_DOMAIN = 1,
	DISCE_SUSPEND = 2,
	DISCE_RESUME = 3,
	DISC_NUM_EVENTS = 4,
};

enum routing_attribute {
	DIRECT_ROUTING = 0,
	SUBTRACTIVE_ROUTING = 1,
	TABLE_ROUTING = 2,
};

enum ex_phy_state {
	PHY_EMPTY = 0,
	PHY_VACANT = 1,
	PHY_NOT_PRESENT = 2,
	PHY_DEVICE_DISCOVERED = 3,
};

struct ex_phy {
	int phy_id;
	enum ex_phy_state phy_state;
	enum sas_device_type attached_dev_type;
	enum sas_linkrate linkrate;
	u8 attached_sata_host: 1;
	u8 attached_sata_dev: 1;
	u8 attached_sata_ps: 1;
	enum sas_protocol attached_tproto;
	enum sas_protocol attached_iproto;
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	int phy_change_count;
	enum routing_attribute routing_attr;
	u8 virtual: 1;
	int last_da_index;
	struct sas_phy *phy;
	struct sas_port *port;
};

struct expander_device {
	struct list_head children;
	int ex_change_count;
	u16 max_route_indexes;
	u8 num_phys;
	u8 t2t_supp: 1;
	u8 configuring: 1;
	u8 conf_route_table: 1;
	u8 enclosure_logical_id[8];
	struct ex_phy *ex_phy;
	struct sas_port *parent_port;
	struct mutex cmd_mutex;
};

struct sata_device {
	unsigned int class;
	u8 port_no;
	struct ata_port *ap;
	struct ata_host *ata_host;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct smp_resp rps_resp;
	u8 fis[24];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ssp_device {
	struct list_head eh_list_node;
	struct scsi_lun reset_lun;
};

struct asd_sas_port;

struct domain_device {
	spinlock_t done_lock;
	enum sas_device_type dev_type;
	enum sas_linkrate linkrate;
	enum sas_linkrate min_linkrate;
	enum sas_linkrate max_linkrate;
	int pathways;
	struct domain_device *parent;
	struct list_head siblings;
	struct asd_sas_port *port;
	struct sas_phy *phy;
	struct list_head dev_list_node;
	struct list_head disco_list_node;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	struct sas_rphy *rphy;
	u8 sas_addr[8];
	u8 hashed_sas_addr[3];
	u8 frame_rcvd[32];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct expander_device ex_dev;
		struct sata_device sata_dev;
		struct ssp_device ssp_dev;
	};
	void *lldd_dev;
	long unsigned int state;
	struct kref kref;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sas_work {
	struct list_head drain_node;
	struct work_struct work;
};

struct sas_discovery_event {
	struct sas_work work;
	struct asd_sas_port *port;
};

struct sas_discovery {
	struct sas_discovery_event disc_work[4];
	long unsigned int pending;
	u8 fanout_sas_addr[8];
	u8 eeds_a[8];
	u8 eeds_b[8];
	int max_level;
};

struct sas_ha_struct;

struct asd_sas_port {
	struct sas_discovery disc;
	struct domain_device *port_dev;
	spinlock_t dev_list_lock;
	struct list_head dev_list;
	struct list_head disco_list;
	struct list_head destroy_list;
	struct list_head sas_port_del_list;
	enum sas_linkrate linkrate;
	struct sas_work work;
	int suspended;
	int id;
	enum sas_class class;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_oob_mode oob_mode;
	spinlock_t phy_list_lock;
	struct list_head phy_list;
	int num_phys;
	u32 phy_mask;
	struct sas_ha_struct *ha;
	struct sas_port *port;
	void *lldd_port;
};

struct scsi_core {
	struct Scsi_Host *shost;
};

struct asd_sas_phy;

struct sas_ha_struct {
	struct list_head defer_q;
	struct mutex drain_mutex;
	long unsigned int state;
	spinlock_t lock;
	int eh_active;
	wait_queue_head_t eh_wait_q;
	struct list_head eh_dev_q;
	struct mutex disco_mutex;
	struct scsi_core core;
	char *sas_ha_name;
	struct device *dev;
	struct module *lldd_module;
	struct workqueue_struct *event_q;
	struct workqueue_struct *disco_q;
	u8 *sas_addr;
	u8 hashed_sas_addr[3];
	spinlock_t phy_port_lock;
	struct asd_sas_phy **sas_phy;
	struct asd_sas_port **sas_port;
	int num_phys;
	int strict_wide_ports;
	void *lldd_ha;
	struct list_head eh_done_q;
	struct list_head eh_ata_q;
	int event_thres;
};

struct asd_sas_event {
	struct sas_work work;
	struct asd_sas_phy *phy;
	int event;
};

struct asd_sas_phy {
	atomic_t event_nr;
	int in_shutdown;
	int error;
	int suspended;
	struct sas_phy *phy;
	int enabled;
	int id;
	enum sas_class class;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_phy_type type;
	enum sas_phy_role role;
	enum sas_oob_mode oob_mode;
	enum sas_linkrate linkrate;
	u8 *sas_addr;
	u8 attached_sas_addr[8];
	spinlock_t frame_rcvd_lock;
	u8 *frame_rcvd;
	int frame_rcvd_size;
	spinlock_t sas_prim_lock;
	u32 sas_prim;
	struct list_head port_phy_el;
	struct asd_sas_port *port;
	struct sas_ha_struct *ha;
	void *lldd_phy;
};

enum sas_ha_state {
	SAS_HA_REGISTERED = 0,
	SAS_HA_DRAINING = 1,
	SAS_HA_ATA_EH_ACTIVE = 2,
	SAS_HA_FROZEN = 3,
};

enum service_response {
	SAS_TASK_COMPLETE = 0,
	SAS_TASK_UNDELIVERED = 4294967295,
};

enum exec_status {
	SAS_SAM_STAT_GOOD = 0,
	SAS_SAM_STAT_BUSY = 8,
	SAS_SAM_STAT_TASK_ABORTED = 64,
	SAS_SAM_STAT_CHECK_CONDITION = 2,
	SAS_DEV_NO_RESPONSE = 128,
	SAS_DATA_UNDERRUN = 129,
	SAS_DATA_OVERRUN = 130,
	SAS_INTERRUPTED = 131,
	SAS_QUEUE_FULL = 132,
	SAS_DEVICE_UNKNOWN = 133,
	SAS_SG_ERR = 134,
	SAS_OPEN_REJECT = 135,
	SAS_OPEN_TO = 136,
	SAS_PROTO_RESPONSE = 137,
	SAS_PHY_DOWN = 138,
	SAS_NAK_R_ERR = 139,
	SAS_PENDING = 140,
	SAS_ABORTED_TASK = 141,
};

struct task_status_struct {
	enum service_response resp;
	enum exec_status stat;
	int buf_valid_size;
	u8 buf[96];
	u32 residual;
	enum sas_open_rej_reason open_rej_reason;
};

struct sas_ata_task {
	struct host_to_dev_fis fis;
	u8 atapi_packet[16];
	u8 retry_count;
	u8 dma_xfer: 1;
	u8 use_ncq: 1;
	u8 set_affil_pol: 1;
	u8 stp_affil_pol: 1;
	u8 device_control_reg_update: 1;
} __attribute__((packed));

struct sas_smp_task {
	struct scatterlist smp_req;
	struct scatterlist smp_resp;
};

enum task_attribute {
	TASK_ATTR_SIMPLE = 0,
	TASK_ATTR_HOQ = 1,
	TASK_ATTR_ORDERED = 2,
	TASK_ATTR_ACA = 4,
};

struct sas_ssp_task {
	u8 retry_count;
	u8 LUN[8];
	u8 enable_first_burst: 1;
	enum task_attribute task_attr;
	u8 task_prio;
	struct scsi_cmnd *cmd;
};

struct sas_task_slow;

struct sas_task {
	struct domain_device *dev;
	spinlock_t task_state_lock;
	unsigned int task_state_flags;
	enum sas_protocol task_proto;
	union {
		struct sas_ata_task ata_task;
		struct sas_smp_task smp_task;
		struct sas_ssp_task ssp_task;
	};
	struct scatterlist *scatter;
	int num_scatter;
	u32 total_xfer_len;
	u8 data_dir: 2;
	struct task_status_struct task_status;
	void (*task_done)(struct sas_task *);
	void *lldd_task;
	void *uldd_task;
	struct sas_task_slow *slow_task;
};

struct sas_task_slow {
	struct timer_list timer;
	struct completion completion;
	struct sas_task *task;
};

struct sas_domain_function_template {
	void (*lldd_port_formed)(struct asd_sas_phy *);
	void (*lldd_port_deformed)(struct asd_sas_phy *);
	int (*lldd_dev_found)(struct domain_device *);
	void (*lldd_dev_gone)(struct domain_device *);
	int (*lldd_execute_task)(struct sas_task *, gfp_t);
	int (*lldd_abort_task)(struct sas_task *);
	int (*lldd_abort_task_set)(struct domain_device *, u8 *);
	int (*lldd_clear_aca)(struct domain_device *, u8 *);
	int (*lldd_clear_task_set)(struct domain_device *, u8 *);
	int (*lldd_I_T_nexus_reset)(struct domain_device *);
	int (*lldd_ata_check_ready)(struct domain_device *);
	void (*lldd_ata_set_dmamode)(struct domain_device *);
	int (*lldd_lu_reset)(struct domain_device *, u8 *);
	int (*lldd_query_task)(struct sas_task *);
	int (*lldd_clear_nexus_port)(struct asd_sas_port *);
	int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);
	int (*lldd_write_gpio)(struct sas_ha_struct *, u8, u8, u8, u8 *);
};

struct sas_phy_data {
	struct sas_phy *phy;
	struct mutex event_lock;
	int hard_reset;
	int reset_result;
	struct sas_work reset_work;
	int enable;
	int enable_result;
	struct sas_work enable_work;
};

struct sas_identify_frame {
	u8 frame_type: 4;
	u8 dev_type: 3;
	u8 _un0: 1;
	u8 _un1;
	union {
		struct {
			u8 _un20: 1;
			u8 smp_iport: 1;
			u8 stp_iport: 1;
			u8 ssp_iport: 1;
			u8 _un247: 4;
		};
		u8 initiator_bits;
	};
	union {
		struct {
			u8 _un30: 1;
			u8 smp_tport: 1;
			u8 stp_tport: 1;
			u8 ssp_tport: 1;
			u8 _un347: 4;
		};
		u8 target_bits;
	};
	u8 _un4_11[8];
	u8 sas_addr[8];
	u8 phy_id;
	u8 _un21_27[7];
	__be32 crc;
};

enum {
	SAS_DEV_GONE = 0,
	SAS_DEV_FOUND = 1,
	SAS_DEV_DESTROY = 2,
	SAS_DEV_EH_PENDING = 3,
	SAS_DEV_LU_RESET = 4,
	SAS_DEV_RESET = 5,
};

enum task_disposition {
	TASK_IS_DONE = 0,
	TASK_IS_ABORTED = 1,
	TASK_IS_AT_LU = 2,
	TASK_IS_NOT_AT_LU = 3,
	TASK_ABORT_FAILED = 4,
};

struct ssp_response_iu {
	u8 _r_a[10];
	u8 datapres: 2;
	u8 _r_b: 6;
	u8 status;
	u32 _r_c;
	__be32 sense_data_len;
	__be32 response_data_len;
	u8 resp_data[0];
	u8 sense_data[0];
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct opal_dev;

struct scsi_disk {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct device dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
};

enum scsi_host_guard_type {
	SHOST_DIX_GUARD_CRC = 1,
	SHOST_DIX_GUARD_IP = 2,
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

enum {
	ATA_MSG_DRV = 1,
	ATA_MSG_INFO = 2,
	ATA_MSG_PROBE = 4,
	ATA_MSG_WARN = 8,
	ATA_MSG_MALLOC = 16,
	ATA_MSG_CTL = 32,
	ATA_MSG_INTR = 64,
	ATA_MSG_ERR = 128,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct trace_event_raw_ata_qc_issue {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = 2147483648,
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	long unsigned int horkage;
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = 2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const long unsigned int *timeouts;
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

struct mtd_notifier {
	void (*add)(struct mtd_info *);
	void (*remove)(struct mtd_info *);
	struct list_head list;
};

struct mtd_partition {
	const char *name;
	const char * const *types;
	uint64_t size;
	uint64_t offset;
	uint32_t mask_flags;
	uint32_t add_flags;
	struct device_node *of_node;
};

struct mtd_part_parser_data {
	long unsigned int origin;
};

struct mtd_concat {
	struct mtd_info mtd;
	int num_subdev;
	struct mtd_info **subdev;
};

enum mtd_parser_type {
	MTD_PARSER_TYPE_DEVICE = 0,
	MTD_PARSER_TYPE_ROOTFS = 1,
	MTD_PARSER_TYPE_FIRMWARE = 2,
};

struct mtd_part_parser {
	struct list_head list;
	struct module *owner;
	const char *name;
	const struct of_device_id *of_match_table;
	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **, struct mtd_part_parser_data *);
	void (*cleanup)(const struct mtd_partition *, int);
	enum mtd_parser_type type;
};

struct mtd_partitions {
	const struct mtd_partition *parts;
	int nr_parts;
	const struct mtd_part_parser *parser;
};

typedef long unsigned int u_long;

struct erase_info_user {
	__u32 start;
	__u32 length;
};

struct erase_info_user64 {
	__u64 start;
	__u64 length;
};

struct mtd_oob_buf {
	__u32 start;
	__u32 length;
	unsigned char *ptr;
};

struct mtd_oob_buf64 {
	__u64 start;
	__u32 pad;
	__u32 length;
	__u64 usr_ptr;
};

struct mtd_write_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
};

struct mtd_read_req_ecc_stats {
	__u32 uncorrectable_errors;
	__u32 corrected_bitflips;
	__u32 max_bitflips;
};

struct mtd_read_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
	struct mtd_read_req_ecc_stats ecc_stats;
};

struct mtd_info_user {
	__u8 type;
	__u32 flags;
	__u32 size;
	__u32 erasesize;
	__u32 writesize;
	__u32 oobsize;
	__u64 padding;
};

struct region_info_user {
	__u32 offset;
	__u32 erasesize;
	__u32 numblocks;
	__u32 regionindex;
};

struct nand_oobinfo {
	__u32 useecc;
	__u32 eccbytes;
	__u32 oobfree[16];
	__u32 eccpos[32];
};

struct nand_oobfree {
	__u32 offset;
	__u32 length;
};

struct nand_ecclayout_user {
	__u32 eccbytes;
	__u32 eccpos[64];
	__u32 oobavail;
	struct nand_oobfree oobfree[8];
};

enum mtd_file_modes {
	MTD_FILE_MODE_NORMAL = 0,
	MTD_FILE_MODE_OTP_FACTORY = 1,
	MTD_FILE_MODE_OTP_USER = 2,
	MTD_FILE_MODE_RAW = 3,
};

struct mtd_chip_driver;

struct map_info {
	const char *name;
	long unsigned int size;
	resource_size_t phys;
	void *virt;
	void *cached;
	int swap;
	int bankwidth;
	void (*inval_cache)(struct map_info *, long unsigned int, ssize_t);
	void (*set_vpp)(struct map_info *, int);
	long unsigned int pfow_base;
	long unsigned int map_priv_1;
	long unsigned int map_priv_2;
	struct device_node *device_node;
	void *fldrv_priv;
	struct mtd_chip_driver *fldrv;
};

struct mtd_chip_driver {
	struct mtd_info * (*probe)(struct map_info *);
	void (*destroy)(struct mtd_info *);
	struct module *module;
	char *name;
	struct list_head list;
};

struct mtd_file_info {
	struct mtd_info *mtd;
	enum mtd_file_modes mode;
};

struct cmdline_mtd_partition {
	struct cmdline_mtd_partition *next;
	char *mtd_id;
	int num_parts;
	struct mtd_partition *parts;
};

struct fixed_partitions_quirks {
	int (*post_parse)(struct mtd_info *, struct mtd_partition *, int);
};

enum mtdsplit_part_type {
	MTDSPLIT_PART_TYPE_UNK = 0,
	MTDSPLIT_PART_TYPE_SQUASHFS = 1,
	MTDSPLIT_PART_TYPE_JFFS2 = 2,
	MTDSPLIT_PART_TYPE_UBI = 3,
};

struct squashfs_super_block___2 {
	__le32 s_magic;
	__le32 pad0[9];
	__le64 bytes_used;
};

struct mtd_blktrans_ops;

struct mtd_blktrans_dev {
	struct mtd_blktrans_ops *tr;
	struct list_head list;
	struct mtd_info *mtd;
	struct mutex lock;
	int devnum;
	bool bg_stop;
	long unsigned int size;
	int readonly;
	int open;
	struct kref ref;
	struct gendisk *disk;
	struct attribute_group *disk_attributes;
	struct request_queue *rq;
	struct list_head rq_list;
	struct blk_mq_tag_set *tag_set;
	spinlock_t queue_lock;
	void *priv;
	fmode_t file_mode;
};

struct mtd_blktrans_ops {
	char *name;
	int major;
	int part_bits;
	int blksize;
	int blkshift;
	int (*readsect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*writesect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*discard)(struct mtd_blktrans_dev *, long unsigned int, unsigned int);
	void (*background)(struct mtd_blktrans_dev *);
	int (*getgeo)(struct mtd_blktrans_dev *, struct hd_geometry *);
	int (*flush)(struct mtd_blktrans_dev *);
	int (*open)(struct mtd_blktrans_dev *);
	void (*release)(struct mtd_blktrans_dev *);
	void (*add_mtd)(struct mtd_blktrans_ops *, struct mtd_info *);
	void (*remove_dev)(struct mtd_blktrans_dev *);
	struct list_head devs;
	struct list_head list;
	struct module *owner;
};

struct mtdblk_dev {
	struct mtd_blktrans_dev mbd;
	int count;
	struct mutex cache_mutex;
	unsigned char *cache_data;
	long unsigned int cache_offset;
	unsigned int cache_size;
	enum {
		STATE_EMPTY = 0,
		STATE_CLEAN = 1,
		STATE_DIRTY = 2,
	} cache_state;
};

typedef union {
	long unsigned int x[1];
} map_word;

typedef enum {
	FL_READY = 0,
	FL_STATUS = 1,
	FL_CFI_QUERY = 2,
	FL_JEDEC_QUERY = 3,
	FL_ERASING = 4,
	FL_ERASE_SUSPENDING = 5,
	FL_ERASE_SUSPENDED = 6,
	FL_WRITING = 7,
	FL_WRITING_TO_BUFFER = 8,
	FL_OTP_WRITE = 9,
	FL_WRITE_SUSPENDING = 10,
	FL_WRITE_SUSPENDED = 11,
	FL_PM_SUSPENDED = 12,
	FL_SYNCING = 13,
	FL_UNLOADING = 14,
	FL_LOCKING = 15,
	FL_UNLOCKING = 16,
	FL_POINT = 17,
	FL_XIP_WHILE_ERASING = 18,
	FL_XIP_WHILE_WRITING = 19,
	FL_SHUTDOWN = 20,
	FL_READING = 21,
	FL_CACHEDPRG = 22,
	FL_RESETTING = 23,
	FL_OTPING = 24,
	FL_PREPARING_ERASE = 25,
	FL_VERIFYING_ERASE = 26,
	FL_UNKNOWN = 27,
} flstate_t;

struct flchip {
	long unsigned int start;
	int ref_point_counter;
	flstate_t state;
	flstate_t oldstate;
	unsigned int write_suspended: 1;
	unsigned int erase_suspended: 1;
	long unsigned int in_progress_block_addr;
	long unsigned int in_progress_block_mask;
	struct mutex mutex;
	wait_queue_head_t wq;
	int word_write_time;
	int buffer_write_time;
	int erase_time;
	int word_write_time_max;
	int buffer_write_time_max;
	int erase_time_max;
	void *priv;
};

struct cfi_ident {
	uint8_t qry[3];
	uint16_t P_ID;
	uint16_t P_ADR;
	uint16_t A_ID;
	uint16_t A_ADR;
	uint8_t VccMin;
	uint8_t VccMax;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t WordWriteTimeoutTyp;
	uint8_t BufWriteTimeoutTyp;
	uint8_t BlockEraseTimeoutTyp;
	uint8_t ChipEraseTimeoutTyp;
	uint8_t WordWriteTimeoutMax;
	uint8_t BufWriteTimeoutMax;
	uint8_t BlockEraseTimeoutMax;
	uint8_t ChipEraseTimeoutMax;
	uint8_t DevSize;
	uint16_t InterfaceDesc;
	uint16_t MaxBufWriteSize;
	uint8_t NumEraseRegions;
	uint32_t EraseRegionInfo[0];
} __attribute__((packed));

struct cfi_private {
	uint16_t cmdset;
	void *cmdset_priv;
	int interleave;
	int device_type;
	int cfi_mode;
	int addr_unlock1;
	int addr_unlock2;
	struct mtd_info * (*cmdset_setup)(struct map_info *);
	struct cfi_ident *cfiq;
	int mfr;
	int id;
	int numchips;
	map_word sector_erase_cmd;
	long unsigned int chipshift;
	const char *im_name;
	long unsigned int quirks;
	struct flchip chips[0];
};

struct chip_probe {
	char *name;
	int (*probe_chip)(struct map_info *, __u32, long unsigned int *, struct cfi_private *);
};

struct cfi_early_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct cfi_private *);
};

struct cfi_extquery {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
};

struct cfi_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct mtd_info *);
};

typedef int (*varsize_frob_t)(struct map_info *, struct flchip *, long unsigned int, int, void *);

struct cfi_pri_intelext {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint32_t FeatureSupport;
	uint8_t SuspendCmdSupport;
	uint16_t BlkStatusRegMask;
	uint8_t VccOptimal;
	uint8_t VppOptimal;
	uint8_t NumProtectionFields;
	uint16_t ProtRegAddr;
	uint8_t FactProtRegSize;
	uint8_t UserProtRegSize;
	uint8_t extra[0];
} __attribute__((packed));

struct cfi_pri_amdstd {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t SiliconRevision;
	uint8_t EraseSuspend;
	uint8_t BlkProt;
	uint8_t TmpBlkUnprotect;
	uint8_t BlkProtUnprot;
	uint8_t SimultaneousOps;
	uint8_t BurstMode;
	uint8_t PageMode;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t TopBottom;
	uint8_t ProgramSuspend;
	uint8_t UnlockBypass;
	uint8_t SecureSiliconSector;
	uint8_t SoftwareFeatures;
};

struct cfi_pri_atmel {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t Features;
	uint8_t BottomBoot;
	uint8_t BurstMode;
	uint8_t PageMode;
};

enum cfi_quirks {
	CFI_QUIRK_DQ_TRUE_DATA = 1,
};

enum fwh_lock_state {
	FWH_UNLOCKED = 0,
	FWH_DENY_WRITE = 1,
	FWH_IMMUTABLE = 2,
	FWH_DENY_READ = 4,
};

struct fwh_xxlock_thunk {
	enum fwh_lock_state val;
	flstate_t state;
};

typedef int (*otp_op_t)(struct map_info *, struct flchip *, loff_t, size_t, u_char *, size_t);

struct ppb_lock {
	struct flchip *chip;
	long unsigned int adr;
	int locked;
};

struct flchip_shared {
	struct mutex lock;
	struct flchip *writing;
	struct flchip *erasing;
};

struct cfi_intelext_blockinfo {
	uint16_t NumIdentBlocks;
	uint16_t BlockSize;
	uint16_t MinBlockEraseCycles;
	uint8_t BitsPerCell;
	uint8_t BlockCap;
};

struct cfi_intelext_regioninfo {
	uint16_t NumIdentPartitions;
	uint8_t NumOpAllowed;
	uint8_t NumOpAllowedSimProgMode;
	uint8_t NumOpAllowedSimEraMode;
	uint8_t NumBlockTypes;
	struct cfi_intelext_blockinfo BlockTypes[1];
};

struct cfi_intelext_programming_regioninfo {
	uint8_t ProgRegShift;
	uint8_t Reserved1;
	uint8_t ControlValid;
	uint8_t Reserved2;
	uint8_t ControlInvalid;
	uint8_t Reserved3;
};

typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);

struct physmap_flash_data {
	unsigned int width;
	int (*init)(struct platform_device *);
	void (*exit)(struct platform_device *);
	void (*set_vpp)(struct platform_device *, int);
	unsigned int nr_parts;
	unsigned int pfow_base;
	char *probe_type;
	struct mtd_partition *parts;
	const char * const *part_probe_types;
};

struct physmap_flash_info {
	unsigned int nmaps;
	struct mtd_info **mtds;
	struct mtd_info *cmtd;
	struct map_info *maps;
	spinlock_t vpp_lock;
	int vpp_refcnt;
	const char *probe_type;
	const char * const *part_types;
	unsigned int nparts;
	const struct mtd_partition *parts;
	struct gpio_descs *gpios;
	unsigned int gpio_values;
	unsigned int win_order;
};

struct flash_platform_data {
	char *name;
	struct mtd_partition *parts;
	unsigned int nr_parts;
	char *type;
};

struct dataflash {
	u8 command[4];
	char name[24];
	short unsigned int page_offset;
	unsigned int page_size;
	struct mutex lock;
	struct spi_device *spi;
	struct mtd_info mtd;
};

struct flash_info {
	char *name;
	u64 jedec_id;
	unsigned int nr_pages;
	u16 pagesize;
	u16 pageoffset;
	u16 flags;
};

struct sst25l_flash {
	struct spi_device *spi;
	struct mutex lock;
	struct mtd_info mtd;
};

struct flash_info___2 {
	const char *name;
	uint16_t device_id;
	unsigned int page_size;
	unsigned int nr_pages;
	unsigned int erase_size;
};

struct nand_memory_organization {
	unsigned int bits_per_cell;
	unsigned int pagesize;
	unsigned int oobsize;
	unsigned int pages_per_eraseblock;
	unsigned int eraseblocks_per_lun;
	unsigned int max_bad_eraseblocks_per_lun;
	unsigned int planes_per_lun;
	unsigned int luns_per_target;
	unsigned int ntargets;
};

struct nand_row_converter {
	unsigned int lun_addr_shift;
	unsigned int eraseblock_addr_shift;
};

struct nand_pos {
	unsigned int target;
	unsigned int lun;
	unsigned int plane;
	unsigned int eraseblock;
	unsigned int page;
};

enum nand_page_io_req_type {
	NAND_PAGE_READ = 0,
	NAND_PAGE_WRITE = 1,
};

struct nand_page_io_req {
	enum nand_page_io_req_type type;
	struct nand_pos pos;
	unsigned int dataoffs;
	unsigned int datalen;
	union {
		const void *out;
		void *in;
	} databuf;
	unsigned int ooboffs;
	unsigned int ooblen;
	union {
		const void *out;
		void *in;
	} oobbuf;
	int mode;
};

enum nand_ecc_engine_type {
	NAND_ECC_ENGINE_TYPE_INVALID = 0,
	NAND_ECC_ENGINE_TYPE_NONE = 1,
	NAND_ECC_ENGINE_TYPE_SOFT = 2,
	NAND_ECC_ENGINE_TYPE_ON_HOST = 3,
	NAND_ECC_ENGINE_TYPE_ON_DIE = 4,
};

enum nand_ecc_placement {
	NAND_ECC_PLACEMENT_UNKNOWN = 0,
	NAND_ECC_PLACEMENT_OOB = 1,
	NAND_ECC_PLACEMENT_INTERLEAVED = 2,
};

enum nand_ecc_algo {
	NAND_ECC_ALGO_UNKNOWN = 0,
	NAND_ECC_ALGO_HAMMING = 1,
	NAND_ECC_ALGO_BCH = 2,
	NAND_ECC_ALGO_RS = 3,
};

struct nand_ecc_props {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	unsigned int strength;
	unsigned int step_size;
	unsigned int flags;
};

struct nand_bbt {
	long unsigned int *cache;
};

struct nand_device;

struct nand_ops {
	int (*erase)(struct nand_device *, const struct nand_pos *);
	int (*markbad)(struct nand_device *, const struct nand_pos *);
	bool (*isbad)(struct nand_device *, const struct nand_pos *);
};

struct nand_ecc_context {
	struct nand_ecc_props conf;
	unsigned int nsteps;
	unsigned int total;
	void *priv;
};

struct nand_ecc_engine;

struct nand_ecc {
	struct nand_ecc_props defaults;
	struct nand_ecc_props requirements;
	struct nand_ecc_props user_conf;
	struct nand_ecc_context ctx;
	struct nand_ecc_engine *ondie_engine;
	struct nand_ecc_engine *engine;
};

struct nand_device {
	struct mtd_info mtd;
	struct nand_memory_organization memorg;
	struct nand_ecc ecc;
	struct nand_row_converter rowconv;
	struct nand_bbt bbt;
	const struct nand_ops *ops;
};

struct nand_ecc_engine_ops {
	int (*init_ctx)(struct nand_device *);
	void (*cleanup_ctx)(struct nand_device *);
	int (*prepare_io_req)(struct nand_device *, struct nand_page_io_req *);
	int (*finish_io_req)(struct nand_device *, struct nand_page_io_req *);
};

struct nand_ecc_engine {
	struct nand_ecc_engine_ops *ops;
};

enum nand_bbt_block_status {
	NAND_BBT_BLOCK_STATUS_UNKNOWN = 0,
	NAND_BBT_BLOCK_GOOD = 1,
	NAND_BBT_BLOCK_WORN = 2,
	NAND_BBT_BLOCK_RESERVED = 3,
	NAND_BBT_BLOCK_FACTORY_BAD = 4,
	NAND_BBT_BLOCK_NUM_STATUS = 5,
};

struct nand_ecc_req_tweak_ctx {
	struct nand_page_io_req orig_req;
	struct nand_device *nand;
	unsigned int page_buffer_size;
	unsigned int oob_buffer_size;
	void *spare_databuf;
	void *spare_oobbuf;
	bool bounce_data;
	bool bounce_oob;
};

struct nand_ecc_sw_hamming_conf {
	struct nand_ecc_req_tweak_ctx req_ctx;
	unsigned int code_size;
	u8 *calc_buf;
	u8 *code_buf;
	unsigned int sm_order;
};

struct nand_bbt_descr {
	int options;
	int pages[8];
	int offs;
	int veroffs;
	uint8_t version[8];
	int len;
	int maxblocks;
	int reserved_block_code;
	uint8_t *pattern;
};

struct nand_onfi_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	__le16 opt_cmd;
	u8 reserved0[2];
	__le16 ext_param_page_length;
	u8 num_of_param_pages;
	u8 reserved1[17];
	char manufacturer[12];
	char model[20];
	u8 jedec_id;
	__le16 date_code;
	u8 reserved2[13];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	__le32 data_bytes_per_ppage;
	__le16 spare_bytes_per_ppage;
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	u8 programs_per_page;
	u8 ppage_attr;
	u8 ecc_bits;
	u8 interleaved_bits;
	u8 interleaved_ops;
	u8 reserved3[13];
	u8 io_pin_capacitance_max;
	__le16 sdr_timing_modes;
	__le16 program_cache_timing_mode;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_ccs;
	u8 nvddr_timing_modes;
	u8 nvddr2_timing_modes;
	u8 nvddr_nvddr2_features;
	__le16 clk_pin_capacitance_typ;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	u8 input_pin_capacitance_max;
	u8 driver_strength_support;
	__le16 t_int_r;
	__le16 t_adl;
	u8 reserved4[8];
	__le16 vendor_revision;
	u8 vendor[88];
	__le16 crc;
} __attribute__((packed));

struct onfi_params {
	int version;
	u16 tPROG;
	u16 tBERS;
	u16 tR;
	u16 tCCS;
	bool fast_tCAD;
	u16 sdr_timing_modes;
	u16 nvddr_timing_modes;
	u16 vendor_revision;
	u8 vendor[88];
};

struct nand_parameters {
	const char *model;
	bool supports_set_get_features;
	long unsigned int set_feature_list[4];
	long unsigned int get_feature_list[4];
	struct onfi_params *onfi;
};

struct nand_id {
	u8 data[8];
	int len;
};

struct nand_ecc_step_info {
	int stepsize;
	const int *strengths;
	int nstrengths;
};

struct nand_ecc_caps {
	const struct nand_ecc_step_info *stepinfos;
	int nstepinfos;
	int (*calc_ecc_bytes)(int, int);
};

struct nand_chip;

struct nand_ecc_ctrl {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	int steps;
	int size;
	int bytes;
	int total;
	int strength;
	int prepad;
	int postpad;
	unsigned int options;
	u8 *calc_buf;
	u8 *code_buf;
	void (*hwctl)(struct nand_chip *, int);
	int (*calculate)(struct nand_chip *, const uint8_t *, uint8_t *);
	int (*correct)(struct nand_chip *, uint8_t *, uint8_t *, uint8_t *);
	int (*read_page_raw)(struct nand_chip *, uint8_t *, int, int);
	int (*write_page_raw)(struct nand_chip *, const uint8_t *, int, int);
	int (*read_page)(struct nand_chip *, uint8_t *, int, int);
	int (*read_subpage)(struct nand_chip *, uint32_t, uint32_t, uint8_t *, int);
	int (*write_subpage)(struct nand_chip *, uint32_t, uint32_t, const uint8_t *, int, int);
	int (*write_page)(struct nand_chip *, const uint8_t *, int, int);
	int (*write_oob_raw)(struct nand_chip *, int);
	int (*read_oob_raw)(struct nand_chip *, int);
	int (*read_oob)(struct nand_chip *, int);
	int (*write_oob)(struct nand_chip *, int);
};

struct nand_manufacturer_desc;

struct nand_manufacturer {
	const struct nand_manufacturer_desc *desc;
	void *priv;
};

struct nand_interface_config;

struct nand_chip_ops {
	int (*suspend)(struct nand_chip *);
	void (*resume)(struct nand_chip *);
	int (*lock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*unlock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*setup_read_retry)(struct nand_chip *, int);
	int (*choose_interface_config)(struct nand_chip *, struct nand_interface_config *);
};

struct nand_controller_ops;

struct nand_controller {
	struct mutex lock;
	const struct nand_controller_ops *ops;
};

struct nand_legacy {
	void *IO_ADDR_R;
	void *IO_ADDR_W;
	void (*select_chip)(struct nand_chip *, int);
	u8 (*read_byte)(struct nand_chip *);
	void (*write_byte)(struct nand_chip *, u8);
	void (*write_buf)(struct nand_chip *, const u8 *, int);
	void (*read_buf)(struct nand_chip *, u8 *, int);
	void (*cmd_ctrl)(struct nand_chip *, int, unsigned int);
	void (*cmdfunc)(struct nand_chip *, unsigned int, int, int);
	int (*dev_ready)(struct nand_chip *);
	int (*waitfunc)(struct nand_chip *);
	int (*block_bad)(struct nand_chip *, loff_t);
	int (*block_markbad)(struct nand_chip *, loff_t);
	int (*set_features)(struct nand_chip *, int, u8 *);
	int (*get_features)(struct nand_chip *, int, u8 *);
	int chip_delay;
	struct nand_controller dummy_controller;
};

struct nand_secure_region;

struct nand_chip {
	struct nand_device base;
	struct nand_id id;
	struct nand_parameters parameters;
	struct nand_manufacturer manufacturer;
	struct nand_chip_ops ops;
	struct nand_legacy legacy;
	unsigned int options;
	const struct nand_interface_config *current_interface_config;
	struct nand_interface_config *best_interface_config;
	unsigned int bbt_erase_shift;
	unsigned int bbt_options;
	unsigned int badblockpos;
	unsigned int badblockbits;
	struct nand_bbt_descr *bbt_td;
	struct nand_bbt_descr *bbt_md;
	struct nand_bbt_descr *badblock_pattern;
	u8 *bbt;
	unsigned int page_shift;
	unsigned int phys_erase_shift;
	unsigned int chip_shift;
	unsigned int pagemask;
	unsigned int subpagesize;
	u8 *data_buf;
	u8 *oob_poi;
	struct {
		unsigned int bitflips;
		int page;
	} pagecache;
	long unsigned int buf_align;
	struct mutex lock;
	unsigned int suspended: 1;
	wait_queue_head_t resume_wq;
	int cur_cs;
	int read_retries;
	struct nand_secure_region *secure_regions;
	u8 nr_secure_regions;
	struct nand_controller *controller;
	struct nand_ecc_ctrl ecc;
	void *priv;
};

struct nand_sdr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	u64 tPROG_max;
	u64 tR_max;
	u32 tALH_min;
	u32 tADL_min;
	u32 tALS_min;
	u32 tAR_min;
	u32 tCEA_max;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCHZ_max;
	u32 tCLH_min;
	u32 tCLR_min;
	u32 tCLS_min;
	u32 tCOH_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDS_min;
	u32 tFEAT_max;
	u32 tIR_min;
	u32 tITC_max;
	u32 tRC_min;
	u32 tREA_max;
	u32 tREH_min;
	u32 tRHOH_min;
	u32 tRHW_min;
	u32 tRHZ_max;
	u32 tRLOH_min;
	u32 tRP_min;
	u32 tRR_min;
	u64 tRST_max;
	u32 tWB_max;
	u32 tWC_min;
	u32 tWH_min;
	u32 tWHR_min;
	u32 tWP_min;
	u32 tWW_min;
};

struct nand_nvddr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	u64 tPROG_max;
	u64 tR_max;
	u32 tAC_min;
	u32 tAC_max;
	u32 tADL_min;
	u32 tCAD_min;
	u32 tCAH_min;
	u32 tCALH_min;
	u32 tCALS_min;
	u32 tCAS_min;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCK_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDQSCK_min;
	u32 tDQSCK_max;
	u32 tDQSD_min;
	u32 tDQSD_max;
	u32 tDQSHZ_max;
	u32 tDQSQ_max;
	u32 tDS_min;
	u32 tDSC_min;
	u32 tFEAT_max;
	u32 tITC_max;
	u32 tQHS_max;
	u32 tRHW_min;
	u32 tRR_min;
	u32 tRST_max;
	u32 tWB_max;
	u32 tWHR_min;
	u32 tWRCK_min;
	u32 tWW_min;
};

enum nand_interface_type {
	NAND_SDR_IFACE = 0,
	NAND_NVDDR_IFACE = 1,
};

struct nand_timings {
	unsigned int mode;
	union {
		struct nand_sdr_timings sdr;
		struct nand_nvddr_timings nvddr;
	};
};

struct nand_interface_config {
	enum nand_interface_type type;
	struct nand_timings timings;
};

struct nand_op_cmd_instr {
	u8 opcode;
};

struct nand_op_addr_instr {
	unsigned int naddrs;
	const u8 *addrs;
};

struct nand_op_data_instr {
	unsigned int len;
	union {
		void *in;
		const void *out;
	} buf;
	bool force_8bit;
};

struct nand_op_waitrdy_instr {
	unsigned int timeout_ms;
};

enum nand_op_instr_type {
	NAND_OP_CMD_INSTR = 0,
	NAND_OP_ADDR_INSTR = 1,
	NAND_OP_DATA_IN_INSTR = 2,
	NAND_OP_DATA_OUT_INSTR = 3,
	NAND_OP_WAITRDY_INSTR = 4,
};

struct nand_op_instr {
	enum nand_op_instr_type type;
	union {
		struct nand_op_cmd_instr cmd;
		struct nand_op_addr_instr addr;
		struct nand_op_data_instr data;
		struct nand_op_waitrdy_instr waitrdy;
	} ctx;
	unsigned int delay_ns;
};

struct nand_subop {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	unsigned int first_instr_start_off;
	unsigned int last_instr_end_off;
};

struct nand_op_parser_addr_constraints {
	unsigned int maxcycles;
};

struct nand_op_parser_data_constraints {
	unsigned int maxlen;
};

struct nand_op_parser_pattern_elem {
	enum nand_op_instr_type type;
	bool optional;
	union {
		struct nand_op_parser_addr_constraints addr;
		struct nand_op_parser_data_constraints data;
	} ctx;
};

struct nand_op_parser_pattern {
	const struct nand_op_parser_pattern_elem *elems;
	unsigned int nelems;
	int (*exec)(struct nand_chip *, const struct nand_subop *);
};

struct nand_op_parser {
	const struct nand_op_parser_pattern *patterns;
	unsigned int npatterns;
};

struct nand_operation {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
};

struct nand_controller_ops {
	int (*attach_chip)(struct nand_chip *);
	void (*detach_chip)(struct nand_chip *);
	int (*exec_op)(struct nand_chip *, const struct nand_operation *, bool);
	int (*setup_interface)(struct nand_chip *, int, const struct nand_interface_config *);
};

struct nand_manufacturer_ops;

struct nand_manufacturer_desc {
	int id;
	char *name;
	const struct nand_manufacturer_ops *ops;
};

struct nand_secure_region {
	u64 offset;
	u64 size;
};

struct nand_flash_dev {
	char *name;
	union {
		struct {
			uint8_t mfr_id;
			uint8_t dev_id;
		};
		uint8_t id[8];
	};
	unsigned int pagesize;
	unsigned int chipsize;
	unsigned int erasesize;
	unsigned int options;
	uint16_t id_len;
	uint16_t oobsize;
	struct {
		uint16_t strength_ds;
		uint16_t step_ds;
	} ecc;
};

struct nand_manufacturer_ops {
	void (*detect)(struct nand_chip *);
	int (*init)(struct nand_chip *);
	void (*cleanup)(struct nand_chip *);
	void (*fixup_onfi_param_page)(struct nand_chip *, struct nand_onfi_params *);
};

struct nand_op_parser_ctx {
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	struct nand_subop subop;
};

enum nand_ecc_legacy_mode {
	NAND_ECC_INVALID = 0,
	NAND_ECC_NONE = 1,
	NAND_ECC_SOFT = 2,
	NAND_ECC_SOFT_BCH = 3,
	NAND_ECC_HW = 4,
	NAND_ECC_HW_SYNDROME = 5,
	NAND_ECC_ON_DIE = 6,
};

struct onfi_ext_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct onfi_ext_section {
	u8 type;
	u8 length;
};

struct onfi_ext_param_page {
	__le16 crc;
	u8 sig[4];
	u8 reserved0[10];
	struct onfi_ext_section sections[8];
};

struct jedec_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct nand_jedec_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	u8 opt_cmd[3];
	__le16 sec_cmd;
	u8 num_of_param_pages;
	u8 reserved0[18];
	char manufacturer[12];
	char model[20];
	u8 jedec_id[6];
	u8 reserved1[10];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	u8 reserved2[6];
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	u8 programs_per_page;
	u8 multi_plane_addr;
	u8 multi_plane_op_attr;
	u8 reserved3[38];
	__le16 async_sdr_speed_grade;
	__le16 toggle_ddr_speed_grade;
	__le16 sync_ddr_speed_grade;
	u8 async_sdr_features;
	u8 toggle_ddr_features;
	u8 sync_ddr_features;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_r_multi_plane;
	__le16 t_ccs;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	__le16 clk_pin_capacitance_typ;
	u8 driver_strength_support;
	__le16 t_adl;
	u8 reserved4[36];
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	struct jedec_ecc_info ecc_info[4];
	u8 reserved5[29];
	u8 reserved6[148];
	__le16 vendor_rev_num;
	u8 reserved7[88];
	__le16 crc;
} __attribute__((packed));

struct hynix_read_retry {
	int nregs;
	const u8 *regs;
	u8 values[0];
};

struct hynix_nand {
	const struct hynix_read_retry *read_retry;
};

struct hynix_read_retry_otp {
	int nregs;
	const u8 *regs;
	const u8 *values;
	int page;
	int size;
};

struct nand_onfi_vendor_macronix {
	u8 reserved;
	u8 reliability_func;
};

struct nand_onfi_vendor_micron {
	u8 two_plane_read;
	u8 read_cache;
	u8 read_unique_id;
	u8 dq_imped;
	u8 dq_imped_num_settings;
	u8 dq_imped_feat_addr;
	u8 rb_pulldown_strength;
	u8 rb_pulldown_strength_feat_addr;
	u8 rb_pulldown_strength_num_settings;
	u8 otp_mode;
	u8 otp_page_start;
	u8 otp_data_prot_addr;
	u8 otp_num_pages;
	u8 otp_feat_addr;
	u8 read_retry_options;
	u8 reserved[72];
	u8 param_revision;
};

struct micron_on_die_ecc {
	bool forced;
	bool enabled;
	void *rawbuf;
};

struct micron_nand {
	struct micron_on_die_ecc ecc;
};

enum {
	MICRON_ON_DIE_UNSUPPORTED = 0,
	MICRON_ON_DIE_SUPPORTED = 1,
	MICRON_ON_DIE_MANDATORY = 2,
};

enum ifc_nand_fir_opcodes {
	IFC_FIR_OP_NOP = 0,
	IFC_FIR_OP_CA0 = 1,
	IFC_FIR_OP_CA1 = 2,
	IFC_FIR_OP_CA2 = 3,
	IFC_FIR_OP_CA3 = 4,
	IFC_FIR_OP_RA0 = 5,
	IFC_FIR_OP_RA1 = 6,
	IFC_FIR_OP_RA2 = 7,
	IFC_FIR_OP_RA3 = 8,
	IFC_FIR_OP_CMD0 = 9,
	IFC_FIR_OP_CMD1 = 10,
	IFC_FIR_OP_CMD2 = 11,
	IFC_FIR_OP_CMD3 = 12,
	IFC_FIR_OP_CMD4 = 13,
	IFC_FIR_OP_CMD5 = 14,
	IFC_FIR_OP_CMD6 = 15,
	IFC_FIR_OP_CMD7 = 16,
	IFC_FIR_OP_CW0 = 17,
	IFC_FIR_OP_CW1 = 18,
	IFC_FIR_OP_CW2 = 19,
	IFC_FIR_OP_CW3 = 20,
	IFC_FIR_OP_CW4 = 21,
	IFC_FIR_OP_CW5 = 22,
	IFC_FIR_OP_CW6 = 23,
	IFC_FIR_OP_CW7 = 24,
	IFC_FIR_OP_WBCD = 25,
	IFC_FIR_OP_RBCD = 26,
	IFC_FIR_OP_BTRD = 27,
	IFC_FIR_OP_RDSTAT = 28,
	IFC_FIR_OP_NWAIT = 29,
	IFC_FIR_OP_WFR = 30,
	IFC_FIR_OP_SBRD = 31,
	IFC_FIR_OP_UA = 32,
	IFC_FIR_OP_RB = 33,
};

struct fsl_ifc_nand {
	__be32 ncfgr;
	u32 res1[4];
	__be32 nand_fcr0;
	__be32 nand_fcr1;
	u32 res2[8];
	__be32 row0;
	u32 res3;
	__be32 col0;
	u32 res4;
	__be32 row1;
	u32 res5;
	__be32 col1;
	u32 res6;
	__be32 row2;
	u32 res7;
	__be32 col2;
	u32 res8;
	__be32 row3;
	u32 res9;
	__be32 col3;
	u32 res10[36];
	__be32 nand_fbcr;
	u32 res11;
	__be32 nand_fir0;
	__be32 nand_fir1;
	__be32 nand_fir2;
	u32 res12[16];
	__be32 nand_csel;
	u32 res13;
	__be32 nandseq_strt;
	u32 res14;
	__be32 nand_evter_stat;
	u32 res15;
	__be32 pgrdcmpl_evt_stat;
	u32 res16[2];
	__be32 nand_evter_en;
	u32 res17[2];
	__be32 nand_evter_intr_en;
	__be32 nand_vol_addr_stat;
	u32 res18;
	__be32 nand_erattr0;
	__be32 nand_erattr1;
	u32 res19[16];
	__be32 nand_fsr;
	u32 res20;
	__be32 nand_eccstat[8];
	u32 res21[28];
	__be32 nanndcr;
	u32 res22[2];
	__be32 nand_autoboot_trgr;
	u32 res23;
	__be32 nand_mdr;
	u32 res24[28];
	__be32 nand_dll_lowcfg0;
	__be32 nand_dll_lowcfg1;
	u32 res25;
	__be32 nand_dll_lowstat;
	u32 res26[60];
};

struct fsl_ifc_nor {
	__be32 nor_evter_stat;
	u32 res1[2];
	__be32 nor_evter_en;
	u32 res2[2];
	__be32 nor_evter_intr_en;
	u32 res3[2];
	__be32 nor_erattr0;
	__be32 nor_erattr1;
	__be32 nor_erattr2;
	u32 res4[4];
	__be32 norcr;
	u32 res5[239];
};

struct fsl_ifc_gpcm {
	__be32 gpcm_evter_stat;
	u32 res1[2];
	__be32 gpcm_evter_en;
	u32 res2[2];
	__be32 gpcm_evter_intr_en;
	u32 res3[2];
	__be32 gpcm_erattr0;
	__be32 gpcm_erattr1;
	__be32 gpcm_erattr2;
	__be32 gpcm_stat;
};

struct fsl_ifc_global {
	__be32 ifc_rev;
	u32 res1[2];
	struct {
		__be32 cspr_ext;
		__be32 cspr;
		u32 res2;
	} cspr_cs[8];
	u32 res3[13];
	struct {
		__be32 amask;
		u32 res4[2];
	} amask_cs[8];
	u32 res5[12];
	struct {
		__be32 csor;
		__be32 csor_ext;
		u32 res6;
	} csor_cs[8];
	u32 res7[12];
	struct {
		__be32 ftim[4];
		u32 res8[8];
	} ftim_cs[8];
	u32 res9[48];
	__be32 rb_stat;
	__be32 rb_map;
	__be32 wb_map;
	__be32 ifc_gcr;
	u32 res10[2];
	__be32 cm_evter_stat;
	u32 res11[2];
	__be32 cm_evter_en;
	u32 res12[2];
	__be32 cm_evter_intr_en;
	u32 res13[2];
	__be32 cm_erattr0;
	__be32 cm_erattr1;
	u32 res14[2];
	__be32 ifc_ccr;
	__be32 ifc_csr;
	__be32 ddr_ccr_low;
};

struct fsl_ifc_runtime {
	struct fsl_ifc_nand ifc_nand;
	struct fsl_ifc_nor ifc_nor;
	struct fsl_ifc_gpcm ifc_gpcm;
};

struct fsl_ifc_ctrl {
	struct device *dev;
	struct fsl_ifc_global *gregs;
	struct fsl_ifc_runtime *rregs;
	int irq;
	int nand_irq;
	spinlock_t lock;
	void *nand;
	int version;
	int banks;
	u32 nand_stat;
	wait_queue_head_t nand_wait;
	bool little_endian;
};

struct fsl_ifc_mtd {
	struct nand_chip chip;
	struct fsl_ifc_ctrl *ctrl;
	struct device *dev;
	int bank;
	unsigned int bufnum_mask;
	u8 *vbase;
};

struct fsl_ifc_nand_ctrl {
	struct nand_controller controller;
	struct fsl_ifc_mtd *chips[8];
	void *addr;
	unsigned int page;
	unsigned int read_bytes;
	unsigned int column;
	unsigned int index;
	unsigned int oob;
	unsigned int eccread;
	unsigned int counter;
	unsigned int max_bitflips;
};

struct nand_io_iter {
	struct nand_page_io_req req;
	unsigned int oobbytes_per_page;
	unsigned int dataleft;
	unsigned int oobleft;
};

enum spi_mem_data_dir {
	SPI_MEM_NO_DATA = 0,
	SPI_MEM_DATA_IN = 1,
	SPI_MEM_DATA_OUT = 2,
};

struct spi_mem_op {
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u16 opcode;
	} cmd;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u64 val;
	} addr;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
	} dummy;
	struct {
		u8 buswidth;
		u8 dtr: 1;
		enum spi_mem_data_dir dir;
		unsigned int nbytes;
		union {
			void *in;
			const void *out;
		} buf;
	} data;
};

struct spi_mem_dirmap_info {
	struct spi_mem_op op_tmpl;
	u64 offset;
	u64 length;
};

struct spi_mem_dirmap_desc {
	struct spi_mem *mem;
	struct spi_mem_dirmap_info info;
	unsigned int nodirmap;
	void *priv;
};

struct spi_mem {
	struct spi_device *spi;
	void *drvpriv;
	const char *name;
};

struct spi_mem_driver {
	struct spi_driver spidrv;
	int (*probe)(struct spi_mem *);
	int (*remove)(struct spi_mem *);
	void (*shutdown)(struct spi_mem *);
};

struct spinand_id {
	u8 data[4];
	int len;
};

enum spinand_readid_method {
	SPINAND_READID_METHOD_OPCODE = 0,
	SPINAND_READID_METHOD_OPCODE_ADDR = 1,
	SPINAND_READID_METHOD_OPCODE_DUMMY = 2,
};

struct spinand_devid {
	const u8 *id;
	const u8 len;
	const enum spinand_readid_method method;
};

struct spinand_device;

struct spinand_manufacturer_ops {
	int (*init)(struct spinand_device *);
	void (*cleanup)(struct spinand_device *);
};

struct spinand_ecc_info {
	int (*get_status)(struct spinand_device *, u8);
	const struct mtd_ooblayout_ops *ooblayout;
};

struct spinand_dirmap;

struct spinand_manufacturer;

struct spinand_device {
	struct nand_device base;
	struct spi_mem *spimem;
	struct mutex lock;
	struct spinand_id id;
	u32 flags;
	struct {
		const struct spi_mem_op *read_cache;
		const struct spi_mem_op *write_cache;
		const struct spi_mem_op *update_cache;
	} op_templates;
	struct spinand_dirmap *dirmaps;
	int (*select_target)(struct spinand_device *, unsigned int);
	unsigned int cur_target;
	struct spinand_ecc_info eccinfo;
	u8 *cfg_cache;
	u8 *databuf;
	u8 *oobbuf;
	u8 *scratchbuf;
	const struct spinand_manufacturer *manufacturer;
	void *priv;
};

struct spinand_info;

struct spinand_manufacturer {
	u8 id;
	char *name;
	const struct spinand_info *chips;
	const size_t nchips;
	const struct spinand_manufacturer_ops *ops;
};

struct spinand_op_variants;

struct spinand_info {
	const char *model;
	struct spinand_devid devid;
	u32 flags;
	struct nand_memory_organization memorg;
	struct nand_ecc_props eccreq;
	struct spinand_ecc_info eccinfo;
	struct {
		const struct spinand_op_variants *read_cache;
		const struct spinand_op_variants *write_cache;
		const struct spinand_op_variants *update_cache;
	} op_variants;
	int (*select_target)(struct spinand_device *, unsigned int);
};

struct spinand_op_variants {
	const struct spi_mem_op *ops;
	unsigned int nops;
};

struct spinand_ondie_ecc_conf {
	u8 status;
};

struct spinand_dirmap {
	struct spi_mem_dirmap_desc *wdesc;
	struct spi_mem_dirmap_desc *rdesc;
};

enum spi_nor_protocol {
	SNOR_PROTO_1_1_1 = 65793,
	SNOR_PROTO_1_1_2 = 65794,
	SNOR_PROTO_1_1_4 = 65796,
	SNOR_PROTO_1_1_8 = 65800,
	SNOR_PROTO_1_2_2 = 66050,
	SNOR_PROTO_1_4_4 = 66564,
	SNOR_PROTO_1_8_8 = 67592,
	SNOR_PROTO_2_2_2 = 131586,
	SNOR_PROTO_4_4_4 = 263172,
	SNOR_PROTO_8_8_8 = 526344,
	SNOR_PROTO_1_1_1_DTR = 16843009,
	SNOR_PROTO_1_2_2_DTR = 16843266,
	SNOR_PROTO_1_4_4_DTR = 16843780,
	SNOR_PROTO_1_8_8_DTR = 16844808,
	SNOR_PROTO_8_8_8_DTR = 17303560,
};

struct spi_nor_hwcaps {
	u32 mask;
};

struct spi_nor;

struct spi_nor_controller_ops {
	int (*prepare)(struct spi_nor *);
	void (*unprepare)(struct spi_nor *);
	int (*read_reg)(struct spi_nor *, u8, u8 *, size_t);
	int (*write_reg)(struct spi_nor *, u8, const u8 *, size_t);
	ssize_t (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	ssize_t (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*erase)(struct spi_nor *, loff_t);
};

enum spi_nor_cmd_ext {
	SPI_NOR_EXT_NONE = 0,
	SPI_NOR_EXT_REPEAT = 1,
	SPI_NOR_EXT_INVERT = 2,
	SPI_NOR_EXT_HEX = 3,
};

struct flash_info___3;

struct spi_nor_manufacturer;

struct sfdp;

struct spi_nor_flash_parameter;

struct spi_nor {
	struct mtd_info mtd;
	struct mutex lock;
	struct device *dev;
	struct spi_mem *spimem;
	u8 *bouncebuf;
	size_t bouncebuf_size;
	const struct flash_info___3 *info;
	const struct spi_nor_manufacturer *manufacturer;
	u32 page_size;
	u8 addr_width;
	u8 erase_opcode;
	u8 read_opcode;
	u8 read_dummy;
	u8 program_opcode;
	enum spi_nor_protocol read_proto;
	enum spi_nor_protocol write_proto;
	enum spi_nor_protocol reg_proto;
	bool sst_write_second;
	u32 flags;
	enum spi_nor_cmd_ext cmd_ext_type;
	struct sfdp *sfdp;
	const struct spi_nor_controller_ops *controller_ops;
	struct spi_nor_flash_parameter *params;
	struct {
		struct spi_mem_dirmap_desc *rdesc;
		struct spi_mem_dirmap_desc *wdesc;
	} dirmap;
	void *priv;
};

struct spi_nor_otp_organization {
	size_t len;
	loff_t base;
	loff_t offset;
	unsigned int n_regions;
};

struct spi_nor_fixups;

struct flash_info___3 {
	char *name;
	u8 id[6];
	u8 id_len;
	unsigned int sector_size;
	u16 n_sectors;
	u16 page_size;
	u16 addr_width;
	u32 flags;
	const struct spi_nor_otp_organization otp_org;
	const struct spi_nor_fixups *fixups;
};

struct spi_nor_manufacturer {
	const char *name;
	const struct flash_info___3 *parts;
	unsigned int nparts;
	const struct spi_nor_fixups *fixups;
};

struct sfdp {
	size_t num_dwords;
	u32 *dwords;
};

struct spi_nor_read_command {
	u8 num_mode_clocks;
	u8 num_wait_states;
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_pp_command {
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_erase_region {
	u64 offset;
	u64 size;
};

struct spi_nor_erase_type {
	u32 size;
	u32 size_shift;
	u32 size_mask;
	u8 opcode;
	u8 idx;
};

struct spi_nor_erase_map {
	struct spi_nor_erase_region *regions;
	struct spi_nor_erase_region uniform_region;
	struct spi_nor_erase_type erase_type[4];
	u8 uniform_erase_type;
};

struct spi_nor_otp_ops;

struct spi_nor_otp {
	const struct spi_nor_otp_organization *org;
	const struct spi_nor_otp_ops *ops;
};

struct spi_nor_locking_ops;

struct spi_nor_flash_parameter {
	u64 size;
	u32 writesize;
	u32 page_size;
	u8 rdsr_dummy;
	u8 rdsr_addr_nbytes;
	struct spi_nor_hwcaps hwcaps;
	struct spi_nor_read_command reads[16];
	struct spi_nor_pp_command page_programs[8];
	struct spi_nor_erase_map erase_map;
	struct spi_nor_otp otp;
	int (*octal_dtr_enable)(struct spi_nor *, bool);
	int (*quad_enable)(struct spi_nor *);
	int (*set_4byte_addr_mode)(struct spi_nor *, bool);
	u32 (*convert_addr)(struct spi_nor *, u32);
	int (*setup)(struct spi_nor *, const struct spi_nor_hwcaps *);
	const struct spi_nor_locking_ops *locking_ops;
};

struct sfdp_bfpt {
	u32 dwords[20];
};

struct sfdp_parameter_header {
	u8 id_lsb;
	u8 minor;
	u8 major;
	u8 length;
	u8 parameter_table_pointer[3];
	u8 id_msb;
};

enum spi_nor_option_flags {
	SNOR_F_USE_FSR = 1,
	SNOR_F_HAS_SR_TB = 2,
	SNOR_F_NO_OP_CHIP_ERASE = 4,
	SNOR_F_READY_XSR_RDY = 8,
	SNOR_F_USE_CLSR = 16,
	SNOR_F_BROKEN_RESET = 32,
	SNOR_F_4B_OPCODES = 64,
	SNOR_F_HAS_4BAIT = 128,
	SNOR_F_HAS_LOCK = 256,
	SNOR_F_HAS_16BIT_SR = 512,
	SNOR_F_NO_READ_CR = 1024,
	SNOR_F_HAS_SR_TB_BIT6 = 2048,
	SNOR_F_HAS_4BIT_BP = 4096,
	SNOR_F_HAS_SR_BP3_BIT6 = 8192,
	SNOR_F_IO_MODE_EN_VOLATILE = 16384,
	SNOR_F_SOFT_RESET = 32768,
	SNOR_F_SWP_IS_VOLATILE = 65536,
};

enum spi_nor_read_command_index {
	SNOR_CMD_READ = 0,
	SNOR_CMD_READ_FAST = 1,
	SNOR_CMD_READ_1_1_1_DTR = 2,
	SNOR_CMD_READ_1_1_2 = 3,
	SNOR_CMD_READ_1_2_2 = 4,
	SNOR_CMD_READ_2_2_2 = 5,
	SNOR_CMD_READ_1_2_2_DTR = 6,
	SNOR_CMD_READ_1_1_4 = 7,
	SNOR_CMD_READ_1_4_4 = 8,
	SNOR_CMD_READ_4_4_4 = 9,
	SNOR_CMD_READ_1_4_4_DTR = 10,
	SNOR_CMD_READ_1_1_8 = 11,
	SNOR_CMD_READ_1_8_8 = 12,
	SNOR_CMD_READ_8_8_8 = 13,
	SNOR_CMD_READ_1_8_8_DTR = 14,
	SNOR_CMD_READ_8_8_8_DTR = 15,
	SNOR_CMD_READ_MAX = 16,
};

enum spi_nor_pp_command_index {
	SNOR_CMD_PP = 0,
	SNOR_CMD_PP_1_1_4 = 1,
	SNOR_CMD_PP_1_4_4 = 2,
	SNOR_CMD_PP_4_4_4 = 3,
	SNOR_CMD_PP_1_1_8 = 4,
	SNOR_CMD_PP_1_8_8 = 5,
	SNOR_CMD_PP_8_8_8 = 6,
	SNOR_CMD_PP_8_8_8_DTR = 7,
	SNOR_CMD_PP_MAX = 8,
};

struct spi_nor_erase_command {
	struct list_head list;
	u32 count;
	u32 size;
	u8 opcode;
};

struct spi_nor_locking_ops {
	int (*lock)(struct spi_nor *, loff_t, uint64_t);
	int (*unlock)(struct spi_nor *, loff_t, uint64_t);
	int (*is_locked)(struct spi_nor *, loff_t, uint64_t);
};

struct spi_nor_otp_ops {
	int (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	int (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*lock)(struct spi_nor *, unsigned int);
	int (*erase)(struct spi_nor *, loff_t);
	int (*is_locked)(struct spi_nor *, unsigned int);
};

struct spi_nor_fixups {
	void (*default_init)(struct spi_nor *);
	int (*post_bfpt)(struct spi_nor *, const struct sfdp_parameter_header *, const struct sfdp_bfpt *);
	void (*post_sfdp)(struct spi_nor *);
};

struct sfdp_header {
	u32 signature;
	u8 minor;
	u8 major;
	u8 nph;
	u8 unused;
	struct sfdp_parameter_header bfpt_header;
};

struct sfdp_bfpt_read {
	u32 hwcaps;
	u32 supported_dword;
	u32 supported_bit;
	u32 settings_dword;
	u32 settings_shift;
	enum spi_nor_protocol proto;
};

struct sfdp_bfpt_erase {
	u32 dword;
	u32 shift;
};

struct sfdp_4bait {
	u32 hwcaps;
	u32 supported_bit;
};

enum {
	UBI_VID_DYNAMIC = 1,
	UBI_VID_STATIC = 2,
};

enum {
	UBI_VTBL_AUTORESIZE_FLG = 1,
	UBI_VTBL_SKIP_CRC_CHECK_FLG = 2,
};

enum {
	UBI_COMPAT_DELETE = 1,
	UBI_COMPAT_RO = 2,
	UBI_COMPAT_PRESERVE = 4,
	UBI_COMPAT_REJECT = 5,
};

struct ubi_ec_hdr {
	__be32 magic;
	__u8 version;
	__u8 padding1[3];
	__be64 ec;
	__be32 vid_hdr_offset;
	__be32 data_offset;
	__be32 image_seq;
	__u8 padding2[32];
	__be32 hdr_crc;
};

struct ubi_vid_hdr {
	__be32 magic;
	__u8 version;
	__u8 vol_type;
	__u8 copy_flag;
	__u8 compat;
	__be32 vol_id;
	__be32 lnum;
	__u8 padding1[4];
	__be32 data_size;
	__be32 used_ebs;
	__be32 data_pad;
	__be32 data_crc;
	__u8 padding2[4];
	__be64 sqnum;
	__u8 padding3[12];
	__be32 hdr_crc;
};

struct ubi_vtbl_record {
	__be32 reserved_pebs;
	__be32 alignment;
	__be32 data_pad;
	__u8 vol_type;
	__u8 upd_marker;
	__be16 name_len;
	__u8 name[128];
	__u8 flags;
	__u8 padding[23];
	__be32 crc;
};

enum {
	UBI_IO_FF = 1,
	UBI_IO_FF_BITFLIPS = 2,
	UBI_IO_BAD_HDR = 3,
	UBI_IO_BAD_HDR_EBADMSG = 4,
	UBI_IO_BITFLIPS = 5,
};

struct ubi_vid_io_buf {
	struct ubi_vid_hdr *hdr;
	void *buffer;
};

struct ubi_wl_entry {
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
	int ec;
	int pnum;
};

struct ubi_rename_entry {
	int new_name_len;
	char new_name[128];
	int remove;
	struct ubi_volume_desc *desc;
	struct list_head list;
};

struct ubi_volume;

struct ubi_volume_desc {
	struct ubi_volume *vol;
	int mode;
};

struct ubi_fastmap_layout {
	struct ubi_wl_entry *e[32];
	int to_be_tortured[32];
	int used_blocks;
	int max_pool_size;
	int max_wl_pool_size;
};

struct ubi_fm_pool {
	int pebs[256];
	int used;
	int size;
	int max_size;
};

struct ubi_device;

struct ubi_eba_table;

struct ubi_volume {
	struct device dev;
	struct cdev cdev;
	struct ubi_device *ubi;
	int vol_id;
	int ref_count;
	int readers;
	int writers;
	int exclusive;
	int metaonly;
	int reserved_pebs;
	int vol_type;
	int usable_leb_size;
	int used_ebs;
	int last_eb_bytes;
	long long int used_bytes;
	int alignment;
	int data_pad;
	int name_len;
	char name[128];
	int upd_ebs;
	int ch_lnum;
	long long int upd_bytes;
	long long int upd_received;
	void *upd_buf;
	struct ubi_eba_table *eba_tbl;
	unsigned int skip_check: 1;
	unsigned int checked: 1;
	unsigned int corrupted: 1;
	unsigned int upd_marker: 1;
	unsigned int updating: 1;
	unsigned int changing_leb: 1;
	unsigned int direct_writes: 1;
};

struct ubi_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_io: 1;
	unsigned int chk_fastmap: 1;
	unsigned int disable_bgt: 1;
	unsigned int emulate_bitflips: 1;
	unsigned int emulate_io_failures: 1;
	unsigned int emulate_power_cut: 2;
	unsigned int power_cut_counter;
	unsigned int power_cut_min;
	unsigned int power_cut_max;
	char dfs_dir_name[7];
	struct dentry *dfs_dir;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_io;
	struct dentry *dfs_chk_fastmap;
	struct dentry *dfs_disable_bgt;
	struct dentry *dfs_emulate_bitflips;
	struct dentry *dfs_emulate_io_failures;
	struct dentry *dfs_emulate_power_cut;
	struct dentry *dfs_power_cut_min;
	struct dentry *dfs_power_cut_max;
};

struct ubi_device {
	struct cdev cdev;
	struct device dev;
	int ubi_num;
	char ubi_name[9];
	int vol_count;
	struct ubi_volume *volumes[129];
	spinlock_t volumes_lock;
	int ref_count;
	int image_seq;
	int rsvd_pebs;
	int avail_pebs;
	int beb_rsvd_pebs;
	int beb_rsvd_level;
	int bad_peb_limit;
	int autoresize_vol_id;
	int vtbl_slots;
	int vtbl_size;
	struct ubi_vtbl_record *vtbl;
	struct mutex device_mutex;
	int max_ec;
	int mean_ec;
	long long unsigned int global_sqnum;
	spinlock_t ltree_lock;
	struct rb_root ltree;
	struct mutex alc_mutex;
	int fm_disabled;
	struct ubi_fastmap_layout *fm;
	struct ubi_fm_pool fm_pool;
	struct ubi_fm_pool fm_wl_pool;
	struct rw_semaphore fm_eba_sem;
	struct rw_semaphore fm_protect;
	void *fm_buf;
	size_t fm_size;
	struct work_struct fm_work;
	int fm_work_scheduled;
	int fast_attach;
	struct ubi_wl_entry *fm_anchor;
	int fm_do_produce_anchor;
	struct rb_root used;
	struct rb_root erroneous;
	struct rb_root free;
	int free_count;
	struct rb_root scrub;
	struct list_head pq[10];
	int pq_head;
	spinlock_t wl_lock;
	struct mutex move_mutex;
	struct rw_semaphore work_sem;
	int wl_scheduled;
	struct ubi_wl_entry **lookuptbl;
	struct ubi_wl_entry *move_from;
	struct ubi_wl_entry *move_to;
	int move_to_put;
	struct list_head works;
	int works_count;
	struct task_struct *bgt_thread;
	int thread_enabled;
	char bgt_name[13];
	long long int flash_size;
	int peb_count;
	int peb_size;
	int bad_peb_count;
	int good_peb_count;
	int corr_peb_count;
	int erroneous_peb_count;
	int max_erroneous;
	int min_io_size;
	int hdrs_min_io_size;
	int ro_mode;
	int leb_size;
	int leb_start;
	int ec_hdr_alsize;
	int vid_hdr_alsize;
	int vid_hdr_offset;
	int vid_hdr_aloffset;
	int vid_hdr_shift;
	unsigned int bad_allowed: 1;
	unsigned int nor_flash: 1;
	int max_write_size;
	struct mtd_info *mtd;
	void *peb_buf;
	struct mutex buf_mutex;
	struct mutex ckvol_mutex;
	struct ubi_debug_info dbg;
};

struct ubi_ainf_peb {
	int ec;
	int pnum;
	int vol_id;
	int lnum;
	unsigned int scrub: 1;
	unsigned int copy_flag: 1;
	long long unsigned int sqnum;
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
};

struct ubi_ainf_volume {
	int vol_id;
	int highest_lnum;
	int leb_count;
	int vol_type;
	int used_ebs;
	int last_data_size;
	int data_pad;
	int compat;
	struct rb_node rb;
	struct rb_root root;
};

struct ubi_attach_info {
	struct rb_root volumes;
	struct list_head corr;
	struct list_head free;
	struct list_head erase;
	struct list_head alien;
	struct list_head fastmap;
	int corr_peb_count;
	int empty_peb_count;
	int alien_peb_count;
	int bad_peb_count;
	int maybe_bad_peb_count;
	int vols_found;
	int highest_vol_id;
	int is_empty;
	int force_full_scan;
	int min_ec;
	int max_ec;
	long long unsigned int max_sqnum;
	int mean_ec;
	uint64_t ec_sum;
	int ec_count;
	bool eof_found;
	struct kmem_cache *aeb_slab_cache;
	struct ubi_ec_hdr *ech;
	struct ubi_vid_io_buf *vidb;
};

enum {
	UBI_VOL_SKIP_CRC_CHECK_FLG = 1,
};

struct ubi_mkvol_req {
	__s32 vol_id;
	__s32 alignment;
	__s64 bytes;
	__s8 vol_type;
	__u8 flags;
	__s16 name_len;
	__s8 padding2[4];
	char name[128];
};

enum {
	UBI_VOLUME_ADDED = 0,
	UBI_VOLUME_REMOVED = 1,
	UBI_VOLUME_RESIZED = 2,
	UBI_VOLUME_RENAMED = 3,
	UBI_VOLUME_UPDATED = 4,
};

struct ubi_leb_change_req {
	__s32 lnum;
	__s32 bytes;
	__s8 dtype;
	__s8 padding[7];
};

struct ubi_notification {
	struct ubi_device_info di;
	struct ubi_volume_info vi;
};

struct mtd_dev_param {
	char name[64];
	int ubi_num;
	int vid_hdr_offs;
	int max_beb_per1024;
};

enum {
	UBI_VOL_PROP_DIRECT_WRITE = 1,
};

struct ubi_attach_req {
	__s32 ubi_num;
	__s32 mtd_num;
	__s32 vid_hdr_offset;
	__s16 max_beb_per1024;
	__s8 padding[10];
};

struct ubi_rsvol_req {
	__s64 bytes;
	__s32 vol_id;
} __attribute__((packed));

struct ubi_rnvol_req {
	__s32 count;
	__s8 padding1[12];
	struct {
		__s32 vol_id;
		__s16 name_len;
		__s8 padding2[2];
		char name[128];
	} ents[32];
};

struct ubi_map_req {
	__s32 lnum;
	__s8 dtype;
	__s8 padding[3];
};

struct ubi_set_vol_prop_req {
	__u8 property;
	__u8 padding[7];
	__u64 value;
};

struct ubi_sgl {
	int list_pos;
	int page_pos;
	struct scatterlist sg[64];
};

enum {
	MOVE_CANCEL_RACE = 1,
	MOVE_SOURCE_RD_ERR = 2,
	MOVE_TARGET_RD_ERR = 3,
	MOVE_TARGET_WR_ERR = 4,
	MOVE_TARGET_BITFLIPS = 5,
	MOVE_RETRY = 6,
};

struct ubi_ltree_entry {
	struct rb_node rb;
	int vol_id;
	int lnum;
	int users;
	struct rw_semaphore mutex;
};

struct ubi_eba_leb_desc {
	int lnum;
	int pnum;
};

struct ubi_eba_entry;

struct ubi_eba_table {
	struct ubi_eba_entry *entries;
};

struct ubi_eba_entry {
	int pnum;
};

enum {
	POWER_CUT_EC_WRITE = 1,
	POWER_CUT_VID_WRITE = 2,
};

struct ubi_work {
	struct list_head list;
	int (*func)(struct ubi_device *, struct ubi_work *, int);
	struct ubi_wl_entry *e;
	int vol_id;
	int lnum;
	int torture;
};

struct ubiblock_param {
	int ubi_num;
	int vol_id;
	char name[64];
};

struct ubiblock_pdu {
	struct work_struct work;
	struct ubi_sgl usgl;
};

struct ubiblock {
	struct ubi_volume_desc *desc;
	int ubi_num;
	int vol_id;
	int refcnt;
	int leb_size;
	struct gendisk *gd;
	struct request_queue *rq;
	struct workqueue_struct *wq;
	struct mutex dev_mutex;
	struct list_head list;
	struct blk_mq_tag_set tag_set;
};

typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);

struct spi_res {
	struct list_head entry;
	spi_res_release_t release;
	long long unsigned int data[0];
};

struct spi_replaced_transfers;

typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);

struct spi_replaced_transfers {
	spi_replaced_release_t release;
	void *extradata;
	struct list_head replaced_transfers;
	struct list_head *replaced_after;
	size_t inserted;
	struct spi_transfer inserted_transfers[0];
};

struct spi_board_info {
	char modalias[32];
	const void *platform_data;
	const struct software_node *swnode;
	void *controller_data;
	int irq;
	u32 max_speed_hz;
	u16 bus_num;
	u16 chip_select;
	u32 mode;
};

struct trace_event_raw_spi_controller {
	struct trace_entry ent;
	int bus_num;
	char __data[0];
};

struct trace_event_raw_spi_setup {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	long unsigned int mode;
	unsigned int bits_per_word;
	unsigned int max_speed_hz;
	int status;
	char __data[0];
};

struct trace_event_raw_spi_set_cs {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	long unsigned int mode;
	bool enable;
	char __data[0];
};

struct trace_event_raw_spi_message {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	char __data[0];
};

struct trace_event_raw_spi_message_done {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	unsigned int frame;
	unsigned int actual;
	char __data[0];
};

struct trace_event_raw_spi_transfer {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_transfer *xfer;
	int len;
	u32 __data_loc_rx_buf;
	u32 __data_loc_tx_buf;
	char __data[0];
};

struct trace_event_data_offsets_spi_controller {};

struct trace_event_data_offsets_spi_setup {};

struct trace_event_data_offsets_spi_set_cs {};

struct trace_event_data_offsets_spi_message {};

struct trace_event_data_offsets_spi_message_done {};

struct trace_event_data_offsets_spi_transfer {
	u32 rx_buf;
	u32 tx_buf;
};

typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_setup)(void *, struct spi_device *, int);

typedef void (*btf_trace_spi_set_cs)(void *, struct spi_device *, bool);

typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);

typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);

typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);

struct boardinfo {
	struct list_head list;
	struct spi_board_info board_info;
};

struct fsl_dspi_platform_data {
	u32 cs_num;
	u32 bus_num;
	u32 sck_cs_delay;
	u32 cs_sck_delay;
};

struct chip_data {
	u32 ctar_val;
};

enum dspi_trans_mode {
	DSPI_XSPI_MODE = 0,
	DSPI_DMA_MODE = 1,
};

struct fsl_dspi_devtype_data {
	enum dspi_trans_mode trans_mode;
	u8 max_clock_factor;
	int fifo_size;
};

enum {
	LS1021A = 0,
	LS1012A = 1,
	LS1028A = 2,
	LS1043A = 3,
	LS1046A = 4,
	LS2080A = 5,
	LS2085A = 6,
	LX2160A = 7,
	MCF5441X = 8,
	VF610 = 9,
};

struct fsl_dspi_dma {
	u32 *tx_dma_buf;
	struct dma_chan *chan_tx;
	dma_addr_t tx_dma_phys;
	struct completion cmd_tx_complete;
	struct dma_async_tx_descriptor *tx_desc;
	u32 *rx_dma_buf;
	struct dma_chan *chan_rx;
	dma_addr_t rx_dma_phys;
	struct completion cmd_rx_complete;
	struct dma_async_tx_descriptor *rx_desc;
};

struct fsl_dspi {
	struct spi_controller *ctlr;
	struct platform_device *pdev;
	struct regmap *regmap;
	struct regmap *regmap_pushr;
	int irq;
	struct clk *clk;
	struct spi_transfer *cur_transfer;
	struct spi_message *cur_msg;
	struct chip_data *cur_chip;
	size_t progress;
	size_t len;
	const void *tx;
	void *rx;
	u16 tx_cmd;
	const struct fsl_dspi_devtype_data *devtype_data;
	struct completion xfer_done;
	struct fsl_dspi_dma *dma;
	int oper_word_size;
	int oper_bits_per_word;
	int words_in_flight;
	int pushr_cmd;
	int pushr_tx;
	void (*host_to_dev)(struct fsl_dspi *, u32 *);
	void (*dev_to_host)(struct fsl_dspi *, u32);
};

struct fsl_qspi_devtype_data {
	unsigned int rxfifo;
	unsigned int txfifo;
	int invalid_mstrid;
	unsigned int ahb_buf_size;
	unsigned int quirks;
	bool little_endian;
};

struct fsl_qspi {
	void *iobase;
	void *ahb_addr;
	u32 memmap_phy;
	struct clk *clk;
	struct clk *clk_en;
	struct device *dev;
	struct completion c;
	const struct fsl_qspi_devtype_data *devtype_data;
	struct mutex lock;
	struct pm_qos_request pm_qos_req;
	int selected;
};

struct nxp_fspi_devtype_data {
	unsigned int rxfifo;
	unsigned int txfifo;
	unsigned int ahb_buf_size;
	unsigned int quirks;
	bool little_endian;
};

struct nxp_fspi {
	void *iobase;
	void *ahb_addr;
	u32 memmap_phy;
	u32 memmap_phy_size;
	u32 memmap_start;
	u32 memmap_len;
	struct clk *clk;
	struct clk *clk_en;
	struct device *dev;
	struct completion c;
	struct nxp_fspi_devtype_data *devtype_data;
	struct mutex lock;
	struct pm_qos_request pm_qos_req;
	int selected;
};

enum ssp_loopback {
	LOOPBACK_DISABLED = 0,
	LOOPBACK_ENABLED = 1,
};

enum ssp_interface {
	SSP_INTERFACE_MOTOROLA_SPI = 0,
	SSP_INTERFACE_TI_SYNC_SERIAL = 1,
	SSP_INTERFACE_NATIONAL_MICROWIRE = 2,
	SSP_INTERFACE_UNIDIRECTIONAL = 3,
};

enum ssp_hierarchy {
	SSP_MASTER = 0,
	SSP_SLAVE = 1,
};

struct ssp_clock_params {
	u8 cpsdvsr;
	u8 scr;
};

enum ssp_rx_endian {
	SSP_RX_MSB = 0,
	SSP_RX_LSB = 1,
};

enum ssp_tx_endian {
	SSP_TX_MSB = 0,
	SSP_TX_LSB = 1,
};

enum ssp_data_size {
	SSP_DATA_BITS_4 = 3,
	SSP_DATA_BITS_5 = 4,
	SSP_DATA_BITS_6 = 5,
	SSP_DATA_BITS_7 = 6,
	SSP_DATA_BITS_8 = 7,
	SSP_DATA_BITS_9 = 8,
	SSP_DATA_BITS_10 = 9,
	SSP_DATA_BITS_11 = 10,
	SSP_DATA_BITS_12 = 11,
	SSP_DATA_BITS_13 = 12,
	SSP_DATA_BITS_14 = 13,
	SSP_DATA_BITS_15 = 14,
	SSP_DATA_BITS_16 = 15,
	SSP_DATA_BITS_17 = 16,
	SSP_DATA_BITS_18 = 17,
	SSP_DATA_BITS_19 = 18,
	SSP_DATA_BITS_20 = 19,
	SSP_DATA_BITS_21 = 20,
	SSP_DATA_BITS_22 = 21,
	SSP_DATA_BITS_23 = 22,
	SSP_DATA_BITS_24 = 23,
	SSP_DATA_BITS_25 = 24,
	SSP_DATA_BITS_26 = 25,
	SSP_DATA_BITS_27 = 26,
	SSP_DATA_BITS_28 = 27,
	SSP_DATA_BITS_29 = 28,
	SSP_DATA_BITS_30 = 29,
	SSP_DATA_BITS_31 = 30,
	SSP_DATA_BITS_32 = 31,
};

enum ssp_mode {
	INTERRUPT_TRANSFER = 0,
	POLLING_TRANSFER = 1,
	DMA_TRANSFER = 2,
};

enum ssp_rx_level_trig {
	SSP_RX_1_OR_MORE_ELEM = 0,
	SSP_RX_4_OR_MORE_ELEM = 1,
	SSP_RX_8_OR_MORE_ELEM = 2,
	SSP_RX_16_OR_MORE_ELEM = 3,
	SSP_RX_32_OR_MORE_ELEM = 4,
};

enum ssp_tx_level_trig {
	SSP_TX_1_OR_MORE_EMPTY_LOC = 0,
	SSP_TX_4_OR_MORE_EMPTY_LOC = 1,
	SSP_TX_8_OR_MORE_EMPTY_LOC = 2,
	SSP_TX_16_OR_MORE_EMPTY_LOC = 3,
	SSP_TX_32_OR_MORE_EMPTY_LOC = 4,
};

enum ssp_spi_clk_phase {
	SSP_CLK_FIRST_EDGE = 0,
	SSP_CLK_SECOND_EDGE = 1,
};

enum ssp_spi_clk_pol {
	SSP_CLK_POL_IDLE_LOW = 0,
	SSP_CLK_POL_IDLE_HIGH = 1,
};

enum ssp_microwire_ctrl_len {
	SSP_BITS_4 = 3,
	SSP_BITS_5 = 4,
	SSP_BITS_6 = 5,
	SSP_BITS_7 = 6,
	SSP_BITS_8 = 7,
	SSP_BITS_9 = 8,
	SSP_BITS_10 = 9,
	SSP_BITS_11 = 10,
	SSP_BITS_12 = 11,
	SSP_BITS_13 = 12,
	SSP_BITS_14 = 13,
	SSP_BITS_15 = 14,
	SSP_BITS_16 = 15,
	SSP_BITS_17 = 16,
	SSP_BITS_18 = 17,
	SSP_BITS_19 = 18,
	SSP_BITS_20 = 19,
	SSP_BITS_21 = 20,
	SSP_BITS_22 = 21,
	SSP_BITS_23 = 22,
	SSP_BITS_24 = 23,
	SSP_BITS_25 = 24,
	SSP_BITS_26 = 25,
	SSP_BITS_27 = 26,
	SSP_BITS_28 = 27,
	SSP_BITS_29 = 28,
	SSP_BITS_30 = 29,
	SSP_BITS_31 = 30,
	SSP_BITS_32 = 31,
};

enum ssp_microwire_wait_state {
	SSP_MWIRE_WAIT_ZERO = 0,
	SSP_MWIRE_WAIT_ONE = 1,
};

enum ssp_duplex {
	SSP_MICROWIRE_CHANNEL_FULL_DUPLEX = 0,
	SSP_MICROWIRE_CHANNEL_HALF_DUPLEX = 1,
};

enum ssp_clkdelay {
	SSP_FEEDBACK_CLK_DELAY_NONE = 0,
	SSP_FEEDBACK_CLK_DELAY_1T = 1,
	SSP_FEEDBACK_CLK_DELAY_2T = 2,
	SSP_FEEDBACK_CLK_DELAY_3T = 3,
	SSP_FEEDBACK_CLK_DELAY_4T = 4,
	SSP_FEEDBACK_CLK_DELAY_5T = 5,
	SSP_FEEDBACK_CLK_DELAY_6T = 6,
	SSP_FEEDBACK_CLK_DELAY_7T = 7,
};

enum ssp_chip_select {
	SSP_CHIP_SELECT = 0,
	SSP_CHIP_DESELECT = 1,
};

struct pl022_ssp_controller {
	u16 bus_id;
	u8 enable_dma: 1;
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	int autosuspend_delay;
	bool rt;
};

struct pl022_config_chip {
	enum ssp_interface iface;
	enum ssp_hierarchy hierarchy;
	bool slave_tx_disable;
	struct ssp_clock_params clk_freq;
	enum ssp_mode com_mode;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	enum ssp_microwire_ctrl_len ctrl_len;
	enum ssp_microwire_wait_state wait_state;
	enum ssp_duplex duplex;
	enum ssp_clkdelay clkdelay;
};

enum ssp_reading {
	READING_NULL = 0,
	READING_U8 = 1,
	READING_U16 = 2,
	READING_U32 = 3,
};

enum ssp_writing {
	WRITING_NULL = 0,
	WRITING_U8 = 1,
	WRITING_U16 = 2,
	WRITING_U32 = 3,
};

struct vendor_data___2 {
	int fifodepth;
	int max_bpw;
	bool unidir;
	bool extended_cr;
	bool pl023;
	bool loopback;
	bool internal_cs_ctrl;
};

struct chip_data___2;

struct pl022 {
	struct amba_device *adev;
	struct vendor_data___2 *vendor;
	resource_size_t phybase;
	void *virtbase;
	struct clk *clk;
	struct spi_controller *master;
	struct pl022_ssp_controller *master_info;
	struct tasklet_struct pump_transfers;
	struct spi_message *cur_msg;
	struct spi_transfer *cur_transfer;
	struct chip_data___2 *cur_chip;
	bool next_msg_cs_active;
	void *tx;
	void *tx_end;
	void *rx;
	void *rx_end;
	enum ssp_reading read;
	enum ssp_writing write;
	u32 exp_fifo_level;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	struct dma_chan *dma_rx_channel;
	struct dma_chan *dma_tx_channel;
	struct sg_table sgt_rx;
	struct sg_table sgt_tx;
	char *dummypage;
	bool dma_running;
	int cur_cs;
	struct gpio_desc *cur_gpiod;
};

struct chip_data___2 {
	u32 cr0;
	u16 cr1;
	u16 dmacr;
	u16 cpsr;
	u8 n_bytes;
	bool enable_dma;
	enum ssp_reading read;
	enum ssp_writing write;
	int xfer_type;
};

struct spmi_controller;

struct spmi_device {
	struct device dev;
	struct spmi_controller *ctrl;
	u8 usid;
};

struct spmi_controller {
	struct device dev;
	unsigned int nr;
	int (*cmd)(struct spmi_controller *, u8, u8);
	int (*read_cmd)(struct spmi_controller *, u8, u8, u16, u8 *, size_t);
	int (*write_cmd)(struct spmi_controller *, u8, u8, u16, const u8 *, size_t);
};

struct spmi_driver {
	struct device_driver driver;
	int (*probe)(struct spmi_device *);
	void (*remove)(struct spmi_device *);
	void (*shutdown)(struct spmi_device *);
};

struct trace_event_raw_spmi_write_begin {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	u8 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_spmi_write_end {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	int ret;
	char __data[0];
};

struct trace_event_raw_spmi_read_begin {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	char __data[0];
};

struct trace_event_raw_spmi_read_end {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	int ret;
	u8 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_spmi_cmd {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_spmi_write_begin {
	u32 buf;
};

struct trace_event_data_offsets_spmi_write_end {};

struct trace_event_data_offsets_spmi_read_begin {};

struct trace_event_data_offsets_spmi_read_end {
	u32 buf;
};

struct trace_event_data_offsets_spmi_cmd {};

typedef void (*btf_trace_spmi_write_begin)(void *, u8, u8, u16, u8, const u8 *);

typedef void (*btf_trace_spmi_write_end)(void *, u8, u8, u16, int);

typedef void (*btf_trace_spmi_read_begin)(void *, u8, u8, u16);

typedef void (*btf_trace_spmi_read_end)(void *, u8, u8, u16, int, u8, const u8 *);

typedef void (*btf_trace_spmi_cmd)(void *, u8, u8, int);

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETIF_F_GRO_UDP_FWD_BIT = 59,
	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
	NETIF_F_HW_HSR_FWD_BIT = 62,
	NETIF_F_HW_HSR_DUP_BIT = 63,
	NETDEV_FEATURE_COUNT = 64,
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_hwtstamps {
	ktime_t hwtstamp;
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_SCHED_TSTAMP = 64,
};

struct skb_shared_info {
	__u8 flags;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	unsigned int xdp_frags_size;
	void *destructor_arg;
	skb_frag_t frags[17];
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct phylink_link_state {
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	unsigned int link: 1;
	unsigned int an_enabled: 1;
	unsigned int an_complete: 1;
};

struct phylink_mac_ops;

struct phylink_pcs_ops;

struct phylink_config;

struct phylink_pcs;

struct phylink {
	struct net_device *netdev;
	const struct phylink_mac_ops *mac_ops;
	const struct phylink_pcs_ops *pcs_ops;
	struct phylink_config *config;
	struct phylink_pcs *pcs;
	struct device *dev;
	unsigned int old_link_state: 1;
	long unsigned int phylink_disable_state;
	struct phy_device *phydev;
	phy_interface_t link_interface;
	u8 cfg_link_an_mode;
	u8 cur_link_an_mode;
	u8 link_port;
	long unsigned int supported[2];
	struct phylink_link_state link_config;
	phy_interface_t cur_interface;
	struct gpio_desc *link_gpio;
	unsigned int link_irq;
	struct timer_list link_poll;
	void (*get_fixed_state)(struct net_device *, struct phylink_link_state *);
	struct mutex state_mutex;
	struct phylink_link_state phy_state;
	struct work_struct resolve;
	unsigned int pcs_state;
	bool mac_link_dropped;
	bool using_mac_select_pcs;
	struct sfp_bus *sfp_bus;
	bool sfp_may_have_phy;
	long unsigned int sfp_support[2];
	u8 sfp_port;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

enum {
	MLO_PAUSE_NONE = 0,
	MLO_PAUSE_RX = 1,
	MLO_PAUSE_TX = 2,
	MLO_PAUSE_TXRX_MASK = 3,
	MLO_PAUSE_AN = 4,
	MLO_AN_PHY = 0,
	MLO_AN_FIXED = 1,
	MLO_AN_INBAND = 2,
	MAC_SYM_PAUSE = 1,
	MAC_ASYM_PAUSE = 2,
	MAC_10HD = 4,
	MAC_10FD = 8,
	MAC_10 = 12,
	MAC_100HD = 16,
	MAC_100FD = 32,
	MAC_100 = 48,
	MAC_1000HD = 64,
	MAC_1000FD = 128,
	MAC_1000 = 192,
	MAC_2500FD = 256,
	MAC_5000FD = 512,
	MAC_10000FD = 1024,
	MAC_20000FD = 2048,
	MAC_25000FD = 4096,
	MAC_40000FD = 8192,
	MAC_50000FD = 16384,
	MAC_56000FD = 32768,
	MAC_100000FD = 65536,
	MAC_200000FD = 131072,
	MAC_400000FD = 262144,
};

enum phylink_op_type {
	PHYLINK_NETDEV = 0,
	PHYLINK_DEV = 1,
};

struct phylink_config {
	struct device *dev;
	enum phylink_op_type type;
	bool legacy_pre_march2020;
	bool pcs_poll;
	bool poll_fixed_state;
	bool mac_managed_pm;
	bool ovr_an_inband;
	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
	long unsigned int supported_interfaces[1];
	long unsigned int mac_capabilities;
};

struct phylink_mac_ops {
	void (*validate)(struct phylink_config *, long unsigned int *, struct phylink_link_state *);
	struct phylink_pcs * (*mac_select_pcs)(struct phylink_config *, phy_interface_t);
	void (*mac_pcs_get_state)(struct phylink_config *, struct phylink_link_state *);
	int (*mac_prepare)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_config)(struct phylink_config *, unsigned int, const struct phylink_link_state *);
	int (*mac_finish)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_an_restart)(struct phylink_config *);
	void (*mac_link_down)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_link_up)(struct phylink_config *, struct phy_device *, unsigned int, phy_interface_t, int, int, bool, bool);
};

struct phylink_pcs {
	const struct phylink_pcs_ops *ops;
	bool poll;
};

struct phylink_pcs_ops {
	int (*pcs_validate)(struct phylink_pcs *, long unsigned int *, const struct phylink_link_state *);
	int (*pcs_enable)(struct phylink_pcs *);
	void (*pcs_disable)(struct phylink_pcs *);
	void (*pcs_get_state)(struct phylink_pcs *, struct phylink_link_state *);
	int (*pcs_config)(struct phylink_pcs *, unsigned int, phy_interface_t, const long unsigned int *, bool);
	void (*pcs_an_restart)(struct phylink_pcs *);
	void (*pcs_link_up)(struct phylink_pcs *, unsigned int, phy_interface_t, int, int);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

enum {
	PHYLINK_DISABLE_STOPPED = 0,
	PHYLINK_DISABLE_LINK = 1,
	PHYLINK_DISABLE_MAC_WOL = 2,
	PCS_STATE_DOWN = 0,
	PCS_STATE_STARTING = 1,
	PCS_STATE_STARTED = 2,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	ETHTOOL_MSG_FEC_GET_REPLY = 30,
	ETHTOOL_MSG_FEC_NTF = 31,
	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
	ETHTOOL_MSG_STATS_GET_REPLY = 33,
	ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY = 34,
	__ETHTOOL_MSG_KERNEL_CNT = 35,
	ETHTOOL_MSG_KERNEL_MAX = 34,
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_pattern;

struct led_trigger;

struct led_classdev {
	const char *name;
	unsigned int brightness;
	unsigned int max_brightness;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	const char *hw_control_trigger;
	int (*hw_control_is_supported)(struct led_classdev *, long unsigned int);
	int (*hw_control_set)(struct led_classdev *, long unsigned int);
	int (*hw_control_get)(struct led_classdev *, long unsigned int *);
	struct device * (*hw_control_get_device)(struct led_classdev *);
	int brightness_hw_changed;
	struct kernfs_node *brightness_hw_changed_kn;
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	struct led_hw_trigger_type *trigger_type;
	rwlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

struct phy_led {
	struct list_head list;
	struct phy_device *phydev;
	struct led_classdev led_cdev;
	u8 index;
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

enum {
	ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_CODE_OK = 1,
	ETHTOOL_A_CABLE_RESULT_CODE_OPEN = 2,
	ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT = 3,
	ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT = 4,
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

struct mdio_device_id {
	__u32 phy_id;
	__u32 phy_id_mask;
};

struct clock_identity {
	u8 id[8];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_clock_info {
	struct module *owner;
	char name[32];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjfreq)(struct ptp_clock_info *, s32);
	int (*adjphase)(struct ptp_clock_info *, s32);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct nxp_c45_skb_cb {
	struct ptp_header *header;
	unsigned int type;
};

struct nxp_c45_hwts {
	u32 nsec;
	u32 sec;
	u8 domain_number;
	u16 sequence_id;
	u8 msg_type;
};

struct ptp_clock;

struct nxp_c45_phy {
	struct phy_device *phydev;
	struct mii_timestamper mii_ts;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info caps;
	struct sk_buff_head tx_queue;
	struct sk_buff_head rx_queue;
	struct mutex ptp_lock;
	int hwts_tx;
	int hwts_rx;
	u32 tx_delay;
	u32 rx_delay;
};

struct nxp_c45_phy_stats {
	const char *name;
	u8 mmd;
	u16 reg;
	u8 off;
	u16 mask;
};

struct mdiobb_ctrl;

struct mdiobb_ops {
	struct module *owner;
	void (*set_mdc)(struct mdiobb_ctrl *, int);
	void (*set_mdio_dir)(struct mdiobb_ctrl *, int);
	void (*set_mdio_data)(struct mdiobb_ctrl *, int);
	int (*get_mdio_data)(struct mdiobb_ctrl *);
};

struct mdiobb_ctrl {
	const struct mdiobb_ops *ops;
	unsigned int override_op_c22;
	u8 op_c22_read;
	u8 op_c22_write;
};

struct mdio_mux_child_bus;

struct mdio_mux_parent_bus {
	struct mii_bus *mii_bus;
	int current_child;
	int parent_id;
	void *switch_data;
	int (*switch_fn)(int, int, void *);
	struct mdio_mux_child_bus *children;
};

struct mdio_mux_child_bus {
	struct mii_bus *mii_bus;
	struct mdio_mux_parent_bus *parent;
	struct mdio_mux_child_bus *next;
	int bus_number;
};

struct mdio_mux_mmioreg_state {
	void *mux_handle;
	phys_addr_t phys;
	unsigned int iosize;
	unsigned int mask;
};

struct mux_control;

struct mdio_mux_multiplexer_state {
	struct mux_control *muxc;
	bool do_deselect;
	void *mux_handle;
};

struct lynx_pcs {
	struct phylink_pcs pcs;
	struct mdio_device *mdio;
};

enum sgmii_speed {
	SGMII_SPEED_10 = 0,
	SGMII_SPEED_100 = 1,
	SGMII_SPEED_1000 = 2,
	SGMII_SPEED_2500 = 2,
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[28];
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct nf_conntrack {
	refcount_t use;
};

enum {
	SKBFL_ZEROCOPY_ENABLE = 1,
	SKBFL_SHARED_FRAG = 2,
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info {
	void (*callback)(struct sk_buff *, struct ubuf_info *, bool);
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	refcount_t refcnt;
	u8 flags;
	struct mmpin mmp;
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

struct netdev_hw_addr {
	struct list_head list;
	struct rb_node node;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	int defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
	struct task_struct *thread;
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_CONSUMED = 4,
};

typedef enum gro_result gro_result_t;

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	unsigned int process_queue_empty;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct {
		u16 recursion;
		u8 more;
	} xmit;
	long: 64;
	long: 64;
	long: 64;
	unsigned int input_queue_head;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_STATS_STD = 16,
	ETH_SS_STATS_ETH_PHY = 17,
	ETH_SS_STATS_ETH_MAC = 18,
	ETH_SS_STATS_ETH_CTRL = 19,
	ETH_SS_STATS_RMON = 20,
	ETH_SS_COUNT = 21,
};

struct virtio_net_config {
	__u8 mac[6];
	__virtio16 status;
	__virtio16 max_virtqueue_pairs;
	__virtio16 mtu;
	__le32 speed;
	__u8 duplex;
	__u8 rss_max_key_size;
	__le16 rss_max_indirection_table_length;
	__le32 supported_hash_types;
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

typedef __u8 virtio_net_ctrl_ack;

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct failover {
	struct list_head list;
	struct net_device *failover_dev;
	struct failover_ops *ops;
};

struct ewma_pkt_len {
	long unsigned int internal;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 xdp_tx;
	u64 xdp_tx_drops;
	u64 kicks;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 drops;
	u64 xdp_packets;
	u64 xdp_tx;
	u64 xdp_redirects;
	u64 xdp_drops;
	u64 kicks;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[40];
	struct virtnet_sq_stats stats;
	struct napi_struct napi;
};

struct receive_queue {
	struct virtqueue *vq;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct virtnet_rq_stats stats;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[40];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
	struct virtio_net_ctrl_mq mq;
	u8 promisc;
	u8 allmulti;
	__virtio16 vid;
	__virtio64 offloads;
};

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool xdp_enabled;
	bool big_packets;
	bool mergeable_rx_bufs;
	bool has_cvq;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	bool refill_enabled;
	spinlock_t refill_lock;
	struct work_struct config_work;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	long unsigned int guest_offloads;
	long unsigned int guest_offloads_capable;
	struct failover *failover;
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_pci_sf_attrs {
	u32 controller;
	u32 sf;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
		struct devlink_port_pci_sf_attrs pci_sf;
	};
};

struct devlink;

struct devlink_rate;

struct devlink_port {
	struct list_head list;
	struct list_head param_list;
	struct list_head region_list;
	struct devlink *devlink;
	unsigned int index;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_rate *devlink_rate;
};

struct dsa_device_ops;

struct dsa_switch_tree;

struct dsa_switch;

struct dsa_netdevice_ops;

struct dsa_port {
	union {
		struct net_device *master;
		struct net_device *slave;
	};
	const struct dsa_device_ops *tag_ops;
	struct dsa_switch_tree *dst;
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
	enum {
		DSA_PORT_TYPE_UNUSED = 0,
		DSA_PORT_TYPE_CPU = 1,
		DSA_PORT_TYPE_DSA = 2,
		DSA_PORT_TYPE_USER = 3,
	} type;
	struct dsa_switch *ds;
	unsigned int index;
	const char *name;
	struct dsa_port *cpu_dp;
	u8 mac[6];
	struct device_node *dn;
	unsigned int ageing_time;
	bool vlan_filtering;
	bool learning;
	u8 stp_state;
	struct net_device *bridge_dev;
	int bridge_num;
	struct devlink_port devlink_port;
	bool devlink_port_setup;
	struct phylink *pl;
	struct phylink_config pl_config;
	struct net_device *lag_dev;
	bool lag_tx_enabled;
	struct net_device *hsr_dev;
	struct list_head list;
	void *priv;
	const struct ethtool_ops *orig_ethtool_ops;
	const struct dsa_netdevice_ops *netdev_ops;
	struct list_head fdbs;
	struct list_head mdbs;
	bool setup;
	u8 master_admin_up: 1;
	u8 master_oper_up: 1;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
	NETDEV_LAG_HASH_UNKNOWN = 7,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	__TCA_MAX = 16,
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_WAKE = 19,
	FLOW_ACTION_QUEUE = 20,
	FLOW_ACTION_SAMPLE = 21,
	FLOW_ACTION_POLICE = 22,
	FLOW_ACTION_CT = 23,
	FLOW_ACTION_CT_METADATA = 24,
	FLOW_ACTION_MPLS_PUSH = 25,
	FLOW_ACTION_MPLS_POP = 26,
	FLOW_ACTION_MPLS_MANGLE = 27,
	FLOW_ACTION_GATE = 28,
	FLOW_ACTION_PPPOE_PUSH = 29,
	NUM_FLOW_ACTIONS = 30,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

typedef void (*action_destr)(void *);

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

struct nf_flowtable;

struct ip_tunnel_info;

struct psample_group;

struct action_gate_entry;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 index;
			u32 burst;
			u64 rate_bytes_ps;
			u64 burst_pkt;
			u64 rate_pkt_ps;
			u32 mtu;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
			bool orig_dir;
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			u32 index;
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
		struct {
			u16 sid;
		} pppoe;
	};
	struct flow_action_cookie *cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct dsa_chip_data {
	struct device *host_dev;
	int sw_addr;
	struct device *netdev[12];
	int eeprom_len;
	struct device_node *of_node;
	char *port_names[12];
	struct device_node *port_dn[12];
	s8 rtable[4];
};

struct dsa_platform_data {
	struct device *netdev;
	struct net_device *of_netdev;
	int nr_chips;
	struct dsa_chip_data *chip;
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_rate_type {
	DEVLINK_RATE_TYPE_LEAF = 0,
	DEVLINK_RATE_TYPE_NODE = 1,
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

enum devlink_port_fn_state {
	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
};

enum devlink_port_fn_opstate {
	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	u32 index;
	struct list_head port_list;
	struct list_head rate_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	const struct devlink_ops *ops;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	u8 reload_failed: 1;
	u8 reload_enabled: 1;
	refcount_t refcount;
	struct completion comp;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_sb_pool_info;

struct devlink_info_req;

struct devlink_flash_update_params;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_trap_policer;

struct devlink_port_new_attrs;

struct devlink_ops {
	u32 supported_flash_update_params;
	long unsigned int reload_actions;
	long unsigned int reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, unsigned int, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_drop_counter_get)(struct devlink *, const struct devlink_trap *, u64 *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_function_hw_addr_get)(struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_function_hw_addr_set)(struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
	int (*port_new)(struct devlink *, const struct devlink_port_new_attrs *, struct netlink_ext_ack *, unsigned int *);
	int (*port_del)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*port_fn_state_get)(struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
	int (*port_fn_state_set)(struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
	int (*rate_leaf_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_leaf_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_new)(struct devlink_rate *, void **, struct netlink_ext_ack *);
	int (*rate_node_del)(struct devlink_rate *, void *, struct netlink_ext_ack *);
	int (*rate_leaf_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
	int (*rate_node_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
};

struct devlink_rate {
	struct list_head list;
	enum devlink_rate_type type;
	struct devlink *devlink;
	void *priv;
	u64 tx_share;
	u64 tx_max;
	struct devlink_rate *parent;
	union {
		struct devlink_port *devlink_port;
		struct {
			char *name;
			refcount_t refcnt;
		};
	};
};

struct devlink_port_new_attrs {
	enum devlink_port_flavour flavour;
	unsigned int port_index;
	u32 controller;
	u32 sfnum;
	u16 pfnum;
	u8 port_index_valid: 1;
	u8 controller_valid: 1;
	u8 sfnum_valid: 1;
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct devlink_flash_update_params {
	const struct firmware *fw;
	const char *component;
	u32 overwrite_mask;
};

struct devlink_trap_policer {
	u32 id;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct switchdev_brport_flags {
	long unsigned int val;
	long unsigned int mask;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
	SWITCHDEV_OBJ_ID_MRP = 4,
	SWITCHDEV_OBJ_ID_RING_TEST_MRP = 5,
	SWITCHDEV_OBJ_ID_RING_ROLE_MRP = 6,
	SWITCHDEV_OBJ_ID_RING_STATE_MRP = 7,
	SWITCHDEV_OBJ_ID_IN_TEST_MRP = 8,
	SWITCHDEV_OBJ_ID_IN_ROLE_MRP = 9,
	SWITCHDEV_OBJ_ID_IN_STATE_MRP = 10,
};

struct switchdev_obj {
	struct list_head list;
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_vlan {
	struct switchdev_obj obj;
	u16 flags;
	u16 vid;
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

struct switchdev_obj_mrp {
	struct switchdev_obj obj;
	struct net_device *p_port;
	struct net_device *s_port;
	u32 ring_id;
	u16 prio;
};

struct switchdev_obj_ring_role_mrp {
	struct switchdev_obj obj;
	u8 ring_role;
	u32 ring_id;
	u8 sw_backup;
};

enum dsa_tag_protocol {
	DSA_TAG_PROTO_NONE = 0,
	DSA_TAG_PROTO_BRCM = 1,
	DSA_TAG_PROTO_BRCM_LEGACY = 22,
	DSA_TAG_PROTO_BRCM_PREPEND = 2,
	DSA_TAG_PROTO_DSA = 3,
	DSA_TAG_PROTO_EDSA = 4,
	DSA_TAG_PROTO_GSWIP = 5,
	DSA_TAG_PROTO_KSZ9477 = 6,
	DSA_TAG_PROTO_KSZ9893 = 7,
	DSA_TAG_PROTO_LAN9303 = 8,
	DSA_TAG_PROTO_MTK = 9,
	DSA_TAG_PROTO_QCA = 10,
	DSA_TAG_PROTO_TRAILER = 11,
	DSA_TAG_PROTO_8021Q = 12,
	DSA_TAG_PROTO_SJA1105 = 13,
	DSA_TAG_PROTO_KSZ8795 = 14,
	DSA_TAG_PROTO_OCELOT = 15,
	DSA_TAG_PROTO_AR9331 = 16,
	DSA_TAG_PROTO_RTL4_A = 17,
	DSA_TAG_PROTO_HELLCREEK = 18,
	DSA_TAG_PROTO_XRS700X = 19,
	DSA_TAG_PROTO_OCELOT_8021Q = 20,
	DSA_TAG_PROTO_SEVILLE = 21,
	DSA_TAG_PROTO_SJA1110 = 23,
};

struct dsa_device_ops {
	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
	void (*flow_dissect)(const struct sk_buff *, __be16 *, int *);
	int (*connect)(struct dsa_switch *);
	void (*disconnect)(struct dsa_switch *);
	unsigned int needed_headroom;
	unsigned int needed_tailroom;
	const char *name;
	enum dsa_tag_protocol proto;
	bool promisc_on_master;
};

struct dsa_switch_ops;

struct dsa_8021q_context;

struct dsa_switch {
	bool setup;
	struct device *dev;
	struct dsa_switch_tree *dst;
	unsigned int index;
	struct notifier_block nb;
	void *priv;
	void *tagger_data;
	struct dsa_chip_data *cd;
	const struct dsa_switch_ops *ops;
	u32 phys_mii_mask;
	struct mii_bus *slave_mii_bus;
	unsigned int ageing_time_min;
	unsigned int ageing_time_max;
	struct dsa_8021q_context *tag_8021q_ctx;
	struct devlink *devlink;
	unsigned int num_tx_queues;
	bool vlan_filtering_is_global;
	bool needs_standalone_vlan_filtering;
	bool configure_vlan_while_not_filtering;
	bool untag_bridge_pvid;
	bool assisted_learning_on_cpu_port;
	bool vlan_filtering;
	bool pcs_poll;
	bool mtu_enforcement_ingress;
	unsigned int num_lag_ids;
	unsigned int num_fwd_offloading_bridges;
	size_t num_ports;
};

struct dsa_netdevice_ops {
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
};

struct dsa_switch_tree {
	struct list_head list;
	struct raw_notifier_head nh;
	unsigned int index;
	struct kref refcount;
	bool setup;
	const struct dsa_device_ops *tag_ops;
	enum dsa_tag_protocol default_proto;
	struct dsa_platform_data *pd;
	struct list_head ports;
	struct list_head rtable;
	struct net_device **lags;
	unsigned int lags_len;
	unsigned int last_switch;
};

struct dsa_mall_mirror_tc_entry {
	u8 to_local_port;
	bool ingress;
};

struct dsa_mall_policer_tc_entry {
	u32 burst;
	u64 rate_bytes_per_sec;
};

struct dsa_link {
	struct dsa_port *dp;
	struct dsa_port *link_dp;
	struct list_head list;
};

typedef int dsa_fdb_dump_cb_t(const unsigned char *, u16, bool, void *);

struct dsa_switch_ops {
	enum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*change_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*connect_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
	int (*setup)(struct dsa_switch *);
	void (*teardown)(struct dsa_switch *);
	int (*port_setup)(struct dsa_switch *, int);
	void (*port_teardown)(struct dsa_switch *, int);
	u32 (*get_phy_flags)(struct dsa_switch *, int);
	int (*phy_read)(struct dsa_switch *, int, int);
	int (*phy_write)(struct dsa_switch *, int, int, u16);
	void (*adjust_link)(struct dsa_switch *, int, struct phy_device *);
	void (*fixed_link_update)(struct dsa_switch *, int, struct fixed_phy_status *);
	void (*phylink_get_caps)(struct dsa_switch *, int, struct phylink_config *);
	void (*phylink_validate)(struct dsa_switch *, int, long unsigned int *, struct phylink_link_state *);
	struct phylink_pcs * (*phylink_mac_select_pcs)(struct dsa_switch *, int, phy_interface_t);
	int (*phylink_mac_link_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*phylink_mac_config)(struct dsa_switch *, int, unsigned int, const struct phylink_link_state *);
	void (*phylink_mac_an_restart)(struct dsa_switch *, int);
	void (*phylink_mac_link_down)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_link_up)(struct dsa_switch *, int, unsigned int, phy_interface_t, struct phy_device *, int, int, bool, bool);
	void (*phylink_fixed_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*get_strings)(struct dsa_switch *, int, u32, uint8_t *);
	void (*get_ethtool_stats)(struct dsa_switch *, int, uint64_t *);
	int (*get_sset_count)(struct dsa_switch *, int, int);
	void (*get_ethtool_phy_stats)(struct dsa_switch *, int, uint64_t *);
	void (*get_stats64)(struct dsa_switch *, int, struct rtnl_link_stats64 *);
	void (*self_test)(struct dsa_switch *, int, struct ethtool_test *, u64 *);
	void (*get_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*set_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*get_ts_info)(struct dsa_switch *, int, struct ethtool_ts_info *);
	int (*suspend)(struct dsa_switch *);
	int (*resume)(struct dsa_switch *);
	int (*port_enable)(struct dsa_switch *, int, struct phy_device *);
	void (*port_disable)(struct dsa_switch *, int);
	int (*set_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_eeprom_len)(struct dsa_switch *);
	int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*get_regs_len)(struct dsa_switch *, int);
	void (*get_regs)(struct dsa_switch *, int, struct ethtool_regs *, void *);
	int (*port_prechangeupper)(struct dsa_switch *, int, struct netdev_notifier_changeupper_info *);
	int (*set_ageing_time)(struct dsa_switch *, unsigned int);
	int (*port_bridge_join)(struct dsa_switch *, int, struct net_device *);
	void (*port_bridge_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_bridge_tx_fwd_offload)(struct dsa_switch *, int, struct net_device *, int);
	void (*port_bridge_tx_fwd_unoffload)(struct dsa_switch *, int, struct net_device *, int);
	void (*port_stp_state_set)(struct dsa_switch *, int, u8);
	void (*port_fast_age)(struct dsa_switch *, int);
	int (*port_pre_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	int (*port_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	int (*port_vlan_filtering)(struct dsa_switch *, int, bool, struct netlink_ext_ack *);
	int (*port_vlan_add)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *, struct netlink_ext_ack *);
	int (*port_vlan_del)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	int (*port_fdb_add)(struct dsa_switch *, int, const unsigned char *, u16);
	int (*port_fdb_del)(struct dsa_switch *, int, const unsigned char *, u16);
	int (*port_fdb_dump)(struct dsa_switch *, int, dsa_fdb_dump_cb_t *, void *);
	int (*port_mdb_add)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	int (*port_mdb_del)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	int (*get_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *);
	int (*cls_flower_add)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_del)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_stats)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*port_mirror_add)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *, bool);
	void (*port_mirror_del)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *);
	int (*port_policer_add)(struct dsa_switch *, int, struct dsa_mall_policer_tc_entry *);
	void (*port_policer_del)(struct dsa_switch *, int);
	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
	int (*crosschip_bridge_join)(struct dsa_switch *, int, int, int, struct net_device *);
	void (*crosschip_bridge_leave)(struct dsa_switch *, int, int, int, struct net_device *);
	int (*crosschip_lag_change)(struct dsa_switch *, int, int);
	int (*crosschip_lag_join)(struct dsa_switch *, int, int, struct net_device *, struct netdev_lag_upper_info *);
	int (*crosschip_lag_leave)(struct dsa_switch *, int, int, struct net_device *);
	int (*port_hwtstamp_get)(struct dsa_switch *, int, struct ifreq *);
	int (*port_hwtstamp_set)(struct dsa_switch *, int, struct ifreq *);
	void (*port_txtstamp)(struct dsa_switch *, int, struct sk_buff *);
	bool (*port_rxtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
	int (*devlink_param_get)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_param_set)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_info_get)(struct dsa_switch *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*devlink_sb_pool_get)(struct dsa_switch *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*devlink_sb_pool_set)(struct dsa_switch *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*devlink_sb_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *);
	int (*devlink_sb_port_pool_set)(struct dsa_switch *, int, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_tc_pool_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*devlink_sb_tc_pool_bind_set)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_occ_snapshot)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_max_clear)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *, u32 *);
	int (*devlink_sb_occ_tc_port_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*port_change_mtu)(struct dsa_switch *, int, int);
	int (*port_max_mtu)(struct dsa_switch *, int);
	int (*port_lag_change)(struct dsa_switch *, int);
	int (*port_lag_join)(struct dsa_switch *, int, struct net_device *, struct netdev_lag_upper_info *);
	int (*port_lag_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_hsr_join)(struct dsa_switch *, int, struct net_device *);
	int (*port_hsr_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_mrp_add)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_del)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_add_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*port_mrp_del_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*tag_8021q_vlan_add)(struct dsa_switch *, int, u16, u16);
	int (*tag_8021q_vlan_del)(struct dsa_switch *, int, u16);
	void (*master_state_change)(struct dsa_switch *, const struct net_device *, bool);
};

struct dsa_8021q_context {
	struct dsa_switch *ds;
	struct list_head vlans;
	__be16 proto;
};

enum ocelot_target {
	ANA = 1,
	QS = 2,
	QSYS = 3,
	REW = 4,
	SYS = 5,
	S0 = 6,
	S1 = 7,
	S2 = 8,
	HSIO = 9,
	PTP = 10,
	GCB = 11,
	DEV_GMII = 12,
	TARGET_MAX = 13,
};

enum ocelot_reg {
	ANA_ADVLEARN = 16777216,
	ANA_VLANMASK = 16777217,
	ANA_PORT_B_DOMAIN = 16777218,
	ANA_ANAGEFIL = 16777219,
	ANA_ANEVENTS = 16777220,
	ANA_STORMLIMIT_BURST = 16777221,
	ANA_STORMLIMIT_CFG = 16777222,
	ANA_ISOLATED_PORTS = 16777223,
	ANA_COMMUNITY_PORTS = 16777224,
	ANA_AUTOAGE = 16777225,
	ANA_MACTOPTIONS = 16777226,
	ANA_LEARNDISC = 16777227,
	ANA_AGENCTRL = 16777228,
	ANA_MIRRORPORTS = 16777229,
	ANA_EMIRRORPORTS = 16777230,
	ANA_FLOODING = 16777231,
	ANA_FLOODING_IPMC = 16777232,
	ANA_SFLOW_CFG = 16777233,
	ANA_PORT_MODE = 16777234,
	ANA_CUT_THRU_CFG = 16777235,
	ANA_PGID_PGID = 16777236,
	ANA_TABLES_ANMOVED = 16777237,
	ANA_TABLES_MACHDATA = 16777238,
	ANA_TABLES_MACLDATA = 16777239,
	ANA_TABLES_STREAMDATA = 16777240,
	ANA_TABLES_MACACCESS = 16777241,
	ANA_TABLES_MACTINDX = 16777242,
	ANA_TABLES_VLANACCESS = 16777243,
	ANA_TABLES_VLANTIDX = 16777244,
	ANA_TABLES_ISDXACCESS = 16777245,
	ANA_TABLES_ISDXTIDX = 16777246,
	ANA_TABLES_ENTRYLIM = 16777247,
	ANA_TABLES_PTP_ID_HIGH = 16777248,
	ANA_TABLES_PTP_ID_LOW = 16777249,
	ANA_TABLES_STREAMACCESS = 16777250,
	ANA_TABLES_STREAMTIDX = 16777251,
	ANA_TABLES_SEQ_HISTORY = 16777252,
	ANA_TABLES_SEQ_MASK = 16777253,
	ANA_TABLES_SFID_MASK = 16777254,
	ANA_TABLES_SFIDACCESS = 16777255,
	ANA_TABLES_SFIDTIDX = 16777256,
	ANA_MSTI_STATE = 16777257,
	ANA_OAM_UPM_LM_CNT = 16777258,
	ANA_SG_ACCESS_CTRL = 16777259,
	ANA_SG_CONFIG_REG_1 = 16777260,
	ANA_SG_CONFIG_REG_2 = 16777261,
	ANA_SG_CONFIG_REG_3 = 16777262,
	ANA_SG_CONFIG_REG_4 = 16777263,
	ANA_SG_CONFIG_REG_5 = 16777264,
	ANA_SG_GCL_GS_CONFIG = 16777265,
	ANA_SG_GCL_TI_CONFIG = 16777266,
	ANA_SG_STATUS_REG_1 = 16777267,
	ANA_SG_STATUS_REG_2 = 16777268,
	ANA_SG_STATUS_REG_3 = 16777269,
	ANA_PORT_VLAN_CFG = 16777270,
	ANA_PORT_DROP_CFG = 16777271,
	ANA_PORT_QOS_CFG = 16777272,
	ANA_PORT_VCAP_CFG = 16777273,
	ANA_PORT_VCAP_S1_KEY_CFG = 16777274,
	ANA_PORT_VCAP_S2_CFG = 16777275,
	ANA_PORT_PCP_DEI_MAP = 16777276,
	ANA_PORT_CPU_FWD_CFG = 16777277,
	ANA_PORT_CPU_FWD_BPDU_CFG = 16777278,
	ANA_PORT_CPU_FWD_GARP_CFG = 16777279,
	ANA_PORT_CPU_FWD_CCM_CFG = 16777280,
	ANA_PORT_PORT_CFG = 16777281,
	ANA_PORT_POL_CFG = 16777282,
	ANA_PORT_PTP_CFG = 16777283,
	ANA_PORT_PTP_DLY1_CFG = 16777284,
	ANA_PORT_PTP_DLY2_CFG = 16777285,
	ANA_PORT_SFID_CFG = 16777286,
	ANA_PFC_PFC_CFG = 16777287,
	ANA_PFC_PFC_TIMER = 16777288,
	ANA_IPT_OAM_MEP_CFG = 16777289,
	ANA_IPT_IPT = 16777290,
	ANA_PPT_PPT = 16777291,
	ANA_FID_MAP_FID_MAP = 16777292,
	ANA_AGGR_CFG = 16777293,
	ANA_CPUQ_CFG = 16777294,
	ANA_CPUQ_CFG2 = 16777295,
	ANA_CPUQ_8021_CFG = 16777296,
	ANA_DSCP_CFG = 16777297,
	ANA_DSCP_REWR_CFG = 16777298,
	ANA_VCAP_RNG_TYPE_CFG = 16777299,
	ANA_VCAP_RNG_VAL_CFG = 16777300,
	ANA_VRAP_CFG = 16777301,
	ANA_VRAP_HDR_DATA = 16777302,
	ANA_VRAP_HDR_MASK = 16777303,
	ANA_DISCARD_CFG = 16777304,
	ANA_FID_CFG = 16777305,
	ANA_POL_PIR_CFG = 16777306,
	ANA_POL_CIR_CFG = 16777307,
	ANA_POL_MODE_CFG = 16777308,
	ANA_POL_PIR_STATE = 16777309,
	ANA_POL_CIR_STATE = 16777310,
	ANA_POL_STATE = 16777311,
	ANA_POL_FLOWC = 16777312,
	ANA_POL_HYST = 16777313,
	ANA_POL_MISC_CFG = 16777314,
	QS_XTR_GRP_CFG = 33554432,
	QS_XTR_RD = 33554433,
	QS_XTR_FRM_PRUNING = 33554434,
	QS_XTR_FLUSH = 33554435,
	QS_XTR_DATA_PRESENT = 33554436,
	QS_XTR_CFG = 33554437,
	QS_INJ_GRP_CFG = 33554438,
	QS_INJ_WR = 33554439,
	QS_INJ_CTRL = 33554440,
	QS_INJ_STATUS = 33554441,
	QS_INJ_ERR = 33554442,
	QS_INH_DBG = 33554443,
	QSYS_PORT_MODE = 50331648,
	QSYS_SWITCH_PORT_MODE = 50331649,
	QSYS_STAT_CNT_CFG = 50331650,
	QSYS_EEE_CFG = 50331651,
	QSYS_EEE_THRES = 50331652,
	QSYS_IGR_NO_SHARING = 50331653,
	QSYS_EGR_NO_SHARING = 50331654,
	QSYS_SW_STATUS = 50331655,
	QSYS_EXT_CPU_CFG = 50331656,
	QSYS_PAD_CFG = 50331657,
	QSYS_CPU_GROUP_MAP = 50331658,
	QSYS_QMAP = 50331659,
	QSYS_ISDX_SGRP = 50331660,
	QSYS_TIMED_FRAME_ENTRY = 50331661,
	QSYS_TFRM_MISC = 50331662,
	QSYS_TFRM_PORT_DLY = 50331663,
	QSYS_TFRM_TIMER_CFG_1 = 50331664,
	QSYS_TFRM_TIMER_CFG_2 = 50331665,
	QSYS_TFRM_TIMER_CFG_3 = 50331666,
	QSYS_TFRM_TIMER_CFG_4 = 50331667,
	QSYS_TFRM_TIMER_CFG_5 = 50331668,
	QSYS_TFRM_TIMER_CFG_6 = 50331669,
	QSYS_TFRM_TIMER_CFG_7 = 50331670,
	QSYS_TFRM_TIMER_CFG_8 = 50331671,
	QSYS_RED_PROFILE = 50331672,
	QSYS_RES_QOS_MODE = 50331673,
	QSYS_RES_CFG = 50331674,
	QSYS_RES_STAT = 50331675,
	QSYS_EGR_DROP_MODE = 50331676,
	QSYS_EQ_CTRL = 50331677,
	QSYS_EVENTS_CORE = 50331678,
	QSYS_QMAXSDU_CFG_0 = 50331679,
	QSYS_QMAXSDU_CFG_1 = 50331680,
	QSYS_QMAXSDU_CFG_2 = 50331681,
	QSYS_QMAXSDU_CFG_3 = 50331682,
	QSYS_QMAXSDU_CFG_4 = 50331683,
	QSYS_QMAXSDU_CFG_5 = 50331684,
	QSYS_QMAXSDU_CFG_6 = 50331685,
	QSYS_QMAXSDU_CFG_7 = 50331686,
	QSYS_PREEMPTION_CFG = 50331687,
	QSYS_CIR_CFG = 50331688,
	QSYS_EIR_CFG = 50331689,
	QSYS_SE_CFG = 50331690,
	QSYS_SE_DWRR_CFG = 50331691,
	QSYS_SE_CONNECT = 50331692,
	QSYS_SE_DLB_SENSE = 50331693,
	QSYS_CIR_STATE = 50331694,
	QSYS_EIR_STATE = 50331695,
	QSYS_SE_STATE = 50331696,
	QSYS_HSCH_MISC_CFG = 50331697,
	QSYS_TAG_CONFIG = 50331698,
	QSYS_TAS_PARAM_CFG_CTRL = 50331699,
	QSYS_PORT_MAX_SDU = 50331700,
	QSYS_PARAM_CFG_REG_1 = 50331701,
	QSYS_PARAM_CFG_REG_2 = 50331702,
	QSYS_PARAM_CFG_REG_3 = 50331703,
	QSYS_PARAM_CFG_REG_4 = 50331704,
	QSYS_PARAM_CFG_REG_5 = 50331705,
	QSYS_GCL_CFG_REG_1 = 50331706,
	QSYS_GCL_CFG_REG_2 = 50331707,
	QSYS_PARAM_STATUS_REG_1 = 50331708,
	QSYS_PARAM_STATUS_REG_2 = 50331709,
	QSYS_PARAM_STATUS_REG_3 = 50331710,
	QSYS_PARAM_STATUS_REG_4 = 50331711,
	QSYS_PARAM_STATUS_REG_5 = 50331712,
	QSYS_PARAM_STATUS_REG_6 = 50331713,
	QSYS_PARAM_STATUS_REG_7 = 50331714,
	QSYS_PARAM_STATUS_REG_8 = 50331715,
	QSYS_PARAM_STATUS_REG_9 = 50331716,
	QSYS_GCL_STATUS_REG_1 = 50331717,
	QSYS_GCL_STATUS_REG_2 = 50331718,
	REW_PORT_VLAN_CFG = 67108864,
	REW_TAG_CFG = 67108865,
	REW_PORT_CFG = 67108866,
	REW_DSCP_CFG = 67108867,
	REW_PCP_DEI_QOS_MAP_CFG = 67108868,
	REW_PTP_CFG = 67108869,
	REW_PTP_DLY1_CFG = 67108870,
	REW_RED_TAG_CFG = 67108871,
	REW_DSCP_REMAP_DP1_CFG = 67108872,
	REW_DSCP_REMAP_CFG = 67108873,
	REW_STAT_CFG = 67108874,
	REW_REW_STICKY = 67108875,
	REW_PPT = 67108876,
	SYS_COUNT_RX_OCTETS = 83886080,
	SYS_COUNT_RX_UNICAST = 83886081,
	SYS_COUNT_RX_MULTICAST = 83886082,
	SYS_COUNT_RX_BROADCAST = 83886083,
	SYS_COUNT_RX_SHORTS = 83886084,
	SYS_COUNT_RX_FRAGMENTS = 83886085,
	SYS_COUNT_RX_JABBERS = 83886086,
	SYS_COUNT_RX_CRC_ALIGN_ERRS = 83886087,
	SYS_COUNT_RX_SYM_ERRS = 83886088,
	SYS_COUNT_RX_64 = 83886089,
	SYS_COUNT_RX_65_127 = 83886090,
	SYS_COUNT_RX_128_255 = 83886091,
	SYS_COUNT_RX_256_1023 = 83886092,
	SYS_COUNT_RX_1024_1526 = 83886093,
	SYS_COUNT_RX_1527_MAX = 83886094,
	SYS_COUNT_RX_PAUSE = 83886095,
	SYS_COUNT_RX_CONTROL = 83886096,
	SYS_COUNT_RX_LONGS = 83886097,
	SYS_COUNT_RX_CLASSIFIED_DROPS = 83886098,
	SYS_COUNT_TX_OCTETS = 83886099,
	SYS_COUNT_TX_UNICAST = 83886100,
	SYS_COUNT_TX_MULTICAST = 83886101,
	SYS_COUNT_TX_BROADCAST = 83886102,
	SYS_COUNT_TX_COLLISION = 83886103,
	SYS_COUNT_TX_DROPS = 83886104,
	SYS_COUNT_TX_PAUSE = 83886105,
	SYS_COUNT_TX_64 = 83886106,
	SYS_COUNT_TX_65_127 = 83886107,
	SYS_COUNT_TX_128_511 = 83886108,
	SYS_COUNT_TX_512_1023 = 83886109,
	SYS_COUNT_TX_1024_1526 = 83886110,
	SYS_COUNT_TX_1527_MAX = 83886111,
	SYS_COUNT_TX_AGING = 83886112,
	SYS_RESET_CFG = 83886113,
	SYS_SR_ETYPE_CFG = 83886114,
	SYS_VLAN_ETYPE_CFG = 83886115,
	SYS_PORT_MODE = 83886116,
	SYS_FRONT_PORT_MODE = 83886117,
	SYS_FRM_AGING = 83886118,
	SYS_STAT_CFG = 83886119,
	SYS_SW_STATUS = 83886120,
	SYS_MISC_CFG = 83886121,
	SYS_REW_MAC_HIGH_CFG = 83886122,
	SYS_REW_MAC_LOW_CFG = 83886123,
	SYS_TIMESTAMP_OFFSET = 83886124,
	SYS_CMID = 83886125,
	SYS_PAUSE_CFG = 83886126,
	SYS_PAUSE_TOT_CFG = 83886127,
	SYS_ATOP = 83886128,
	SYS_ATOP_TOT_CFG = 83886129,
	SYS_MAC_FC_CFG = 83886130,
	SYS_MMGT = 83886131,
	SYS_MMGT_FAST = 83886132,
	SYS_EVENTS_DIF = 83886133,
	SYS_EVENTS_CORE = 83886134,
	SYS_CNT = 83886135,
	SYS_PTP_STATUS = 83886136,
	SYS_PTP_TXSTAMP = 83886137,
	SYS_PTP_NXT = 83886138,
	SYS_PTP_CFG = 83886139,
	SYS_RAM_INIT = 83886140,
	SYS_CM_ADDR = 83886141,
	SYS_CM_DATA_WR = 83886142,
	SYS_CM_DATA_RD = 83886143,
	SYS_CM_OP = 83886144,
	SYS_CM_DATA = 83886145,
	PTP_PIN_CFG = 167772160,
	PTP_PIN_TOD_SEC_MSB = 167772161,
	PTP_PIN_TOD_SEC_LSB = 167772162,
	PTP_PIN_TOD_NSEC = 167772163,
	PTP_PIN_WF_HIGH_PERIOD = 167772164,
	PTP_PIN_WF_LOW_PERIOD = 167772165,
	PTP_CFG_MISC = 167772166,
	PTP_CLK_CFG_ADJ_CFG = 167772167,
	PTP_CLK_CFG_ADJ_FREQ = 167772168,
	GCB_SOFT_RST = 184549376,
	GCB_MIIM_MII_STATUS = 184549377,
	GCB_MIIM_MII_CMD = 184549378,
	GCB_MIIM_MII_DATA = 184549379,
	DEV_CLOCK_CFG = 201326592,
	DEV_PORT_MISC = 201326593,
	DEV_EVENTS = 201326594,
	DEV_EEE_CFG = 201326595,
	DEV_RX_PATH_DELAY = 201326596,
	DEV_TX_PATH_DELAY = 201326597,
	DEV_PTP_PREDICT_CFG = 201326598,
	DEV_MAC_ENA_CFG = 201326599,
	DEV_MAC_MODE_CFG = 201326600,
	DEV_MAC_MAXLEN_CFG = 201326601,
	DEV_MAC_TAGS_CFG = 201326602,
	DEV_MAC_ADV_CHK_CFG = 201326603,
	DEV_MAC_IFG_CFG = 201326604,
	DEV_MAC_HDX_CFG = 201326605,
	DEV_MAC_DBG_CFG = 201326606,
	DEV_MAC_FC_MAC_LOW_CFG = 201326607,
	DEV_MAC_FC_MAC_HIGH_CFG = 201326608,
	DEV_MAC_STICKY = 201326609,
	PCS1G_CFG = 201326610,
	PCS1G_MODE_CFG = 201326611,
	PCS1G_SD_CFG = 201326612,
	PCS1G_ANEG_CFG = 201326613,
	PCS1G_ANEG_NP_CFG = 201326614,
	PCS1G_LB_CFG = 201326615,
	PCS1G_DBG_CFG = 201326616,
	PCS1G_CDET_CFG = 201326617,
	PCS1G_ANEG_STATUS = 201326618,
	PCS1G_ANEG_NP_STATUS = 201326619,
	PCS1G_LINK_STATUS = 201326620,
	PCS1G_LINK_DOWN_CNT = 201326621,
	PCS1G_STICKY = 201326622,
	PCS1G_DEBUG_STATUS = 201326623,
	PCS1G_LPI_CFG = 201326624,
	PCS1G_LPI_WAKE_ERROR_CNT = 201326625,
	PCS1G_LPI_STATUS = 201326626,
	PCS1G_TSTPAT_MODE_CFG = 201326627,
	PCS1G_TSTPAT_STATUS = 201326628,
	DEV_PCS_FX100_CFG = 201326629,
	DEV_PCS_FX100_STATUS = 201326630,
};

enum ocelot_regfield {
	ANA_ADVLEARN_VLAN_CHK = 0,
	ANA_ADVLEARN_LEARN_MIRROR = 1,
	ANA_ANEVENTS_FLOOD_DISCARD = 2,
	ANA_ANEVENTS_MSTI_DROP = 3,
	ANA_ANEVENTS_ACLKILL = 4,
	ANA_ANEVENTS_ACLUSED = 5,
	ANA_ANEVENTS_AUTOAGE = 6,
	ANA_ANEVENTS_VS2TTL1 = 7,
	ANA_ANEVENTS_STORM_DROP = 8,
	ANA_ANEVENTS_LEARN_DROP = 9,
	ANA_ANEVENTS_AGED_ENTRY = 10,
	ANA_ANEVENTS_CPU_LEARN_FAILED = 11,
	ANA_ANEVENTS_AUTO_LEARN_FAILED = 12,
	ANA_ANEVENTS_LEARN_REMOVE = 13,
	ANA_ANEVENTS_AUTO_LEARNED = 14,
	ANA_ANEVENTS_AUTO_MOVED = 15,
	ANA_ANEVENTS_DROPPED = 16,
	ANA_ANEVENTS_CLASSIFIED_DROP = 17,
	ANA_ANEVENTS_CLASSIFIED_COPY = 18,
	ANA_ANEVENTS_VLAN_DISCARD = 19,
	ANA_ANEVENTS_FWD_DISCARD = 20,
	ANA_ANEVENTS_MULTICAST_FLOOD = 21,
	ANA_ANEVENTS_UNICAST_FLOOD = 22,
	ANA_ANEVENTS_DEST_KNOWN = 23,
	ANA_ANEVENTS_BUCKET3_MATCH = 24,
	ANA_ANEVENTS_BUCKET2_MATCH = 25,
	ANA_ANEVENTS_BUCKET1_MATCH = 26,
	ANA_ANEVENTS_BUCKET0_MATCH = 27,
	ANA_ANEVENTS_CPU_OPERATION = 28,
	ANA_ANEVENTS_DMAC_LOOKUP = 29,
	ANA_ANEVENTS_SMAC_LOOKUP = 30,
	ANA_ANEVENTS_SEQ_GEN_ERR_0 = 31,
	ANA_ANEVENTS_SEQ_GEN_ERR_1 = 32,
	ANA_TABLES_MACACCESS_B_DOM = 33,
	ANA_TABLES_MACTINDX_BUCKET = 34,
	ANA_TABLES_MACTINDX_M_INDEX = 35,
	QSYS_SWITCH_PORT_MODE_PORT_ENA = 36,
	QSYS_SWITCH_PORT_MODE_SCH_NEXT_CFG = 37,
	QSYS_SWITCH_PORT_MODE_YEL_RSRVD = 38,
	QSYS_SWITCH_PORT_MODE_INGRESS_DROP_MODE = 39,
	QSYS_SWITCH_PORT_MODE_TX_PFC_ENA = 40,
	QSYS_SWITCH_PORT_MODE_TX_PFC_MODE = 41,
	QSYS_TIMED_FRAME_ENTRY_TFRM_VLD = 42,
	QSYS_TIMED_FRAME_ENTRY_TFRM_FP = 43,
	QSYS_TIMED_FRAME_ENTRY_TFRM_PORTNO = 44,
	QSYS_TIMED_FRAME_ENTRY_TFRM_TM_SEL = 45,
	QSYS_TIMED_FRAME_ENTRY_TFRM_TM_T = 46,
	SYS_PORT_MODE_DATA_WO_TS = 47,
	SYS_PORT_MODE_INCL_INJ_HDR = 48,
	SYS_PORT_MODE_INCL_XTR_HDR = 49,
	SYS_PORT_MODE_INCL_HDR_ERR = 50,
	SYS_RESET_CFG_CORE_ENA = 51,
	SYS_RESET_CFG_MEM_ENA = 52,
	SYS_RESET_CFG_MEM_INIT = 53,
	GCB_SOFT_RST_SWC_RST = 54,
	GCB_MIIM_MII_STATUS_PENDING = 55,
	GCB_MIIM_MII_STATUS_BUSY = 56,
	SYS_PAUSE_CFG_PAUSE_START = 57,
	SYS_PAUSE_CFG_PAUSE_STOP = 58,
	SYS_PAUSE_CFG_PAUSE_ENA = 59,
	REGFIELD_MAX = 60,
};

struct ocelot_stat_layout {
	u32 offset;
	char name[32];
};

enum ocelot_tag_prefix {
	OCELOT_TAG_PREFIX_DISABLED = 0,
	OCELOT_TAG_PREFIX_NONE = 1,
	OCELOT_TAG_PREFIX_SHORT = 2,
	OCELOT_TAG_PREFIX_LONG = 3,
};

struct ocelot;

struct ocelot_ops {
	struct net_device * (*port_to_netdev)(struct ocelot *, int);
	int (*netdev_to_port)(struct net_device *);
	int (*reset)(struct ocelot *);
	u16 (*wm_enc)(u16);
	u16 (*wm_dec)(u16);
	void (*wm_stat)(u32, u32 *, u32 *);
};

struct ocelot_vcap_block {
	struct list_head rules;
	int count;
	int pol_lpr;
};

struct ocelot_port;

struct vcap_props;

struct ocelot {
	struct device *dev;
	struct devlink *devlink;
	struct devlink_port *devlink_ports;
	const struct ocelot_ops *ops;
	struct regmap *targets[13];
	struct regmap_field *regfields[60];
	const u32 * const *map;
	const struct ocelot_stat_layout *stats_layout;
	unsigned int num_stats;
	u32 pool_size[4];
	int packet_buffer_size;
	int num_frame_refs;
	int num_mact_rows;
	struct ocelot_port **ports;
	u8 base_mac[6];
	u32 vlan_mask[4096];
	int num_flooding_pgids;
	u8 num_phys_ports;
	int npi;
	enum ocelot_tag_prefix npi_inj_prefix;
	enum ocelot_tag_prefix npi_xtr_prefix;
	struct list_head multicast;
	struct list_head pgids;
	struct list_head dummy_rules;
	struct ocelot_vcap_block block[3];
	struct vcap_props *vcap;
	struct mutex stats_lock;
	u64 *stats;
	struct delayed_work stats_work;
	struct workqueue_struct *stats_queue;
	struct workqueue_struct *owq;
	u8 ptp: 1;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_info;
	struct hwtstamp_config hwtstamp_config;
	unsigned int ptp_skbs_in_flight;
	spinlock_t ts_id_lock;
	struct mutex ptp_lock;
	spinlock_t ptp_clock_lock;
	struct ptp_pin_desc ptp_pins[4];
};

struct ocelot_vlan {
	bool valid;
	u16 vid;
};

enum ocelot_sb {
	OCELOT_SB_BUF = 0,
	OCELOT_SB_REF = 1,
	OCELOT_SB_NUM = 2,
};

enum ocelot_sb_pool {
	OCELOT_SB_POOL_ING = 0,
	OCELOT_SB_POOL_EGR = 1,
	OCELOT_SB_POOL_NUM = 2,
};

struct ocelot_port {
	struct ocelot *ocelot;
	struct regmap *target;
	bool vlan_aware;
	struct ocelot_vlan pvid_vlan;
	struct ocelot_vlan native_vlan;
	unsigned int ptp_skbs_in_flight;
	u8 ptp_cmd;
	struct sk_buff_head tx_skbs;
	u8 ts_id;
	phy_interface_t phy_mode;
	u8 *xmit_template;
	bool is_dsa_8021q_cpu;
	bool learn_ena;
	struct net_device *bond;
	bool lag_tx_active;
	u16 mrp_ring_id;
	struct net_device *bridge;
	u8 stp_state;
};

struct vcap_field;

struct vcap_props {
	u16 tg_width;
	u16 sw_count;
	u16 entry_count;
	u16 entry_words;
	u16 entry_width;
	u16 action_count;
	u16 action_words;
	u16 action_width;
	u16 action_type_width;
	struct {
		u16 width;
		u16 count;
	} action_table[2];
	u16 counter_words;
	u16 counter_width;
	enum ocelot_target target;
	const struct vcap_field *keys;
	const struct vcap_field *actions;
};

struct ocelot_policer {
	u32 rate;
	u32 burst;
};

enum {
	VCAP_ES0 = 0,
	VCAP_IS1 = 1,
	VCAP_IS2 = 2,
	__VCAP_COUNT = 3,
};

struct vcap_field {
	int offset;
	int length;
};

enum vcap_es0_key_field {
	VCAP_ES0_EGR_PORT = 0,
	VCAP_ES0_IGR_PORT = 1,
	VCAP_ES0_RSV = 2,
	VCAP_ES0_L2_MC = 3,
	VCAP_ES0_L2_BC = 4,
	VCAP_ES0_VID = 5,
	VCAP_ES0_DP = 6,
	VCAP_ES0_PCP = 7,
};

struct ocelot_ipv4 {
	u8 addr[4];
};

enum ocelot_vcap_bit {
	OCELOT_VCAP_BIT_ANY = 0,
	OCELOT_VCAP_BIT_0 = 1,
	OCELOT_VCAP_BIT_1 = 2,
};

struct ocelot_vcap_u8 {
	u8 value[1];
	u8 mask[1];
};

struct ocelot_vcap_u16 {
	u8 value[2];
	u8 mask[2];
};

struct ocelot_vcap_u32 {
	u8 value[4];
	u8 mask[4];
};

struct ocelot_vcap_u40 {
	u8 value[5];
	u8 mask[5];
};

struct ocelot_vcap_u48 {
	u8 value[6];
	u8 mask[6];
};

struct ocelot_vcap_u128 {
	u8 value[16];
	u8 mask[16];
};

struct ocelot_vcap_vid {
	u16 value;
	u16 mask;
};

struct ocelot_vcap_ipv4 {
	struct ocelot_ipv4 value;
	struct ocelot_ipv4 mask;
};

struct ocelot_vcap_udp_tcp {
	u16 value;
	u16 mask;
};

struct ocelot_vcap_port {
	u8 value;
	u8 mask;
};

enum ocelot_vcap_key_type {
	OCELOT_VCAP_KEY_ANY = 0,
	OCELOT_VCAP_KEY_ETYPE = 1,
	OCELOT_VCAP_KEY_LLC = 2,
	OCELOT_VCAP_KEY_SNAP = 3,
	OCELOT_VCAP_KEY_ARP = 4,
	OCELOT_VCAP_KEY_IPV4 = 5,
	OCELOT_VCAP_KEY_IPV6 = 6,
};

struct ocelot_vcap_key_vlan {
	struct ocelot_vcap_vid vid;
	struct ocelot_vcap_u8 pcp;
	enum ocelot_vcap_bit dei;
	enum ocelot_vcap_bit tagged;
};

struct ocelot_vcap_key_etype {
	struct ocelot_vcap_u48 dmac;
	struct ocelot_vcap_u48 smac;
	struct ocelot_vcap_u16 etype;
	struct ocelot_vcap_u16 data;
};

struct ocelot_vcap_key_llc {
	struct ocelot_vcap_u48 dmac;
	struct ocelot_vcap_u48 smac;
	struct ocelot_vcap_u32 llc;
};

struct ocelot_vcap_key_snap {
	struct ocelot_vcap_u48 dmac;
	struct ocelot_vcap_u48 smac;
	struct ocelot_vcap_u40 snap;
};

struct ocelot_vcap_key_arp {
	struct ocelot_vcap_u48 smac;
	enum ocelot_vcap_bit arp;
	enum ocelot_vcap_bit req;
	enum ocelot_vcap_bit unknown;
	enum ocelot_vcap_bit smac_match;
	enum ocelot_vcap_bit dmac_match;
	enum ocelot_vcap_bit length;
	enum ocelot_vcap_bit ip;
	enum ocelot_vcap_bit ethernet;
	struct ocelot_vcap_ipv4 sip;
	struct ocelot_vcap_ipv4 dip;
};

struct ocelot_vcap_key_ipv4 {
	enum ocelot_vcap_bit ttl;
	enum ocelot_vcap_bit fragment;
	enum ocelot_vcap_bit options;
	struct ocelot_vcap_u8 ds;
	struct ocelot_vcap_u8 proto;
	struct ocelot_vcap_ipv4 sip;
	struct ocelot_vcap_ipv4 dip;
	struct ocelot_vcap_u48 data;
	struct ocelot_vcap_udp_tcp sport;
	struct ocelot_vcap_udp_tcp dport;
	enum ocelot_vcap_bit tcp_fin;
	enum ocelot_vcap_bit tcp_syn;
	enum ocelot_vcap_bit tcp_rst;
	enum ocelot_vcap_bit tcp_psh;
	enum ocelot_vcap_bit tcp_ack;
	enum ocelot_vcap_bit tcp_urg;
	enum ocelot_vcap_bit sip_eq_dip;
	enum ocelot_vcap_bit sport_eq_dport;
	enum ocelot_vcap_bit seq_zero;
};

struct ocelot_vcap_key_ipv6 {
	struct ocelot_vcap_u8 proto;
	struct ocelot_vcap_u128 sip;
	struct ocelot_vcap_u128 dip;
	enum ocelot_vcap_bit ttl;
	struct ocelot_vcap_u8 ds;
	struct ocelot_vcap_u48 data;
	struct ocelot_vcap_udp_tcp sport;
	struct ocelot_vcap_udp_tcp dport;
	enum ocelot_vcap_bit tcp_fin;
	enum ocelot_vcap_bit tcp_syn;
	enum ocelot_vcap_bit tcp_rst;
	enum ocelot_vcap_bit tcp_psh;
	enum ocelot_vcap_bit tcp_ack;
	enum ocelot_vcap_bit tcp_urg;
	enum ocelot_vcap_bit sip_eq_dip;
	enum ocelot_vcap_bit sport_eq_dport;
	enum ocelot_vcap_bit seq_zero;
};

enum ocelot_mask_mode {
	OCELOT_MASK_MODE_NONE = 0,
	OCELOT_MASK_MODE_PERMIT_DENY = 1,
	OCELOT_MASK_MODE_POLICY = 2,
	OCELOT_MASK_MODE_REDIRECT = 3,
};

enum ocelot_es0_tag {
	OCELOT_NO_ES0_TAG = 0,
	OCELOT_ES0_TAG = 1,
	OCELOT_FORCE_PORT_TAG = 2,
	OCELOT_FORCE_UNTAG = 3,
};

enum ocelot_tag_tpid_sel {
	OCELOT_TAG_TPID_SEL_8021Q = 0,
	OCELOT_TAG_TPID_SEL_8021AD = 1,
};

struct ocelot_vcap_action {
	union {
		struct {
			enum ocelot_es0_tag push_outer_tag;
			enum ocelot_es0_tag push_inner_tag;
			enum ocelot_tag_tpid_sel tag_a_tpid_sel;
			int tag_a_vid_sel;
			int tag_a_pcp_sel;
			u16 vid_a_val;
			u8 pcp_a_val;
			u8 dei_a_val;
			enum ocelot_tag_tpid_sel tag_b_tpid_sel;
			int tag_b_vid_sel;
			int tag_b_pcp_sel;
			u16 vid_b_val;
			u8 pcp_b_val;
			u8 dei_b_val;
		};
		struct {
			bool vid_replace_ena;
			u16 vid;
			bool vlan_pop_cnt_ena;
			int vlan_pop_cnt;
			bool pcp_dei_ena;
			u8 pcp;
			u8 dei;
			bool qos_ena;
			u8 qos_val;
			u8 pag_override_mask;
			u8 pag_val;
		};
		struct {
			bool cpu_copy_ena;
			u8 cpu_qu_num;
			enum ocelot_mask_mode mask_mode;
			long unsigned int port_mask;
			bool police_ena;
			struct ocelot_policer pol;
			u32 pol_ix;
		};
	};
};

struct ocelot_vcap_stats {
	u64 bytes;
	u64 pkts;
	u64 used;
};

enum ocelot_vcap_filter_type {
	OCELOT_VCAP_FILTER_DUMMY = 0,
	OCELOT_VCAP_FILTER_PAG = 1,
	OCELOT_VCAP_FILTER_OFFLOAD = 2,
};

struct ocelot_vcap_id {
	long unsigned int cookie;
	bool tc_offload;
};

struct ocelot_vcap_filter {
	struct list_head list;
	enum ocelot_vcap_filter_type type;
	int block_id;
	int goto_target;
	int lookup;
	u8 pag;
	u16 prio;
	struct ocelot_vcap_id id;
	struct ocelot_vcap_action action;
	struct ocelot_vcap_stats stats;
	long unsigned int ingress_port_mask;
	struct ocelot_vcap_port ingress_port;
	struct ocelot_vcap_port egress_port;
	enum ocelot_vcap_bit dmac_mc;
	enum ocelot_vcap_bit dmac_bc;
	struct ocelot_vcap_key_vlan vlan;
	enum ocelot_vcap_key_type key_type;
	union {
		struct ocelot_vcap_key_etype etype;
		struct ocelot_vcap_key_llc llc;
		struct ocelot_vcap_key_snap snap;
		struct ocelot_vcap_key_arp arp;
		struct ocelot_vcap_key_ipv4 ipv4;
		struct ocelot_vcap_key_ipv6 ipv6;
	} key;
};

struct ocelot_skb_cb {
	struct sk_buff *clone;
	unsigned int ptp_class;
	u32 tstamp_lo;
	u8 ptp_cmd;
	u8 ts_id;
};

struct felix_deferred_xmit_work {
	struct dsa_port *dp;
	struct sk_buff *skb;
	struct kthread_work work;
};

struct felix_port {
	void (*xmit_work_fn)(struct kthread_work *);
	struct kthread_worker *xmit_worker;
};

struct felix_info {
	const struct resource *target_io_res;
	const struct resource *port_io_res;
	const struct resource *imdio_res;
	const struct reg_field *regfields;
	const u32 * const *map;
	const struct ocelot_ops *ops;
	int num_mact_rows;
	const struct ocelot_stat_layout *stats_layout;
	unsigned int num_stats;
	int num_ports;
	int num_tx_queues;
	struct vcap_props *vcap;
	int switch_pci_bar;
	int imdio_pci_bar;
	const struct ptp_clock_info *ptp_caps;
	bool quirk_no_xtr_irq;
	int (*mdio_bus_alloc)(struct ocelot *);
	void (*mdio_bus_free)(struct ocelot *);
	void (*phylink_validate)(struct ocelot *, int, long unsigned int *, struct phylink_link_state *);
	int (*prevalidate_phy_mode)(struct ocelot *, int, phy_interface_t);
	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
	void (*port_sched_speed_set)(struct ocelot *, int, u32);
};

struct felix {
	struct dsa_switch *ds;
	const struct felix_info *info;
	struct ocelot ocelot;
	struct mii_bus *imdio;
	struct lynx_pcs **pcs;
	resource_size_t switch_base;
	resource_size_t imdio_base;
	enum dsa_tag_protocol tag_proto;
	struct kthread_worker *xmit_worker;
};

struct enetc_hw;

struct enetc_mdio_priv {
	struct enetc_hw *hw;
	int mdio_base;
};

enum {
	VCAP_CORE_UPDATE_CTRL = 0,
	VCAP_CORE_MV_CFG = 1,
	VCAP_CACHE_ENTRY_DAT = 2,
	VCAP_CACHE_MASK_DAT = 3,
	VCAP_CACHE_ACTION_DAT = 4,
	VCAP_CACHE_CNT_DAT = 5,
	VCAP_CACHE_TG_DAT = 6,
	VCAP_CONST_VCAP_VER = 7,
	VCAP_CONST_ENTRY_WIDTH = 8,
	VCAP_CONST_ENTRY_CNT = 9,
	VCAP_CONST_ENTRY_SWCNT = 10,
	VCAP_CONST_ENTRY_TG_WIDTH = 11,
	VCAP_CONST_ACTION_DEF_CNT = 12,
	VCAP_CONST_ACTION_WIDTH = 13,
	VCAP_CONST_CNT_WIDTH = 14,
	VCAP_CONST_CORE_CNT = 15,
	VCAP_CONST_IF_CNT = 16,
};

enum {
	IS2_ACTION_TYPE_NORMAL = 0,
	IS2_ACTION_TYPE_SMAC_SIP = 1,
	IS2_ACTION_TYPE_MAX = 2,
};

enum vcap_is2_half_key_field {
	VCAP_IS2_TYPE = 0,
	VCAP_IS2_HK_FIRST = 1,
	VCAP_IS2_HK_PAG = 2,
	VCAP_IS2_HK_RSV1 = 3,
	VCAP_IS2_HK_IGR_PORT_MASK = 4,
	VCAP_IS2_HK_RSV2 = 5,
	VCAP_IS2_HK_HOST_MATCH = 6,
	VCAP_IS2_HK_L2_MC = 7,
	VCAP_IS2_HK_L2_BC = 8,
	VCAP_IS2_HK_VLAN_TAGGED = 9,
	VCAP_IS2_HK_VID = 10,
	VCAP_IS2_HK_DEI = 11,
	VCAP_IS2_HK_PCP = 12,
	VCAP_IS2_HK_L2_DMAC = 13,
	VCAP_IS2_HK_L2_SMAC = 14,
	VCAP_IS2_HK_MAC_ETYPE_ETYPE = 15,
	VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD0 = 16,
	VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD1 = 17,
	VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD2 = 18,
	VCAP_IS2_HK_MAC_LLC_DMAC = 19,
	VCAP_IS2_HK_MAC_LLC_SMAC = 20,
	VCAP_IS2_HK_MAC_LLC_L2_LLC = 21,
	VCAP_IS2_HK_MAC_SNAP_SMAC = 22,
	VCAP_IS2_HK_MAC_SNAP_DMAC = 23,
	VCAP_IS2_HK_MAC_SNAP_L2_SNAP = 24,
	VCAP_IS2_HK_MAC_ARP_SMAC = 25,
	VCAP_IS2_HK_MAC_ARP_ADDR_SPACE_OK = 26,
	VCAP_IS2_HK_MAC_ARP_PROTO_SPACE_OK = 27,
	VCAP_IS2_HK_MAC_ARP_LEN_OK = 28,
	VCAP_IS2_HK_MAC_ARP_TARGET_MATCH = 29,
	VCAP_IS2_HK_MAC_ARP_SENDER_MATCH = 30,
	VCAP_IS2_HK_MAC_ARP_OPCODE_UNKNOWN = 31,
	VCAP_IS2_HK_MAC_ARP_OPCODE = 32,
	VCAP_IS2_HK_MAC_ARP_L3_IP4_DIP = 33,
	VCAP_IS2_HK_MAC_ARP_L3_IP4_SIP = 34,
	VCAP_IS2_HK_MAC_ARP_DIP_EQ_SIP = 35,
	VCAP_IS2_HK_IP4 = 36,
	VCAP_IS2_HK_L3_FRAGMENT = 37,
	VCAP_IS2_HK_L3_FRAG_OFS_GT0 = 38,
	VCAP_IS2_HK_L3_OPTIONS = 39,
	VCAP_IS2_HK_IP4_L3_TTL_GT0 = 40,
	VCAP_IS2_HK_L3_TOS = 41,
	VCAP_IS2_HK_L3_IP4_DIP = 42,
	VCAP_IS2_HK_L3_IP4_SIP = 43,
	VCAP_IS2_HK_DIP_EQ_SIP = 44,
	VCAP_IS2_HK_TCP = 45,
	VCAP_IS2_HK_L4_SPORT = 46,
	VCAP_IS2_HK_L4_DPORT = 47,
	VCAP_IS2_HK_L4_RNG = 48,
	VCAP_IS2_HK_L4_SPORT_EQ_DPORT = 49,
	VCAP_IS2_HK_L4_SEQUENCE_EQ0 = 50,
	VCAP_IS2_HK_L4_URG = 51,
	VCAP_IS2_HK_L4_ACK = 52,
	VCAP_IS2_HK_L4_PSH = 53,
	VCAP_IS2_HK_L4_RST = 54,
	VCAP_IS2_HK_L4_SYN = 55,
	VCAP_IS2_HK_L4_FIN = 56,
	VCAP_IS2_HK_L4_1588_DOM = 57,
	VCAP_IS2_HK_L4_1588_VER = 58,
	VCAP_IS2_HK_IP4_L3_PROTO = 59,
	VCAP_IS2_HK_L3_PAYLOAD = 60,
	VCAP_IS2_HK_IP6_L3_TTL_GT0 = 61,
	VCAP_IS2_HK_IP6_L3_PROTO = 62,
	VCAP_IS2_HK_L3_IP6_SIP = 63,
	VCAP_IS2_HK_OAM_MEL_FLAGS = 64,
	VCAP_IS2_HK_OAM_VER = 65,
	VCAP_IS2_HK_OAM_OPCODE = 66,
	VCAP_IS2_HK_OAM_FLAGS = 67,
	VCAP_IS2_HK_OAM_MEPID = 68,
	VCAP_IS2_HK_OAM_CCM_CNTS_EQ0 = 69,
	VCAP_IS2_HK_OAM_IS_Y1731 = 70,
};

enum vcap_is2_action_field {
	VCAP_IS2_ACT_HIT_ME_ONCE = 0,
	VCAP_IS2_ACT_CPU_COPY_ENA = 1,
	VCAP_IS2_ACT_CPU_QU_NUM = 2,
	VCAP_IS2_ACT_MASK_MODE = 3,
	VCAP_IS2_ACT_MIRROR_ENA = 4,
	VCAP_IS2_ACT_LRN_DIS = 5,
	VCAP_IS2_ACT_POLICE_ENA = 6,
	VCAP_IS2_ACT_POLICE_IDX = 7,
	VCAP_IS2_ACT_POLICE_VCAP_ONLY = 8,
	VCAP_IS2_ACT_PORT_MASK = 9,
	VCAP_IS2_ACT_REW_OP = 10,
	VCAP_IS2_ACT_SMAC_REPLACE_ENA = 11,
	VCAP_IS2_ACT_RSV = 12,
	VCAP_IS2_ACT_ACL_ID = 13,
	VCAP_IS2_ACT_HIT_CNT = 14,
};

enum {
	IS1_ACTION_TYPE_NORMAL = 0,
	IS1_ACTION_TYPE_MAX = 1,
};

enum vcap_is1_half_key_field {
	VCAP_IS1_HK_TYPE = 0,
	VCAP_IS1_HK_LOOKUP = 1,
	VCAP_IS1_HK_IGR_PORT_MASK = 2,
	VCAP_IS1_HK_RSV = 3,
	VCAP_IS1_HK_OAM_Y1731 = 4,
	VCAP_IS1_HK_L2_MC = 5,
	VCAP_IS1_HK_L2_BC = 6,
	VCAP_IS1_HK_IP_MC = 7,
	VCAP_IS1_HK_VLAN_TAGGED = 8,
	VCAP_IS1_HK_VLAN_DBL_TAGGED = 9,
	VCAP_IS1_HK_TPID = 10,
	VCAP_IS1_HK_VID = 11,
	VCAP_IS1_HK_DEI = 12,
	VCAP_IS1_HK_PCP = 13,
	VCAP_IS1_HK_L2_SMAC = 14,
	VCAP_IS1_HK_ETYPE_LEN = 15,
	VCAP_IS1_HK_ETYPE = 16,
	VCAP_IS1_HK_IP_SNAP = 17,
	VCAP_IS1_HK_IP4 = 18,
	VCAP_IS1_HK_L3_FRAGMENT = 19,
	VCAP_IS1_HK_L3_FRAG_OFS_GT0 = 20,
	VCAP_IS1_HK_L3_OPTIONS = 21,
	VCAP_IS1_HK_L3_DSCP = 22,
	VCAP_IS1_HK_L3_IP4_SIP = 23,
	VCAP_IS1_HK_TCP_UDP = 24,
	VCAP_IS1_HK_TCP = 25,
	VCAP_IS1_HK_L4_SPORT = 26,
	VCAP_IS1_HK_L4_RNG = 27,
	VCAP_IS1_HK_IP4_INNER_TPID = 28,
	VCAP_IS1_HK_IP4_INNER_VID = 29,
	VCAP_IS1_HK_IP4_INNER_DEI = 30,
	VCAP_IS1_HK_IP4_INNER_PCP = 31,
	VCAP_IS1_HK_IP4_IP4 = 32,
	VCAP_IS1_HK_IP4_L3_FRAGMENT = 33,
	VCAP_IS1_HK_IP4_L3_FRAG_OFS_GT0 = 34,
	VCAP_IS1_HK_IP4_L3_OPTIONS = 35,
	VCAP_IS1_HK_IP4_L3_DSCP = 36,
	VCAP_IS1_HK_IP4_L3_IP4_DIP = 37,
	VCAP_IS1_HK_IP4_L3_IP4_SIP = 38,
	VCAP_IS1_HK_IP4_L3_PROTO = 39,
	VCAP_IS1_HK_IP4_TCP_UDP = 40,
	VCAP_IS1_HK_IP4_TCP = 41,
	VCAP_IS1_HK_IP4_L4_RNG = 42,
	VCAP_IS1_HK_IP4_IP_PAYLOAD_S1_5TUPLE = 43,
};

enum vcap_is1_action_field {
	VCAP_IS1_ACT_DSCP_ENA = 0,
	VCAP_IS1_ACT_DSCP_VAL = 1,
	VCAP_IS1_ACT_QOS_ENA = 2,
	VCAP_IS1_ACT_QOS_VAL = 3,
	VCAP_IS1_ACT_DP_ENA = 4,
	VCAP_IS1_ACT_DP_VAL = 5,
	VCAP_IS1_ACT_PAG_OVERRIDE_MASK = 6,
	VCAP_IS1_ACT_PAG_VAL = 7,
	VCAP_IS1_ACT_RSV = 8,
	VCAP_IS1_ACT_VID_REPLACE_ENA = 9,
	VCAP_IS1_ACT_VID_ADD_VAL = 10,
	VCAP_IS1_ACT_FID_SEL = 11,
	VCAP_IS1_ACT_FID_VAL = 12,
	VCAP_IS1_ACT_PCP_DEI_ENA = 13,
	VCAP_IS1_ACT_PCP_VAL = 14,
	VCAP_IS1_ACT_DEI_VAL = 15,
	VCAP_IS1_ACT_VLAN_POP_CNT_ENA = 16,
	VCAP_IS1_ACT_VLAN_POP_CNT = 17,
	VCAP_IS1_ACT_CUSTOM_ACE_TYPE_ENA = 18,
	VCAP_IS1_ACT_HIT_STICKY = 19,
};

enum {
	ES0_ACTION_TYPE_NORMAL = 0,
	ES0_ACTION_TYPE_MAX = 1,
};

enum vcap_es0_action_field {
	VCAP_ES0_ACT_PUSH_OUTER_TAG = 0,
	VCAP_ES0_ACT_PUSH_INNER_TAG = 1,
	VCAP_ES0_ACT_TAG_A_TPID_SEL = 2,
	VCAP_ES0_ACT_TAG_A_VID_SEL = 3,
	VCAP_ES0_ACT_TAG_A_PCP_SEL = 4,
	VCAP_ES0_ACT_TAG_A_DEI_SEL = 5,
	VCAP_ES0_ACT_TAG_B_TPID_SEL = 6,
	VCAP_ES0_ACT_TAG_B_VID_SEL = 7,
	VCAP_ES0_ACT_TAG_B_PCP_SEL = 8,
	VCAP_ES0_ACT_TAG_B_DEI_SEL = 9,
	VCAP_ES0_ACT_VID_A_VAL = 10,
	VCAP_ES0_ACT_PCP_A_VAL = 11,
	VCAP_ES0_ACT_DEI_A_VAL = 12,
	VCAP_ES0_ACT_VID_B_VAL = 13,
	VCAP_ES0_ACT_PCP_B_VAL = 14,
	VCAP_ES0_ACT_DEI_B_VAL = 15,
	VCAP_ES0_ACT_RSV = 16,
	VCAP_ES0_ACT_HIT_STICKY = 17,
};

struct tc_cbs_qopt_offload {
	u8 enable;
	s32 queue;
	s32 hicredit;
	s32 locredit;
	s32 idleslope;
	s32 sendslope;
};

struct tc_taprio_sched_entry {
	u8 command;
	u32 gate_mask;
	u32 interval;
};

struct tc_taprio_qopt_offload {
	u8 enable;
	ktime_t base_time;
	u64 cycle_time;
	u64 cycle_time_extension;
	size_t num_entries;
	struct tc_taprio_sched_entry entries[0];
};

struct tgec_mdio_controller {
	__be32 reserved[12];
	__be32 mdio_stat;
	__be32 mdio_ctl;
	__be32 mdio_data;
	__be32 mdio_addr;
};

struct mdio_fsl_priv {
	struct tgec_mdio_controller *mdio_base;
	bool is_little_endian;
	bool has_a009885;
	bool has_a011043;
};

struct muram_info {
	struct gen_pool *pool;
	void *vbase;
	size_t size;
	phys_addr_t pbase;
};

enum fman_port_type {
	FMAN_PORT_TYPE_TX = 0,
	FMAN_PORT_TYPE_RX = 1,
};

struct fman_rev_info {
	u8 major;
	u8 minor;
};

enum fman_exceptions {
	FMAN_EX_DMA_BUS_ERROR = 0,
	FMAN_EX_DMA_READ_ECC = 1,
	FMAN_EX_DMA_SYSTEM_WRITE_ECC = 2,
	FMAN_EX_DMA_FM_WRITE_ECC = 3,
	FMAN_EX_DMA_SINGLE_PORT_ECC = 4,
	FMAN_EX_FPM_STALL_ON_TASKS = 5,
	FMAN_EX_FPM_SINGLE_ECC = 6,
	FMAN_EX_FPM_DOUBLE_ECC = 7,
	FMAN_EX_QMI_SINGLE_ECC = 8,
	FMAN_EX_QMI_DOUBLE_ECC = 9,
	FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID = 10,
	FMAN_EX_BMI_LIST_RAM_ECC = 11,
	FMAN_EX_BMI_STORAGE_PROFILE_ECC = 12,
	FMAN_EX_BMI_STATISTICS_RAM_ECC = 13,
	FMAN_EX_BMI_DISPATCH_RAM_ECC = 14,
	FMAN_EX_IRAM_ECC = 15,
	FMAN_EX_MURAM_ECC = 16,
};

enum fman_event_modules {
	FMAN_MOD_MAC = 0,
	FMAN_MOD_FMAN_CTRL = 1,
	FMAN_MOD_DUMMY_LAST = 2,
};

enum fman_intr_type {
	FMAN_INTR_TYPE_ERR = 0,
	FMAN_INTR_TYPE_NORMAL = 1,
};

enum fman_inter_module_event {
	FMAN_EV_ERR_MAC0 = 0,
	FMAN_EV_ERR_MAC1 = 1,
	FMAN_EV_ERR_MAC2 = 2,
	FMAN_EV_ERR_MAC3 = 3,
	FMAN_EV_ERR_MAC4 = 4,
	FMAN_EV_ERR_MAC5 = 5,
	FMAN_EV_ERR_MAC6 = 6,
	FMAN_EV_ERR_MAC7 = 7,
	FMAN_EV_ERR_MAC8 = 8,
	FMAN_EV_ERR_MAC9 = 9,
	FMAN_EV_MAC0 = 10,
	FMAN_EV_MAC1 = 11,
	FMAN_EV_MAC2 = 12,
	FMAN_EV_MAC3 = 13,
	FMAN_EV_MAC4 = 14,
	FMAN_EV_MAC5 = 15,
	FMAN_EV_MAC6 = 16,
	FMAN_EV_MAC7 = 17,
	FMAN_EV_MAC8 = 18,
	FMAN_EV_MAC9 = 19,
	FMAN_EV_FMAN_CTRL_0 = 20,
	FMAN_EV_FMAN_CTRL_1 = 21,
	FMAN_EV_FMAN_CTRL_2 = 22,
	FMAN_EV_FMAN_CTRL_3 = 23,
	FMAN_EV_CNT = 24,
};

struct fman_intr_src {
	void (*isr_cb)(void *);
	void *src_handle;
};

struct fman;

typedef irqreturn_t fman_exceptions_cb(struct fman *, enum fman_exceptions);

typedef irqreturn_t fman_bus_error_cb(struct fman *, u8, u64, u8, u16);

struct fman_dts_params {
	void *base_addr;
	struct resource *res;
	u8 id;
	int err_irq;
	u16 clk_freq;
	u32 qman_channel_base;
	u32 num_of_qman_channels;
	struct resource muram_res;
};

struct fman_fpm_regs;

struct fman_bmi_regs;

struct fman_qmi_regs;

struct fman_dma_regs;

struct fman_hwp_regs;

struct fman_kg_regs;

struct fman_state_struct;

struct fman_cfg;

struct fman_keygen;

struct fman {
	struct device *dev;
	void *base_addr;
	struct fman_intr_src intr_mng[24];
	struct fman_fpm_regs *fpm_regs;
	struct fman_bmi_regs *bmi_regs;
	struct fman_qmi_regs *qmi_regs;
	struct fman_dma_regs *dma_regs;
	struct fman_hwp_regs *hwp_regs;
	struct fman_kg_regs *kg_regs;
	fman_exceptions_cb *exception_cb;
	fman_bus_error_cb *bus_error_cb;
	spinlock_t spinlock;
	struct fman_state_struct *state;
	struct fman_cfg *cfg;
	struct muram_info *muram;
	struct fman_keygen *keygen;
	long unsigned int cam_offset;
	size_t cam_size;
	long unsigned int fifo_offset;
	size_t fifo_size;
	u32 liodn_base[64];
	u32 liodn_offset[64];
	struct fman_dts_params dts_params;
};

struct fman_fpm_regs {
	u32 fmfp_tnc;
	u32 fmfp_prc;
	u32 fmfp_brkc;
	u32 fmfp_mxd;
	u32 fmfp_dist1;
	u32 fmfp_dist2;
	u32 fm_epi;
	u32 fm_rie;
	u32 fmfp_fcev[4];
	u32 res0030[4];
	u32 fmfp_cee[4];
	u32 res0050[4];
	u32 fmfp_tsc1;
	u32 fmfp_tsc2;
	u32 fmfp_tsp;
	u32 fmfp_tsf;
	u32 fm_rcr;
	u32 fmfp_extc;
	u32 fmfp_ext1;
	u32 fmfp_ext2;
	u32 fmfp_drd[16];
	u32 fmfp_dra;
	u32 fm_ip_rev_1;
	u32 fm_ip_rev_2;
	u32 fm_rstc;
	u32 fm_cld;
	u32 fm_npi;
	u32 fmfp_exte;
	u32 fmfp_ee;
	u32 fmfp_cev[4];
	u32 res00f0[4];
	u32 fmfp_ps[50];
	u32 res01c8[14];
	u32 fmfp_clfabc;
	u32 fmfp_clfcc;
	u32 fmfp_clfaval;
	u32 fmfp_clfbval;
	u32 fmfp_clfcval;
	u32 fmfp_clfamsk;
	u32 fmfp_clfbmsk;
	u32 fmfp_clfcmsk;
	u32 fmfp_clfamc;
	u32 fmfp_clfbmc;
	u32 fmfp_clfcmc;
	u32 fmfp_decceh;
	u32 res0230[116];
	u32 fmfp_ts[128];
	u32 res0600[640];
};

struct fman_bmi_regs {
	u32 fmbm_init;
	u32 fmbm_cfg1;
	u32 fmbm_cfg2;
	u32 res000c[5];
	u32 fmbm_ievr;
	u32 fmbm_ier;
	u32 fmbm_ifr;
	u32 res002c[5];
	u32 fmbm_arb[8];
	u32 res0060[12];
	u32 fmbm_dtc[3];
	u32 res009c;
	u32 fmbm_dcv[12];
	u32 fmbm_dcm[12];
	u32 fmbm_gde;
	u32 fmbm_pp[63];
	u32 res0200;
	u32 fmbm_pfs[63];
	u32 res0300;
	u32 fmbm_spliodn[63];
};

struct fman_qmi_regs {
	u32 fmqm_gc;
	u32 res0004;
	u32 fmqm_eie;
	u32 fmqm_eien;
	u32 fmqm_eif;
	u32 fmqm_ie;
	u32 fmqm_ien;
	u32 fmqm_if;
	u32 fmqm_gs;
	u32 fmqm_ts;
	u32 fmqm_etfc;
	u32 fmqm_dtfc;
	u32 fmqm_dc0;
	u32 fmqm_dc1;
	u32 fmqm_dc2;
	u32 fmqm_dc3;
	u32 fmqm_dfdc;
	u32 fmqm_dfcc;
	u32 fmqm_dffc;
	u32 fmqm_dcc;
	u32 res0050[7];
	u32 fmqm_tapc;
	u32 fmqm_dmcvc;
	u32 fmqm_difdcc;
	u32 fmqm_da1v;
	u32 res007c;
	u32 fmqm_dtc;
	u32 fmqm_efddd;
	u32 res0088[2];
	struct {
		u32 fmqm_dtcfg1;
		u32 fmqm_dtval1;
		u32 fmqm_dtm1;
		u32 fmqm_dtc1;
		u32 fmqm_dtcfg2;
		u32 fmqm_dtval2;
		u32 fmqm_dtm2;
		u32 res001c;
	} dbg_traps[3];
	u8 res00f0[784];
};

struct fman_dma_regs {
	u32 fmdmsr;
	u32 fmdmmr;
	u32 fmdmtr;
	u32 fmdmhy;
	u32 fmdmsetr;
	u32 fmdmtah;
	u32 fmdmtal;
	u32 fmdmtcid;
	u32 fmdmra;
	u32 fmdmrd;
	u32 fmdmwcr;
	u32 fmdmebcr;
	u32 fmdmccqdr;
	u32 fmdmccqvr1;
	u32 fmdmccqvr2;
	u32 fmdmcqvr3;
	u32 fmdmcqvr4;
	u32 fmdmcqvr5;
	u32 fmdmsefrc;
	u32 fmdmsqfrc;
	u32 fmdmssrc;
	u32 fmdmdcr;
	u32 fmdmemsr;
	u32 res005c;
	u32 fmdmplr[32];
	u32 res00e0[968];
};

struct fman_hwp_regs {
	u32 res0000[529];
	u32 fmprrpimac;
	u32 res[494];
};

struct fman_state_struct {
	u8 fm_id;
	u16 fm_clk_freq;
	struct fman_rev_info rev_info;
	bool enabled_time_stamp;
	u8 count1_micro_bit;
	u8 total_num_of_tasks;
	u8 accumulated_num_of_tasks;
	u32 accumulated_fifo_size;
	u8 accumulated_num_of_open_dmas;
	u8 accumulated_num_of_deq_tnums;
	u32 exceptions;
	u32 extra_fifo_pool_size;
	u8 extra_tasks_pool_size;
	u8 extra_open_dmas_pool_size;
	u16 port_mfl[10];
	u16 mac_mfl[10];
	u32 fm_iram_size;
	u32 dma_thresh_max_commq;
	u32 dma_thresh_max_buf;
	u32 max_num_of_open_dmas;
	u32 qmi_max_num_of_tnums;
	u32 qmi_def_tnums_thresh;
	u32 bmi_max_num_of_tasks;
	u32 bmi_max_fifo_size;
	u32 fm_port_num_of_cg;
	u32 num_of_rx_ports;
	u32 total_fifo_size;
	u32 qman_channel_base;
	u32 num_of_qman_channels;
	struct resource *res;
};

enum fman_dma_aid_mode {
	FMAN_DMA_AID_OUT_PORT_ID = 0,
	FMAN_DMA_AID_OUT_TNUM = 1,
};

struct fman_cfg {
	u8 disp_limit_tsh;
	u8 prs_disp_tsh;
	u8 plcr_disp_tsh;
	u8 kg_disp_tsh;
	u8 bmi_disp_tsh;
	u8 qmi_enq_disp_tsh;
	u8 qmi_deq_disp_tsh;
	u8 fm_ctl1_disp_tsh;
	u8 fm_ctl2_disp_tsh;
	int dma_cache_override;
	enum fman_dma_aid_mode dma_aid_mode;
	u32 dma_axi_dbg_num_of_beats;
	u32 dma_cam_num_of_entries;
	u32 dma_watchdog;
	u8 dma_comm_qtsh_asrt_emer;
	u32 dma_write_buf_tsh_asrt_emer;
	u32 dma_read_buf_tsh_asrt_emer;
	u8 dma_comm_qtsh_clr_emer;
	u32 dma_write_buf_tsh_clr_emer;
	u32 dma_read_buf_tsh_clr_emer;
	u32 dma_sos_emergency;
	int dma_dbg_cnt_mode;
	int catastrophic_err;
	int dma_err;
	u32 exceptions;
	u16 clk_freq;
	u32 cam_base_addr;
	u32 fifo_base_addr;
	u32 total_fifo_size;
	u32 total_num_of_tasks;
	u32 qmi_def_tnums_thresh;
};

struct fman_port_init_params {
	u8 port_id;
	enum fman_port_type port_type;
	u16 port_speed;
	u16 liodn_offset;
	u8 num_of_tasks;
	u8 num_of_extra_tasks;
	u8 num_of_open_dmas;
	u8 num_of_extra_open_dmas;
	u32 size_of_fifo;
	u32 extra_size_of_fifo;
	u8 deq_pipeline_depth;
	u16 max_frame_length;
	u16 liodn_base;
};

struct fman_iram_regs {
	u32 iadd;
	u32 idata;
	u32 itcfg;
	u32 iready;
};

struct fman_buffer_prefix_content {
	u16 priv_data_size;
	bool pass_prs_result;
	bool pass_time_stamp;
	bool pass_hash_result;
	u16 data_align;
};

struct fman_ext_pool_params {
	u8 id;
	u16 size;
};

struct fman_ext_pools {
	u8 num_of_pools_used;
	struct fman_ext_pool_params ext_buf_pool[8];
};

struct fman_sp_int_context_data_copy {
	u16 ext_buf_offset;
	u8 int_context_offset;
	u16 size;
};

struct fman_sp_buf_margins {
	u16 start_margins;
	u16 end_margins;
};

struct fman_sp_buffer_offsets {
	u32 data_offset;
	u32 prs_result_offset;
	u32 time_stamp_offset;
	u32 hash_result_offset;
};

struct fman_kg_scheme_regs {
	u32 kgse_mode;
	u32 kgse_ekfc;
	u32 kgse_ekdv;
	u32 kgse_bmch;
	u32 kgse_bmcl;
	u32 kgse_fqb;
	u32 kgse_hc;
	u32 kgse_ppc;
	u32 kgse_gec[8];
	u32 kgse_spc;
	u32 kgse_dv0;
	u32 kgse_dv1;
	u32 kgse_ccbs;
	u32 kgse_mv;
	u32 kgse_om;
	u32 kgse_vsp;
};

struct fman_kg_pe_regs {
	u32 fmkg_pe_sp;
	u32 fmkg_pe_cpp;
};

struct fman_kg_regs {
	u32 fmkg_gcr;
	u32 res004;
	u32 res008;
	u32 fmkg_eer;
	u32 fmkg_eeer;
	u32 res014;
	u32 res018;
	u32 fmkg_seer;
	u32 fmkg_seeer;
	u32 fmkg_gsr;
	u32 fmkg_tpc;
	u32 fmkg_serc;
	u32 res030[4];
	u32 fmkg_fdor;
	u32 fmkg_gdv0r;
	u32 fmkg_gdv1r;
	u32 res04c[6];
	u32 fmkg_feer;
	u32 res068[38];
	union {
		u32 fmkg_indirect[63];
		struct fman_kg_scheme_regs fmkg_sch;
		struct fman_kg_pe_regs fmkg_pe;
	};
	u32 fmkg_ar;
};

struct keygen_scheme {
	bool used;
	u8 hw_port_id;
	u32 base_fqid;
	u32 hash_fqid_count;
	bool use_hashing;
	bool symmetric_hash;
	u8 hashShift;
	u32 match_vector;
};

struct fman_keygen {
	struct keygen_scheme schemes[32];
	struct fman_kg_regs *keygen_regs;
};

struct fman_buf_pool_depletion {
	bool pools_grp_mode_enable;
	u8 num_of_pools;
	bool pools_to_consider[64];
	bool single_pool_mode_enable;
	bool pools_to_consider_for_single_mode[64];
};

struct fman_port_rx_params {
	u32 err_fqid;
	u32 dflt_fqid;
	u32 pcd_base_fqid;
	u32 pcd_fqs_count;
	struct fman_ext_pools ext_buf_pools;
};

struct fman_port_non_rx_params {
	u32 err_fqid;
	u32 dflt_fqid;
};

union fman_port_specific_params {
	struct fman_port_rx_params rx_params;
	struct fman_port_non_rx_params non_rx_params;
};

struct fman_port_params {
	void *fm;
	union fman_port_specific_params specific_params;
};

struct fman_port_rx_bmi_regs {
	u32 fmbm_rcfg;
	u32 fmbm_rst;
	u32 fmbm_rda;
	u32 fmbm_rfp;
	u32 fmbm_rfed;
	u32 fmbm_ricp;
	u32 fmbm_rim;
	u32 fmbm_rebm;
	u32 fmbm_rfne;
	u32 fmbm_rfca;
	u32 fmbm_rfpne;
	u32 fmbm_rpso;
	u32 fmbm_rpp;
	u32 fmbm_rccb;
	u32 fmbm_reth;
	u32 reserved003c[1];
	u32 fmbm_rprai[8];
	u32 fmbm_rfqid;
	u32 fmbm_refqid;
	u32 fmbm_rfsdm;
	u32 fmbm_rfsem;
	u32 fmbm_rfene;
	u32 reserved0074[2];
	u32 fmbm_rcmne;
	u32 reserved0080[32];
	u32 fmbm_ebmpi[8];
	u32 fmbm_acnt[8];
	u32 reserved0130[8];
	u32 fmbm_rcgm[8];
	u32 fmbm_mpd;
	u32 reserved0184[31];
	u32 fmbm_rstc;
	u32 fmbm_rfrc;
	u32 fmbm_rfbc;
	u32 fmbm_rlfc;
	u32 fmbm_rffc;
	u32 fmbm_rfdc;
	u32 fmbm_rfldec;
	u32 fmbm_rodc;
	u32 fmbm_rbdc;
	u32 fmbm_rpec;
	u32 reserved0224[22];
	u32 fmbm_rpc;
	u32 fmbm_rpcp;
	u32 fmbm_rccn;
	u32 fmbm_rtuc;
	u32 fmbm_rrquc;
	u32 fmbm_rduc;
	u32 fmbm_rfuc;
	u32 fmbm_rpac;
	u32 reserved02a0[24];
	u32 fmbm_rdcfg[3];
	u32 fmbm_rgpr;
	u32 reserved0310[58];
};

struct fman_port_tx_bmi_regs {
	u32 fmbm_tcfg;
	u32 fmbm_tst;
	u32 fmbm_tda;
	u32 fmbm_tfp;
	u32 fmbm_tfed;
	u32 fmbm_ticp;
	u32 fmbm_tfdne;
	u32 fmbm_tfca;
	u32 fmbm_tcfqid;
	u32 fmbm_tefqid;
	u32 fmbm_tfene;
	u32 fmbm_trlmts;
	u32 fmbm_trlmt;
	u32 reserved0034[14];
	u32 fmbm_tccb;
	u32 fmbm_tfne;
	u32 fmbm_tpfcm[2];
	u32 fmbm_tcmne;
	u32 reserved0080[96];
	u32 fmbm_tstc;
	u32 fmbm_tfrc;
	u32 fmbm_tfdc;
	u32 fmbm_tfledc;
	u32 fmbm_tfufdc;
	u32 fmbm_tbdc;
	u32 reserved0218[26];
	u32 fmbm_tpc;
	u32 fmbm_tpcp;
	u32 fmbm_tccn;
	u32 fmbm_ttuc;
	u32 fmbm_ttcquc;
	u32 fmbm_tduc;
	u32 fmbm_tfuc;
	u32 reserved029c[16];
	u32 fmbm_tdcfg[3];
	u32 fmbm_tgpr;
	u32 reserved0310[58];
};

union fman_port_bmi_regs {
	struct fman_port_rx_bmi_regs rx;
	struct fman_port_tx_bmi_regs tx;
};

struct fman_port_qmi_regs {
	u32 fmqm_pnc;
	u32 fmqm_pns;
	u32 fmqm_pnts;
	u32 reserved00c[4];
	u32 fmqm_pnen;
	u32 fmqm_pnetfc;
	u32 reserved024[2];
	u32 fmqm_pndn;
	u32 fmqm_pndc;
	u32 fmqm_pndtfc;
	u32 fmqm_pndfdc;
	u32 fmqm_pndcc;
};

struct fman_port_hwp_regs {
	struct {
		u32 ssa;
		u32 lcv;
	} pmda[16];
	u32 reserved080[222];
	u32 fmpr_pcac;
};

enum fman_port_deq_prefetch {
	FMAN_PORT_DEQ_NO_PREFETCH = 0,
	FMAN_PORT_DEQ_PART_PREFETCH = 1,
	FMAN_PORT_DEQ_FULL_PREFETCH = 2,
};

struct fman_port_rsrc {
	u32 num;
	u32 extra;
};

enum fman_port_dma_swap {
	FMAN_PORT_DMA_NO_SWAP = 0,
	FMAN_PORT_DMA_SWAP_LE = 1,
	FMAN_PORT_DMA_SWAP_BE = 2,
};

enum fman_port_color {
	FMAN_PORT_COLOR_GREEN = 0,
	FMAN_PORT_COLOR_YELLOW = 1,
	FMAN_PORT_COLOR_RED = 2,
	FMAN_PORT_COLOR_OVERRIDE = 3,
};

enum fman_port_deq_type {
	FMAN_PORT_DEQ_BY_PRI = 0,
	FMAN_PORT_DEQ_ACTIVE_FQ = 1,
	FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS = 2,
};

struct fman_port_bpools {
	u8 count;
	bool counters_enable;
	u8 grp_bp_depleted_num;
	struct {
		u8 bpid;
		u16 size;
		bool is_backup;
		bool grp_bp_depleted;
		bool single_bp_depleted;
	} bpool[8];
};

struct fman_port_cfg {
	u32 dflt_fqid;
	u32 err_fqid;
	u32 pcd_base_fqid;
	u32 pcd_fqs_count;
	u8 deq_sp;
	bool deq_high_priority;
	enum fman_port_deq_type deq_type;
	enum fman_port_deq_prefetch deq_prefetch_option;
	u16 deq_byte_cnt;
	u8 cheksum_last_bytes_ignore;
	u8 rx_cut_end_bytes;
	struct fman_buf_pool_depletion buf_pool_depletion;
	struct fman_ext_pools ext_buf_pools;
	u32 tx_fifo_min_level;
	u32 tx_fifo_low_comf_level;
	u32 rx_pri_elevation;
	u32 rx_fifo_thr;
	struct fman_sp_buf_margins buf_margins;
	u32 int_buf_start_margin;
	struct fman_sp_int_context_data_copy int_context;
	u32 discard_mask;
	u32 err_mask;
	struct fman_buffer_prefix_content buffer_prefix_content;
	bool dont_release_buf;
	u8 rx_fd_bits;
	u32 tx_fifo_deq_pipeline_depth;
	bool errata_A006320;
	bool excessive_threshold_register;
	bool fmbm_tfne_has_features;
	enum fman_port_dma_swap dma_swap_data;
	enum fman_port_color color;
};

struct fman_port_rx_pools_params {
	u8 num_of_pools;
	u16 largest_buf_size;
};

struct fman_port_dts_params {
	void *base_addr;
	enum fman_port_type type;
	u16 speed;
	u8 id;
	u32 qman_channel_id;
	struct fman *fman;
};

struct fman_port {
	void *fm;
	struct device *dev;
	struct fman_rev_info rev_info;
	u8 port_id;
	enum fman_port_type port_type;
	u16 port_speed;
	union fman_port_bmi_regs *bmi_regs;
	struct fman_port_qmi_regs *qmi_regs;
	struct fman_port_hwp_regs *hwp_regs;
	struct fman_sp_buffer_offsets buffer_offsets;
	u8 internal_buf_offset;
	struct fman_ext_pools ext_buf_pools;
	u16 max_frame_length;
	struct fman_port_rsrc open_dmas;
	struct fman_port_rsrc tasks;
	struct fman_port_rsrc fifo_bufs;
	struct fman_port_rx_pools_params rx_pools_params;
	struct fman_port_cfg *cfg;
	struct fman_port_dts_params dts_params;
	u8 ext_pools_num;
	u32 max_port_fifo_size;
	u32 max_num_of_ext_pools;
	u32 max_num_of_sub_portals;
	u32 bm_max_num_of_pools;
};

typedef u8 enet_addr_t[6];

enum comm_mode {
	COMM_MODE_NONE = 0,
	COMM_MODE_RX = 1,
	COMM_MODE_TX = 2,
	COMM_MODE_RX_AND_TX = 3,
};

enum fman_mac_exceptions {
	FM_MAC_EX_10G_MDIO_SCAN_EVENT = 0,
	FM_MAC_EX_10G_MDIO_CMD_CMPL = 1,
	FM_MAC_EX_10G_REM_FAULT = 2,
	FM_MAC_EX_10G_LOC_FAULT = 3,
	FM_MAC_EX_10G_TX_ECC_ER = 4,
	FM_MAC_EX_10G_TX_FIFO_UNFL = 5,
	FM_MAC_EX_10G_TX_FIFO_OVFL = 6,
	FM_MAC_EX_10G_TX_ER = 7,
	FM_MAC_EX_10G_RX_FIFO_OVFL = 8,
	FM_MAC_EX_10G_RX_ECC_ER = 9,
	FM_MAC_EX_10G_RX_JAB_FRM = 10,
	FM_MAC_EX_10G_RX_OVRSZ_FRM = 11,
	FM_MAC_EX_10G_RX_RUNT_FRM = 12,
	FM_MAC_EX_10G_RX_FRAG_FRM = 13,
	FM_MAC_EX_10G_RX_LEN_ER = 14,
	FM_MAC_EX_10G_RX_CRC_ER = 15,
	FM_MAC_EX_10G_RX_ALIGN_ER = 16,
	FM_MAC_EX_1G_BAB_RX = 17,
	FM_MAC_EX_1G_RX_CTL = 18,
	FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET = 19,
	FM_MAC_EX_1G_BAB_TX = 20,
	FM_MAC_EX_1G_TX_CTL = 21,
	FM_MAC_EX_1G_TX_ERR = 22,
	FM_MAC_EX_1G_LATE_COL = 23,
	FM_MAC_EX_1G_COL_RET_LMT = 24,
	FM_MAC_EX_1G_TX_FIFO_UNDRN = 25,
	FM_MAC_EX_1G_MAG_PCKT = 26,
	FM_MAC_EX_1G_MII_MNG_RD_COMPLET = 27,
	FM_MAC_EX_1G_MII_MNG_WR_COMPLET = 28,
	FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET = 29,
	FM_MAC_EX_1G_DATA_ERR = 30,
	FM_MAC_1G_RX_DATA_ERR = 31,
	FM_MAC_EX_1G_1588_TS_RX_ERR = 32,
	FM_MAC_EX_1G_RX_MIB_CNT_OVFL = 33,
	FM_MAC_EX_TS_FIFO_ECC_ERR = 34,
	FM_MAC_EX_MAGIC_PACKET_INDICATION = 26,
};

typedef void fman_mac_exception_cb(void *, enum fman_mac_exceptions);

struct fman_mac_params {
	void *base_addr;
	enet_addr_t addr;
	u8 mac_id;
	phy_interface_t phy_if;
	u16 max_speed;
	void *fm;
	void *dev_id;
	fman_mac_exception_cb *event_cb;
	fman_mac_exception_cb *exception_cb;
	bool basex_if;
	struct device_node *internal_phy_node;
};

struct fman_mac;

struct mac_priv_s;

struct mac_device {
	struct resource *res;
	u8 addr[6];
	struct fman_port *port[2];
	u32 if_support;
	struct phy_device *phy_dev;
	phy_interface_t phy_if;
	struct device_node *phy_node;
	bool autoneg_pause;
	bool rx_pause_req;
	bool tx_pause_req;
	bool rx_pause_active;
	bool tx_pause_active;
	bool promisc;
	bool allmulti;
	int (*init)(struct mac_device *);
	int (*start)(struct mac_device *);
	int (*stop)(struct mac_device *);
	void (*adjust_link)(struct mac_device *);
	int (*set_promisc)(struct fman_mac *, bool);
	int (*change_addr)(struct fman_mac *, enet_addr_t *);
	int (*set_allmulti)(struct fman_mac *, bool);
	int (*set_tstamp)(struct fman_mac *, bool);
	int (*set_multi)(struct net_device *, struct mac_device *);
	int (*set_rx_pause)(struct fman_mac *, bool);
	int (*set_tx_pause)(struct fman_mac *, u8, u16, u16);
	int (*set_exception)(struct fman_mac *, enum fman_mac_exceptions, bool);
	int (*add_hash_mac_addr)(struct fman_mac *, enet_addr_t *);
	int (*remove_hash_mac_addr)(struct fman_mac *, enet_addr_t *);
	struct fman_mac *fman_mac;
	struct mac_priv_s *priv;
};

struct mac_priv_s {
	struct device *dev;
	void *vaddr;
	u8 cell_index;
	struct fman *fman;
	struct device_node *internal_phy_node;
	struct list_head mc_addr_list;
	struct platform_device *eth_dev;
	struct fixed_phy_status *fixed_link;
	u16 speed;
	u16 max_speed;
	int (*enable)(struct fman_mac *, enum comm_mode);
	int (*disable)(struct fman_mac *, enum comm_mode);
};

struct dpaa_eth_data {
	struct mac_device *mac_dev;
	int mac_hw_id;
	int fman_hw_id;
};

struct mac_address {
	u8 addr[6];
	struct list_head list;
};

struct eth_hash_entry {
	u64 addr;
	struct list_head node;
};

struct eth_hash_t {
	u16 size;
	struct list_head *lsts;
};

struct dtsec_regs {
	u32 tsec_id;
	u32 tsec_id2;
	u32 ievent;
	u32 imask;
	u32 reserved0010[1];
	u32 ecntrl;
	u32 ptv;
	u32 tbipa;
	u32 tmr_ctrl;
	u32 tmr_pevent;
	u32 tmr_pemask;
	u32 reserved002c[5];
	u32 tctrl;
	u32 reserved0044[3];
	u32 rctrl;
	u32 reserved0054[11];
	u32 igaddr[8];
	u32 gaddr[8];
	u32 reserved00c0[16];
	u32 maccfg1;
	u32 maccfg2;
	u32 ipgifg;
	u32 hafdup;
	u32 maxfrm;
	u32 reserved0114[10];
	u32 ifstat;
	u32 macstnaddr1;
	u32 macstnaddr2;
	struct {
		u32 exact_match1;
		u32 exact_match2;
	} macaddr[15];
	u32 reserved01c0[16];
	u32 tr64;
	u32 tr127;
	u32 tr255;
	u32 tr511;
	u32 tr1k;
	u32 trmax;
	u32 trmgv;
	u32 rbyt;
	u32 rpkt;
	u32 rfcs;
	u32 rmca;
	u32 rbca;
	u32 rxcf;
	u32 rxpf;
	u32 rxuo;
	u32 raln;
	u32 rflr;
	u32 rcde;
	u32 rcse;
	u32 rund;
	u32 rovr;
	u32 rfrg;
	u32 rjbr;
	u32 rdrp;
	u32 tbyt;
	u32 tpkt;
	u32 tmca;
	u32 tbca;
	u32 txpf;
	u32 tdfr;
	u32 tedf;
	u32 tscl;
	u32 tmcl;
	u32 tlcl;
	u32 txcl;
	u32 tncl;
	u32 reserved0290[1];
	u32 tdrp;
	u32 tjbr;
	u32 tfcs;
	u32 txcf;
	u32 tovr;
	u32 tund;
	u32 tfrg;
	u32 car1;
	u32 car2;
	u32 cam1;
	u32 cam2;
	u32 reserved02c0[848];
};

struct dtsec_cfg {
	u16 halfdup_retransmit;
	u16 halfdup_coll_window;
	bool tx_pad_crc;
	u16 tx_pause_time;
	bool ptp_tsu_en;
	bool ptp_exception_en;
	u32 preamble_len;
	u32 rx_prepend;
	u16 tx_pause_time_extd;
	u16 maximum_frame;
	u32 non_back_to_back_ipg1;
	u32 non_back_to_back_ipg2;
	u32 min_ifg_enforcement;
	u32 back_to_back_ipg;
};

struct fman_mac {
	struct dtsec_regs *regs;
	u64 addr;
	phy_interface_t phy_if;
	u16 max_speed;
	void *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	u8 num_of_ind_addr_in_regs;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	bool ptp_tsu_enabled;
	bool en_tsu_err_exception;
	struct dtsec_cfg *dtsec_drv_param;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool basex_if;
	struct phy_device *tbiphy;
};

struct mac_addr {
	u32 mac_addr_l;
	u32 mac_addr_u;
};

struct memac_regs {
	u32 res0000[2];
	u32 command_config;
	struct mac_addr mac_addr0;
	u32 maxfrm;
	u32 res0018[1];
	u32 rx_fifo_sections;
	u32 tx_fifo_sections;
	u32 res0024[2];
	u32 hashtable_ctrl;
	u32 res0030[4];
	u32 ievent;
	u32 tx_ipg_length;
	u32 res0048;
	u32 imask;
	u32 res0050;
	u32 pause_quanta[4];
	u32 pause_thresh[4];
	u32 rx_pause_status;
	u32 res0078[2];
	struct mac_addr mac_addr[7];
	u32 lpwake_timer;
	u32 sleep_timer;
	u32 res00c0[8];
	u32 statn_config;
	u32 res00e4[7];
	u32 reoct_l;
	u32 reoct_u;
	u32 roct_l;
	u32 roct_u;
	u32 raln_l;
	u32 raln_u;
	u32 rxpf_l;
	u32 rxpf_u;
	u32 rfrm_l;
	u32 rfrm_u;
	u32 rfcs_l;
	u32 rfcs_u;
	u32 rvlan_l;
	u32 rvlan_u;
	u32 rerr_l;
	u32 rerr_u;
	u32 ruca_l;
	u32 ruca_u;
	u32 rmca_l;
	u32 rmca_u;
	u32 rbca_l;
	u32 rbca_u;
	u32 rdrp_l;
	u32 rdrp_u;
	u32 rpkt_l;
	u32 rpkt_u;
	u32 rund_l;
	u32 rund_u;
	u32 r64_l;
	u32 r64_u;
	u32 r127_l;
	u32 r127_u;
	u32 r255_l;
	u32 r255_u;
	u32 r511_l;
	u32 r511_u;
	u32 r1023_l;
	u32 r1023_u;
	u32 r1518_l;
	u32 r1518_u;
	u32 r1519x_l;
	u32 r1519x_u;
	u32 rovr_l;
	u32 rovr_u;
	u32 rjbr_l;
	u32 rjbr_u;
	u32 rfrg_l;
	u32 rfrg_u;
	u32 rcnp_l;
	u32 rcnp_u;
	u32 rdrntp_l;
	u32 rdrntp_u;
	u32 res01d0[12];
	u32 teoct_l;
	u32 teoct_u;
	u32 toct_l;
	u32 toct_u;
	u32 res0210[2];
	u32 txpf_l;
	u32 txpf_u;
	u32 tfrm_l;
	u32 tfrm_u;
	u32 tfcs_l;
	u32 tfcs_u;
	u32 tvlan_l;
	u32 tvlan_u;
	u32 terr_l;
	u32 terr_u;
	u32 tuca_l;
	u32 tuca_u;
	u32 tmca_l;
	u32 tmca_u;
	u32 tbca_l;
	u32 tbca_u;
	u32 res0258[2];
	u32 tpkt_l;
	u32 tpkt_u;
	u32 tund_l;
	u32 tund_u;
	u32 t64_l;
	u32 t64_u;
	u32 t127_l;
	u32 t127_u;
	u32 t255_l;
	u32 t255_u;
	u32 t511_l;
	u32 t511_u;
	u32 t1023_l;
	u32 t1023_u;
	u32 t1518_l;
	u32 t1518_u;
	u32 t1519x_l;
	u32 t1519x_u;
	u32 res02a8[6];
	u32 tcnp_l;
	u32 tcnp_u;
	u32 res02c8[14];
	u32 if_mode;
	u32 if_status;
	u32 res0308[14];
	u32 hg_config;
	u32 res0344[3];
	u32 hg_pause_quanta;
	u32 res0354[3];
	u32 hg_pause_thresh;
	u32 res0364[3];
	u32 hgrx_pause_status;
	u32 hg_fifos_status;
	u32 rhm;
	u32 thm;
};

struct memac_cfg {
	bool reset_on_init;
	bool pause_ignore;
	bool promiscuous_mode_enable;
	struct fixed_phy_status *fixed_link;
	u16 max_frame_length;
	u16 pause_quanta;
	u32 tx_ipg_length;
};

struct fman_mac___2 {
	struct memac_regs *regs;
	u64 addr;
	phy_interface_t phy_if;
	u16 max_speed;
	void *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	struct memac_cfg *memac_drv_param;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool basex_if;
	struct phy_device *pcsphy;
	bool allmulti_enabled;
};

struct tgec_regs {
	u32 tgec_id;
	u32 reserved001[1];
	u32 command_config;
	u32 mac_addr_0;
	u32 mac_addr_1;
	u32 maxfrm;
	u32 pause_quant;
	u32 rx_fifo_sections;
	u32 tx_fifo_sections;
	u32 rx_fifo_almost_f_e;
	u32 tx_fifo_almost_f_e;
	u32 hashtable_ctrl;
	u32 mdio_cfg_status;
	u32 mdio_command;
	u32 mdio_data;
	u32 mdio_regaddr;
	u32 status;
	u32 tx_ipg_len;
	u32 mac_addr_2;
	u32 mac_addr_3;
	u32 rx_fifo_ptr_rd;
	u32 rx_fifo_ptr_wr;
	u32 tx_fifo_ptr_rd;
	u32 tx_fifo_ptr_wr;
	u32 imask;
	u32 ievent;
	u32 udp_port;
	u32 type_1588v2;
	u32 reserved070[4];
	u32 tfrm_u;
	u32 tfrm_l;
	u32 rfrm_u;
	u32 rfrm_l;
	u32 rfcs_u;
	u32 rfcs_l;
	u32 raln_u;
	u32 raln_l;
	u32 txpf_u;
	u32 txpf_l;
	u32 rxpf_u;
	u32 rxpf_l;
	u32 rlong_u;
	u32 rlong_l;
	u32 rflr_u;
	u32 rflr_l;
	u32 tvlan_u;
	u32 tvlan_l;
	u32 rvlan_u;
	u32 rvlan_l;
	u32 toct_u;
	u32 toct_l;
	u32 roct_u;
	u32 roct_l;
	u32 ruca_u;
	u32 ruca_l;
	u32 rmca_u;
	u32 rmca_l;
	u32 rbca_u;
	u32 rbca_l;
	u32 terr_u;
	u32 terr_l;
	u32 reserved100[2];
	u32 tuca_u;
	u32 tuca_l;
	u32 tmca_u;
	u32 tmca_l;
	u32 tbca_u;
	u32 tbca_l;
	u32 rdrp_u;
	u32 rdrp_l;
	u32 reoct_u;
	u32 reoct_l;
	u32 rpkt_u;
	u32 rpkt_l;
	u32 trund_u;
	u32 trund_l;
	u32 r64_u;
	u32 r64_l;
	u32 r127_u;
	u32 r127_l;
	u32 r255_u;
	u32 r255_l;
	u32 r511_u;
	u32 r511_l;
	u32 r1023_u;
	u32 r1023_l;
	u32 r1518_u;
	u32 r1518_l;
	u32 r1519x_u;
	u32 r1519x_l;
	u32 trovr_u;
	u32 trovr_l;
	u32 trjbr_u;
	u32 trjbr_l;
	u32 trfrg_u;
	u32 trfrg_l;
	u32 rerr_u;
	u32 rerr_l;
};

struct tgec_cfg {
	bool pause_ignore;
	bool promiscuous_mode_enable;
	u16 max_frame_length;
	u16 pause_quant;
	u32 tx_ipg_length;
};

struct fman_mac___3 {
	struct tgec_regs *regs;
	u64 addr;
	u16 max_speed;
	void *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	struct tgec_cfg *cfg;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool allmulti_enabled;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum {
	TC_MQPRIO_HW_OFFLOAD_NONE = 0,
	TC_MQPRIO_HW_OFFLOAD_TCS = 1,
	__TC_MQPRIO_HW_OFFLOAD_MAX = 2,
};

struct tc_mqprio_qopt {
	__u8 num_tc;
	__u8 prio_tc_map[16];
	__u8 hw;
	__u16 count[16];
	__u16 offset[16];
};

struct vlan_ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
		};
		struct {
			__be32 saddr;
			__be32 daddr;
		} addrs;
	};
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	union {
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		};
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		} addrs;
	};
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

enum qm_fd_format {
	qm_fd_contig = 0,
	qm_fd_contig_big = 1073741824,
	qm_fd_sg = 2147483648,
	qm_fd_sg_big = 3221225472,
	qm_fd_compound = 536870912,
};

struct qm_sg_entry {
	union {
		struct {
			u8 __reserved1[3];
			u8 addr_hi;
			__be32 addr_lo;
		};
		__be64 data;
	};
	__be32 cfg;
	u8 __reserved2;
	u8 bpid;
	__be16 offset;
};

struct fman_prs_result {
	u8 lpid;
	u8 shimr;
	__be16 l2r;
	__be16 l3r;
	u8 l4r;
	u8 cplan;
	__be16 nxthdr;
	__be16 cksum;
	__be16 flags_frag_off;
	u8 route_type;
	u8 rhp_ip_valid;
	u8 shim_off[2];
	u8 ip_pid_off;
	u8 eth_off;
	u8 llc_snap_off;
	u8 vlan_off[2];
	u8 etype_off;
	u8 pppoe_off;
	u8 mpls_off[2];
	u8 ip_off[2];
	u8 gre_off;
	u8 l4_off;
	u8 nxthdr_off;
};

enum dpaa_fq_type {
	FQ_TYPE_RX_DEFAULT = 1,
	FQ_TYPE_RX_ERROR = 2,
	FQ_TYPE_RX_PCD = 3,
	FQ_TYPE_TX = 4,
	FQ_TYPE_TX_CONFIRM = 5,
	FQ_TYPE_TX_CONF_MQ = 6,
	FQ_TYPE_TX_ERROR = 7,
};

struct dpaa_fq {
	struct qman_fq fq_base;
	struct list_head list;
	struct net_device *net_dev;
	bool init;
	u32 fqid;
	u32 flags;
	u16 channel;
	u8 wq;
	enum dpaa_fq_type fq_type;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct dpaa_fq_cbs {
	struct qman_fq rx_defq;
	struct qman_fq tx_defq;
	struct qman_fq rx_errq;
	struct qman_fq tx_errq;
	struct qman_fq egress_ern;
};

struct dpaa_priv;

struct dpaa_bp {
	struct dpaa_priv *priv;
	int *percpu_count;
	size_t raw_size;
	size_t size;
	u16 config_count;
	u8 bpid;
	struct bman_pool *pool;
	int (*seed_cb)(struct dpaa_bp *);
	void (*free_buf_cb)(const struct dpaa_bp *, struct bm_buffer *);
	refcount_t refs;
};

struct dpaa_buffer_layout {
	u16 priv_data_size;
};

struct dpaa_percpu_priv;

struct dpaa_priv {
	struct dpaa_percpu_priv *percpu_priv;
	struct dpaa_bp *dpaa_bp;
	u16 tx_headroom;
	struct net_device *net_dev;
	struct mac_device *mac_dev;
	struct device *rx_dma_dev;
	struct device *tx_dma_dev;
	struct qman_fq *egress_fqs[256];
	struct qman_fq *conf_fqs[256];
	u16 channel;
	struct list_head dpaa_fq_list;
	u8 num_tc;
	bool keygen_in_use;
	u32 msg_enable;
	struct {
		struct qman_cgr cgr;
		u32 congestion_start_jiffies;
		u32 congested_jiffies;
		u32 cgr_congested_count;
	} cgr_data;
	bool use_ingress_cgr;
	struct qman_cgr ingress_cgr;
	struct dpaa_buffer_layout buf_layout[2];
	u16 rx_headroom;
	bool tx_tstamp;
	bool rx_tstamp;
	struct bpf_prog *xdp_prog;
};

struct dpaa_rx_errors {
	u64 dme;
	u64 fpe;
	u64 fse;
	u64 phe;
};

struct dpaa_ern_cnt {
	u64 cg_tdrop;
	u64 wred;
	u64 err_cond;
	u64 early_window;
	u64 late_window;
	u64 fq_tdrop;
	u64 fq_retired;
	u64 orp_zero;
};

struct dpaa_napi_portal {
	struct napi_struct napi;
	struct qman_portal *p;
	bool down;
	int xdp_act;
};

struct dpaa_percpu_priv {
	struct net_device *net_dev;
	struct dpaa_napi_portal np;
	u64 in_interrupt;
	u64 tx_confirm;
	u64 tx_frag_skbuffs;
	struct rtnl_link_stats64 stats;
	struct dpaa_rx_errors rx_errors;
	struct dpaa_ern_cnt ern_cnt;
};

struct dpaa_eth_swbp {
	struct sk_buff *skb;
	struct xdp_frame *xdpf;
};

struct trace_event_raw_dpaa_eth_fd {
	struct trace_entry ent;
	u32 fqid;
	u64 fd_addr;
	u8 fd_format;
	u16 fd_offset;
	u32 fd_length;
	u32 fd_status;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_dpaa_eth_fd {
	u32 name;
};

typedef void (*btf_trace_dpaa_tx_fd)(void *, struct net_device *, struct qman_fq *, const struct qm_fd *);

typedef void (*btf_trace_dpaa_rx_fd)(void *, struct net_device *, struct qman_fq *, const struct qm_fd *);

typedef void (*btf_trace_dpaa_tx_conf_fd)(void *, struct net_device *, struct qman_fq *, const struct qm_fd *);

enum port_type {
	RX = 0,
	TX = 1,
};

struct fm_port_fqs {
	struct dpaa_fq *tx_defq;
	struct dpaa_fq *tx_errq;
	struct dpaa_fq *rx_defq;
	struct dpaa_fq *rx_errq;
	struct dpaa_fq *rx_pcdq;
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_BIND_PHC = 32768,
	SOF_TIMESTAMPING_LAST = 32768,
	SOF_TIMESTAMPING_MASK = 65535,
};

struct ctrl_regs {
	u32 tmr_ctrl;
	u32 tmr_tevent;
	u32 tmr_temask;
	u32 tmr_pevent;
	u32 tmr_pemask;
	u32 tmr_stat;
	u32 tmr_cnt_h;
	u32 tmr_cnt_l;
	u32 tmr_add;
	u32 tmr_acc;
	u32 tmr_prsc;
	u8 res1[4];
	u32 tmroff_h;
	u32 tmroff_l;
};

struct alarm_regs {
	u32 tmr_alarm1_h;
	u32 tmr_alarm1_l;
	u32 tmr_alarm2_h;
	u32 tmr_alarm2_l;
};

struct fiper_regs {
	u32 tmr_fiper1;
	u32 tmr_fiper2;
	u32 tmr_fiper3;
};

struct etts_regs {
	u32 tmr_etts1_h;
	u32 tmr_etts1_l;
	u32 tmr_etts2_h;
	u32 tmr_etts2_l;
};

struct ptp_qoriq_registers {
	struct ctrl_regs *ctrl_regs;
	struct alarm_regs *alarm_regs;
	struct fiper_regs *fiper_regs;
	struct etts_regs *etts_regs;
};

struct ptp_qoriq {
	void *base;
	struct ptp_qoriq_registers regs;
	spinlock_t lock;
	struct ptp_clock *clock;
	struct ptp_clock_info caps;
	struct resource *rsrc;
	struct dentry *debugfs_root;
	struct device *dev;
	bool extts_fifo_support;
	bool fiper3_support;
	int irq;
	int phc_index;
	u32 tclk_period;
	u32 tmr_prsc;
	u32 tmr_add;
	u32 cksel;
	u32 tmr_fiper1;
	u32 tmr_fiper2;
	u32 tmr_fiper3;
	u32 (*read)(unsigned int *);
	void (*write)(unsigned int *, u32);
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		void *ptr[0];
	};
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_packed *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_tbf_command {
	TC_TBF_REPLACE = 0,
	TC_TBF_DESTROY = 1,
	TC_TBF_STATS = 2,
};

struct tc_tbf_qopt_offload_replace_params {
	struct psched_ratecfg rate;
	u32 max_size;
	struct gnet_stats_queue *qstats;
};

struct tc_tbf_qopt_offload {
	enum tc_tbf_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_tbf_qopt_offload_replace_params replace_params;
		struct tc_qopt_offload_stats stats;
	};
};

enum dpaa2_fd_format {
	dpaa2_fd_single = 0,
	dpaa2_fd_list = 1,
	dpaa2_fd_sg = 2,
};

struct dpaa2_sg_entry {
	__le64 addr;
	__le32 len;
	__le16 bpid;
	__le16 format_offset;
};

enum dpkg_extract_from_hdr_type {
	DPKG_FROM_HDR = 0,
	DPKG_FROM_FIELD = 1,
	DPKG_FULL_FIELD = 2,
};

enum dpkg_extract_type {
	DPKG_EXTRACT_FROM_HDR = 0,
	DPKG_EXTRACT_FROM_DATA = 1,
	DPKG_EXTRACT_FROM_PARSE = 3,
};

struct dpkg_mask {
	u8 mask;
	u8 offset;
};

enum net_prot {
	NET_PROT_NONE = 0,
	NET_PROT_PAYLOAD = 1,
	NET_PROT_ETH = 2,
	NET_PROT_VLAN = 3,
	NET_PROT_IPV4 = 4,
	NET_PROT_IPV6 = 5,
	NET_PROT_IP = 6,
	NET_PROT_TCP = 7,
	NET_PROT_UDP = 8,
	NET_PROT_UDP_LITE = 9,
	NET_PROT_IPHC = 10,
	NET_PROT_SCTP = 11,
	NET_PROT_SCTP_CHUNK_DATA = 12,
	NET_PROT_PPPOE = 13,
	NET_PROT_PPP = 14,
	NET_PROT_PPPMUX = 15,
	NET_PROT_PPPMUX_SUBFRM = 16,
	NET_PROT_L2TPV2 = 17,
	NET_PROT_L2TPV3_CTRL = 18,
	NET_PROT_L2TPV3_SESS = 19,
	NET_PROT_LLC = 20,
	NET_PROT_LLC_SNAP = 21,
	NET_PROT_NLPID = 22,
	NET_PROT_SNAP = 23,
	NET_PROT_MPLS = 24,
	NET_PROT_IPSEC_AH = 25,
	NET_PROT_IPSEC_ESP = 26,
	NET_PROT_UDP_ENC_ESP = 27,
	NET_PROT_MACSEC = 28,
	NET_PROT_GRE = 29,
	NET_PROT_MINENCAP = 30,
	NET_PROT_DCCP = 31,
	NET_PROT_ICMP = 32,
	NET_PROT_IGMP = 33,
	NET_PROT_ARP = 34,
	NET_PROT_CAPWAP_DATA = 35,
	NET_PROT_CAPWAP_CTRL = 36,
	NET_PROT_RFC2684 = 37,
	NET_PROT_ICMPV6 = 38,
	NET_PROT_FCOE = 39,
	NET_PROT_FIP = 40,
	NET_PROT_ISCSI = 41,
	NET_PROT_GTP = 42,
	NET_PROT_USER_DEFINED_L2 = 43,
	NET_PROT_USER_DEFINED_L3 = 44,
	NET_PROT_USER_DEFINED_L4 = 45,
	NET_PROT_USER_DEFINED_L5 = 46,
	NET_PROT_USER_DEFINED_SHIM1 = 47,
	NET_PROT_USER_DEFINED_SHIM2 = 48,
	NET_PROT_DUMMY_LAST = 49,
};

struct dpkg_extract {
	enum dpkg_extract_type type;
	union {
		struct {
			enum net_prot prot;
			enum dpkg_extract_from_hdr_type type;
			u32 field;
			u8 size;
			u8 offset;
			u8 hdr_index;
		} from_hdr;
		struct {
			u8 size;
			u8 offset;
		} from_data;
		struct {
			u8 size;
			u8 offset;
		} from_parse;
	} extract;
	u8 num_of_byte_masks;
	struct dpkg_mask masks[4];
};

struct dpkg_profile_cfg {
	u8 num_extracts;
	struct dpkg_extract extracts[10];
};

struct dpni_pools_cfg {
	u8 num_dpbp;
	struct {
		int dpbp_id;
		u16 buffer_size;
		int backup_pool;
	} pools[8];
};

struct dpni_attr {
	u32 options;
	u8 num_queues;
	u8 num_tcs;
	u8 mac_filter_entries;
	u8 vlan_filter_entries;
	u8 qos_entries;
	u16 fs_entries;
	u8 qos_key_size;
	u8 fs_key_size;
	u16 wriop_version;
};

enum dpni_error_action {
	DPNI_ERROR_ACTION_DISCARD = 0,
	DPNI_ERROR_ACTION_CONTINUE = 1,
	DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE = 2,
};

struct dpni_error_cfg {
	u32 errors;
	enum dpni_error_action error_action;
	int set_frame_annotation;
};

struct dpni_buffer_layout {
	u32 options;
	int pass_timestamp;
	int pass_parser_result;
	int pass_frame_status;
	u16 private_data_size;
	u16 data_align;
	u16 data_head_room;
	u16 data_tail_room;
};

enum dpni_queue_type {
	DPNI_QUEUE_RX = 0,
	DPNI_QUEUE_TX = 1,
	DPNI_QUEUE_TX_CONFIRM = 2,
	DPNI_QUEUE_RX_ERR = 3,
};

enum dpni_offload {
	DPNI_OFF_RX_L3_CSUM = 0,
	DPNI_OFF_RX_L4_CSUM = 1,
	DPNI_OFF_TX_L3_CSUM = 2,
	DPNI_OFF_TX_L4_CSUM = 3,
};

union dpni_statistics {
	struct {
		u64 ingress_all_frames;
		u64 ingress_all_bytes;
		u64 ingress_multicast_frames;
		u64 ingress_multicast_bytes;
		u64 ingress_broadcast_frames;
		u64 ingress_broadcast_bytes;
	} page_0;
	struct {
		u64 egress_all_frames;
		u64 egress_all_bytes;
		u64 egress_multicast_frames;
		u64 egress_multicast_bytes;
		u64 egress_broadcast_frames;
		u64 egress_broadcast_bytes;
	} page_1;
	struct {
		u64 ingress_filtered_frames;
		u64 ingress_discarded_frames;
		u64 ingress_nobuffer_discards;
		u64 egress_discarded_frames;
		u64 egress_confirmed_frames;
	} page_2;
	struct {
		u64 egress_dequeue_bytes;
		u64 egress_dequeue_frames;
		u64 egress_reject_bytes;
		u64 egress_reject_frames;
	} page_3;
	struct {
		u64 cgr_reject_frames;
		u64 cgr_reject_bytes;
	} page_4;
	struct {
		u64 policer_cnt_red;
		u64 policer_cnt_yellow;
		u64 policer_cnt_green;
		u64 policer_cnt_re_red;
		u64 policer_cnt_re_yellow;
	} page_5;
	struct {
		u64 tx_pending_frames;
	} page_6;
	struct {
		u64 counter[7];
	} raw;
};

struct dpni_link_cfg {
	u32 rate;
	u64 options;
};

struct dpni_link_state {
	u32 rate;
	u64 options;
	int up;
};

enum dpni_dist_mode {
	DPNI_DIST_MODE_NONE = 0,
	DPNI_DIST_MODE_HASH = 1,
	DPNI_DIST_MODE_FS = 2,
};

enum dpni_fs_miss_action {
	DPNI_FS_MISS_DROP = 0,
	DPNI_FS_MISS_EXPLICIT_FLOWID = 1,
	DPNI_FS_MISS_HASH = 2,
};

struct dpni_fs_tbl_cfg {
	enum dpni_fs_miss_action miss_action;
	u16 default_flow_id;
};

struct dpni_rx_tc_dist_cfg {
	u16 dist_size;
	enum dpni_dist_mode dist_mode;
	u64 key_cfg_iova;
	struct dpni_fs_tbl_cfg fs_cfg;
};

struct dpni_rx_dist_cfg {
	u16 dist_size;
	u64 key_cfg_iova;
	u8 enable;
	u8 tc;
	u16 fs_miss_flow_id;
};

struct dpni_qos_tbl_cfg {
	u64 key_cfg_iova;
	int discard_on_miss;
	u8 default_tc;
};

enum dpni_dest {
	DPNI_DEST_NONE = 0,
	DPNI_DEST_DPIO = 1,
	DPNI_DEST_DPCON = 2,
};

struct dpni_queue {
	struct {
		u16 id;
		enum dpni_dest type;
		char hold_active;
		u8 priority;
	} destination;
	u64 user_context;
	struct {
		u64 value;
		char stash_control;
	} flc;
};

struct dpni_queue_id {
	u32 fqid;
	u16 qdbin;
};

enum dpni_congestion_unit {
	DPNI_CONGESTION_UNIT_BYTES = 0,
	DPNI_CONGESTION_UNIT_FRAMES = 1,
};

enum dpni_congestion_point {
	DPNI_CP_QUEUE = 0,
	DPNI_CP_GROUP = 1,
};

struct dpni_taildrop {
	char enable;
	enum dpni_congestion_unit units;
	u32 threshold;
};

struct dpni_rule_cfg {
	u64 key_iova;
	u64 mask_iova;
	u8 key_size;
};

struct dpni_tx_shaping_cfg {
	u32 rate_limit;
	u16 max_burst_size;
};

struct dpni_single_step_cfg {
	u8 en;
	u8 ch_update;
	u16 offset;
	u32 peer_delay;
};

struct dpaa2_debugfs {
	struct dentry *dir;
};

enum dpmac_link_type {
	DPMAC_LINK_TYPE_NONE = 0,
	DPMAC_LINK_TYPE_FIXED = 1,
	DPMAC_LINK_TYPE_PHY = 2,
	DPMAC_LINK_TYPE_BACKPLANE = 3,
};

enum dpmac_eth_if {
	DPMAC_ETH_IF_MII = 0,
	DPMAC_ETH_IF_RMII = 1,
	DPMAC_ETH_IF_SMII = 2,
	DPMAC_ETH_IF_GMII = 3,
	DPMAC_ETH_IF_RGMII = 4,
	DPMAC_ETH_IF_SGMII = 5,
	DPMAC_ETH_IF_QSGMII = 6,
	DPMAC_ETH_IF_XAUI = 7,
	DPMAC_ETH_IF_XFI = 8,
	DPMAC_ETH_IF_CAUI = 9,
	DPMAC_ETH_IF_1000BASEX = 10,
	DPMAC_ETH_IF_USXGMII = 11,
};

struct dpmac_attr {
	u16 id;
	u32 max_rate;
	enum dpmac_eth_if eth_if;
	enum dpmac_link_type link_type;
};

struct dpmac_link_state {
	u32 rate;
	u64 options;
	int up;
	int state_valid;
	u64 supported;
	u64 advertising;
};

struct dpaa2_mac {
	struct fsl_mc_device *mc_dev;
	struct dpmac_link_state state;
	struct net_device *net_dev;
	struct fsl_mc_io *mc_io;
	struct dpmac_attr attr;
	struct phylink_config phylink_config;
	struct phylink *phylink;
	phy_interface_t if_mode;
	enum dpmac_link_type if_link_type;
	struct lynx_pcs *pcs;
	struct fwnode_handle *fw_node;
};

enum dpaa2_eth_swa_type {
	DPAA2_ETH_SWA_SINGLE = 0,
	DPAA2_ETH_SWA_SG = 1,
	DPAA2_ETH_SWA_XDP = 2,
};

struct dpaa2_eth_swa {
	enum dpaa2_eth_swa_type type;
	union {
		struct {
			struct sk_buff *skb;
			int sgt_size;
		} single;
		struct {
			struct sk_buff *skb;
			struct scatterlist *scl;
			int num_sg;
			int sgt_size;
		} sg;
		struct {
			int dma_size;
			struct xdp_frame *xdpf;
		} xdp;
	};
};

struct dpaa2_fas {
	u8 reserved;
	u8 ppid;
	__le16 ifpid;
	__le32 status;
};

struct dpaa2_fapr {
	__le32 faf_lo;
	__le16 faf_ext;
	__le16 nxt_hdr;
	__le64 faf_hi;
	u8 last_ethertype_offset;
	u8 vlan_tci_offset_n;
	u8 vlan_tci_offset_1;
	u8 llc_snap_offset;
	u8 eth_offset;
	u8 ip1_pid_offset;
	u8 shim_offset_2;
	u8 shim_offset_1;
	u8 l5_offset;
	u8 l4_offset;
	u8 gre_offset;
	u8 l3_offset_n;
	u8 l3_offset_1;
	u8 mpls_offset_n;
	u8 mpls_offset_1;
	u8 pppoe_offset;
	__le16 running_sum;
	__le16 gross_running_sum;
	u8 ipv6_frag_offset;
	u8 nxt_hdr_offset;
	u8 routing_hdr_offset_2;
	u8 routing_hdr_offset_1;
	u8 reserved[5];
	u8 ip_proto_offset_n;
	u8 nxt_hdr_frag_offset;
	u8 parse_error_code;
};

struct dpaa2_faead {
	__le32 conf_fqid;
	__le32 ctrl;
};

struct ptp_tstamp {
	u16 sec_msb;
	u32 sec_lsb;
	u32 nsec;
};

struct dpaa2_eth_drv_stats {
	__u64 tx_conf_frames;
	__u64 tx_conf_bytes;
	__u64 tx_sg_frames;
	__u64 tx_sg_bytes;
	__u64 rx_sg_frames;
	__u64 rx_sg_bytes;
	__u64 tx_converted_sg_frames;
	__u64 tx_converted_sg_bytes;
	__u64 tx_portal_busy;
};

struct dpaa2_eth_fq_stats {
	__u64 frames;
};

struct dpaa2_eth_ch_stats {
	__u64 dequeue_portal_busy;
	__u64 pull_err;
	__u64 cdan;
	__u64 xdp_drop;
	__u64 xdp_tx;
	__u64 xdp_tx_err;
	__u64 xdp_redirect;
	__u64 frames;
};

enum dpaa2_eth_fq_type {
	DPAA2_RX_FQ = 0,
	DPAA2_TX_CONF_FQ = 1,
	DPAA2_RX_ERR_FQ = 2,
};

struct dpaa2_eth_xdp_fds {
	struct dpaa2_fd fds[16];
	ssize_t num;
};

struct dpaa2_eth_channel;

struct dpaa2_eth_priv;

struct dpaa2_eth_fq {
	u32 fqid;
	u32 tx_qdbin;
	u32 tx_fqid[8];
	u16 flowid;
	u8 tc;
	int target_cpu;
	u32 dq_frames;
	u32 dq_bytes;
	struct dpaa2_eth_channel *channel;
	enum dpaa2_eth_fq_type type;
	void (*consume)(struct dpaa2_eth_priv *, struct dpaa2_eth_channel *, const struct dpaa2_fd *, struct dpaa2_eth_fq *);
	struct dpaa2_eth_fq_stats stats;
	struct dpaa2_eth_xdp_fds xdp_redirect_fds;
	struct dpaa2_eth_xdp_fds xdp_tx_fds;
};

struct dpaa2_eth_ch_xdp {
	struct bpf_prog *prog;
	unsigned int res;
};

struct dpaa2_eth_channel {
	struct dpaa2_io_notification_ctx nctx;
	struct fsl_mc_device *dpcon;
	int dpcon_id;
	int ch_id;
	struct napi_struct napi;
	struct dpaa2_io *dpio;
	struct dpaa2_io_store *store;
	struct dpaa2_eth_priv *priv;
	int buf_count;
	struct dpaa2_eth_ch_stats stats;
	struct dpaa2_eth_ch_xdp xdp;
	struct xdp_rxq_info xdp_rxq;
	struct list_head *rx_list;
	u64 recycled_bufs[7];
	int recycled_bufs_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dpaa2_eth_sgt_cache;

struct dpaa2_eth_cls_rule;

struct dpaa2_eth_trap_data;

struct dpaa2_eth_priv {
	struct net_device *net_dev;
	u8 num_fqs;
	struct dpaa2_eth_fq fq[145];
	int (*enqueue)(struct dpaa2_eth_priv *, struct dpaa2_eth_fq *, struct dpaa2_fd *, u8, u32, int *);
	u8 num_channels;
	struct dpaa2_eth_channel *channel[16];
	struct dpaa2_eth_sgt_cache *sgt_cache;
	struct dpni_attr dpni_attrs;
	u16 dpni_ver_major;
	u16 dpni_ver_minor;
	u16 tx_data_offset;
	struct fsl_mc_device *dpbp_dev;
	u16 rx_buf_size;
	u16 bpid;
	struct iommu_domain *iommu_domain;
	enum hwtstamp_tx_types tx_tstamp_type;
	bool rx_tstamp;
	u16 tx_qdid;
	struct fsl_mc_io *mc_io;
	struct cpumask dpio_cpumask;
	struct rtnl_link_stats64 *percpu_stats;
	struct dpaa2_eth_drv_stats *percpu_extras;
	u16 mc_token;
	u8 rx_fqtd_enabled;
	u8 rx_cgtd_enabled;
	struct dpni_link_state link_state;
	bool do_link_poll;
	struct task_struct *poll_thread;
	u64 rx_hash_fields;
	u64 rx_cls_fields;
	struct dpaa2_eth_cls_rule *cls_rules;
	u8 rx_cls_enabled;
	u8 vlan_cls_enabled;
	u8 pfc_enabled;
	struct bpf_prog *xdp_prog;
	struct dpaa2_debugfs dbg;
	struct dpaa2_mac *mac;
	struct workqueue_struct *dpaa2_ptp_wq;
	struct work_struct tx_onestep_tstamp;
	struct sk_buff_head tx_skbs;
	struct mutex onestep_tstamp_lock;
	struct devlink *devlink;
	struct dpaa2_eth_trap_data *trap_data;
	struct devlink_port devlink_port;
	u32 rx_copybreak;
};

struct dpaa2_eth_dist_fields {
	u64 rxnfc_field;
	enum net_prot cls_prot;
	int cls_field;
	int size;
	u64 id;
};

struct dpaa2_eth_cls_rule {
	struct ethtool_rx_flow_spec fs;
	u8 in_use;
};

struct dpaa2_eth_sgt_cache {
	void *buf[256];
	u16 count;
};

struct dpaa2_eth_trap_item {
	void *trap_ctx;
};

struct dpaa2_eth_trap_data {
	struct dpaa2_eth_trap_item *trap_items_arr;
	struct dpaa2_eth_priv *priv;
};

enum dpaa2_eth_rx_dist {
	DPAA2_ETH_RX_DIST_HASH = 0,
	DPAA2_ETH_RX_DIST_CLS = 1,
};

struct trace_event_raw_dpaa2_eth_fd {
	struct trace_entry ent;
	u64 fd_addr;
	u32 fd_len;
	u16 fd_offset;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_dpaa2_eth_buf_seed {
	struct trace_entry ent;
	void *vaddr;
	size_t size;
	dma_addr_t dma_addr;
	size_t map_size;
	u16 bpid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_dpaa2_eth_fd {
	u32 name;
};

struct trace_event_data_offsets_dpaa2_eth_buf_seed {
	u32 name;
};

typedef void (*btf_trace_dpaa2_tx_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_rx_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_tx_conf_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_eth_buf_seed)(void *, struct net_device *, void *, size_t, dma_addr_t, size_t, u16);

struct dpni_fs_action_cfg {
	u64 flc;
	u16 flow_id;
	u16 options;
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	__ETHTOOL_TUNABLE_COUNT = 4,
};

struct dpni_dest_cfg {
	enum dpni_dest dest_type;
	int dest_id;
	u8 priority;
};

struct dpni_congestion_notification_cfg {
	enum dpni_congestion_unit units;
	u32 threshold_entry;
	u32 threshold_exit;
	u64 message_ctx;
	u64 message_iova;
	struct dpni_dest_cfg dest_cfg;
	u16 notification_mode;
};

struct dpni_cmd_open {
	__le32 dpni_id;
};

struct dpni_cmd_set_pools {
	u8 num_dpbp;
	u8 backup_pool_mask;
	__le16 pad;
	__le32 dpbp_id[8];
	__le16 buffer_size[8];
};

struct dpni_rsp_is_enabled {
	u8 enabled;
};

struct dpni_cmd_set_irq_enable {
	u8 enable;
	u8 pad[3];
	u8 irq_index;
};

struct dpni_cmd_get_irq_enable {
	__le32 pad;
	u8 irq_index;
};

struct dpni_rsp_get_irq_enable {
	u8 enabled;
};

struct dpni_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
};

struct dpni_cmd_get_irq_mask {
	__le32 pad;
	u8 irq_index;
};

struct dpni_rsp_get_irq_mask {
	__le32 mask;
};

struct dpni_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dpni_rsp_get_irq_status {
	__le32 status;
};

struct dpni_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dpni_rsp_get_attr {
	__le32 options;
	u8 num_queues;
	u8 num_tcs;
	u8 mac_filter_entries;
	u8 pad0;
	u8 vlan_filter_entries;
	u8 pad1;
	u8 qos_entries;
	u8 pad2;
	__le16 fs_entries;
	__le16 pad3;
	u8 qos_key_size;
	u8 fs_key_size;
	__le16 wriop_version;
};

struct dpni_cmd_set_errors_behavior {
	__le32 errors;
	u8 flags;
};

struct dpni_cmd_get_buffer_layout {
	u8 qtype;
};

struct dpni_rsp_get_buffer_layout {
	u8 pad0[6];
	u8 flags;
	u8 pad1;
	__le16 private_data_size;
	__le16 data_align;
	__le16 head_room;
	__le16 tail_room;
};

struct dpni_cmd_set_buffer_layout {
	u8 qtype;
	u8 pad0[3];
	__le16 options;
	u8 flags;
	u8 pad1;
	__le16 private_data_size;
	__le16 data_align;
	__le16 head_room;
	__le16 tail_room;
};

struct dpni_cmd_set_offload {
	u8 pad[3];
	u8 dpni_offload;
	__le32 config;
};

struct dpni_cmd_get_offload {
	u8 pad[3];
	u8 dpni_offload;
};

struct dpni_rsp_get_offload {
	__le32 pad;
	__le32 config;
};

struct dpni_cmd_get_qdid {
	u8 qtype;
};

struct dpni_rsp_get_qdid {
	__le16 qdid;
};

struct dpni_rsp_get_tx_data_offset {
	__le16 data_offset;
};

struct dpni_cmd_get_statistics {
	u8 page_number;
};

struct dpni_rsp_get_statistics {
	__le64 counter[7];
};

struct dpni_cmd_link_cfg {
	__le64 pad0;
	__le32 rate;
	__le32 pad1;
	__le64 options;
};

struct dpni_rsp_get_link_state {
	__le32 pad0;
	u8 flags;
	u8 pad1[3];
	__le32 rate;
	__le32 pad2;
	__le64 options;
};

struct dpni_cmd_set_max_frame_length {
	__le16 max_frame_length;
};

struct dpni_rsp_get_max_frame_length {
	__le16 max_frame_length;
};

struct dpni_cmd_set_multicast_promisc {
	u8 enable;
};

struct dpni_rsp_get_multicast_promisc {
	u8 enabled;
};

struct dpni_cmd_set_unicast_promisc {
	u8 enable;
};

struct dpni_rsp_get_unicast_promisc {
	u8 enabled;
};

struct dpni_cmd_set_primary_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_rsp_get_primary_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_rsp_get_port_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_cmd_add_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_cmd_remove_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_cmd_clear_mac_filters {
	u8 flags;
};

struct dpni_cmd_set_rx_tc_dist {
	__le16 dist_size;
	u8 tc_id;
	u8 flags;
	__le16 pad0;
	__le16 default_flow_id;
	__le64 pad1[5];
	__le64 key_cfg_iova;
};

struct dpni_mask_cfg {
	u8 mask;
	u8 offset;
};

struct dpni_dist_extract {
	u8 prot;
	u8 efh_type;
	u8 size;
	u8 offset;
	__le32 field;
	u8 hdr_index;
	u8 constant;
	u8 num_of_repeats;
	u8 num_of_byte_masks;
	u8 extract_type;
	u8 pad[3];
	struct dpni_mask_cfg masks[4];
};

struct dpni_ext_set_rx_tc_dist {
	u8 num_extracts;
	u8 pad[7];
	struct dpni_dist_extract extracts[10];
};

struct dpni_cmd_get_queue {
	u8 qtype;
	u8 tc;
	u8 index;
};

struct dpni_rsp_get_queue {
	__le64 pad0;
	__le32 dest_id;
	__le16 pad1;
	u8 dest_prio;
	u8 flags;
	__le64 flc;
	__le64 user_context;
	__le32 fqid;
	__le16 qdbin;
};

struct dpni_cmd_set_queue {
	u8 qtype;
	u8 tc;
	u8 index;
	u8 options;
	__le32 pad0;
	__le32 dest_id;
	__le16 pad1;
	u8 dest_prio;
	u8 flags;
	__le64 flc;
	__le64 user_context;
};

struct dpni_cmd_set_taildrop {
	u8 congestion_point;
	u8 qtype;
	u8 tc;
	u8 index;
	__le32 pad0;
	u8 enable;
	u8 pad1;
	u8 units;
	u8 pad2;
	__le32 threshold;
};

struct dpni_cmd_get_taildrop {
	u8 congestion_point;
	u8 qtype;
	u8 tc;
	u8 index;
};

struct dpni_rsp_get_taildrop {
	__le64 pad0;
	u8 enable;
	u8 pad1;
	u8 units;
	u8 pad2;
	__le32 threshold;
};

struct dpni_rsp_get_api_version {
	__le16 major;
	__le16 minor;
};

struct dpni_cmd_set_rx_fs_dist {
	__le16 dist_size;
	u8 enable;
	u8 tc;
	__le16 miss_flow_id;
	__le16 pad;
	__le64 key_cfg_iova;
};

struct dpni_cmd_set_rx_hash_dist {
	__le16 dist_size;
	u8 enable;
	u8 tc;
	__le32 pad;
	__le64 key_cfg_iova;
};

struct dpni_cmd_add_fs_entry {
	__le16 options;
	u8 tc_id;
	u8 key_size;
	__le16 index;
	__le16 flow_id;
	__le64 key_iova;
	__le64 mask_iova;
	__le64 flc;
};

struct dpni_cmd_remove_fs_entry {
	__le16 pad0;
	u8 tc_id;
	u8 key_size;
	__le32 pad1;
	__le64 key_iova;
	__le64 mask_iova;
};

struct dpni_cmd_set_qos_table {
	__le32 pad;
	u8 default_tc;
	u8 discard_on_miss;
	__le16 pad1[21];
	__le64 key_cfg_iova;
};

struct dpni_cmd_add_qos_entry {
	__le16 pad;
	u8 tc_id;
	u8 key_size;
	__le16 index;
	__le16 pad1;
	__le64 key_iova;
	__le64 mask_iova;
};

struct dpni_cmd_remove_qos_entry {
	u8 pad[3];
	u8 key_size;
	__le32 pad1;
	__le64 key_iova;
	__le64 mask_iova;
};

struct dpni_cmd_set_congestion_notification {
	u8 qtype;
	u8 tc;
	u8 pad[6];
	__le32 dest_id;
	__le16 notification_mode;
	u8 dest_priority;
	u8 type_units;
	__le64 message_iova;
	__le64 message_ctx;
	__le32 threshold_entry;
	__le32 threshold_exit;
};

struct dpni_cmd_set_tx_shaping {
	__le16 tx_cr_max_burst_size;
	__le16 tx_er_max_burst_size;
	__le32 pad;
	__le32 tx_cr_rate_limit;
	__le32 tx_er_rate_limit;
	u8 coupled;
};

struct dpni_cmd_single_step_cfg {
	__le16 flags;
	__le16 offset;
	__le32 peer_delay;
};

struct dpni_rsp_single_step_cfg {
	__le16 flags;
	__le16 offset;
	__le32 peer_delay;
};

struct dpni_cmd_enable_vlan_filter {
	u8 en;
};

struct dpni_cmd_vlan_id {
	u8 flags;
	u8 tc_id;
	u8 flow_id;
	u8 pad;
	__le16 vlan_id;
};

enum dpmac_counter_id {
	DPMAC_CNT_ING_FRAME_64 = 0,
	DPMAC_CNT_ING_FRAME_127 = 1,
	DPMAC_CNT_ING_FRAME_255 = 2,
	DPMAC_CNT_ING_FRAME_511 = 3,
	DPMAC_CNT_ING_FRAME_1023 = 4,
	DPMAC_CNT_ING_FRAME_1518 = 5,
	DPMAC_CNT_ING_FRAME_1519_MAX = 6,
	DPMAC_CNT_ING_FRAG = 7,
	DPMAC_CNT_ING_JABBER = 8,
	DPMAC_CNT_ING_FRAME_DISCARD = 9,
	DPMAC_CNT_ING_ALIGN_ERR = 10,
	DPMAC_CNT_EGR_UNDERSIZED = 11,
	DPMAC_CNT_ING_OVERSIZED = 12,
	DPMAC_CNT_ING_VALID_PAUSE_FRAME = 13,
	DPMAC_CNT_EGR_VALID_PAUSE_FRAME = 14,
	DPMAC_CNT_ING_BYTE = 15,
	DPMAC_CNT_ING_MCAST_FRAME = 16,
	DPMAC_CNT_ING_BCAST_FRAME = 17,
	DPMAC_CNT_ING_ALL_FRAME = 18,
	DPMAC_CNT_ING_UCAST_FRAME = 19,
	DPMAC_CNT_ING_ERR_FRAME = 20,
	DPMAC_CNT_EGR_BYTE = 21,
	DPMAC_CNT_EGR_MCAST_FRAME = 22,
	DPMAC_CNT_EGR_BCAST_FRAME = 23,
	DPMAC_CNT_EGR_UCAST_FRAME = 24,
	DPMAC_CNT_EGR_ERR_FRAME = 25,
	DPMAC_CNT_ING_GOOD_FRAME = 26,
	DPMAC_CNT_EGR_GOOD_FRAME = 27,
};

struct dpmac_cmd_open {
	__le32 dpmac_id;
};

struct dpmac_rsp_get_attributes {
	u8 eth_if;
	u8 link_type;
	__le16 id;
	__le32 max_rate;
};

struct dpmac_cmd_set_link_state {
	__le64 options;
	__le32 rate;
	__le32 pad0;
	u8 state;
	u8 pad1[7];
	__le64 supported;
	__le64 advertising;
};

struct dpmac_cmd_get_counter {
	u8 id;
};

struct dpmac_rsp_get_counter {
	__le64 pad;
	__le64 counter;
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
	DEVLINK_TRAP_GENERIC_ID_STP = 29,
	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_NEXTHOP = 90,
	DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER = 91,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 92,
	DEVLINK_TRAP_GENERIC_ID_MAX = 91,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 25,
};

struct dpaa2_eth_devlink_priv {
	struct dpaa2_eth_priv *dpaa2_priv;
};

struct dpaa2_faf_error_bit {
	int position;
	enum devlink_trap_generic_id trap_id;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_PPS = 2,
	PTP_CLOCK_PPSUSR = 3,
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		struct pps_event_time pps_times;
	};
};

struct dprtc_cmd_open {
	__le32 dprtc_id;
};

struct dprtc_cmd_get_irq {
	__le32 pad;
	u8 irq_index;
} __attribute__((packed));

struct dprtc_cmd_set_irq_enable {
	u8 en;
	u8 pad[3];
	u8 irq_index;
};

struct dprtc_rsp_get_irq_enable {
	u8 en;
};

struct dprtc_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
} __attribute__((packed));

struct dprtc_rsp_get_irq_mask {
	__le32 mask;
};

struct dprtc_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
} __attribute__((packed));

struct dprtc_rsp_get_irq_status {
	__le32 status;
};

struct dprtc_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
} __attribute__((packed));

struct enetc_hw {
	void *reg;
	void *port;
	void *global;
};

enum enetc_bdr_type {
	TX___2 = 0,
	RX___2 = 1,
};

struct enetc_cmd_rfse {
	u8 smac_h[6];
	u8 smac_m[6];
	u8 dmac_h[6];
	u8 dmac_m[6];
	__be32 sip_h[4];
	__be32 sip_m[4];
	__be32 dip_h[4];
	__be32 dip_m[4];
	u16 ethtype_h;
	u16 ethtype_m;
	u16 ethtype4_h;
	u16 ethtype4_m;
	u16 sport_h;
	u16 sport_m;
	u16 dport_h;
	u16 dport_m;
	u16 vlan_h;
	u16 vlan_m;
	u8 proto_h;
	u8 proto_m;
	u16 flags;
	u16 result;
	u16 mode;
};

enum enetc_msg_cmd_status {
	ENETC_MSG_CMD_STATUS_OK = 0,
	ENETC_MSG_CMD_STATUS_FAIL = 1,
};

enum enetc_msg_cmd_type {
	ENETC_MSG_CMD_MNG_MAC = 1,
	ENETC_MSG_CMD_MNG_RX_MAC_FILTER = 2,
	ENETC_MSG_CMD_MNG_RX_VLAN_FILTER = 3,
};

enum enetc_msg_cmd_action_type {
	ENETC_MSG_CMD_MNG_ADD = 1,
	ENETC_MSG_CMD_MNG_REMOVE = 2,
};

struct enetc_msg_cmd_header {
	u16 type;
	u16 id;
};

struct enetc_tx_swbd {
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdp_frame;
	};
	dma_addr_t dma;
	struct page *page;
	u16 page_offset;
	u16 len;
	enum dma_data_direction dir;
	u8 is_dma_page: 1;
	u8 check_wb: 1;
	u8 do_twostep_tstamp: 1;
	u8 is_eof: 1;
	u8 is_xdp_tx: 1;
	u8 is_xdp_redirect: 1;
};

struct enetc_rx_swbd {
	dma_addr_t dma;
	struct page *page;
	u16 page_offset;
	enum dma_data_direction dir;
	u16 len;
};

struct enetc_ring_stats {
	unsigned int packets;
	unsigned int bytes;
	unsigned int rx_alloc_errs;
	unsigned int xdp_drops;
	unsigned int xdp_tx;
	unsigned int xdp_tx_drops;
	unsigned int xdp_redirect;
	unsigned int xdp_redirect_failures;
	unsigned int xdp_redirect_sg;
	unsigned int recycles;
	unsigned int recycle_failures;
};

struct enetc_xdp_data {
	struct xdp_rxq_info rxq;
	struct bpf_prog *prog;
	int xdp_tx_in_flight;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct enetc_bdr {
	struct device *dev;
	struct net_device *ndev;
	void *bd_base;
	union {
		void *tpir;
		void *rcir;
	};
	u16 index;
	u16 prio;
	int bd_count;
	int next_to_use;
	int next_to_clean;
	union {
		struct enetc_tx_swbd *tx_swbd;
		struct enetc_rx_swbd *rx_swbd;
	};
	union {
		void *tcir;
		int next_to_alloc;
	};
	void *idr;
	int buffer_offset;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct enetc_xdp_data xdp;
	struct enetc_ring_stats stats;
	dma_addr_t bd_dma_base;
	u8 tsd_enable;
	bool ext_en;
};

struct enetc_cbdr {
	void *bd_base;
	void *pir;
	void *cir;
	void *mr;
	int bd_count;
	int next_to_use;
	int next_to_clean;
	dma_addr_t bd_dma_base;
	struct device *dma_dev;
};

struct enetc_msg_swbd {
	void *vaddr;
	dma_addr_t dma;
	int size;
};

enum enetc_errata {
	ENETC_ERR_VLAN_ISOL = 1,
	ENETC_ERR_UCMCSWP = 2,
};

struct enetc_si {
	struct pci_dev *pdev;
	struct enetc_hw hw;
	enum enetc_errata errata;
	struct net_device *ndev;
	struct enetc_cbdr cbd_ring;
	int num_rx_rings;
	int num_tx_rings;
	int num_fs_entries;
	int num_rss;
	short unsigned int pad;
	int hw_features;
};

struct enetc_int_vector {
	void *rbier;
	void *tbier_base;
	void *ricr1;
	long unsigned int tx_rings_map;
	int count_tx_rings;
	u32 rx_ictt;
	u16 comp_cnt;
	bool rx_dim_en;
	bool rx_napi_work;
	long: 64;
	long: 64;
	struct napi_struct napi;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dim rx_dim;
	char name[24];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct enetc_bdr rx_ring;
	struct enetc_bdr tx_ring[0];
};

struct enetc_cls_rule {
	struct ethtool_rx_flow_spec fs;
	int used;
};

struct psfp_cap {
	u32 max_streamid;
	u32 max_psfp_filter;
	u32 max_psfp_gate;
	u32 max_psfp_gatelist;
	u32 max_psfp_meter;
};

enum enetc_active_offloads {
	ENETC_F_TX_TSTAMP = 1,
	ENETC_F_TX_ONESTEP_SYNC_TSTAMP = 2,
	ENETC_F_RX_TSTAMP = 256,
	ENETC_F_QBV = 512,
	ENETC_F_QCI = 1024,
};

struct enetc_ndev_priv {
	struct net_device *ndev;
	struct device *dev;
	struct enetc_si *si;
	int bdr_int_num;
	struct enetc_int_vector *int_vector[2];
	u16 num_rx_rings;
	u16 num_tx_rings;
	u16 rx_bd_count;
	u16 tx_bd_count;
	u16 msg_enable;
	enum enetc_active_offloads active_offloads;
	u32 speed;
	struct enetc_bdr **xdp_tx_ring;
	struct enetc_bdr *tx_ring[16];
	struct enetc_bdr *rx_ring[16];
	struct enetc_cls_rule *cls_rules;
	struct psfp_cap psfp_cap;
	struct phylink *phylink;
	int ic_mode;
	u32 tx_ictt;
	struct bpf_prog *xdp_prog;
	long unsigned int flags;
	struct work_struct tx_onestep_tstamp;
	struct sk_buff_head tx_skbs;
};

struct enetc_msg_cmd_set_primary_mac {
	struct enetc_msg_cmd_header header;
	struct sockaddr mac;
};

enum enetc_mac_addr_type {
	UC = 0,
	MC = 1,
	MADDR_TYPE = 2,
};

struct enetc_mac_filter {
	union {
		char mac_addr[6];
		long unsigned int mac_hash_table[1];
	};
	int mac_addr_cnt;
};

enum enetc_vf_flags {
	ENETC_VF_FLAG_PF_SET_MAC = 1,
};

struct enetc_vf_state {
	enum enetc_vf_flags flags;
};

struct enetc_pf {
	struct enetc_si *si;
	int num_vfs;
	int total_vfs;
	struct enetc_vf_state *vf_state;
	struct enetc_mac_filter mac_filter[6];
	struct enetc_msg_swbd rxmsg[2];
	struct work_struct msg_task;
	char msg_int_name[24];
	char vlan_promisc_simap;
	long unsigned int vlan_ht_filter[1];
	long unsigned int active_vlans[64];
	struct mii_bus *mdio;
	struct mii_bus *imdio;
	struct lynx_pcs *pcs;
	phy_interface_t if_mode;
	struct phylink_config phylink_config;
};

union enetc_tx_bd {
	struct {
		__le64 addr;
		__le16 buf_len;
		__le16 frm_len;
		union {
			struct {
				u8 reserved[3];
				u8 flags;
			};
			__le32 txstart;
			__le32 lstatus;
		};
	};
	struct {
		__le32 tstamp;
		__le16 tpid;
		__le16 vid;
		u8 reserved[6];
		u8 e_flags;
		u8 flags;
	} ext;
	struct {
		__le32 tstamp;
		u8 reserved[10];
		u8 status;
		u8 flags;
	} wb;
};

enum enetc_txbd_flags {
	ENETC_TXBD_FLAGS_RES0 = 1,
	ENETC_TXBD_FLAGS_TSE = 2,
	ENETC_TXBD_FLAGS_W = 4,
	ENETC_TXBD_FLAGS_RES3 = 8,
	ENETC_TXBD_FLAGS_TXSTART = 16,
	ENETC_TXBD_FLAGS_EX = 64,
	ENETC_TXBD_FLAGS_F = 128,
};

union enetc_rx_bd {
	struct {
		__le64 addr;
		u8 reserved[8];
	} w;
	struct {
		__le16 inet_csum;
		__le16 parse_summary;
		__le32 rss_hash;
		__le16 buf_len;
		__le16 vlan_opt;
		union {
			struct {
				__le16 flags;
				__le16 error;
			};
			__le32 lstatus;
		};
	} r;
	struct {
		__le32 tstamp;
		u8 reserved[12];
	} ext;
};

enum enetc_flags_bit {
	ENETC_TX_ONESTEP_TSTAMP_IN_PROGRESS = 0,
};

enum enetc_ic_mode {
	ENETC_IC_NONE = 0,
	ENETC_IC_RX_MANUAL = 1,
	ENETC_IC_TX_MANUAL = 2,
	ENETC_IC_RX_ADAPTIVE = 4,
};

struct tgs_gcl_conf {
	u8 atc;
	u8 res[7];
	struct {
		u8 res1[4];
		__le16 acl_len;
		u8 res2[2];
	};
};

struct streamid_conf {
	__le32 stream_handle;
	__le32 iports;
	u8 id_type;
	u8 oui[3];
	u8 res[3];
	u8 en;
};

struct sfi_conf {
	__le32 stream_handle;
	u8 multi;
	u8 res[2];
	u8 sthm;
	__le16 fm_inst_table_index;
	__le16 msdu;
	__le16 sg_inst_table_index;
	u8 res1[2];
	__le32 input_ports;
	u8 res2[3];
	u8 en;
};

struct sgi_table {
	u8 res[8];
	u8 oipv;
	u8 res0[2];
	u8 ocgtst;
	u8 res1[7];
	u8 gset;
	u8 oacl_len;
	u8 res2[2];
	u8 en;
};

struct sgcl_conf {
	u8 aipv;
	u8 res[2];
	u8 agtst;
	u8 res1[4];
	union {
		struct {
			u8 res2[4];
			u8 acl_len;
			u8 res3[3];
		};
		u8 cct[8];
	};
};

struct fmi_conf {
	__le32 cir;
	__le32 cbs;
	__le32 eir;
	__le32 ebs;
	u8 conf;
	u8 res1;
	u8 ir_fpp;
	u8 res2[4];
	u8 en;
};

struct enetc_cbd {
	union {
		struct sfi_conf sfi_conf;
		struct sgi_table sgi_table;
		struct fmi_conf fmi_conf;
		struct {
			__le32 addr[2];
			union {
				__le32 opt[4];
				struct tgs_gcl_conf gcl_conf;
				struct streamid_conf sid_set;
				struct sgcl_conf sgcl_conf;
			};
		};
		__le32 data[6];
	};
	__le16 index;
	__le16 length;
	u8 cmd;
	u8 cls;
	u8 _res;
	u8 status_flags;
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

struct enetc_ierb {
	void *regs;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	__NDA_MAX = 15,
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	RTM_NEWNEXTHOPBUCKET = 116,
	RTM_DELNEXTHOPBUCKET = 117,
	RTM_GETNEXTHOPBUCKET = 118,
	__RTM_MAX = 119,
};

enum ocelot_ptp_pins {
	PTP_PIN_0 = 0,
	PTP_PIN_1 = 1,
	PTP_PIN_2 = 2,
	PTP_PIN_3 = 3,
	TOD_ACC_PIN = 4,
};

enum {
	PTP_PIN_ACTION_IDLE = 0,
	PTP_PIN_ACTION_LOAD = 1,
	PTP_PIN_ACTION_SAVE = 2,
	PTP_PIN_ACTION_CLOCK = 3,
	PTP_PIN_ACTION_DELTA = 4,
	PTP_PIN_ACTION_NOSYNC = 5,
	PTP_PIN_ACTION_SYNC = 6,
};

struct ocelot_dump_ctx {
	struct net_device *dev;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	int idx;
};

enum macaccess_entry_type {
	ENTRYTYPE_NORMAL = 0,
	ENTRYTYPE_LOCKED = 1,
	ENTRYTYPE_MACv4 = 2,
	ENTRYTYPE_MACv6 = 3,
};

struct ocelot_pgid {
	long unsigned int ports;
	int index;
	refcount_t refcount;
	struct list_head list;
};

struct ocelot_multicast {
	struct list_head list;
	enum macaccess_entry_type entry_type;
	unsigned char addr[6];
	u16 vid;
	u16 ports;
	struct ocelot_pgid *pgid;
};

struct ocelot_mact_entry {
	u8 mac[6];
	u16 vid;
	enum macaccess_entry_type type;
};

enum mscc_qos_rate_mode {
	MSCC_QOS_RATE_MODE_DISABLED = 0,
	MSCC_QOS_RATE_MODE_LINE = 1,
	MSCC_QOS_RATE_MODE_DATA = 2,
	MSCC_QOS_RATE_MODE_FRAME = 3,
	__MSCC_QOS_RATE_MODE_END = 4,
	NUM_MSCC_QOS_RATE_MODE = 4,
	MSCC_QOS_RATE_MODE_MAX = 3,
};

struct qos_policer_conf {
	enum mscc_qos_rate_mode mode;
	bool dlb;
	bool cf;
	u32 cir;
	u32 cbs;
	u32 pir;
	u32 pbs;
	u8 ipg;
};

struct ocelot_vcap_u64 {
	u8 value[8];
	u8 mask[8];
};

enum vcap_sel {
	VCAP_SEL_ENTRY = 1,
	VCAP_SEL_ACTION = 2,
	VCAP_SEL_COUNTER = 4,
	VCAP_SEL_ALL = 7,
};

enum vcap_cmd {
	VCAP_CMD_WRITE = 0,
	VCAP_CMD_READ = 1,
	VCAP_CMD_MOVE_UP = 2,
	VCAP_CMD_MOVE_DOWN = 3,
	VCAP_CMD_INITIALIZE = 4,
};

struct vcap_data {
	u32 entry[12];
	u32 mask[12];
	u32 action[12];
	u32 counter[4];
	u32 tg;
	u32 type;
	u32 tg_sw;
	u32 cnt;
	u32 key_offset;
	u32 action_offset;
	u32 counter_offset;
	u32 tg_value;
	u32 tg_mask;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
	__be16 vlan_eth_type;
	u16 padding;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct xen_netif_tx_request {
	grant_ref_t gref;
	uint16_t offset;
	uint16_t flags;
	uint16_t id;
	uint16_t size;
};

struct xen_netif_extra_info {
	uint8_t type;
	uint8_t flags;
	union {
		struct {
			uint16_t size;
			uint8_t type;
			uint8_t pad;
			uint16_t features;
		} gso;
		struct {
			uint8_t addr[6];
		} mcast;
		struct {
			uint8_t type;
			uint8_t algorithm;
			uint8_t value[4];
		} hash;
		struct {
			uint16_t headroom;
			uint16_t pad[2];
		} xdp;
		uint16_t pad[3];
	} u;
};

struct xen_netif_tx_response {
	uint16_t id;
	int16_t status;
};

struct xen_netif_rx_request {
	uint16_t id;
	uint16_t pad;
	grant_ref_t gref;
};

struct xen_netif_rx_response {
	uint16_t id;
	uint16_t offset;
	uint16_t flags;
	int16_t status;
};

union xen_netif_tx_sring_entry {
	struct xen_netif_tx_request req;
	struct xen_netif_tx_response rsp;
};

struct xen_netif_tx_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union xen_netif_tx_sring_entry ring[1];
};

struct xen_netif_tx_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct xen_netif_tx_sring *sring;
};

union xen_netif_rx_sring_entry {
	struct xen_netif_rx_request req;
	struct xen_netif_rx_response rsp;
};

struct xen_netif_rx_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union xen_netif_rx_sring_entry ring[1];
};

struct xen_netif_rx_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct xen_netif_rx_sring *sring;
};

struct netfront_cb {
	int pull_to;
};

struct netfront_stats {
	u64 packets;
	u64 bytes;
	struct u64_stats_sync syncp;
};

struct netfront_info;

struct netfront_queue {
	unsigned int id;
	char name[22];
	struct netfront_info *info;
	struct bpf_prog *xdp_prog;
	struct napi_struct napi;
	unsigned int tx_evtchn;
	unsigned int rx_evtchn;
	unsigned int tx_irq;
	unsigned int rx_irq;
	char tx_irq_name[25];
	char rx_irq_name[25];
	spinlock_t tx_lock;
	struct xen_netif_tx_front_ring tx;
	int tx_ring_ref;
	struct sk_buff *tx_skbs[256];
	short unsigned int tx_link[256];
	grant_ref_t gref_tx_head;
	grant_ref_t grant_tx_ref[256];
	struct page *grant_tx_page[256];
	unsigned int tx_skb_freelist;
	unsigned int tx_pend_queue;
	long: 64;
	long: 64;
	spinlock_t rx_lock;
	struct xen_netif_rx_front_ring rx;
	int rx_ring_ref;
	struct timer_list rx_refill_timer;
	struct sk_buff *rx_skbs[256];
	grant_ref_t gref_rx_head;
	grant_ref_t grant_rx_ref[256];
	unsigned int rx_rsp_unconsumed;
	spinlock_t rx_cons_lock;
	struct page_pool *page_pool;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct netfront_info {
	struct list_head list;
	struct net_device *netdev;
	struct xenbus_device *xbdev;
	struct netfront_queue *queues;
	struct netfront_stats *rx_stats;
	struct netfront_stats *tx_stats;
	bool netback_has_xdp_headroom;
	bool netfront_xdp_enabled;
	bool broken;
	bool bounce;
	atomic_t rx_gso_checksum_fixup;
};

struct netfront_rx_info {
	struct xen_netif_rx_response rx;
	struct xen_netif_extra_info extras[5];
};

struct xennet_gnttab_make_txreq {
	struct netfront_queue *queue;
	struct sk_buff *skb;
	struct page *page;
	struct xen_netif_tx_request *tx;
	struct xen_netif_tx_request tx_local;
	unsigned int size;
};

struct xennet_stat {
	char name[32];
	u16 offset;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

struct net_failover_info {
	struct net_device *primary_dev;
	struct net_device *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
};

struct uio_map;

struct uio_mem {
	const char *name;
	phys_addr_t addr;
	long unsigned int offs;
	resource_size_t size;
	int memtype;
	void *internal_addr;
	struct uio_map *map;
};

struct uio_map {
	struct kobject kobj;
	struct uio_mem *mem;
};

struct uio_portio;

struct uio_port {
	const char *name;
	long unsigned int start;
	long unsigned int size;
	int porttype;
	struct uio_portio *portio;
};

struct uio_portio {
	struct kobject kobj;
	struct uio_port *port;
};

struct uio_info;

struct uio_device {
	struct module *owner;
	struct device dev;
	int minor;
	atomic_t event;
	struct fasync_struct *async_queue;
	wait_queue_head_t wait;
	struct uio_info *info;
	struct mutex info_lock;
	struct kobject *map_dir;
	struct kobject *portio_dir;
};

struct uio_info {
	struct uio_device *uio_dev;
	const char *name;
	const char *version;
	struct uio_mem mem[5];
	struct uio_port port[5];
	long int irq;
	long unsigned int irq_flags;
	void *priv;
	irqreturn_t (*handler)(int, struct uio_info *);
	int (*mmap)(struct uio_info *, struct vm_area_struct *);
	int (*open)(struct uio_info *, struct inode *);
	int (*release)(struct uio_info *, struct inode *);
	int (*irqcontrol)(struct uio_info *, s32);
};

struct map_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct uio_mem *, char *);
	ssize_t (*store)(struct uio_mem *, const char *, size_t);
};

struct portio_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct uio_port *, char *);
	ssize_t (*store)(struct uio_port *, const char *, size_t);
};

struct uio_listener {
	struct uio_device *dev;
	s32 event_count;
};

struct uio_pdrv_genirq_platdata {
	struct uio_info *uioinfo;
	spinlock_t lock;
	long unsigned int flags;
	struct platform_device *pdev;
};

enum {
	UIO_IRQ_DISABLED = 0,
};

struct uio_dmem_genirq_pdata {
	struct uio_info uioinfo;
	unsigned int *dynamic_region_sizes;
	unsigned int num_dynamic_regions;
};

struct uio_dmem_genirq_platdata {
	struct uio_info *uioinfo;
	spinlock_t lock;
	long unsigned int flags;
	struct platform_device *pdev;
	unsigned int dmem_region_start;
	unsigned int num_dmem_regions;
	void *dmem_region_vaddr[5];
	struct mutex alloc_lock;
	unsigned int refcnt;
};

struct sercos3_priv {
	u32 ier0_cache;
	spinlock_t ier0_cache_lock;
};

struct uio_pci_generic_dev {
	struct uio_info info;
	struct pci_dev *pdev;
};

enum mf624_interrupt_source {
	ADC = 0,
	CTR4 = 1,
	ALL = 2,
};

struct vfio_info_cap_header {
	__u16 id;
	__u16 version;
	__u32 next;
};

struct vfio_group_status {
	__u32 argsz;
	__u32 flags;
};

struct vfio_irq_set {
	__u32 argsz;
	__u32 flags;
	__u32 index;
	__u32 start;
	__u32 count;
	__u8 data[0];
};

struct vfio_device_set {
	void *set_id;
	struct mutex lock;
	struct list_head device_list;
	unsigned int device_count;
};

struct vfio_device_ops;

struct vfio_group;

struct vfio_device {
	struct device *dev;
	const struct vfio_device_ops *ops;
	struct vfio_group *group;
	struct vfio_device_set *dev_set;
	struct list_head dev_set_list;
	refcount_t refcount;
	unsigned int open_count;
	struct completion comp;
	struct list_head group_next;
};

struct vfio_device_ops {
	char *name;
	int (*open_device)(struct vfio_device *);
	void (*close_device)(struct vfio_device *);
	ssize_t (*read)(struct vfio_device *, char *, size_t, loff_t *);
	ssize_t (*write)(struct vfio_device *, const char *, size_t, loff_t *);
	long int (*ioctl)(struct vfio_device *, unsigned int, long unsigned int);
	int (*mmap)(struct vfio_device *, struct vm_area_struct *);
	void (*request)(struct vfio_device *, unsigned int);
	int (*match)(struct vfio_device *, char *);
};

struct kvm;

struct vfio_container;

struct vfio_group {
	struct kref kref;
	int minor;
	atomic_t container_users;
	struct iommu_group *iommu_group;
	struct vfio_container *container;
	struct list_head device_list;
	struct mutex device_lock;
	struct device *dev;
	struct notifier_block nb;
	struct list_head vfio_next;
	struct list_head container_next;
	struct list_head unbound_list;
	struct mutex unbound_lock;
	atomic_t opened;
	wait_queue_head_t container_q;
	bool noiommu;
	unsigned int dev_counter;
	struct kvm *kvm;
	struct blocking_notifier_head notifier;
};

enum vfio_iommu_notify_type {
	VFIO_IOMMU_CONTAINER_CLOSE = 0,
};

struct vfio_iommu_driver_ops {
	char *name;
	struct module *owner;
	void * (*open)(long unsigned int);
	void (*release)(void *);
	ssize_t (*read)(void *, char *, size_t, loff_t *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	long int (*ioctl)(void *, unsigned int, long unsigned int);
	int (*mmap)(void *, struct vm_area_struct *);
	int (*attach_group)(void *, struct iommu_group *);
	void (*detach_group)(void *, struct iommu_group *);
	int (*pin_pages)(void *, struct iommu_group *, long unsigned int *, int, int, long unsigned int *);
	int (*unpin_pages)(void *, long unsigned int *, int);
	int (*register_notifier)(void *, long unsigned int *, struct notifier_block *);
	int (*unregister_notifier)(void *, struct notifier_block *);
	int (*dma_rw)(void *, dma_addr_t, void *, size_t, bool);
	struct iommu_domain * (*group_iommu_domain)(void *, struct iommu_group *);
	void (*notify)(void *, enum vfio_iommu_notify_type);
};

enum vfio_notify_type {
	VFIO_IOMMU_NOTIFY = 0,
	VFIO_GROUP_NOTIFY = 1,
};

struct vfio_info_cap {
	struct vfio_info_cap_header *buf;
	size_t size;
};

struct vfio {
	struct class *class;
	struct list_head iommu_drivers_list;
	struct mutex iommu_drivers_lock;
	struct list_head group_list;
	struct idr group_idr;
	struct mutex group_lock;
	struct cdev group_cdev;
	dev_t group_devt;
};

struct vfio_iommu_driver {
	const struct vfio_iommu_driver_ops *ops;
	struct list_head vfio_next;
};

struct vfio_container {
	struct kref kref;
	struct list_head group_list;
	struct rw_semaphore group_lock;
	struct vfio_iommu_driver *iommu_driver;
	void *iommu_data;
	bool noiommu;
};

struct vfio_unbound_dev {
	struct device *dev;
	struct list_head unbound_next;
};

struct vfio_group_put_work {
	struct work_struct work;
	struct vfio_group *group;
};

struct virqfd {
	void *opaque;
	struct eventfd_ctx *eventfd;
	int (*handler)(void *, void *);
	void (*thread)(void *, void *);
	void *data;
	struct work_struct inject;
	wait_queue_entry_t wait;
	poll_table pt;
	struct work_struct shutdown;
	struct virqfd **pvirqfd;
};

struct vfio_iommu_type1_info {
	__u32 argsz;
	__u32 flags;
	__u64 iova_pgsizes;
	__u32 cap_offset;
};

struct vfio_iova_range {
	__u64 start;
	__u64 end;
};

struct vfio_iommu_type1_info_cap_iova_range {
	struct vfio_info_cap_header header;
	__u32 nr_iovas;
	__u32 reserved;
	struct vfio_iova_range iova_ranges[0];
};

struct vfio_iommu_type1_info_cap_migration {
	struct vfio_info_cap_header header;
	__u32 flags;
	__u64 pgsize_bitmap;
	__u64 max_dirty_bitmap_size;
};

struct vfio_iommu_type1_info_dma_avail {
	struct vfio_info_cap_header header;
	__u32 avail;
};

struct vfio_iommu_type1_dma_map {
	__u32 argsz;
	__u32 flags;
	__u64 vaddr;
	__u64 iova;
	__u64 size;
};

struct vfio_bitmap {
	__u64 pgsize;
	__u64 size;
	__u64 *data;
};

struct vfio_iommu_type1_dma_unmap {
	__u32 argsz;
	__u32 flags;
	__u64 iova;
	__u64 size;
	__u8 data[0];
};

struct vfio_iommu_type1_dirty_bitmap {
	__u32 argsz;
	__u32 flags;
	__u8 data[0];
};

struct vfio_iommu_type1_dirty_bitmap_get {
	__u64 iova;
	__u64 size;
	struct vfio_bitmap bitmap;
};

struct mdev_type;

struct mdev_device {
	struct device dev;
	guid_t uuid;
	void *driver_data;
	struct list_head next;
	struct mdev_type *type;
	struct device *iommu_device;
	bool active;
};

struct vfio_domain;

struct vfio_iommu {
	struct list_head domain_list;
	struct list_head iova_list;
	struct vfio_domain *external_domain;
	struct mutex lock;
	struct rb_root dma_list;
	struct blocking_notifier_head notifier;
	unsigned int dma_avail;
	unsigned int vaddr_invalid_count;
	uint64_t pgsize_bitmap;
	uint64_t num_non_pinned_groups;
	wait_queue_head_t vaddr_wait;
	bool v2;
	bool nesting;
	bool dirty_page_tracking;
	bool container_open;
};

struct vfio_domain {
	struct iommu_domain *domain;
	struct list_head next;
	struct list_head group_list;
	int prot;
	bool fgsp;
};

struct vfio_dma {
	struct rb_node node;
	dma_addr_t iova;
	long unsigned int vaddr;
	size_t size;
	int prot;
	bool iommu_mapped;
	bool lock_cap;
	bool vaddr_invalid;
	struct task_struct *task;
	struct rb_root pfn_list;
	long unsigned int *bitmap;
	struct mm_struct *mm;
	size_t locked_vm;
};

struct vfio_batch {
	struct page **pages;
	struct page *fallback_page;
	int capacity;
	int size;
	int offset;
};

struct vfio_iommu_group {
	struct iommu_group *iommu_group;
	struct list_head next;
	bool mdev_group;
	bool pinned_page_dirty_scope;
};

struct vfio_iova {
	struct list_head list;
	dma_addr_t start;
	dma_addr_t end;
};

struct vfio_pfn {
	struct rb_node node;
	dma_addr_t iova;
	long unsigned int pfn;
	unsigned int ref_count;
};

struct vfio_regions {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
	size_t len;
};

struct vfio_device_info {
	__u32 argsz;
	__u32 flags;
	__u32 num_regions;
	__u32 num_irqs;
	__u32 cap_offset;
};

struct vfio_region_info {
	__u32 argsz;
	__u32 flags;
	__u32 index;
	__u32 cap_offset;
	__u64 size;
	__u64 offset;
};

struct vfio_region_info_cap_type {
	struct vfio_info_cap_header header;
	__u32 type;
	__u32 subtype;
};

struct vfio_irq_info {
	__u32 argsz;
	__u32 flags;
	__u32 index;
	__u32 count;
};

enum {
	VFIO_PCI_BAR0_REGION_INDEX = 0,
	VFIO_PCI_BAR1_REGION_INDEX = 1,
	VFIO_PCI_BAR2_REGION_INDEX = 2,
	VFIO_PCI_BAR3_REGION_INDEX = 3,
	VFIO_PCI_BAR4_REGION_INDEX = 4,
	VFIO_PCI_BAR5_REGION_INDEX = 5,
	VFIO_PCI_ROM_REGION_INDEX = 6,
	VFIO_PCI_CONFIG_REGION_INDEX = 7,
	VFIO_PCI_VGA_REGION_INDEX = 8,
	VFIO_PCI_NUM_REGIONS = 9,
};

enum {
	VFIO_PCI_INTX_IRQ_INDEX = 0,
	VFIO_PCI_MSI_IRQ_INDEX = 1,
	VFIO_PCI_MSIX_IRQ_INDEX = 2,
	VFIO_PCI_ERR_IRQ_INDEX = 3,
	VFIO_PCI_REQ_IRQ_INDEX = 4,
	VFIO_PCI_NUM_IRQS = 5,
};

struct vfio_pci_dependent_device {
	__u32 group_id;
	__u16 segment;
	__u8 bus;
	__u8 devfn;
};

struct vfio_pci_hot_reset_info {
	__u32 argsz;
	__u32 flags;
	__u32 count;
	struct vfio_pci_dependent_device devices[0];
};

struct vfio_pci_hot_reset {
	__u32 argsz;
	__u32 flags;
	__u32 count;
	__s32 group_fds[0];
};

struct vfio_device_ioeventfd {
	__u32 argsz;
	__u32 flags;
	__u64 offset;
	__u64 data;
	__s32 fd;
};

struct vfio_device_feature {
	__u32 argsz;
	__u32 flags;
	__u8 data[0];
};

struct irq_bypass_consumer;

struct irq_bypass_producer {
	struct list_head node;
	void *token;
	int irq;
	int (*add_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*del_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*stop)(struct irq_bypass_producer *);
	void (*start)(struct irq_bypass_producer *);
};

struct irq_bypass_consumer {
	struct list_head node;
	void *token;
	int (*add_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*del_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*stop)(struct irq_bypass_consumer *);
	void (*start)(struct irq_bypass_consumer *);
};

struct vfio_pci_core_device;

struct vfio_pci_ioeventfd {
	struct list_head next;
	struct vfio_pci_core_device *vdev;
	struct virqfd *virqfd;
	void *addr;
	uint64_t data;
	loff_t pos;
	int bar;
	int count;
	bool test_mem;
};

struct perm_bits;

struct vfio_pci_irq_ctx;

struct vfio_pci_region;

struct vfio_pci_vf_token;

struct vfio_pci_core_device {
	struct vfio_device vdev;
	struct pci_dev *pdev;
	void *barmap[6];
	bool bar_mmap_supported[6];
	u8 *pci_config_map;
	u8 *vconfig;
	struct perm_bits *msi_perm;
	spinlock_t irqlock;
	struct mutex igate;
	struct vfio_pci_irq_ctx *ctx;
	int num_ctx;
	int irq_type;
	int num_regions;
	struct vfio_pci_region *region;
	u8 msi_qmax;
	u8 msix_bar;
	u16 msix_size;
	u32 msix_offset;
	u32 rbar[7];
	bool pci_2_3;
	bool virq_disabled;
	bool reset_works;
	bool extended_caps;
	bool bardirty;
	bool has_vga;
	bool needs_reset;
	bool nointx;
	bool needs_pm_restore;
	struct pci_saved_state *pci_saved_state;
	struct pci_saved_state *pm_save;
	int ioeventfds_nr;
	struct eventfd_ctx *err_trigger;
	struct eventfd_ctx *req_trigger;
	struct list_head dummy_resources_list;
	struct mutex ioeventfds_lock;
	struct list_head ioeventfds_list;
	struct vfio_pci_vf_token *vf_token;
	struct list_head sriov_pfs_item;
	struct vfio_pci_core_device *sriov_pf_core_dev;
	struct notifier_block nb;
	struct mutex vma_lock;
	struct list_head vma_list;
	struct rw_semaphore memory_lock;
};

struct vfio_pci_irq_ctx {
	struct eventfd_ctx *trigger;
	struct virqfd *unmask;
	struct virqfd *mask;
	char *name;
	bool masked;
	struct irq_bypass_producer producer;
};

struct vfio_pci_regops {
	ssize_t (*rw)(struct vfio_pci_core_device *, char *, size_t, loff_t *, bool);
	void (*release)(struct vfio_pci_core_device *, struct vfio_pci_region *);
	int (*mmap)(struct vfio_pci_core_device *, struct vfio_pci_region *, struct vm_area_struct *);
	int (*add_capability)(struct vfio_pci_core_device *, struct vfio_pci_region *, struct vfio_info_cap *);
};

struct vfio_pci_region {
	u32 type;
	u32 subtype;
	const struct vfio_pci_regops *ops;
	void *data;
	size_t size;
	u32 flags;
};

struct vfio_pci_dummy_resource {
	struct resource resource;
	int index;
	struct list_head res_next;
};

struct vfio_pci_vf_token {
	struct mutex lock;
	uuid_t uuid;
	int users;
};

struct vfio_pci_mmap_vma {
	struct vm_area_struct *vma;
	struct list_head vma_next;
};

struct vfio_pci_fill_info {
	int max;
	int cur;
	struct vfio_pci_dependent_device *devices;
};

struct vfio_pci_group_info {
	int count;
	struct vfio_group **groups;
};

struct vfio_pci_walk_info {
	int (*fn)(struct pci_dev *, void *);
	void *data;
	struct pci_dev *pdev;
	bool slot;
	int ret;
};

struct perm_bits {
	u8 *virt;
	u8 *write;
	int (*readfn)(struct vfio_pci_core_device *, int, int, struct perm_bits *, int, __le32 *);
	int (*writefn)(struct vfio_pci_core_device *, int, int, struct perm_bits *, int, __le32);
};

enum {
	PCI_ID_F_VFIO_DRIVER_OVERRIDE = 1,
};

struct vfio_fsl_mc_irq {
	u32 flags;
	u32 count;
	struct eventfd_ctx *trigger;
	char *name;
};

struct vfio_fsl_mc_region {
	u32 flags;
	u32 type;
	u64 addr;
	resource_size_t size;
	void *ioaddr;
};

struct vfio_fsl_mc_device {
	struct vfio_device vdev;
	struct fsl_mc_device *mc_dev;
	struct notifier_block nb;
	struct vfio_fsl_mc_region *regions;
	struct mutex igate;
	struct vfio_fsl_mc_irq *mc_irqs;
};

enum usb_phy_interface {
	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
	USBPHY_INTERFACE_MODE_UTMI = 1,
	USBPHY_INTERFACE_MODE_UTMIW = 2,
	USBPHY_INTERFACE_MODE_ULPI = 3,
	USBPHY_INTERFACE_MODE_SERIAL = 4,
	USBPHY_INTERFACE_MODE_HSIC = 5,
};

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct amba_kmi_port {
	struct serio *io;
	struct clk *clk;
	void *base;
	unsigned int irq;
	unsigned int divisor;
	unsigned int open;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct ml_effect_state {
	struct ff_effect *effect;
	long unsigned int flags;
	int count;
	long unsigned int play_at;
	long unsigned int stop_at;
	long unsigned int adj_at;
};

struct ml_device {
	void *private;
	struct ml_effect_state states[16];
	int gain;
	struct timer_list timer;
	struct input_dev *dev;
	int (*play_effect)(struct input_dev *, void *, struct ff_effect *);
};

struct mousedev_hw_data {
	int dx;
	int dy;
	int dz;
	int x;
	int y;
	int abs_event;
	long unsigned int buttons;
};

struct mousedev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
	struct list_head mixdev_node;
	bool opened_by_mixdev;
	struct mousedev_hw_data packet;
	unsigned int pkt_count;
	int old_x[4];
	int old_y[4];
	int frac_dx;
	int frac_dy;
	long unsigned int touch;
	int (*open_device)(struct mousedev *);
	void (*close_device)(struct mousedev *);
};

enum mousedev_emul {
	MOUSEDEV_EMUL_PS2 = 0,
	MOUSEDEV_EMUL_IMPS = 1,
	MOUSEDEV_EMUL_EXPS = 2,
};

struct mousedev_motion {
	int dx;
	int dy;
	int dz;
	long unsigned int buttons;
};

struct mousedev_client {
	struct fasync_struct *fasync;
	struct mousedev *mousedev;
	struct list_head node;
	struct mousedev_motion packets[16];
	unsigned int head;
	unsigned int tail;
	spinlock_t packet_lock;
	int pos_x;
	int pos_y;
	u8 ps2[6];
	unsigned char ready;
	unsigned char buffer;
	unsigned char bufsiz;
	unsigned char imexseq;
	unsigned char impsseq;
	enum mousedev_emul mode;
	long unsigned int last_buttons;
};

enum {
	FRACTION_DENOM = 128,
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	u32 function_row_physmap[24];
	int num_function_row_keys;
};

struct gpio_keys_button {
	unsigned int code;
	int gpio;
	int active_low;
	const char *desc;
	unsigned int type;
	int wakeup;
	int wakeup_event_action;
	int debounce_interval;
	bool can_disable;
	int value;
	unsigned int irq;
};

struct gpio_keys_platform_data {
	const struct gpio_keys_button *buttons;
	int nbuttons;
	unsigned int poll_interval;
	unsigned int rep: 1;
	int (*enable)(struct device *);
	void (*disable)(struct device *);
	const char *name;
};

struct gpio_button_data {
	const struct gpio_keys_button *button;
	struct input_dev *input;
	struct gpio_desc *gpiod;
	short unsigned int *code;
	struct hrtimer release_timer;
	unsigned int release_delay;
	struct delayed_work work;
	struct hrtimer debounce_timer;
	unsigned int software_debounce;
	unsigned int irq;
	unsigned int wakeup_trigger_type;
	spinlock_t lock;
	bool disabled;
	bool key_pressed;
	bool suspended;
	bool debounce_use_hrtimer;
};

struct gpio_keys_drvdata {
	const struct gpio_keys_platform_data *pdata;
	struct input_dev *input;
	struct mutex disable_lock;
	short unsigned int *keymap;
	struct gpio_button_data data[0];
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

struct psmouse;

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	long unsigned int last;
	long unsigned int out_of_sync_cnt;
	long unsigned int num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct psmouse_attribute {
	struct device_attribute dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

struct rmi_2d_axis_alignment {
	bool swap_axes;
	bool flip_x;
	bool flip_y;
	u16 clip_x_low;
	u16 clip_y_low;
	u16 clip_x_high;
	u16 clip_y_high;
	u16 offset_x;
	u16 offset_y;
	u8 delta_x_threshold;
	u8 delta_y_threshold;
};

enum rmi_sensor_type {
	rmi_sensor_default = 0,
	rmi_sensor_touchscreen = 1,
	rmi_sensor_touchpad = 2,
};

struct rmi_2d_sensor_platform_data {
	struct rmi_2d_axis_alignment axis_align;
	enum rmi_sensor_type sensor_type;
	int x_mm;
	int y_mm;
	int disable_report_mask;
	u16 rezero_wait;
	bool topbuttonpad;
	bool kernel_tracking;
	int dmax;
	int dribble;
	int palm_detect;
};

struct rmi_gpio_data {
	bool buttonpad;
	bool trackstick_buttons;
	bool disable;
};

enum rmi_reg_state {
	RMI_REG_STATE_DEFAULT = 0,
	RMI_REG_STATE_OFF = 1,
	RMI_REG_STATE_ON = 2,
};

struct rmi_f01_power_management {
	enum rmi_reg_state nosleep;
	u8 wakeup_threshold;
	u8 doze_holdoff;
	u8 doze_interval;
};

struct rmi_device_platform_data_spi {
	u32 block_delay_us;
	u32 split_read_block_delay_us;
	u32 read_delay_us;
	u32 write_delay_us;
	u32 split_read_byte_delay_us;
	u32 pre_delay_us;
	u32 post_delay_us;
	u8 bits_per_word;
	u16 mode;
	void *cs_assert_data;
	int (*cs_assert)(const void *, const bool);
};

struct rmi_device_platform_data {
	int reset_delay_ms;
	int irq;
	struct rmi_device_platform_data_spi spi_data;
	struct rmi_2d_sensor_platform_data sensor_pdata;
	struct rmi_f01_power_management power_management;
	struct rmi_gpio_data gpio_data;
};

enum synaptics_pkt_type {
	SYN_NEWABS = 0,
	SYN_NEWABS_STRICT = 1,
	SYN_NEWABS_RELAXED = 2,
	SYN_OLDABS = 3,
};

struct synaptics_hw_state {
	int x;
	int y;
	int z;
	int w;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int up: 1;
	unsigned int down: 1;
	u8 ext_buttons;
	s8 scroll;
};

struct synaptics_device_info {
	u32 model_id;
	u32 firmware_id;
	u32 board_id;
	u32 capabilities;
	u32 ext_cap;
	u32 ext_cap_0c;
	u32 ext_cap_10;
	u32 identity;
	u32 x_res;
	u32 y_res;
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
};

struct synaptics_data {
	struct synaptics_device_info info;
	enum synaptics_pkt_type pkt_type;
	u8 mode;
	int scroll;
	bool absolute_mode;
	bool disable_gesture;
	struct serio *pt_port;
	struct synaptics_hw_state agm;
	unsigned int agm_count;
	long unsigned int press_start;
	bool press;
	bool report_press;
	bool is_forcepad;
};

struct min_max_quirk {
	const char * const *pnp_ids;
	struct {
		u32 min;
		u32 max;
	} board_id;
	u32 x_min;
	u32 x_max;
	u32 y_min;
	u32 y_max;
};

enum {
	SYNAPTICS_INTERTOUCH_NOT_SET = 4294967295,
	SYNAPTICS_INTERTOUCH_OFF = 0,
	SYNAPTICS_INTERTOUCH_ON = 1,
};

struct focaltech_finger_state {
	bool active;
	bool valid;
	unsigned int x;
	unsigned int y;
};

struct focaltech_hw_state {
	struct focaltech_finger_state fingers[5];
	unsigned int width;
	bool pressed;
};

struct focaltech_data {
	unsigned int x_max;
	unsigned int y_max;
	struct focaltech_hw_state state;
};

enum SS4_PACKET_ID {
	SS4_PACKET_ID_IDLE = 0,
	SS4_PACKET_ID_ONE = 1,
	SS4_PACKET_ID_TWO = 2,
	SS4_PACKET_ID_MULTI = 3,
	SS4_PACKET_ID_STICK = 4,
};

enum V7_PACKET_ID {
	V7_PACKET_ID_IDLE = 0,
	V7_PACKET_ID_TWO = 1,
	V7_PACKET_ID_MULTI = 2,
	V7_PACKET_ID_NEW = 3,
	V7_PACKET_ID_UNKNOWN = 4,
};

struct alps_protocol_info {
	u16 version;
	u8 byte0;
	u8 mask0;
	unsigned int flags;
};

struct alps_model_info {
	u8 signature[3];
	struct alps_protocol_info protocol_info;
};

struct alps_nibble_commands {
	int command;
	unsigned char data;
};

struct alps_bitmap_point {
	int start_bit;
	int num_bits;
};

struct alps_fields {
	unsigned int x_map;
	unsigned int y_map;
	unsigned int fingers;
	int pressure;
	struct input_mt_pos st;
	struct input_mt_pos mt[4];
	unsigned int first_mp: 1;
	unsigned int is_mp: 1;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int ts_left: 1;
	unsigned int ts_right: 1;
	unsigned int ts_middle: 1;
};

struct alps_data {
	struct psmouse *psmouse;
	struct input_dev *dev2;
	struct input_dev *dev3;
	char phys2[32];
	char phys3[32];
	struct delayed_work dev3_register_work;
	const struct alps_nibble_commands *nibble_commands;
	int addr_command;
	u16 proto_version;
	u8 byte0;
	u8 mask0;
	u8 dev_id[3];
	u8 fw_ver[3];
	int flags;
	int x_max;
	int y_max;
	int x_bits;
	int y_bits;
	unsigned int x_res;
	unsigned int y_res;
	int (*hw_init)(struct psmouse *);
	void (*process_packet)(struct psmouse *);
	int (*decode_fields)(struct alps_fields *, unsigned char *, struct psmouse *);
	void (*set_abs_params)(struct alps_data *, struct input_dev *);
	int prev_fin;
	int multi_packet;
	int second_touch;
	unsigned char multi_data[6];
	struct alps_fields f;
	u8 quirks;
	struct timer_list timer;
};

struct byd_data {
	struct timer_list timer;
	struct psmouse *psmouse;
	s32 abs_x;
	s32 abs_y;
	volatile long unsigned int last_touch_time;
	bool btn_left;
	bool btn_right;
	bool touch;
};

struct ps2pp_info {
	u8 model;
	u8 kind;
	u16 features;
};

struct trackpoint_data {
	u8 variant_id;
	u8 firmware_id;
	u8 sensitivity;
	u8 speed;
	u8 inertia;
	u8 reach;
	u8 draghys;
	u8 mindrag;
	u8 thresh;
	u8 upthresh;
	u8 ztime;
	u8 jenks;
	u8 drift_time;
	bool press_to_select;
	bool skipback;
	bool ext_dev;
};

struct trackpoint_attr_data {
	size_t field_offset;
	u8 command;
	u8 mask;
	bool inverted;
	u8 power_on_default;
};

struct cytp_contact {
	int x;
	int y;
	int z;
};

struct cytp_report_data {
	int contact_cnt;
	struct cytp_contact contacts[2];
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int tap: 1;
};

struct cytp_data {
	int fw_version;
	int pkt_size;
	int mode;
	int tp_min_pressure;
	int tp_max_pressure;
	int tp_width;
	int tp_high;
	int tp_max_abs_x;
	int tp_max_abs_y;
	int tp_res_x;
	int tp_res_y;
	int tp_metrics_supported;
};

struct psmouse_smbus_dev {
	struct i2c_board_info board;
	struct psmouse *psmouse;
	struct i2c_client *client;
	struct list_head node;
	bool dead;
	bool need_deactivate;
};

struct psmouse_smbus_removal_work {
	struct work_struct work;
	struct i2c_client *client;
};

struct xenkbd_motion {
	uint8_t type;
	int32_t rel_x;
	int32_t rel_y;
	int32_t rel_z;
};

struct xenkbd_key {
	uint8_t type;
	uint8_t pressed;
	uint32_t keycode;
};

struct xenkbd_position {
	uint8_t type;
	int32_t abs_x;
	int32_t abs_y;
	int32_t rel_z;
};

struct xenkbd_mtouch {
	uint8_t type;
	uint8_t event_type;
	uint8_t contact_id;
	uint8_t reserved[5];
	union {
		struct {
			int32_t abs_x;
			int32_t abs_y;
		} pos;
		struct {
			uint32_t major;
			uint32_t minor;
		} shape;
		int16_t orientation;
	} u;
};

union xenkbd_in_event {
	uint8_t type;
	struct xenkbd_motion motion;
	struct xenkbd_key key;
	struct xenkbd_position pos;
	struct xenkbd_mtouch mtouch;
	char pad[40];
};

struct xenkbd_page {
	uint32_t in_cons;
	uint32_t in_prod;
	uint32_t out_cons;
	uint32_t out_prod;
};

struct xenkbd_info {
	struct input_dev *kbd;
	struct input_dev *ptr;
	struct input_dev *mtouch;
	struct xenkbd_page *page;
	int gref;
	int irq;
	struct xenbus_device *xbdev;
	char phys[32];
	int mtouch_cur_contact_id;
};

enum {
	KPARAM_X = 0,
	KPARAM_Y = 1,
	KPARAM_CNT___2 = 2,
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct ds1307_platform_data {
	u8 trickle_charger_setup;
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	struct notifier_block pm_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

enum ds_type {
	unknown_ds_type = 0,
	ds_1307 = 1,
	ds_1308 = 2,
	ds_1337 = 3,
	ds_1338 = 4,
	ds_1339 = 5,
	ds_1340 = 6,
	ds_1341 = 7,
	ds_1388 = 8,
	ds_3231 = 9,
	m41t0 = 10,
	m41t00 = 11,
	m41t11 = 12,
	mcp794xx = 13,
	rx_8025 = 14,
	rx_8130 = 15,
	last_ds_type = 16,
};

struct ds1307 {
	enum ds_type type;
	struct device *dev;
	struct regmap *regmap;
	const char *name;
	struct rtc_device *rtc;
	struct clk_hw clks[2];
};

struct chip_desc {
	unsigned int alarm: 1;
	u16 nvram_offset;
	u16 nvram_size;
	u8 offset;
	u8 century_reg;
	u8 century_enable_bit;
	u8 century_bit;
	u8 bbsqi_bit;
	irq_handler_t irq_handler;
	const struct rtc_class_ops *rtc_ops;
	u16 trickle_charger_reg;
	u8 (*do_trickle_setup)(struct ds1307 *, u32, bool);
	bool requires_trickle_resistor;
	bool charge_default;
};

enum {
	DS3231_CLK_SQW = 0,
	DS3231_CLK_32KHZ = 1,
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct ds3232 {
	struct device *dev;
	struct regmap *regmap;
	int irq;
	struct rtc_device *rtc;
	bool suspended;
};

struct ftm_rtc {
	struct rtc_device *rtc_dev;
	void *base;
	bool big_endian;
	u32 alarm_freq;
};

struct pcf2127 {
	struct rtc_device *rtc;
	struct watchdog_device wdd;
	struct regmap *regmap;
	time64_t ts;
	bool ts_valid;
	bool irq_enabled;
};

struct pl031_vendor_data {
	struct rtc_class_ops ops;
	bool clockwatch;
	bool st_weekday;
	long unsigned int irqflags;
	time64_t range_min;
	timeu64_t range_max;
};

struct pl031_local {
	struct pl031_vendor_data *vendor;
	struct rtc_device *rtc;
	void *base;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
};

struct trace_event_data_offsets_i2c_result {};

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_smbus_alert_setup {
	int irq;
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

struct i2c_smbus_ioctl_data {
	__u8 read_write;
	__u8 command;
	__u32 size;
	union i2c_smbus_data *data;
};

struct i2c_rdwr_ioctl_data {
	struct i2c_msg *msgs;
	__u32 nmsgs;
};

struct i2c_dev {
	struct list_head list;
	struct i2c_adapter *adap;
	struct device dev;
	struct cdev cdev;
};

struct i2c_mux_core {
	struct i2c_adapter *parent;
	struct device *dev;
	unsigned int mux_locked: 1;
	unsigned int arbitrator: 1;
	unsigned int gate: 1;
	void *priv;
	int (*select)(struct i2c_mux_core *, u32);
	int (*deselect)(struct i2c_mux_core *, u32);
	int num_adapters;
	int max_adapters;
	struct i2c_adapter *adapter[0];
};

struct i2c_mux_priv {
	struct i2c_adapter adap;
	struct i2c_algorithm algo;
	struct i2c_mux_core *muxc;
	u32 chan_id;
};

struct dw_i2c_dev {
	struct device *dev;
	struct regmap *map;
	struct regmap *sysmap;
	void *base;
	void *ext;
	struct completion cmd_complete;
	struct clk *clk;
	struct clk *pclk;
	struct reset_control *rst;
	struct i2c_client *slave;
	u32 (*get_clk_rate_khz)(struct dw_i2c_dev *);
	int cmd_err;
	struct i2c_msg *msgs;
	int msgs_num;
	int msg_write_idx;
	u32 tx_buf_len;
	u8 *tx_buf;
	int msg_read_idx;
	u32 rx_buf_len;
	u8 *rx_buf;
	int msg_err;
	unsigned int status;
	u32 abort_source;
	int irq;
	u32 flags;
	struct i2c_adapter adapter;
	u32 functionality;
	u32 master_cfg;
	u32 slave_cfg;
	unsigned int tx_fifo_depth;
	unsigned int rx_fifo_depth;
	int rx_outstanding;
	struct i2c_timings timings;
	u32 sda_hold_time;
	u16 ss_hcnt;
	u16 ss_lcnt;
	u16 fs_hcnt;
	u16 fs_lcnt;
	u16 fp_hcnt;
	u16 fp_lcnt;
	u16 hs_hcnt;
	u16 hs_lcnt;
	int (*acquire_lock)();
	void (*release_lock)();
	bool shared_with_punit;
	void (*disable)(struct dw_i2c_dev *);
	void (*disable_int)(struct dw_i2c_dev *);
	int (*init)(struct dw_i2c_dev *);
	int (*set_sda_hold_time)(struct dw_i2c_dev *);
	int mode;
	struct i2c_bus_recovery_info rinfo;
	bool suspended;
};

struct imxi2c_platform_data {
	u32 bitrate;
};

struct imx_i2c_clk_pair {
	u16 div;
	u16 val;
};

enum imx_i2c_type {
	IMX1_I2C = 0,
	IMX21_I2C = 1,
	VF610_I2C = 2,
};

struct imx_i2c_hwdata {
	enum imx_i2c_type devtype;
	unsigned int regshift;
	struct imx_i2c_clk_pair *clk_div;
	unsigned int ndivs;
	unsigned int i2sr_clr_opcode;
	unsigned int i2cr_ien_opcode;
};

struct imx_i2c_dma {
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_using;
	struct completion cmd_complete;
	dma_addr_t dma_buf;
	unsigned int dma_len;
	enum dma_transfer_direction dma_transfer_dir;
	enum dma_data_direction dma_data_dir;
};

struct imx_i2c_struct {
	struct i2c_adapter adapter;
	struct clk *clk;
	struct notifier_block clk_change_nb;
	void *base;
	wait_queue_head_t queue;
	long unsigned int i2csr;
	unsigned int disable_delay;
	int stopped;
	unsigned int ifdr;
	unsigned int cur_clk;
	unsigned int bitrate;
	const struct imx_i2c_hwdata *hwdata;
	struct i2c_bus_recovery_info rinfo;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_pins_default;
	struct pinctrl_state *pinctrl_pins_gpio;
	struct imx_i2c_dma *dma;
	struct i2c_client *slave;
	enum i2c_slave_event last_slave_event;
};

enum {
	REG_CON_MOD_TX = 0,
	REG_CON_MOD_REGISTER_TX = 1,
	REG_CON_MOD_RX = 2,
	REG_CON_MOD_REGISTER_RX = 3,
};

struct i2c_spec_values {
	long unsigned int min_hold_start_ns;
	long unsigned int min_low_ns;
	long unsigned int min_high_ns;
	long unsigned int min_setup_start_ns;
	long unsigned int max_data_hold_ns;
	long unsigned int min_data_setup_ns;
	long unsigned int min_setup_stop_ns;
	long unsigned int min_hold_buffer_ns;
};

struct rk3x_i2c_calced_timings {
	long unsigned int div_low;
	long unsigned int div_high;
	unsigned int tuning;
};

enum rk3x_i2c_state {
	STATE_IDLE = 0,
	STATE_START = 1,
	STATE_READ = 2,
	STATE_WRITE = 3,
	STATE_STOP = 4,
};

struct rk3x_i2c_soc_data {
	int grf_offset;
	int (*calc_timings)(long unsigned int, struct i2c_timings *, struct rk3x_i2c_calced_timings *);
};

struct rk3x_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	const struct rk3x_i2c_soc_data *soc_data;
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_rate_nb;
	struct i2c_timings t;
	spinlock_t lock;
	wait_queue_head_t wait;
	bool busy;
	struct i2c_msg *msg;
	u8 addr;
	unsigned int mode;
	bool is_last_msg;
	enum rk3x_i2c_state state;
	unsigned int processed;
	int error;
};

enum pca_type {
	pca_9540 = 0,
	pca_9542 = 1,
	pca_9543 = 2,
	pca_9544 = 3,
	pca_9545 = 4,
	pca_9546 = 5,
	pca_9547 = 6,
	pca_9548 = 7,
	pca_9846 = 8,
	pca_9847 = 9,
	pca_9848 = 10,
	pca_9849 = 11,
};

enum muxtype {
	pca954x_ismux = 0,
	pca954x_isswi = 1,
};

struct chip_desc___2 {
	u8 nchans;
	u8 enable;
	u8 has_irq;
	enum muxtype muxtype;
	struct i2c_device_identity id;
};

struct pca954x {
	const struct chip_desc___2 *chip;
	u8 last_chan;
	s32 idle_state;
	struct i2c_client *client;
	struct irq_domain *irq;
	unsigned int irq_mask;
	raw_spinlock_t lock;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
};

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct cdev cdev;
	struct device *dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
};

struct ptp_clock {
	struct posix_clock clock;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	struct timestamp_event_queue tsevq;
	struct mutex tsevq_mux;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
	unsigned int max_vclocks;
	unsigned int n_vclocks;
	int *vclock_index;
	struct mutex n_vclocks_mux;
	bool is_virtual_clock;
};

struct ptp_vclock {
	struct ptp_clock *pclock;
	struct ptp_clock_info info;
	struct ptp_clock *clock;
	struct cyclecounter cc;
	struct timecounter tc;
	spinlock_t lock;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int rsv[12];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

enum vexpress_reset_func {
	FUNC_RESET = 0,
	FUNC_SHUTDOWN = 1,
	FUNC_REBOOT = 2,
};

struct xgene_reboot_context {
	struct device *dev;
	void *csr;
	u32 mask;
	struct notifier_block restart_handler;
};

struct syscon_reboot_context {
	struct regmap *map;
	u32 offset;
	u32 value;
	u32 mask;
	struct notifier_block restart_handler;
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 37,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 39,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 40,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 43,
	POWER_SUPPLY_PROP_ENERGY_NOW = 44,
	POWER_SUPPLY_PROP_ENERGY_AVG = 45,
	POWER_SUPPLY_PROP_CAPACITY = 46,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 48,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 50,
	POWER_SUPPLY_PROP_TEMP = 51,
	POWER_SUPPLY_PROP_TEMP_MAX = 52,
	POWER_SUPPLY_PROP_TEMP_MIN = 53,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 55,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 58,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 60,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 62,
	POWER_SUPPLY_PROP_TYPE = 63,
	POWER_SUPPLY_PROP_USB_TYPE = 64,
	POWER_SUPPLY_PROP_SCOPE = 65,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 66,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 67,
	POWER_SUPPLY_PROP_CALIBRATE = 68,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 71,
	POWER_SUPPLY_PROP_MODEL_NAME = 72,
	POWER_SUPPLY_PROP_MANUFACTURER = 73,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 74,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct thermal_zone_device;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *charging_full_trig;
	char *charging_full_trig_name;
	struct led_trigger *charging_trig;
	char *charging_trig_name;
	struct led_trigger *full_trig;
	char *full_trig_name;
	struct led_trigger *online_trig;
	char *online_trig_name;
	struct led_trigger *charging_blink_full_solid_trig;
	char *charging_blink_full_solid_trig_name;
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_attr;

struct thermal_zone_device_ops;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	int num_trips;
	long unsigned int trips_disabled;
	long unsigned int passive_delay_jiffies;
	long unsigned int polling_delay_jiffies;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char *type;
	long unsigned int max_state;
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_battery_info {
	unsigned int technology;
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	int factory_internal_resistance_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
	THERMAL_TREND_RAISE_FULL = 3,
	THERMAL_TREND_DROP_FULL = 4,
};

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

struct psy_get_supplier_prop_data {
	struct power_supply *psy;
	enum power_supply_property psp;
	union power_supply_propval *val;
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum bq27xxx_chip {
	BQ27000 = 1,
	BQ27010 = 2,
	BQ2750X = 3,
	BQ2751X = 4,
	BQ2752X = 5,
	BQ27500 = 6,
	BQ27510G1 = 7,
	BQ27510G2 = 8,
	BQ27510G3 = 9,
	BQ27520G1 = 10,
	BQ27520G2 = 11,
	BQ27520G3 = 12,
	BQ27520G4 = 13,
	BQ27521 = 14,
	BQ27530 = 15,
	BQ27531 = 16,
	BQ27541 = 17,
	BQ27542 = 18,
	BQ27546 = 19,
	BQ27742 = 20,
	BQ27545 = 21,
	BQ27411 = 22,
	BQ27421 = 23,
	BQ27425 = 24,
	BQ27426 = 25,
	BQ27441 = 26,
	BQ27621 = 27,
	BQ27Z561 = 28,
	BQ28Z610 = 29,
	BQ34Z100 = 30,
	BQ78Z100 = 31,
};

struct bq27xxx_device_info;

struct bq27xxx_access_methods {
	int (*read)(struct bq27xxx_device_info *, u8, bool);
	int (*write)(struct bq27xxx_device_info *, u8, int, bool);
	int (*read_bulk)(struct bq27xxx_device_info *, u8, u8 *, int);
	int (*write_bulk)(struct bq27xxx_device_info *, u8, u8 *, int);
};

struct bq27xxx_reg_cache {
	int temperature;
	int time_to_empty;
	int time_to_empty_avg;
	int time_to_full;
	int charge_full;
	int cycle_count;
	int capacity;
	int energy;
	int flags;
	int health;
};

struct bq27xxx_dm_reg;

struct bq27xxx_device_info {
	struct device *dev;
	int id;
	enum bq27xxx_chip chip;
	u32 opts;
	const char *name;
	struct bq27xxx_dm_reg *dm_regs;
	u32 unseal_key;
	struct bq27xxx_access_methods bus;
	struct bq27xxx_reg_cache cache;
	int charge_design_full;
	bool removed;
	long unsigned int last_update;
	union power_supply_propval last_status;
	struct delayed_work work;
	struct power_supply *bat;
	struct list_head list;
	struct mutex lock;
	u8 *regs;
};

struct bq27xxx_dm_reg {
	u8 subclass_id;
	u8 offset;
	u8 bytes;
	u16 min;
	u16 max;
};

enum bq27xxx_reg_index {
	BQ27XXX_REG_CTRL = 0,
	BQ27XXX_REG_TEMP = 1,
	BQ27XXX_REG_INT_TEMP = 2,
	BQ27XXX_REG_VOLT = 3,
	BQ27XXX_REG_AI = 4,
	BQ27XXX_REG_FLAGS = 5,
	BQ27XXX_REG_TTE = 6,
	BQ27XXX_REG_TTF = 7,
	BQ27XXX_REG_TTES = 8,
	BQ27XXX_REG_TTECP = 9,
	BQ27XXX_REG_NAC = 10,
	BQ27XXX_REG_RC = 11,
	BQ27XXX_REG_FCC = 12,
	BQ27XXX_REG_CYCT = 13,
	BQ27XXX_REG_AE = 14,
	BQ27XXX_REG_SOC = 15,
	BQ27XXX_REG_DCAP = 16,
	BQ27XXX_REG_AP = 17,
	BQ27XXX_DM_CTRL = 18,
	BQ27XXX_DM_CLASS = 19,
	BQ27XXX_DM_BLOCK = 20,
	BQ27XXX_DM_DATA = 21,
	BQ27XXX_DM_CKSUM = 22,
	BQ27XXX_REG_MAX = 23,
};

enum bq27xxx_dm_reg_id {
	BQ27XXX_DM_DESIGN_CAPACITY = 0,
	BQ27XXX_DM_DESIGN_ENERGY = 1,
	BQ27XXX_DM_TERMINATE_VOLTAGE = 2,
};

struct bq27xxx_dm_buf {
	u8 class;
	u8 block;
	u8 data[32];
	bool has_data;
	bool dirty;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_get_power {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	long unsigned int freq;
	u32 __data_loc_load;
	size_t load_len;
	u32 dynamic_power;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_limit {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

struct trace_event_data_offsets_thermal_power_cpu_get_power {
	u32 cpumask;
	u32 load;
};

struct trace_event_data_offsets_thermal_power_cpu_limit {
	u32 cpumask;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_thermal_power_cpu_get_power)(void *, const struct cpumask *, long unsigned int, u32 *, size_t, u32);

typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, long unsigned int, u32);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct thermal_zone_of_device_ops {
	int (*get_temp)(void *, int *);
	int (*get_trend)(void *, int, enum thermal_trend *);
	int (*set_trips)(void *, int, int);
	int (*set_emul_temp)(void *, int);
	int (*set_trip_temp)(void *, int, int);
};

struct thermal_trip {
	struct device_node *np;
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
};

struct __thermal_cooling_bind_param {
	struct device_node *cooling_device;
	long unsigned int min;
	long unsigned int max;
};

struct __thermal_bind_params {
	struct __thermal_cooling_bind_param *tcbp;
	unsigned int count;
	unsigned int trip_id;
	unsigned int usage;
};

struct __thermal_zone {
	int passive_delay;
	int polling_delay;
	int slope;
	int offset;
	int ntrips;
	struct thermal_trip *trips;
	int num_tbps;
	struct __thermal_bind_params *tbps;
	void *sensor_data;
	const struct thermal_zone_of_device_ops *ops;
};

struct cpufreq_cooling_device {
	u32 last_load;
	unsigned int cpufreq_state;
	unsigned int max_level;
	struct em_perf_domain *em;
	struct cpufreq_policy *policy;
	struct freq_qos_request qos_req;
};

struct qoriq_sensor {
	int id;
};

struct qoriq_tmu_data {
	int ver;
	struct regmap *regmap;
	struct clk *clk;
	struct qoriq_sensor sensor[16];
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct sp805_wdt {
	struct watchdog_device wdd;
	spinlock_t lock;
	void *base;
	struct clk *clk;
	u64 rate;
	struct amba_device *adev;
	unsigned int load_val;
};

struct imx2_wdt_device {
	struct clk *clk;
	struct regmap *regmap;
	struct watchdog_device wdog;
	bool ext_reset;
	bool clk_is_on;
};

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

struct icc_path;

struct dev_pm_opp;

struct dev_pm_set_opp_data;

struct dev_pm_opp_supply;

struct opp_table {
	struct list_head node;
	struct list_head lazy;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node *np;
	long unsigned int clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	long unsigned int current_rate;
	struct dev_pm_opp *current_opp;
	struct dev_pm_opp *suspend_opp;
	struct mutex genpd_virt_dev_lock;
	struct device **genpd_virt_devs;
	struct opp_table **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	struct clk *clk;
	struct regulator **regulators;
	int regulator_count;
	struct icc_path **paths;
	unsigned int path_count;
	bool enabled;
	bool genpd_performance_state;
	bool is_genpd;
	int (*set_opp)(struct dev_pm_set_opp_data *);
	struct dev_pm_opp_supply *sod_supplies;
	struct dev_pm_set_opp_data *set_opp_data;
	struct dentry *dentry;
	char dentry_name[255];
};

struct dev_pm_opp_icc_bw;

struct dev_pm_opp {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	bool removed;
	unsigned int pstate;
	long unsigned int rate;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	struct dev_pm_opp_icc_bw *bandwidth;
	long unsigned int clock_latency_ns;
	struct dev_pm_opp **required_opps;
	struct opp_table *opp_table;
	struct device_node *np;
	struct dentry *dentry;
	const char *of_name;
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
	OPP_EVENT_ADJUST_VOLTAGE = 4,
};

struct dev_pm_opp_supply {
	long unsigned int u_volt;
	long unsigned int u_volt_min;
	long unsigned int u_volt_max;
	long unsigned int u_amp;
};

struct dev_pm_opp_icc_bw {
	u32 avg;
	u32 peak;
};

struct dev_pm_opp_info {
	long unsigned int rate;
	struct dev_pm_opp_supply *supplies;
};

struct dev_pm_set_opp_data {
	struct dev_pm_opp_info old_opp;
	struct dev_pm_opp_info new_opp;
	struct regulator **regulators;
	unsigned int regulator_count;
	struct clk *clk;
	struct device *dev;
};

struct opp_device {
	struct list_head node;
	const struct device *dev;
	struct dentry *dentry;
};

struct em_data_callback {};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, long unsigned int, long unsigned int, long unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
	void (*register_em)(struct cpufreq_policy *);
};

struct cpufreq_stats {
	unsigned int total_trans;
	long long unsigned int last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	long long unsigned int reset_time;
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_governor;

struct dbs_data {
	struct gov_attr_set attr_set;
	struct dbs_governor *gov;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info;

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cs_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int down_skip;
	unsigned int requested_freq;
};

struct cs_dbs_tuners {
	unsigned int down_threshold;
	unsigned int freq_step;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

struct cpufreq_dt_platform_data {
	bool have_governor_per_policy;
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
};

struct private_data {
	struct list_head node;
	cpumask_var_t cpus;
	struct device *cpu_dev;
	struct opp_table *opp_table;
	struct cpufreq_frequency_table *freq_table;
	bool have_static_opps;
};

struct cpu_data {
	struct clk **pclk;
	struct cpufreq_frequency_table *table;
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_driver_kobj {
	struct cpuidle_driver *drv;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_driver_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_driver *, char *);
	ssize_t (*store)(struct cpuidle_driver *, const char *, size_t);
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct psci_cpuidle_data {
	u32 *psci_states;
	struct device *dev;
};

struct mmc_cid {
	unsigned int manfid;
	char prod_name[8];
	unsigned char prv;
	unsigned int serial;
	short unsigned int oemid;
	short unsigned int year;
	unsigned char hwrev;
	unsigned char fwrev;
	unsigned char month;
};

struct mmc_csd {
	unsigned char structure;
	unsigned char mmca_vsn;
	short unsigned int cmdclass;
	short unsigned int taac_clks;
	unsigned int taac_ns;
	unsigned int c_size;
	unsigned int r2w_factor;
	unsigned int max_dtr;
	unsigned int erase_size;
	unsigned int read_blkbits;
	unsigned int write_blkbits;
	unsigned int capacity;
	unsigned int read_partial: 1;
	unsigned int read_misalign: 1;
	unsigned int write_partial: 1;
	unsigned int write_misalign: 1;
	unsigned int dsr_imp: 1;
};

struct mmc_ext_csd {
	u8 rev;
	u8 erase_group_def;
	u8 sec_feature_support;
	u8 rel_sectors;
	u8 rel_param;
	bool enhanced_rpmb_supported;
	u8 part_config;
	u8 cache_ctrl;
	u8 rst_n_function;
	u8 max_packed_writes;
	u8 max_packed_reads;
	u8 packed_event_en;
	unsigned int part_time;
	unsigned int sa_timeout;
	unsigned int generic_cmd6_time;
	unsigned int power_off_longtime;
	u8 power_off_notification;
	unsigned int hs_max_dtr;
	unsigned int hs200_max_dtr;
	unsigned int sectors;
	unsigned int hc_erase_size;
	unsigned int hc_erase_timeout;
	unsigned int sec_trim_mult;
	unsigned int sec_erase_mult;
	unsigned int trim_timeout;
	bool partition_setting_completed;
	long long unsigned int enhanced_area_offset;
	unsigned int enhanced_area_size;
	unsigned int cache_size;
	bool hpi_en;
	bool hpi;
	unsigned int hpi_cmd;
	bool bkops;
	bool man_bkops_en;
	bool auto_bkops_en;
	unsigned int data_sector_size;
	unsigned int data_tag_unit_size;
	unsigned int boot_ro_lock;
	bool boot_ro_lockable;
	bool ffu_capable;
	bool cmdq_en;
	bool cmdq_support;
	unsigned int cmdq_depth;
	u8 fwrev[8];
	u8 raw_exception_status;
	u8 raw_partition_support;
	u8 raw_rpmb_size_mult;
	u8 raw_erased_mem_count;
	u8 strobe_support;
	u8 raw_ext_csd_structure;
	u8 raw_card_type;
	u8 raw_driver_strength;
	u8 out_of_int_time;
	u8 raw_pwr_cl_52_195;
	u8 raw_pwr_cl_26_195;
	u8 raw_pwr_cl_52_360;
	u8 raw_pwr_cl_26_360;
	u8 raw_s_a_timeout;
	u8 raw_hc_erase_gap_size;
	u8 raw_erase_timeout_mult;
	u8 raw_hc_erase_grp_size;
	u8 raw_boot_mult;
	u8 raw_sec_trim_mult;
	u8 raw_sec_erase_mult;
	u8 raw_sec_feature_support;
	u8 raw_trim_mult;
	u8 raw_pwr_cl_200_195;
	u8 raw_pwr_cl_200_360;
	u8 raw_pwr_cl_ddr_52_195;
	u8 raw_pwr_cl_ddr_52_360;
	u8 raw_pwr_cl_ddr_200_360;
	u8 raw_bkops_status;
	u8 raw_sectors[4];
	u8 pre_eol_info;
	u8 device_life_time_est_typ_a;
	u8 device_life_time_est_typ_b;
	unsigned int feature_support;
};

struct sd_scr {
	unsigned char sda_vsn;
	unsigned char sda_spec3;
	unsigned char sda_spec4;
	unsigned char sda_specx;
	unsigned char bus_widths;
	unsigned char cmds;
};

struct sd_ssr {
	unsigned int au;
	unsigned int erase_timeout;
	unsigned int erase_offset;
};

struct sd_switch_caps {
	unsigned int hs_max_dtr;
	unsigned int uhs_max_dtr;
	unsigned int sd3_bus_mode;
	unsigned int sd3_drv_type;
	unsigned int sd3_curr_limit;
};

struct sd_ext_reg {
	u8 fno;
	u8 page;
	u16 offset;
	u8 rev;
	u8 feature_enabled;
	u8 feature_support;
};

struct sdio_cccr {
	unsigned int sdio_vsn;
	unsigned int sd_vsn;
	unsigned int multi_block: 1;
	unsigned int low_speed: 1;
	unsigned int wide_bus: 1;
	unsigned int high_power: 1;
	unsigned int high_speed: 1;
	unsigned int disable_cd: 1;
};

struct sdio_cis {
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int blksize;
	unsigned int max_dtr;
};

struct mmc_part {
	u64 size;
	unsigned int part_cfg;
	char name[20];
	bool force_ro;
	unsigned int area_type;
};

struct mmc_host;

struct sdio_func;

struct sdio_func_tuple;

struct mmc_card {
	struct mmc_host *host;
	struct device dev;
	u32 ocr;
	unsigned int rca;
	unsigned int type;
	unsigned int state;
	unsigned int quirks;
	unsigned int quirk_max_rate;
	bool reenable_cmdq;
	unsigned int erase_size;
	unsigned int erase_shift;
	unsigned int pref_erase;
	unsigned int eg_boundary;
	unsigned int erase_arg;
	u8 erased_byte;
	u32 raw_cid[4];
	u32 raw_csd[4];
	u32 raw_scr[2];
	u32 raw_ssr[16];
	struct mmc_cid cid;
	struct mmc_csd csd;
	struct mmc_ext_csd ext_csd;
	struct sd_scr scr;
	struct sd_ssr ssr;
	struct sd_switch_caps sw_caps;
	struct sd_ext_reg ext_power;
	struct sd_ext_reg ext_perf;
	unsigned int sdio_funcs;
	atomic_t sdio_funcs_probed;
	struct sdio_cccr cccr;
	struct sdio_cis cis;
	struct sdio_func *sdio_func[7];
	struct sdio_func *sdio_single_irq;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	unsigned int sd_bus_speed;
	unsigned int mmc_avail_type;
	unsigned int drive_strength;
	struct dentry *debugfs_root;
	struct mmc_part part[7];
	unsigned int nr_parts;
	struct workqueue_struct *complete_wq;
};

typedef unsigned int mmc_pm_flag_t;

struct mmc_ios {
	unsigned int clock;
	short unsigned int vdd;
	unsigned int power_delay_ms;
	unsigned char bus_mode;
	unsigned char chip_select;
	unsigned char power_mode;
	unsigned char bus_width;
	unsigned char timing;
	unsigned char signal_voltage;
	unsigned char drv_type;
	bool enhanced_strobe;
};

struct mmc_ctx {
	struct task_struct *task;
};

struct mmc_slot {
	int cd_irq;
	bool cd_wake_enabled;
	void *handler_priv;
};

struct mmc_supply {
	struct regulator *vmmc;
	struct regulator *vqmmc;
};

struct mmc_host_ops;

struct mmc_pwrseq;

struct mmc_bus_ops;

struct mmc_request;

struct mmc_cqe_ops;

struct mmc_host {
	struct device *parent;
	struct device class_dev;
	int index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq *pwrseq;
	unsigned int f_min;
	unsigned int f_max;
	unsigned int f_init;
	u32 ocr_avail;
	u32 ocr_avail_sdio;
	u32 ocr_avail_sd;
	u32 ocr_avail_mmc;
	struct wakeup_source *ws;
	u32 max_current_330;
	u32 max_current_300;
	u32 max_current_180;
	u32 caps;
	u32 caps2;
	int fixed_drv_type;
	mmc_pm_flag_t pm_caps;
	unsigned int max_seg_size;
	short unsigned int max_segs;
	short unsigned int unused;
	unsigned int max_req_size;
	unsigned int max_blk_size;
	unsigned int max_blk_count;
	unsigned int max_busy_timeout;
	spinlock_t lock;
	struct mmc_ios ios;
	unsigned int use_spi_crc: 1;
	unsigned int claimed: 1;
	unsigned int doing_init_tune: 1;
	unsigned int can_retune: 1;
	unsigned int doing_retune: 1;
	unsigned int retune_now: 1;
	unsigned int retune_paused: 1;
	unsigned int retune_crc_disable: 1;
	unsigned int can_dma_map_merge: 1;
	int rescan_disable;
	int rescan_entered;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct timer_list retune_timer;
	bool trigger_card_event;
	struct mmc_card *card;
	wait_queue_head_t wq;
	struct mmc_ctx *claimer;
	int claim_cnt;
	struct mmc_ctx default_ctx;
	struct delayed_work detect;
	int detect_change;
	struct mmc_slot slot;
	const struct mmc_bus_ops *bus_ops;
	unsigned int sdio_irqs;
	struct task_struct *sdio_irq_thread;
	struct delayed_work sdio_irq_work;
	bool sdio_irq_pending;
	atomic_t sdio_irq_thread_abort;
	mmc_pm_flag_t pm_flags;
	struct led_trigger *led;
	struct mmc_supply supply;
	struct dentry *debugfs_root;
	struct mmc_request *ongoing_mrq;
	unsigned int actual_clock;
	unsigned int slotno;
	int dsr_req;
	u32 dsr;
	const struct mmc_cqe_ops *cqe_ops;
	void *cqe_private;
	int cqe_qdepth;
	bool cqe_enabled;
	bool cqe_on;
	bool hsq_enabled;
	long unsigned int private[0];
};

struct mmc_data;

struct mmc_command {
	u32 opcode;
	u32 arg;
	u32 resp[4];
	unsigned int flags;
	unsigned int retries;
	int error;
	unsigned int busy_timeout;
	struct mmc_data *data;
	struct mmc_request *mrq;
};

struct mmc_data {
	unsigned int timeout_ns;
	unsigned int timeout_clks;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int blk_addr;
	int error;
	unsigned int flags;
	unsigned int bytes_xfered;
	struct mmc_command *stop;
	struct mmc_request *mrq;
	unsigned int sg_len;
	int sg_count;
	struct scatterlist *sg;
	s32 host_cookie;
};

struct mmc_request {
	struct mmc_command *sbc;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command *stop;
	struct completion completion;
	struct completion cmd_completion;
	void (*done)(struct mmc_request *);
	void (*recovery_notifier)(struct mmc_request *);
	struct mmc_host *host;
	bool cap_cmd_during_tfr;
	int tag;
};

enum blk_crypto_mode_num {
	BLK_ENCRYPTION_MODE_INVALID = 0,
	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
	BLK_ENCRYPTION_MODE_MAX = 4,
};

struct mmc_host_ops {
	void (*post_req)(struct mmc_host *, struct mmc_request *, int);
	void (*pre_req)(struct mmc_host *, struct mmc_request *);
	void (*request)(struct mmc_host *, struct mmc_request *);
	int (*request_atomic)(struct mmc_host *, struct mmc_request *);
	void (*set_ios)(struct mmc_host *, struct mmc_ios *);
	int (*get_ro)(struct mmc_host *);
	int (*get_cd)(struct mmc_host *);
	void (*enable_sdio_irq)(struct mmc_host *, int);
	void (*ack_sdio_irq)(struct mmc_host *);
	void (*init_card)(struct mmc_host *, struct mmc_card *);
	int (*start_signal_voltage_switch)(struct mmc_host *, struct mmc_ios *);
	int (*card_busy)(struct mmc_host *);
	int (*execute_tuning)(struct mmc_host *, u32);
	int (*prepare_hs400_tuning)(struct mmc_host *, struct mmc_ios *);
	int (*hs400_prepare_ddr)(struct mmc_host *);
	void (*hs400_downgrade)(struct mmc_host *);
	void (*hs400_complete)(struct mmc_host *);
	void (*hs400_enhanced_strobe)(struct mmc_host *, struct mmc_ios *);
	int (*select_drive_strength)(struct mmc_card *, unsigned int, int, int, int *);
	void (*hw_reset)(struct mmc_host *);
	void (*card_event)(struct mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*init_sd_express)(struct mmc_host *, struct mmc_ios *);
};

struct mmc_cqe_ops {
	int (*cqe_enable)(struct mmc_host *, struct mmc_card *);
	void (*cqe_disable)(struct mmc_host *);
	int (*cqe_request)(struct mmc_host *, struct mmc_request *);
	void (*cqe_post_req)(struct mmc_host *, struct mmc_request *);
	void (*cqe_off)(struct mmc_host *);
	int (*cqe_wait_for_idle)(struct mmc_host *);
	bool (*cqe_timeout)(struct mmc_host *, struct mmc_request *, bool *);
	void (*cqe_recovery_start)(struct mmc_host *);
	void (*cqe_recovery_finish)(struct mmc_host *);
};

struct mmc_pwrseq_ops;

struct mmc_pwrseq {
	const struct mmc_pwrseq_ops *ops;
	struct device *dev;
	struct list_head pwrseq_node;
	struct module *owner;
};

struct mmc_bus_ops {
	void (*remove)(struct mmc_host *);
	void (*detect)(struct mmc_host *);
	int (*pre_suspend)(struct mmc_host *);
	int (*suspend)(struct mmc_host *);
	int (*resume)(struct mmc_host *);
	int (*runtime_suspend)(struct mmc_host *);
	int (*runtime_resume)(struct mmc_host *);
	int (*alive)(struct mmc_host *);
	int (*shutdown)(struct mmc_host *);
	int (*hw_reset)(struct mmc_host *);
	int (*sw_reset)(struct mmc_host *);
	bool (*cache_enabled)(struct mmc_host *);
	int (*flush_cache)(struct mmc_host *);
};

struct trace_event_raw_mmc_request_start {
	struct trace_entry ent;
	u32 cmd_opcode;
	u32 cmd_arg;
	unsigned int cmd_flags;
	unsigned int cmd_retries;
	u32 stop_opcode;
	u32 stop_arg;
	unsigned int stop_flags;
	unsigned int stop_retries;
	u32 sbc_opcode;
	u32 sbc_arg;
	unsigned int sbc_flags;
	unsigned int sbc_retries;
	unsigned int blocks;
	unsigned int blk_addr;
	unsigned int blksz;
	unsigned int data_flags;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mmc_request_done {
	struct trace_entry ent;
	u32 cmd_opcode;
	int cmd_err;
	u32 cmd_resp[4];
	unsigned int cmd_retries;
	u32 stop_opcode;
	int stop_err;
	u32 stop_resp[4];
	unsigned int stop_retries;
	u32 sbc_opcode;
	int sbc_err;
	u32 sbc_resp[4];
	unsigned int sbc_retries;
	unsigned int bytes_xfered;
	int data_err;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_mmc_request_start {
	u32 name;
};

struct trace_event_data_offsets_mmc_request_done {
	u32 name;
};

typedef void (*btf_trace_mmc_request_start)(void *, struct mmc_host *, struct mmc_request *);

typedef void (*btf_trace_mmc_request_done)(void *, struct mmc_host *, struct mmc_request *);

struct mmc_pwrseq_ops {
	void (*pre_power_on)(struct mmc_host *);
	void (*post_power_on)(struct mmc_host *);
	void (*power_off)(struct mmc_host *);
	void (*reset)(struct mmc_host *);
};

enum mmc_busy_cmd {
	MMC_BUSY_CMD6 = 0,
	MMC_BUSY_ERASE = 1,
	MMC_BUSY_HPI = 2,
	MMC_BUSY_EXTR_SINGLE = 3,
	MMC_BUSY_IO = 4,
};

struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

struct mmc_clk_phase {
	bool valid;
	u16 in_deg;
	u16 out_deg;
};

struct mmc_clk_phase_map {
	struct mmc_clk_phase phase[11];
};

struct mmc_fixup {
	const char *name;
	u64 rev_start;
	u64 rev_end;
	unsigned int manfid;
	short unsigned int oemid;
	u16 cis_vendor;
	u16 cis_device;
	unsigned int ext_csd_rev;
	void (*vendor_fixup)(struct mmc_card *, int);
	int data;
};

struct mmc_busy_data {
	struct mmc_card *card;
	bool retry_crc_err;
	enum mmc_busy_cmd busy_cmd;
};

struct sd_busy_data {
	struct mmc_card *card;
	u8 *reg_buf;
};

typedef void sdio_irq_handler_t(struct sdio_func *);

struct sdio_func {
	struct mmc_card *card;
	struct device dev;
	sdio_irq_handler_t *irq_handler;
	unsigned int num;
	unsigned char class;
	short unsigned int vendor;
	short unsigned int device;
	unsigned int max_blksize;
	unsigned int cur_blksize;
	unsigned int enable_timeout;
	unsigned int state;
	u8 *tmpbuf;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
};

struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

struct sdio_device_id {
	__u8 class;
	__u16 vendor;
	__u16 device;
	kernel_ulong_t driver_data;
};

struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;
	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);
	struct device_driver drv;
};

typedef int tpl_parse_t(struct mmc_card *, struct sdio_func *, const unsigned char *, unsigned int);

struct cis_tpl {
	unsigned char code;
	unsigned char min_size;
	tpl_parse_t *parse;
};

struct mmc_gpio {
	struct gpio_desc *ro_gpio;
	struct gpio_desc *cd_gpio;
	irqreturn_t (*cd_gpio_isr)(int, void *);
	char *ro_label;
	char *cd_label;
	u32 cd_debounce_delay_ms;
};

struct mmc_pwrseq_simple {
	struct mmc_pwrseq pwrseq;
	bool clk_enabled;
	u32 post_power_on_delay_ms;
	u32 power_off_delay_us;
	struct clk *ext_clk;
	struct gpio_descs *reset_gpios;
};

struct mmc_pwrseq_emmc {
	struct mmc_pwrseq pwrseq;
	struct notifier_block reset_nb;
	struct gpio_desc *reset_gpio;
};

struct mmc_ioc_cmd {
	int write_flag;
	int is_acmd;
	__u32 opcode;
	__u32 arg;
	__u32 response[4];
	unsigned int flags;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int postsleep_min_us;
	unsigned int postsleep_max_us;
	unsigned int data_timeout_ns;
	unsigned int cmd_timeout_ms;
	__u32 __pad;
	__u64 data_ptr;
};

struct mmc_ioc_multi_cmd {
	__u64 num_of_cmds;
	struct mmc_ioc_cmd cmds[0];
};

enum mmc_issued {
	MMC_REQ_STARTED = 0,
	MMC_REQ_BUSY = 1,
	MMC_REQ_FAILED_TO_START = 2,
	MMC_REQ_FINISHED = 3,
};

enum mmc_issue_type {
	MMC_ISSUE_SYNC = 0,
	MMC_ISSUE_DCMD = 1,
	MMC_ISSUE_ASYNC = 2,
	MMC_ISSUE_MAX = 3,
};

struct mmc_blk_request {
	struct mmc_request mrq;
	struct mmc_command sbc;
	struct mmc_command cmd;
	struct mmc_command stop;
	struct mmc_data data;
};

enum mmc_drv_op {
	MMC_DRV_OP_IOCTL = 0,
	MMC_DRV_OP_IOCTL_RPMB = 1,
	MMC_DRV_OP_BOOT_WP = 2,
	MMC_DRV_OP_GET_CARD_STATUS = 3,
	MMC_DRV_OP_GET_EXT_CSD = 4,
};

struct mmc_queue_req {
	struct mmc_blk_request brq;
	struct scatterlist *sg;
	enum mmc_drv_op drv_op;
	int drv_op_result;
	void *drv_op_data;
	unsigned int ioc_count;
	int retries;
};

struct mmc_blk_data;

struct mmc_queue {
	struct mmc_card *card;
	struct mmc_ctx ctx;
	struct blk_mq_tag_set tag_set;
	struct mmc_blk_data *blkdata;
	struct request_queue *queue;
	spinlock_t lock;
	int in_flight[3];
	unsigned int cqe_busy;
	bool busy;
	bool recovery_needed;
	bool in_recovery;
	bool rw_wait;
	bool waiting;
	struct work_struct recovery_work;
	wait_queue_head_t wait;
	struct request *recovery_req;
	struct request *complete_req;
	struct mutex complete_lock;
	struct work_struct complete_work;
};

struct mmc_blk_data {
	struct device *parent;
	struct gendisk *disk;
	struct mmc_queue queue;
	struct list_head part;
	struct list_head rpmbs;
	unsigned int flags;
	struct kref kref;
	unsigned int read_only;
	unsigned int part_type;
	unsigned int reset_done;
	unsigned int part_curr;
	int area_type;
	struct dentry *status_dentry;
	struct dentry *ext_csd_dentry;
};

struct mmc_blk_busy_data {
	struct mmc_card *card;
	u32 status;
};

struct mmc_rpmb_data {
	struct device dev;
	struct cdev chrdev;
	int id;
	unsigned int part_index;
	struct mmc_blk_data *md;
	struct list_head node;
};

struct mmc_blk_ioc_data {
	struct mmc_ioc_cmd ic;
	unsigned char *buf;
	u64 buf_bytes;
	struct mmc_rpmb_data *rpmb;
};

struct sdhci_adma2_64_desc {
	__le16 cmd;
	__le16 len;
	__le32 addr_lo;
	__le32 addr_hi;
};

enum sdhci_cookie {
	COOKIE_UNMAPPED = 0,
	COOKIE_PRE_MAPPED = 1,
	COOKIE_MAPPED = 2,
};

struct sdhci_ops;

struct sdhci_host {
	const char *hw_name;
	unsigned int quirks;
	unsigned int quirks2;
	int irq;
	void *ioaddr;
	phys_addr_t mapbase;
	char *bounce_buffer;
	dma_addr_t bounce_addr;
	unsigned int bounce_buffer_size;
	const struct sdhci_ops *ops;
	struct mmc_host *mmc;
	struct mmc_host_ops mmc_host_ops;
	u64 dma_mask;
	struct led_classdev led;
	char led_name[32];
	spinlock_t lock;
	int flags;
	unsigned int version;
	unsigned int max_clk;
	unsigned int timeout_clk;
	u8 max_timeout_count;
	unsigned int clk_mul;
	unsigned int clock;
	u8 pwr;
	u8 drv_type;
	bool reinit_uhs;
	bool runtime_suspended;
	bool bus_on;
	bool preset_enabled;
	bool pending_reset;
	bool irq_wake_enabled;
	bool v4_mode;
	bool use_external_dma;
	bool always_defer_done;
	struct mmc_request *mrqs_done[2];
	struct mmc_command *cmd;
	struct mmc_command *data_cmd;
	struct mmc_command *deferred_cmd;
	struct mmc_data *data;
	unsigned int data_early: 1;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int sg_count;
	int max_adma;
	void *adma_table;
	void *align_buffer;
	size_t adma_table_sz;
	size_t align_buffer_sz;
	dma_addr_t adma_addr;
	dma_addr_t align_addr;
	unsigned int desc_sz;
	unsigned int alloc_desc_sz;
	struct workqueue_struct *complete_wq;
	struct work_struct complete_work;
	struct timer_list timer;
	struct timer_list data_timer;
	u32 caps;
	u32 caps1;
	bool read_caps;
	bool sdhci_core_to_disable_vqmmc;
	unsigned int ocr_avail_sdio;
	unsigned int ocr_avail_sd;
	unsigned int ocr_avail_mmc;
	u32 ocr_mask;
	unsigned int timing;
	u32 thread_isr;
	u32 ier;
	bool cqe_on;
	u32 cqe_ier;
	u32 cqe_err_ier;
	wait_queue_head_t buf_ready_int;
	unsigned int tuning_done;
	unsigned int tuning_count;
	unsigned int tuning_mode;
	unsigned int tuning_err;
	int tuning_delay;
	int tuning_loop_count;
	u32 sdma_boundary;
	u32 adma_table_cnt;
	u64 data_timeout;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct sdhci_ops {
	u32 (*read_l)(struct sdhci_host *, int);
	u16 (*read_w)(struct sdhci_host *, int);
	u8 (*read_b)(struct sdhci_host *, int);
	void (*write_l)(struct sdhci_host *, u32, int);
	void (*write_w)(struct sdhci_host *, u16, int);
	void (*write_b)(struct sdhci_host *, u8, int);
	void (*set_clock)(struct sdhci_host *, unsigned int);
	void (*set_power)(struct sdhci_host *, unsigned char, short unsigned int);
	u32 (*irq)(struct sdhci_host *, u32);
	int (*set_dma_mask)(struct sdhci_host *);
	int (*enable_dma)(struct sdhci_host *);
	unsigned int (*get_max_clock)(struct sdhci_host *);
	unsigned int (*get_min_clock)(struct sdhci_host *);
	unsigned int (*get_timeout_clock)(struct sdhci_host *);
	unsigned int (*get_max_timeout_count)(struct sdhci_host *);
	void (*set_timeout)(struct sdhci_host *, struct mmc_command *);
	void (*set_bus_width)(struct sdhci_host *, int);
	void (*platform_send_init_74_clocks)(struct sdhci_host *, u8);
	unsigned int (*get_ro)(struct sdhci_host *);
	void (*reset)(struct sdhci_host *, u8);
	int (*platform_execute_tuning)(struct sdhci_host *, u32);
	void (*set_uhs_signaling)(struct sdhci_host *, unsigned int);
	void (*hw_reset)(struct sdhci_host *);
	void (*adma_workaround)(struct sdhci_host *, u32);
	void (*card_event)(struct sdhci_host *);
	void (*voltage_switch)(struct sdhci_host *);
	void (*adma_write_desc)(struct sdhci_host *, void **, dma_addr_t, int, unsigned int);
	void (*copy_to_bounce_buffer)(struct sdhci_host *, struct mmc_data *, unsigned int);
	void (*request_done)(struct sdhci_host *, struct mmc_request *);
	void (*dump_vendor_regs)(struct sdhci_host *);
};

struct sdhci_pltfm_data {
	const struct sdhci_ops *ops;
	unsigned int quirks;
	unsigned int quirks2;
};

struct sdhci_pltfm_host {
	struct clk *clk;
	unsigned int clock;
	u16 xfer_mode_shadow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct esdhc_clk_fixup {
	const unsigned int sd_dflt_max_clk;
	const unsigned int max_clk[11];
};

struct sdhci_esdhc {
	u8 vendor_ver;
	u8 spec_ver;
	bool quirk_incorrect_hostver;
	bool quirk_limited_clk_division;
	bool quirk_unreliable_pulse_detection;
	bool quirk_tuning_erratum_type1;
	bool quirk_tuning_erratum_type2;
	bool quirk_ignore_data_inhibit;
	bool quirk_delay_before_data_reset;
	bool quirk_trans_complete_erratum;
	bool in_sw_tuning;
	unsigned int peripheral_clock;
	const struct esdhc_clk_fixup *clk_fixup;
	u32 div_ratio;
};

enum led_default_state {
	LEDS_DEFSTATE_OFF = 0,
	LEDS_DEFSTATE_ON = 1,
	LEDS_DEFSTATE_KEEP = 2,
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

struct mc_subled {
	unsigned int color_index;
	unsigned int brightness;
	unsigned int intensity;
	unsigned int channel;
};

struct led_classdev_mc {
	struct led_classdev led_cdev;
	unsigned int num_colors;
	struct mc_subled *subled_info;
};

struct heartbeat_trig_data {
	struct led_classdev *led_cdev;
	unsigned int phase;
	unsigned int period;
	struct timer_list timer;
	unsigned int invert;
};

enum led_trigger_netdev_modes {
	TRIGGER_NETDEV_LINK = 0,
	TRIGGER_NETDEV_TX = 1,
	TRIGGER_NETDEV_RX = 2,
	__TRIGGER_NETDEV_MAX = 3,
};

struct led_netdev_data {
	struct mutex lock;
	struct delayed_work work;
	struct notifier_block notifier;
	struct led_classdev *led_cdev;
	struct net_device *net_dev;
	char device_name[16];
	atomic_t interval;
	unsigned int last_activity;
	long unsigned int mode;
	bool carrier_link_up;
	bool hw_control;
};

struct arm_smccc_quirk {
	int id;
	union {
		long unsigned int a6;
	} state;
};

struct psci_0_1_function_ids {
	u32 cpu_suspend;
	u32 cpu_on;
	u32 cpu_off;
	u32 migrate;
};

typedef long unsigned int psci_fn(long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef int (*psci_initcall_t)(const struct device_node *);

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 unused: 4;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
	atomic_t fib_rt_uncache;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_node *subtree;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	XFRM_MSG_SETDEFAULT = 39,
	XFRM_MSG_GETDEFAULT = 40,
	__XFRM_MSG_MAX = 41,
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	XFRMA_MTIMER_THRESH = 32,
	__XFRMA_MAX = 33,
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct stat_src {
	int (*report_ssed)(struct device *, const u32, const char *);
	const char *error;
};

struct version_regs {
	u32 crca;
	u32 afha;
	u32 kfha;
	u32 pkha;
	u32 aesa;
	u32 mdha;
	u32 desa;
	u32 snw8a;
	u32 snw9a;
	u32 zuce;
	u32 zuca;
	u32 ccha;
	u32 ptha;
	u32 rng;
	u32 trng;
	u32 aaha;
	u32 rsvd[10];
	u32 sr;
	u32 dma;
	u32 ai;
	u32 qi;
	u32 jr;
	u32 deco;
};

struct caam_perfmon {
	u64 req_dequeued;
	u64 ob_enc_req;
	u64 ib_dec_req;
	u64 ob_enc_bytes;
	u64 ob_prot_bytes;
	u64 ib_dec_bytes;
	u64 ib_valid_bytes;
	u64 rsvd[13];
	u32 cha_rev_ms;
	u32 cha_rev_ls;
	u32 comp_parms_ms;
	u32 comp_parms_ls;
	u64 rsvd1[2];
	u64 faultaddr;
	u32 faultliodn;
	u32 faultdetail;
	u32 rsvd2;
	u32 status;
	u64 rsvd3;
	u32 rtic_id;
	u32 ccb_id;
	u32 cha_id_ms;
	u32 cha_id_ls;
	u32 cha_num_ms;
	u32 cha_num_ls;
	u32 caam_id_ms;
	u32 caam_id_ls;
};

struct masterid {
	u32 liodn_ms;
	u32 liodn_ls;
};

struct partid {
	u32 rsvd1;
	u32 pidr;
};

struct rngtst {
	u32 mode;
	u32 rsvd1[3];
	u32 reset;
	u32 rsvd2[3];
	u32 status;
	u32 rsvd3;
	u32 errstat;
	u32 rsvd4;
	u32 errctl;
	u32 rsvd5;
	u32 entropy;
	u32 rsvd6[15];
	u32 verifctl;
	u32 rsvd7;
	u32 verifstat;
	u32 rsvd8;
	u32 verifdata;
	u32 rsvd9;
	u32 xkey;
	u32 rsvd10;
	u32 oscctctl;
	u32 rsvd11;
	u32 oscct;
	u32 rsvd12;
	u32 oscctstat;
	u32 rsvd13[2];
	u32 ofifo[4];
	u32 rsvd14[15];
};

struct rng4tst {
	u32 rtmctl;
	u32 rtscmisc;
	u32 rtpkrrng;
	union {
		u32 rtpkrmax;
		u32 rtpkrsq;
	};
	u32 rtsdctl;
	union {
		u32 rtsblim;
		u32 rttotsam;
	};
	u32 rtfrqmin;
	union {
		u32 rtfrqmax;
		u32 rtfrqcnt;
	};
	u32 rsvd1[40];
	u32 rdsta;
	u32 rsvd2[15];
};

struct caam_ctrl {
	u32 rsvd1;
	u32 mcr;
	u32 rsvd2;
	u32 scfgr;
	struct masterid jr_mid[4];
	u32 rsvd3[11];
	u32 jrstart;
	struct masterid rtic_mid[4];
	u32 rsvd4[5];
	u32 deco_rsr;
	u32 rsvd11;
	u32 deco_rq;
	struct partid deco_mid[5];
	u32 rsvd5[22];
	u32 deco_avail;
	u32 deco_reset;
	u32 rsvd6[182];
	u32 kek[8];
	u32 tkek[8];
	u32 tdsk[8];
	u32 rsvd7[32];
	u64 sknonce;
	u32 rsvd8[70];
	union {
		struct rngtst rtst[2];
		struct rng4tst r4tst[2];
	};
	u32 rsvd9[416];
	struct version_regs vreg;
	struct caam_perfmon perfmon;
};

struct caam_job_ring {
	u64 inpring_base;
	u32 rsvd1;
	u32 inpring_size;
	u32 rsvd2;
	u32 inpring_avail;
	u32 rsvd3;
	u32 inpring_jobadd;
	u64 outring_base;
	u32 rsvd4;
	u32 outring_size;
	u32 rsvd5;
	u32 outring_rmvd;
	u32 rsvd6;
	u32 outring_used;
	u32 rsvd7;
	u32 jroutstatus;
	u32 rsvd8;
	u32 jrintstatus;
	u32 rconfig_hi;
	u32 rconfig_lo;
	u32 rsvd9;
	u32 inp_rdidx;
	u32 rsvd10;
	u32 out_wtidx;
	u32 rsvd11;
	u32 jrcommand;
	u32 rsvd12[900];
	struct version_regs vreg;
	struct caam_perfmon perfmon;
};

struct rtic_element {
	u64 address;
	u32 rsvd;
	u32 length;
};

struct rtic_block {
	struct rtic_element element[2];
};

struct rtic_memhash {
	u32 memhash_be[32];
	u32 memhash_le[32];
};

struct caam_assurance {
	u32 rsvd1;
	u32 status;
	u32 rsvd2;
	u32 cmd;
	u32 rsvd3;
	u32 ctrl;
	u32 rsvd4;
	u32 throttle;
	u32 rsvd5[2];
	u64 watchdog;
	u32 rsvd6;
	u32 rend;
	u32 rsvd7[50];
	struct rtic_block memblk[4];
	u32 rsvd8[32];
	struct rtic_memhash hash[4];
	u32 rsvd_3[640];
};

struct caam_queue_if {
	u32 qi_control_hi;
	u32 qi_control_lo;
	u32 rsvd1;
	u32 qi_status;
	u32 qi_deq_cfg_hi;
	u32 qi_deq_cfg_lo;
	u32 qi_enq_cfg_hi;
	u32 qi_enq_cfg_lo;
	u32 rsvd2[1016];
};

struct deco_sg_table {
	u64 addr;
	u32 elen;
	u32 bpid_offset;
};

struct caam_deco {
	u32 rsvd1;
	u32 cls1_mode;
	u32 rsvd2;
	u32 cls1_keysize;
	u32 cls1_datasize_hi;
	u32 cls1_datasize_lo;
	u32 rsvd3;
	u32 cls1_icvsize;
	u32 rsvd4[5];
	u32 cha_ctrl;
	u32 rsvd5;
	u32 irq_crtl;
	u32 rsvd6;
	u32 clr_written;
	u32 ccb_status_hi;
	u32 ccb_status_lo;
	u32 rsvd7[3];
	u32 aad_size;
	u32 rsvd8;
	u32 cls1_iv_size;
	u32 rsvd9[7];
	u32 pkha_a_size;
	u32 rsvd10;
	u32 pkha_b_size;
	u32 rsvd11;
	u32 pkha_n_size;
	u32 rsvd12;
	u32 pkha_e_size;
	u32 rsvd13[24];
	u32 cls1_ctx[16];
	u32 rsvd14[48];
	u32 cls1_key[8];
	u32 rsvd15[121];
	u32 cls2_mode;
	u32 rsvd16;
	u32 cls2_keysize;
	u32 cls2_datasize_hi;
	u32 cls2_datasize_lo;
	u32 rsvd17;
	u32 cls2_icvsize;
	u32 rsvd18[56];
	u32 cls2_ctx[18];
	u32 rsvd19[46];
	u32 cls2_key[32];
	u32 rsvd20[84];
	u32 inp_infofifo_hi;
	u32 inp_infofifo_lo;
	u32 rsvd21[2];
	u64 inp_datafifo;
	u32 rsvd22[2];
	u64 out_datafifo;
	u32 rsvd23[2];
	u32 jr_ctl_hi;
	u32 jr_ctl_lo;
	u64 jr_descaddr;
	u32 op_status_hi;
	u32 op_status_lo;
	u32 rsvd24[2];
	u32 liodn;
	u32 td_liodn;
	u32 rsvd26[6];
	u64 math[4];
	u32 rsvd27[8];
	struct deco_sg_table gthr_tbl[4];
	u32 rsvd28[16];
	struct deco_sg_table sctr_tbl[4];
	u32 rsvd29[48];
	u32 descbuf[64];
	u32 rscvd30[193];
	u32 desc_dbg;
	u32 rsvd31[13];
	u32 dbg_exec;
	u32 rsvd32[112];
};

struct caam_drv_private {
	struct caam_ctrl *ctrl;
	struct caam_deco *deco;
	struct caam_assurance *assure;
	struct caam_queue_if *qi;
	struct caam_job_ring *jr[4];
	struct iommu_domain *domain;
	u8 total_jobrs;
	u8 qi_present;
	u8 mc_en;
	int secvio_irq;
	int virt_en;
	int era;
	u32 rng4_sh_init;
	struct clk_bulk_data *clks;
	int num_clks;
	struct dentry *ctl;
	struct debugfs_blob_wrapper ctl_kek_wrap;
	struct debugfs_blob_wrapper ctl_tkek_wrap;
	struct debugfs_blob_wrapper ctl_tdsk_wrap;
};

struct caam_imx_data {
	const struct clk_bulk_data *clks;
	int num_clks;
};

enum qm_mcr_queryfq_np_masks {
	qm_mcr_fqd_link_mask = 16777215,
	qm_mcr_odp_seq_mask = 16383,
	qm_mcr_orp_nesn_mask = 16383,
	qm_mcr_orp_ea_hseq_mask = 32767,
	qm_mcr_orp_ea_tseq_mask = 32767,
	qm_mcr_orp_ea_hptr_mask = 16777215,
	qm_mcr_orp_ea_tptr_mask = 16777215,
	qm_mcr_pfdr_hptr_mask = 16777215,
	qm_mcr_pfdr_tptr_mask = 16777215,
	qm_mcr_is_mask = 1,
	qm_mcr_frm_cnt_mask = 16777215,
};

struct caam_drv_req;

typedef void (*caam_qi_cbk)(struct caam_drv_req *, u32);

struct caam_drv_ctx;

struct caam_drv_req {
	struct qm_sg_entry fd_sgt[2];
	struct caam_drv_ctx *drv_ctx;
	caam_qi_cbk cbk;
	void *app_ctx;
	long: 64;
};

enum optype {
	ENCRYPT = 0,
	DECRYPT = 1,
	NUM_OP = 2,
};

struct caam_drv_ctx {
	u32 prehdr[2];
	u32 sh_desc[56];
	dma_addr_t context_a;
	struct qman_fq *req_fq;
	struct qman_fq *rsp_fq;
	refcount_t refcnt;
	int cpu;
	enum optype op_type;
	struct device *qidev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_napi {
	struct napi_struct irqtask;
	struct qman_portal *p;
};

struct caam_qi_pcpu_priv {
	struct caam_napi caam_napi;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct net_device net_dev;
	struct qman_fq *rsp_fq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_qi_priv {
	struct qman_cgr cgr;
};

struct caam_jrentry_info {
	void (*callbk)(struct device *, u32 *, u32, void *);
	void *cbkarg;
	u32 *desc_addr_virt;
	dma_addr_t desc_addr_dma;
	u32 desc_size;
};

struct caam_drv_private_jr {
	struct list_head list_node;
	struct device *dev;
	int ridx;
	struct caam_job_ring *rregs;
	struct tasklet_struct irqtask;
	int irq;
	bool hwrng;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tfm_count;
	struct caam_jrentry_info *entinfo;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t inplock;
	u32 inpring_avail;
	int head;
	void *inpring;
	int out_ring_read_index;
	int tail;
	void *outring;
	struct crypto_engine *engine;
	long: 64;
	long: 64;
};

struct jr_driver_data {
	struct list_head jr_list;
	spinlock_t jr_alloc_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct alginfo {
	u32 algtype;
	unsigned int keylen;
	unsigned int keylen_pad;
	dma_addr_t key_dma;
	const void *key_virt;
	bool key_inline;
};

struct split_key_result {
	struct completion completion;
	int err;
};

enum dpaa2_sg_format {
	dpaa2_sg_single = 0,
	dpaa2_sg_frame_data = 1,
	dpaa2_sg_sgt_ext = 2,
};

struct sec4_sg_entry {
	u64 ptr;
	u32 len;
	u32 bpid_offset;
};

struct caam_alg_entry {
	int class1_alg_type;
	int class2_alg_type;
	bool rfc3686;
	bool geniv;
	bool nodkp;
};

struct caam_aead_alg {
	struct aead_alg aead;
	struct caam_alg_entry caam;
	bool registered;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_skcipher_alg {
	struct skcipher_alg skcipher;
	struct caam_alg_entry caam;
	bool registered;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_ctx {
	struct crypto_engine_ctx enginectx;
	u32 sh_desc_enc[56];
	u32 sh_desc_dec[56];
	u8 key[164];
	dma_addr_t sh_desc_enc_dma;
	dma_addr_t sh_desc_dec_dma;
	dma_addr_t key_dma;
	enum dma_data_direction dir;
	struct device *jrdev;
	struct alginfo adata;
	struct alginfo cdata;
	unsigned int authsize;
	bool xts_key_fallback;
	struct crypto_skcipher *fallback;
};

struct skcipher_edesc;

struct caam_skcipher_req_ctx {
	struct skcipher_edesc *edesc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request fallback_req;
};

struct skcipher_edesc {
	int src_nents;
	int dst_nents;
	int mapped_src_nents;
	int mapped_dst_nents;
	dma_addr_t iv_dma;
	int sec4_sg_bytes;
	bool bklog;
	dma_addr_t sec4_sg_dma;
	struct sec4_sg_entry *sec4_sg;
	u32 hw_desc[0];
};

struct aead_edesc;

struct caam_aead_req_ctx {
	struct aead_edesc *edesc;
};

struct aead_edesc {
	int src_nents;
	int dst_nents;
	int mapped_src_nents;
	int mapped_dst_nents;
	int sec4_sg_bytes;
	bool bklog;
	dma_addr_t sec4_sg_dma;
	struct sec4_sg_entry *sec4_sg;
	u32 hw_desc[0];
};

struct caam_ctx___2 {
	struct device *jrdev;
	u32 sh_desc_enc[66];
	u32 sh_desc_dec[66];
	u8 key[160];
	dma_addr_t key_dma;
	enum dma_data_direction dir;
	struct alginfo adata;
	struct alginfo cdata;
	unsigned int authsize;
	struct device *qidev;
	spinlock_t lock;
	struct caam_drv_ctx *drv_ctx[2];
	bool xts_key_fallback;
	struct crypto_skcipher *fallback;
};

struct caam_skcipher_req_ctx___2 {
	struct skcipher_request fallback_req;
};

struct aead_edesc___2 {
	int src_nents;
	int dst_nents;
	dma_addr_t iv_dma;
	int qm_sg_bytes;
	dma_addr_t qm_sg_dma;
	unsigned int assoclen;
	dma_addr_t assoclen_dma;
	long: 64;
	long: 64;
	struct caam_drv_req drv_req;
	struct qm_sg_entry sgt[0];
};

struct skcipher_edesc___2 {
	int src_nents;
	int dst_nents;
	dma_addr_t iv_dma;
	int qm_sg_bytes;
	dma_addr_t qm_sg_dma;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct caam_drv_req drv_req;
	struct qm_sg_entry sgt[0];
};

struct caam_hash_ctx {
	struct crypto_engine_ctx enginectx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 sh_desc_update[40];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 sh_desc_update_first[40];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 sh_desc_fin[40];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 sh_desc_digest[40];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 key[128];
	dma_addr_t sh_desc_update_dma;
	dma_addr_t sh_desc_update_first_dma;
	dma_addr_t sh_desc_fin_dma;
	dma_addr_t sh_desc_digest_dma;
	enum dma_data_direction dir;
	enum dma_data_direction key_dir;
	struct device *jrdev;
	int ctx_len;
	struct alginfo adata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ahash_edesc;

struct caam_hash_state {
	dma_addr_t buf_dma;
	dma_addr_t ctx_dma;
	int ctx_dma_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 buf[128];
	int buflen;
	int next_buflen;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 caam_ctx[72];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	struct ahash_edesc *edesc;
	void (*ahash_op_done)(struct device *, u32 *, u32, void *);
	long: 64;
	long: 64;
	long: 64;
};

struct ahash_edesc {
	dma_addr_t sec4_sg_dma;
	int src_nents;
	int sec4_sg_bytes;
	bool bklog;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 hw_desc[11];
	struct sec4_sg_entry sec4_sg[0];
	long: 64;
	long: 64;
};

struct caam_export_state {
	u8 buf[128];
	u8 caam_ctx[72];
	int buflen;
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
};

struct caam_hash_template {
	char name[128];
	char driver_name[128];
	char hmac_name[128];
	char hmac_driver_name[128];
	unsigned int blocksize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ahash_alg template_ahash;
	u32 alg_type;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_hash_alg {
	struct list_head entry;
	int alg_type;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ahash_alg ahash_alg;
};

struct kfifo {
	union {
		struct __kfifo kfifo;
		unsigned char *type;
		const unsigned char *const_type;
		char (*rectype)[0];
		void *ptr;
		const void *ptr_const;
	};
	unsigned char buf[0];
};

struct caam_rng_ctx {
	struct hwrng rng;
	struct device *jrdev;
	struct device *ctrldev;
	void *desc_async;
	void *desc_sync;
	struct work_struct worker;
	struct kfifo fifo;
};

struct caam_rng_job_ctx {
	struct completion *done;
	int *err;
};

struct rsa_pub_pdb {
	u32 sgf;
	dma_addr_t f_dma;
	dma_addr_t g_dma;
	dma_addr_t n_dma;
	dma_addr_t e_dma;
	u32 f_len;
};

struct rsa_priv_f1_pdb {
	u32 sgf;
	dma_addr_t g_dma;
	dma_addr_t f_dma;
	dma_addr_t n_dma;
	dma_addr_t d_dma;
};

struct rsa_priv_f2_pdb {
	u32 sgf;
	dma_addr_t g_dma;
	dma_addr_t f_dma;
	dma_addr_t d_dma;
	dma_addr_t p_dma;
	dma_addr_t q_dma;
	dma_addr_t tmp1_dma;
	dma_addr_t tmp2_dma;
	u32 p_q_len;
};

struct rsa_priv_f3_pdb {
	u32 sgf;
	dma_addr_t g_dma;
	dma_addr_t f_dma;
	dma_addr_t c_dma;
	dma_addr_t p_dma;
	dma_addr_t q_dma;
	dma_addr_t dp_dma;
	dma_addr_t dq_dma;
	dma_addr_t tmp1_dma;
	dma_addr_t tmp2_dma;
	u32 p_q_len;
};

enum caam_priv_key_form {
	FORM1 = 0,
	FORM2 = 1,
	FORM3 = 2,
};

struct caam_rsa_key {
	u8 *n;
	u8 *e;
	u8 *d;
	u8 *p;
	u8 *q;
	u8 *dp;
	u8 *dq;
	u8 *qinv;
	u8 *tmp1;
	u8 *tmp2;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	enum caam_priv_key_form priv_form;
};

struct caam_rsa_ctx {
	struct crypto_engine_ctx enginectx;
	struct caam_rsa_key key;
	struct device *dev;
	dma_addr_t padding_dma;
};

struct rsa_edesc;

struct caam_rsa_req_ctx {
	struct scatterlist src[2];
	struct scatterlist *fixup_src;
	unsigned int fixup_src_len;
	struct rsa_edesc *edesc;
	void (*akcipher_op_done)(struct device *, u32 *, u32, void *);
};

struct rsa_edesc {
	int src_nents;
	int dst_nents;
	int mapped_src_nents;
	int mapped_dst_nents;
	int sec4_sg_bytes;
	bool bklog;
	dma_addr_t sec4_sg_dma;
	struct sec4_sg_entry *sec4_sg;
	union {
		struct rsa_pub_pdb pub;
		struct rsa_priv_f1_pdb priv_f1;
		struct rsa_priv_f2_pdb priv_f2;
		struct rsa_priv_f3_pdb priv_f3;
	} pdb;
	u32 hw_desc[0];
};

struct caam_akcipher_alg {
	struct akcipher_alg akcipher;
	bool registered;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dpaa2_fl_entry {
	__le64 addr;
	__le32 len;
	__le16 bpid;
	__le16 format_offset;
	__le32 frc;
	__le32 ctrl;
	__le64 flc;
};

enum dpaa2_fl_format {
	dpaa2_fl_single = 0,
	dpaa2_fl_res = 1,
	dpaa2_fl_sg = 2,
};

struct dpseci_attr {
	int id;
	u8 num_tx_queues;
	u8 num_rx_queues;
	u32 options;
};

enum dpseci_dest {
	DPSECI_DEST_NONE = 0,
	DPSECI_DEST_DPIO = 1,
	DPSECI_DEST_DPCON = 2,
};

struct dpseci_dest_cfg {
	enum dpseci_dest dest_type;
	int dest_id;
	u8 priority;
};

struct dpseci_rx_queue_cfg {
	u32 options;
	int order_preservation_en;
	u64 user_ctx;
	struct dpseci_dest_cfg dest_cfg;
};

struct dpseci_rx_queue_attr {
	u64 user_ctx;
	int order_preservation_en;
	struct dpseci_dest_cfg dest_cfg;
	u32 fqid;
};

struct dpseci_tx_queue_attr {
	u32 fqid;
	u8 priority;
};

struct dpseci_sec_attr {
	u16 ip_id;
	u8 major_rev;
	u8 minor_rev;
	u8 era;
	u8 deco_num;
	u8 zuc_auth_acc_num;
	u8 zuc_enc_acc_num;
	u8 snow_f8_acc_num;
	u8 snow_f9_acc_num;
	u8 crc_acc_num;
	u8 pk_acc_num;
	u8 kasumi_acc_num;
	u8 rng_acc_num;
	u8 md_acc_num;
	u8 arc4_acc_num;
	u8 des_acc_num;
	u8 aes_acc_num;
	u8 ccha_acc_num;
	u8 ptha_acc_num;
};

enum dpseci_congestion_unit {
	DPSECI_CONGESTION_UNIT_BYTES = 0,
	DPSECI_CONGESTION_UNIT_FRAMES = 1,
};

struct dpseci_congestion_notification_cfg {
	enum dpseci_congestion_unit units;
	u32 threshold_entry;
	u32 threshold_exit;
	u64 message_ctx;
	u64 message_iova;
	struct dpseci_dest_cfg dest_cfg;
	u16 notification_mode;
};

struct dpaa2_caam_priv_per_cpu;

struct dpaa2_caam_priv {
	int dpsec_id;
	u16 major_ver;
	u16 minor_ver;
	struct dpseci_attr dpseci_attr;
	struct dpseci_sec_attr sec_attr;
	struct dpseci_rx_queue_attr rx_queue_attr[16];
	struct dpseci_tx_queue_attr tx_queue_attr[16];
	int num_pairs;
	void *cscn_mem;
	void *cscn_mem_aligned;
	dma_addr_t cscn_dma;
	struct device *dev;
	struct fsl_mc_io *mc_io;
	struct iommu_domain *domain;
	struct dpaa2_caam_priv_per_cpu *ppriv;
	struct dentry *dfs_root;
};

struct dpaa2_caam_priv_per_cpu {
	struct napi_struct napi;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct net_device net_dev;
	int req_fqid;
	int rsp_fqid;
	int prio;
	struct dpaa2_io_notification_ctx nctx;
	struct dpaa2_io_store *store;
	struct dpaa2_caam_priv *priv;
	struct dpaa2_io *dpio;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct aead_edesc___3 {
	int src_nents;
	int dst_nents;
	dma_addr_t iv_dma;
	int qm_sg_bytes;
	dma_addr_t qm_sg_dma;
	unsigned int assoclen;
	dma_addr_t assoclen_dma;
	struct dpaa2_sg_entry sgt[0];
};

struct skcipher_edesc___3 {
	int src_nents;
	int dst_nents;
	dma_addr_t iv_dma;
	int qm_sg_bytes;
	dma_addr_t qm_sg_dma;
	struct dpaa2_sg_entry sgt[0];
};

struct ahash_edesc___2 {
	dma_addr_t qm_sg_dma;
	int src_nents;
	int qm_sg_bytes;
	struct dpaa2_sg_entry sgt[0];
};

struct caam_flc {
	u32 flc[16];
	u32 sh_desc[56];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_request {
	struct dpaa2_fl_entry fd_flt[2];
	dma_addr_t fd_flt_dma;
	struct caam_flc *flc;
	dma_addr_t flc_dma;
	void (*cbk)(void *, u32);
	void *ctx;
	void *edesc;
	long: 64;
	long: 64;
	struct skcipher_request fallback_req;
};

struct caam_alg_entry___2 {
	struct device *dev;
	int class1_alg_type;
	int class2_alg_type;
	bool rfc3686;
	bool geniv;
	bool nodkp;
};

struct caam_aead_alg___2 {
	struct aead_alg aead;
	struct caam_alg_entry___2 caam;
	bool registered;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_skcipher_alg___2 {
	struct skcipher_alg skcipher;
	struct caam_alg_entry___2 caam;
	bool registered;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_ctx___3 {
	struct caam_flc flc[2];
	u8 key[164];
	dma_addr_t flc_dma[2];
	dma_addr_t key_dma;
	enum dma_data_direction dir;
	struct device *dev;
	struct alginfo adata;
	struct alginfo cdata;
	unsigned int authsize;
	bool xts_key_fallback;
	struct crypto_skcipher *fallback;
	long: 64;
	long: 64;
};

enum hash_optype {
	UPDATE = 0,
	UPDATE_FIRST = 1,
	FINALIZE = 2,
	DIGEST = 3,
	HASH_NUM_OP = 4,
};

struct caam_hash_ctx___2 {
	struct caam_flc flc[4];
	u8 key[128];
	dma_addr_t flc_dma[4];
	struct device *dev;
	int ctx_len;
	struct alginfo adata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct caam_hash_state___2 {
	struct caam_request caam_req;
	dma_addr_t buf_dma;
	dma_addr_t ctx_dma;
	int ctx_dma_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 buf[128];
	int buflen;
	int next_buflen;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 caam_ctx[72];
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct split_key_sh_result {
	struct completion completion;
	int err;
	struct device *dev;
};

struct caam_hash_alg___2 {
	struct list_head entry;
	struct device *dev;
	int alg_type;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ahash_alg ahash_alg;
};

struct dpseci_cmd_open {
	__le32 dpseci_id;
};

struct dpseci_rsp_is_enabled {
	u8 is_enabled;
};

struct dpseci_rsp_get_attributes {
	__le32 id;
	__le32 pad0;
	u8 num_tx_queues;
	u8 num_rx_queues;
	u8 pad1[6];
	__le32 options;
};

struct dpseci_cmd_queue {
	__le32 dest_id;
	u8 priority;
	u8 queue;
	u8 dest_type;
	u8 pad;
	__le64 user_ctx;
	union {
		__le32 options;
		__le32 fqid;
	};
	u8 order_preservation_en;
};

struct dpseci_rsp_get_tx_queue {
	__le32 pad;
	__le32 fqid;
	u8 priority;
};

struct dpseci_rsp_get_sec_attr {
	__le16 ip_id;
	u8 major_rev;
	u8 minor_rev;
	u8 era;
	u8 pad0[3];
	u8 deco_num;
	u8 zuc_auth_acc_num;
	u8 zuc_enc_acc_num;
	u8 pad1;
	u8 snow_f8_acc_num;
	u8 snow_f9_acc_num;
	u8 crc_acc_num;
	u8 pad2;
	u8 pk_acc_num;
	u8 kasumi_acc_num;
	u8 rng_acc_num;
	u8 pad3;
	u8 md_acc_num;
	u8 arc4_acc_num;
	u8 des_acc_num;
	u8 aes_acc_num;
	u8 ccha_acc_num;
	u8 ptha_acc_num;
};

struct dpseci_rsp_get_api_version {
	__le16 major;
	__le16 minor;
};

struct dpseci_cmd_congestion_notification {
	__le32 dest_id;
	__le16 notification_mode;
	u8 priority;
	u8 options;
	__le64 message_iova;
	__le64 message_ctx;
	__le32 threshold_entry;
	__le32 threshold_exit;
};

struct of_timer_irq {
	int irq;
	int index;
	int percpu;
	const char *name;
	long unsigned int flags;
	irq_handler_t handler;
};

struct of_timer_base {
	void *base;
	const char *name;
	int index;
};

struct of_timer_clk {
	struct clk *clk;
	const char *name;
	int index;
	long unsigned int rate;
	long unsigned int period;
};

struct timer_of {
	unsigned int flags;
	struct device_node *np;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device clkevt;
	struct of_timer_base of_base;
	struct of_timer_irq of_irq;
	struct of_timer_clk of_clk;
	void *private_data;
	long: 64;
	long: 64;
};

typedef int (*of_init_fn_1_ret)(struct device_node *);

enum arch_timer_reg {
	ARCH_TIMER_REG_CTRL = 0,
	ARCH_TIMER_REG_TVAL = 1,
};

enum arch_timer_ppi_nr {
	ARCH_TIMER_PHYS_SECURE_PPI = 0,
	ARCH_TIMER_PHYS_NONSECURE_PPI = 1,
	ARCH_TIMER_VIRT_PPI = 2,
	ARCH_TIMER_HYP_PPI = 3,
	ARCH_TIMER_HYP_VIRT_PPI = 4,
	ARCH_TIMER_MAX_TIMER_PPI = 5,
};

enum arch_timer_spi_nr {
	ARCH_TIMER_PHYS_SPI = 0,
	ARCH_TIMER_VIRT_SPI = 1,
	ARCH_TIMER_MAX_TIMER_SPI = 2,
};

struct arch_timer_kvm_info {
	struct timecounter timecounter;
	int virtual_irq;
	int physical_irq;
};

struct arch_timer_mem_frame {
	bool valid;
	phys_addr_t cntbase;
	size_t size;
	int phys_irq;
	int virt_irq;
};

struct arch_timer_mem {
	phys_addr_t cntctlbase;
	size_t size;
	struct arch_timer_mem_frame frame[8];
};

enum arch_timer_erratum_match_type {
	ate_match_dt = 0,
	ate_match_local_cap_id = 1,
	ate_match_acpi_oem_info = 2,
};

struct arch_timer_erratum_workaround {
	enum arch_timer_erratum_match_type match_type;
	const void *id;
	const char *desc;
	u32 (*read_cntp_tval_el0)();
	u32 (*read_cntv_tval_el0)();
	u64 (*read_cntpct_el0)();
	u64 (*read_cntvct_el0)();
	int (*set_next_event_phys)(long unsigned int, struct clock_event_device *);
	int (*set_next_event_virt)(long unsigned int, struct clock_event_device *);
	bool disable_compat_vdso;
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct arch_timer {
	void *base;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device evt;
};

struct ate_acpi_oem_info {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
};

typedef bool (*ate_match_fn_t)(const struct arch_timer_erratum_workaround *, const void *);

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_report;

struct hid_input;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
};

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	unsigned int id;
	unsigned int type;
	unsigned int application;
	struct hid_field *field[256];
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	bool registered;
	struct list_head reports;
	unsigned int application;
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	struct device dev;
	struct hid_driver *driver;
	struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	unsigned int initial_quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
	bool (*may_wakeup)(struct hid_device *);
	unsigned int max_buffer_size;
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

struct a4tech_sc {
	long unsigned int quirks;
	unsigned int hw_wheel;
	__s32 delayed_value;
};

struct apple_sc {
	long unsigned int quirks;
	unsigned int fn_on;
	unsigned int fn_found;
	long unsigned int pressed_numlock[12];
};

struct apple_key_translation {
	u16 from;
	u16 to;
	u8 flags;
};

struct ms_data {
	long unsigned int quirks;
	struct hid_device *hdev;
	struct work_struct ff_worker;
	__u8 strong;
	__u8 weak;
	void *output_report_dmabuf;
};

enum {
	MAGNITUDE_STRONG = 2,
	MAGNITUDE_WEAK = 3,
	MAGNITUDE_NUM = 4,
};

struct xb1s_ff_report {
	__u8 report_id;
	__u8 enable;
	__u8 magnitude[4];
	__u8 duration_10ms;
	__u8 start_delay_10ms;
	__u8 loop_count;
};

struct of_phandle_iterator {
	const char *cells_name;
	int cell_count;
	const struct device_node *parent;
	const __be32 *list_end;
	const __be32 *phandle_end;
	const __be32 *cur;
	uint32_t cur_count;
	phandle phandle;
	struct device_node *node;
};

struct alias_prop {
	struct list_head link;
	const char *alias;
	struct device_node *np;
	int id;
	char stem[0];
};

struct of_endpoint {
	unsigned int port;
	unsigned int id;
	const struct device_node *local_node;
};

struct supplier_bindings {
	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
	bool optional;
	bool node_not_dev;
};

struct of_bus___2 {
	void (*count_cells)(const void *, int, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
};

struct of_bus {
	const char *name;
	const char *addresses;
	int (*match)(struct device_node *);
	void (*count_cells)(struct device_node *, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
	bool has_flags;
	unsigned int (*get_flags)(const __be32 *);
};

struct of_intc_desc {
	struct list_head list;
	of_irq_init_cb_t irq_init_cb;
	struct device_node *dev;
	struct device_node *interrupt_parent;
};

struct rmem_assigned_device {
	struct device *dev;
	struct reserved_mem *rmem;
	struct list_head list;
};

union extcon_property_value {
	int intval;
};

struct extcon_cable;

struct extcon_dev {
	const char *name;
	const unsigned int *supported_cable;
	const u32 *mutually_exclusive;
	struct device dev;
	struct raw_notifier_head nh_all;
	struct raw_notifier_head *nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;
	u32 state;
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
};

struct extcon_cable {
	struct extcon_dev *edev;
	int cable_index;
	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct attribute *attrs[3];
	union extcon_property_value usb_propval[3];
	union extcon_property_value chg_propval[1];
	union extcon_property_value jack_propval[1];
	union extcon_property_value disp_propval[2];
	long unsigned int usb_bits[1];
	long unsigned int chg_bits[1];
	long unsigned int jack_bits[1];
	long unsigned int disp_bits[1];
};

struct __extcon_info {
	unsigned int type;
	unsigned int id;
	const char *name;
};

struct extcon_dev_notifier_devres {
	struct extcon_dev *edev;
	unsigned int id;
	struct notifier_block *nb;
};

struct usb_extcon_info {
	struct device *dev;
	struct extcon_dev *edev;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	int id_irq;
	int vbus_irq;
	long unsigned int debounce_jiffies;
	struct delayed_work wq_detcable;
};

struct pmu_irq_ops {
	void (*enable_pmuirq)(unsigned int);
	void (*disable_pmuirq)(unsigned int);
	void (*free_pmuirq)(unsigned int, int, void *);
};

struct cper_sec_proc_arm {
	u32 validation_bits;
	u16 err_info_num;
	u16 context_info_num;
	u32 section_length;
	u8 affinity_level;
	u8 reserved[3];
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
};

enum hw_event_mc_err_type {
	HW_EVENT_ERR_CORRECTED = 0,
	HW_EVENT_ERR_UNCORRECTED = 1,
	HW_EVENT_ERR_DEFERRED = 2,
	HW_EVENT_ERR_FATAL = 3,
	HW_EVENT_ERR_INFO = 4,
};

struct trace_event_raw_mc_event {
	struct trace_entry ent;
	unsigned int error_type;
	u32 __data_loc_msg;
	u32 __data_loc_label;
	u16 error_count;
	u8 mc_index;
	s8 top_layer;
	s8 middle_layer;
	s8 lower_layer;
	long int address;
	u8 grain_bits;
	long int syndrome;
	u32 __data_loc_driver_detail;
	char __data[0];
};

struct trace_event_raw_arm_event {
	struct trace_entry ent;
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
	u8 affinity;
	char __data[0];
};

struct trace_event_raw_non_standard_event {
	struct trace_entry ent;
	char sec_type[16];
	char fru_id[16];
	u32 __data_loc_fru_text;
	u8 sev;
	u32 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_aer_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 status;
	u8 severity;
	u8 tlp_header_valid;
	u32 tlp_header[4];
	char __data[0];
};

struct trace_event_data_offsets_mc_event {
	u32 msg;
	u32 label;
	u32 driver_detail;
};

struct trace_event_data_offsets_arm_event {};

struct trace_event_data_offsets_non_standard_event {
	u32 fru_text;
	u32 buf;
};

struct trace_event_data_offsets_aer_event {
	u32 dev_name;
};

typedef void (*btf_trace_mc_event)(void *, const unsigned int, const char *, const char *, const int, const u8, const s8, const s8, const s8, long unsigned int, const u8, long unsigned int, const char *);

typedef void (*btf_trace_arm_event)(void *, const struct cper_sec_proc_arm *);

typedef void (*btf_trace_non_standard_event)(void *, const guid_t *, const guid_t *, const char *, const u8, const u8 *, const u32);

typedef void (*btf_trace_aer_event)(void *, const char *, const u32, const u8, const u8, struct aer_header_log_regs *);

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device {
	struct module *owner;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	struct nvmem_layout *layout;
	void *priv;
};

struct nvmem_cell_entry {
	const char *name;
	int offset;
	size_t raw_len;
	int bytes;
	int bit_offset;
	int nbits;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
	struct device_node *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct nvmem_cell {
	struct nvmem_cell_entry *entry;
	const char *id;
	int index;
};

struct mux_control_ops {
	int (*set)(struct mux_control *, int);
};

struct mux_chip;

struct mux_control {
	struct semaphore lock;
	struct mux_chip *chip;
	int cached_state;
	unsigned int states;
	int idle_state;
};

struct mux_chip {
	unsigned int controllers;
	struct mux_control *mux;
	struct device dev;
	int id;
	const struct mux_control_ops *ops;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

typedef u32 compat_caddr_t;

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct nf_hook_state;

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sock_skb_cb {
	u32 dropcount;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	struct ip_options_rcu *inet_opt;
	__be16 inet_sport;
	__u16 inet_id;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	const struct in6_addr *saddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 recverr_rfc4884: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct nf_hook_state {
	u8 hook;
	u8 pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 frag_max_size;
	__u16 srhoff;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct prot_inuse {
	int val[64];
};

struct so_timestamping {
	int flags;
	int bind_phc;
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_bind_bucket;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	struct hlist_node icsk_listen_portaddr_node;
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int search_high;
		int search_low;
		u32 probe_size: 31;
		u32 enabled: 1;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 cwnd_usage_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct net_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 gro_remcsum_start;
	long unsigned int age;
	u16 proto;
	u8 same_flow: 1;
	u8 encap_mark: 1;
	u8 csum_valid: 1;
	u8 csum_cnt: 3;
	u8 free: 2;
	u8 is_ipv6: 1;
	u8 is_fou: 1;
	u8 is_atomic: 1;
	u8 recursion_counter: 4;
	u8 is_flist: 1;
	__wsum csum;
	struct sk_buff *last;
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

typedef int (*sendmsg_func)(struct sock *, struct msghdr *, struct kvec *, size_t, size_t);

typedef int (*sendpage_func)(struct sock *, struct page *, int, size_t, int);

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator {
	struct gnet_stats_basic_packed *bstats;
	spinlock_t *stats_lock;
	seqcount_t *running;
	struct gnet_stats_basic_cpu *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	__RTNLGRP_MAX = 34,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

typedef u16 u_int16_t;

typedef u32 u_int32_t;

typedef u64 u_int64_t;

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	long: 0;
};

struct flow_keys_digest {
	u8 data[16];
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

struct nf_ct_event;

struct nf_exp_event;

struct nf_ct_event_notifier {
	int (*ct_event)(unsigned int, const struct nf_ct_event *);
	int (*exp_event)(unsigned int, const struct nf_exp_event *);
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__u32 nh_tclassid;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	refcount_t fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	LWTUNNEL_ENCAP_IOAM6 = 9,
	__LWTUNNEL_ENCAP_MAX = 10,
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry;

struct nh_res_bucket {
	struct nh_grp_entry *nh_entry;
	atomic_long_t used_time;
	long unsigned int migrated_time;
	bool occupied;
	u8 nh_flags;
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	union {
		struct {
			atomic_t upper_bound;
		} hthr;
		struct {
			struct list_head uw_nh_entry;
			u16 count_buckets;
			u16 wants_buckets;
		} res;
	};
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_res_table {
	struct net *net;
	u32 nhg_id;
	struct delayed_work upkeep_dw;
	struct list_head uw_nh_entries;
	long unsigned int unbalanced_since;
	u32 idle_timer;
	u32 unbalanced_timer;
	u16 num_nh_buckets;
	struct nh_res_bucket nh_buckets[0];
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool is_multipath;
	bool hash_threshold;
	bool resilient;
	bool fdb_nh;
	bool has_v4;
	struct nh_res_table *res_table;
	struct nh_grp_entry nh_entries[0];
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
	} u;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct mpls_label {
	__be32 entry;
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 last_dir;
	u8 flags;
};

struct nf_ct_udp {
	long unsigned int stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_zone zone;
	struct nf_conntrack_tuple_hash tuplehash[2];
	long unsigned int status;
	u16 cpu;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {} __nfct_init_offset;
	struct nf_conn *master;
	u_int32_t mark;
	struct nf_ct_ext *ext;
	union nf_conntrack_proto proto;
};

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_ct_ext {
	u8 offset[6];
	u8 len;
	char data[0];
};

struct nf_conntrack_helper;

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

enum nf_ct_ext_id {
	NF_CT_EXT_HELPER = 0,
	NF_CT_EXT_NAT = 1,
	NF_CT_EXT_SEQADJ = 2,
	NF_CT_EXT_ACCT = 3,
	NF_CT_EXT_ECACHE = 4,
	NF_CT_EXT_TSTAMP = 5,
	NF_CT_EXT_NUM = 6,
};

struct nf_ct_event {
	struct nf_conn *ct;
	u32 portid;
	int report;
};

struct nf_exp_event {
	struct nf_conntrack_expect *exp;
	u32 portid;
	int report;
};

struct nf_conn_labels {
	long unsigned int bits[2];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct rps_sock_flow_table {
	u32 mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

struct ipv4_devconf {
	void *sysctl;
	int data[32];
	long unsigned int state[1];
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_NUMHOOKS = 1,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
	NAPIF_STATE_THREADED = 256,
	NAPIF_STATE_SCHED_THREADED = 512,
};

struct net_device_path_stack {
	int num_paths;
	struct net_device_path path[5];
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	u32 mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
	__QDISC_STATE_DRAINING = 3,
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	__IPV4_DEVCONF_MAX = 33,
};

struct tc_skb_cb {
	struct qdisc_skb_cb qdisc_cb;
	u16 mru;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
	u16 zone;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	__NDTPA_MAX = 19,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	RTN_POLICY_FAILED = 12,
	__RTN_MAX = 13,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	IFLA_PARENT_DEV_NAME = 56,
	IFLA_PARENT_DEV_BUS_NAME = 57,
	__IFLA_MAX = 58,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
	IFLA_BRPORT_BPDU_FILTER = 39,
	__IFLA_BRPORT_MAX = 40,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	__IFLA_OFFLOAD_XSTATS_MAX = 2,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	__IFLA_BRIDGE_MAX = 6,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum bpf_lwt_encap_mode {
	BPF_LWT_ENCAP_SEG6 = 0,
	BPF_LWT_ENCAP_SEG6_INLINE = 1,
	BPF_LWT_ENCAP_IP = 2,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	__u16 tunnel_ext;
	__u32 tunnel_label;
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	union {
		__u16 tot_len;
		__u16 mtu_result;
	};
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum bpf_check_mtu_flags {
	BPF_MTU_CHK_SEGS = 1,
};

enum bpf_check_mtu_ret {
	BPF_MTU_CHK_RET_SUCCESS = 0,
	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_kill: 1;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	unsigned char accept_udp_l4: 1;
	unsigned char accept_udp_fraglist: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	void (*encap_err_rcv)(struct sock *, struct sk_buff *, unsigned int);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct fib6_result;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_nh_release_dsts)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
};

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 in_flight: 30;
			__u32 is_app_limited: 1;
			__u32 unused: 1;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
	};
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct sk_skb_cb {
	unsigned char data[20];
	struct _strp_msg strp;
	u64 temp_reg;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
};

struct xsk_queue;

struct xdp_sock {
	struct sock sk;
	long: 64;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
	long: 64;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

enum {
	SEG6_LOCAL_ACTION_UNSPEC = 0,
	SEG6_LOCAL_ACTION_END = 1,
	SEG6_LOCAL_ACTION_END_X = 2,
	SEG6_LOCAL_ACTION_END_T = 3,
	SEG6_LOCAL_ACTION_END_DX2 = 4,
	SEG6_LOCAL_ACTION_END_DX6 = 5,
	SEG6_LOCAL_ACTION_END_DX4 = 6,
	SEG6_LOCAL_ACTION_END_DT6 = 7,
	SEG6_LOCAL_ACTION_END_DT4 = 8,
	SEG6_LOCAL_ACTION_END_B6 = 9,
	SEG6_LOCAL_ACTION_END_B6_ENCAP = 10,
	SEG6_LOCAL_ACTION_END_BM = 11,
	SEG6_LOCAL_ACTION_END_S = 12,
	SEG6_LOCAL_ACTION_END_AS = 13,
	SEG6_LOCAL_ACTION_END_AM = 14,
	SEG6_LOCAL_ACTION_END_BPF = 15,
	SEG6_LOCAL_ACTION_END_DT46 = 16,
	__SEG6_LOCAL_ACTION_MAX = 17,
};

struct seg6_bpf_srh_state {
	struct ipv6_sr_hdr *srh;
	u16 hdrlen;
	bool valid;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct strparser strp;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	struct sk_buff *recv_pkt;
	u8 control;
	u8 async_capable: 1;
	u8 decrypted: 1;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	bool async_notify;
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
	};
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sk_msg)(struct sk_msg *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_store_bytes)(struct sk_buff *, u32, const void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_action)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_adjust_srh)(struct sk_buff *, u32, s32);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

enum xdp_buff_flags {
	XDP_FLAGS_HAS_FRAGS = 1,
};

struct xdp_frame_bulk {
	int count;
	void *xa;
	void *q[16];
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct xdp_buff_xsk;

struct xdp_desc;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	u32 heads_cnt;
	u16 queue_id;
	long: 64;
	long: 64;
	long: 64;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	struct xdp_desc *tx_descs;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	bool unaligned;
	u64 orig_addr;
	struct list_head free_list_node;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	__FRA_MAX = 25,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	FR_ACT_RES9 = 9,
	FR_ACT_RES10 = 10,
	FR_ACT_RES11 = 11,
	FR_ACT_POLICY_FAILED = 12,
	__FR_ACT_MAX = 13,
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	enum skb_drop_reason reason;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_ni_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_rx_ni_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int sysctl_mem[3];
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_inet_sk_error_report {
	struct trace_entry ent;
	int error;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

struct trace_event_data_offsets_inet_sk_error_report {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

typedef void (*btf_trace_inet_sk_error_report)(void *, const struct sock *);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_event_skb {
	struct trace_entry ent;
	const void *skbaddr;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

struct trace_event_data_offsets_tcp_event_skb {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_tcp_bad_csum)(void *, const struct sk_buff *);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_enqueue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_enqueue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_enqueue)(void *, struct Qdisc *, const struct netdev_queue *, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
		unsigned char mac_addr[6];
	} dst;
	__be16 proto;
	__u16 vid;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct mac_addr___2 {
	unsigned char addr[6];
};

typedef struct mac_addr___2 mac_addr;

typedef __u16 port_id;

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	long unsigned int delay_time;
};

struct bridge_mcast_querier {
	struct br_ip addr;
	int port_ifidx;
	seqcount_spinlock_t seq;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

struct net_bridge_port;

struct net_bridge_vlan;

struct net_bridge_mcast_port {
	struct net_bridge_port *port;
	struct net_bridge_vlan *vlan;
	struct bridge_mcast_own_query ip4_own_query;
	struct timer_list ip4_mc_router_timer;
	struct hlist_node ip4_rlist;
	struct bridge_mcast_own_query ip6_own_query;
	struct timer_list ip6_mc_router_timer;
	struct hlist_node ip6_rlist;
	unsigned char multicast_router;
};

struct net_bridge;

struct net_bridge_vlan_group;

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_vlan_group *vlgrp;
	struct net_bridge_port *backup_port;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct net_bridge_mcast_port multicast_ctx;
	struct bridge_mcast_stats *mcast_stats;
	u32 multicast_eht_hosts_limit;
	u32 multicast_eht_hosts_cnt;
	struct hlist_head mglist;
	char sysfs_name[16];
	int hwdom;
	int offload_count;
	struct netdev_phys_item_id ppid;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst *tunnel_dst;
};

struct net_bridge_mcast {
	struct net_bridge *br;
	struct net_bridge_vlan *vlan;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_querier;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct hlist_head ip4_mc_router_list;
	struct timer_list ip4_mc_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct hlist_head ip6_mc_router_list;
	struct timer_list ip6_mc_router_timer;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
};

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	u8 state;
	struct pcpu_sw_netstats *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	struct br_tunnel_info tinfo;
	union {
		struct net_bridge_mcast br_mcast_ctx;
		struct net_bridge_mcast_port port_mcast_ctx;
	};
	struct list_head vlist;
	struct callback_head rcu;
};

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct hlist_head frame_type_list;
	struct net_device *dev;
	long unsigned int options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group *vlgrp;
	struct rhashtable fdb_hash_tbl;
	struct list_head port_list;
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	struct net_bridge_mcast multicast_ctx;
	struct bridge_mcast_stats *mcast_stats;
	u32 hash_max;
	spinlock_t multicast_lock;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	int last_hwdom;
	long unsigned int busy_hwdoms;
	struct hlist_head fdb_list;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	long unsigned int flags;
	long: 64;
	long: 64;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_update_nid {};

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

struct net_packet_attrs {
	unsigned char *src;
	unsigned char *dst;
	u32 ip_src;
	u32 ip_dst;
	bool tcp;
	u16 sport;
	u16 dport;
	int timeout;
	int size;
	int max_size;
	u8 id;
	u16 queue_mapping;
};

struct net_test_priv {
	struct net_packet_attrs *packet;
	struct packet_type pt;
	struct completion comp;
	int double_vlan;
	int vlan_id;
	int ok;
};

struct netsfhdr {
	__be32 version;
	__be64 magic;
	u8 id;
} __attribute__((packed));

struct net_test {
	char name[32];
	int (*fn)(struct net_device *);
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_SRQ = 7,
	RDMA_RESTRACK_MAX = 8,
};

struct rdma_restrack_entry {
	bool valid;
	u8 no_track: 1;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_hw_stats;

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const char * const *names;
	int num_counters;
	u64 value[0];
};

struct ib_device;

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u32 port;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_IRDMA = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

struct uverbs_attr_bundle;

struct rdma_cm_id;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_gid_attr;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct ib_pd;

struct ib_ah;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_flow_action_attrs_esp;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	const struct attribute_group *device_group;
	const struct attribute_group **port_groups;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u32, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u32, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u32, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u32, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u32);
	struct net_device * (*get_netdev)(struct ib_device *, u32);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u32, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u32, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u32, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u32, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	int (*create_qp)(struct ib_qp *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	struct ib_mr * (*reg_user_mr_dmabuf)(struct ib_pd *, u64, u64, u64, int, int, struct ib_udata *);
	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	struct ib_flow_action * (*create_flow_action_esp)(struct ib_device *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*modify_flow_action_esp)(struct ib_flow_action *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*set_vf_link_state)(struct ib_device *, int, u32, int);
	int (*get_vf_config)(struct ib_device *, int, u32, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u32, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u32, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u32, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_device_stats)(struct ib_device *);
	struct rdma_hw_stats * (*alloc_hw_port_stats)(struct ib_device *, u32);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u32, int);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	int (*get_numa_node)(struct ib_device *);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_qp;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	u64 device_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	u64 max_dm_size;
	u32 max_sgl_rd;
};

struct hw_stats_device_data;

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[4];
	u64 uverbs_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u32 phys_port_cnt;
	struct ib_device_attr attrs;
	struct hw_stats_device_data *hw_stats_data;
	struct rdmacg_device cg_device;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	u64 sig_err_offset;
	u32 key;
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_flow_action_esp_keymat {
	IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = 0,
};

struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
	__u64 iv;
	__u32 iv_algo;
	__u32 salt;
	__u32 icv_len;
	__u32 key_len;
	__u32 aes_key[8];
};

enum ib_uverbs_flow_action_esp_replay {
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = 0,
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = 1,
};

struct ib_uverbs_flow_action_esp_replay_bmp {
	__u32 size;
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u32 port_num;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

struct ib_ucq_object;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct ib_event;

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
};

struct ib_uqp_object;

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u32 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_usrq_object;

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
	struct rdma_restrack_entry res;
};

struct ib_uwq_object;

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u32 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mr_status {
	u32 fail_status;
	struct ib_sig_err sig_err;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u32 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_REG_MR = 8,
	IB_WC_MASKED_COMP_SWAP = 9,
	IB_WC_MASKED_FETCH_ADD = 10,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u32 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u32 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_uobject;

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u32 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u32 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_rdmacg_object {
	struct rdma_cgroup *cg;
};

struct ib_uverbs_file;

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u32 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u32 port;
	union ib_flow_spec flows[0];
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_flow_action_attrs_esp_keymats {
	enum ib_uverbs_flow_action_esp_keymat protocol;
	union {
		struct ib_uverbs_flow_action_esp_keymat_aes_gcm aes_gcm;
	} keymat;
};

struct ib_flow_action_attrs_esp_replays {
	enum ib_uverbs_flow_action_esp_replay protocol;
	union {
		struct ib_uverbs_flow_action_esp_replay_bmp bmp;
	} replay;
};

struct ib_flow_spec_list {
	struct ib_flow_spec_list *next;
	union ib_flow_spec spec;
};

struct ib_flow_action_attrs_esp {
	struct ib_flow_action_attrs_esp_keymats *keymat;
	struct ib_flow_action_attrs_esp_replays *replay;
	struct ib_flow_spec_list *encap;
	u32 esn;
	u32 spi;
	u32 seq;
	u32 tfc_pad;
	u64 flags;
	u64 hard_limit_pkts;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct ib_port;

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	spinlock_t netdev_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	struct net_device *netdev;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct ib_port *sysfs;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u32, struct net_device *, void *);
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	long unsigned int start_pgoff;
	size_t npages;
	bool driver_removed;
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
};

struct genl_ops;

struct genl_info;

struct genl_small_ops;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	unsigned int mcgrp_offset;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_mcgrps;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct genl_dumpit_info {
	const struct genl_family *family;
	struct genl_ops op;
	struct nlattr **attrs;
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	DEVLINK_CMD_TRAP_POLICER_GET = 69,
	DEVLINK_CMD_TRAP_POLICER_SET = 70,
	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
	DEVLINK_CMD_RATE_GET = 74,
	DEVLINK_CMD_RATE_SET = 75,
	DEVLINK_CMD_RATE_NEW = 76,
	DEVLINK_CMD_RATE_DEL = 77,
	__DEVLINK_CMD_MAX = 78,
	DEVLINK_CMD_MAX = 77,
};

enum devlink_eswitch_mode {
	DEVLINK_ESWITCH_MODE_LEGACY = 0,
	DEVLINK_ESWITCH_MODE_SWITCHDEV = 1,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
	__DEVLINK_ATTR_STATS_MAX = 3,
	DEVLINK_ATTR_STATS_MAX = 2,
};

enum {
	DEVLINK_FLASH_OVERWRITE_SETTINGS_BIT = 0,
	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS_BIT = 1,
	__DEVLINK_FLASH_OVERWRITE_MAX_BIT = 2,
	DEVLINK_FLASH_OVERWRITE_MAX_BIT = 1,
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	DEVLINK_ATTR_NETNS_FD = 138,
	DEVLINK_ATTR_NETNS_PID = 139,
	DEVLINK_ATTR_NETNS_ID = 140,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
	DEVLINK_ATTR_PORT_FUNCTION = 145,
	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
	DEVLINK_ATTR_PORT_LANES = 147,
	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
	DEVLINK_ATTR_PORT_EXTERNAL = 149,
	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
	DEVLINK_ATTR_RELOAD_ACTION = 153,
	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
	DEVLINK_ATTR_RELOAD_LIMITS = 155,
	DEVLINK_ATTR_DEV_STATS = 156,
	DEVLINK_ATTR_RELOAD_STATS = 157,
	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
	DEVLINK_ATTR_RELOAD_ACTION_INFO = 162,
	DEVLINK_ATTR_RELOAD_ACTION_STATS = 163,
	DEVLINK_ATTR_PORT_PCI_SF_NUMBER = 164,
	DEVLINK_ATTR_RATE_TYPE = 165,
	DEVLINK_ATTR_RATE_TX_SHARE = 166,
	DEVLINK_ATTR_RATE_TX_MAX = 167,
	DEVLINK_ATTR_RATE_NODE_NAME = 168,
	DEVLINK_ATTR_RATE_PARENT_NODE_NAME = 169,
	__DEVLINK_ATTR_MAX = 170,
	DEVLINK_ATTR_MAX = 169,
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

enum devlink_dpipe_field_ethernet_id {
	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
};

enum devlink_dpipe_field_ipv4_id {
	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
};

enum devlink_dpipe_field_ipv6_id {
	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
};

enum devlink_dpipe_header_id {
	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
	DEVLINK_DPIPE_HEADER_IPV4 = 1,
	DEVLINK_DPIPE_HEADER_IPV6 = 2,
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

enum devlink_port_function_attr {
	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
	DEVLINK_PORT_FN_ATTR_STATE = 2,
	DEVLINK_PORT_FN_ATTR_OPSTATE = 3,
	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 4,
	DEVLINK_PORT_FUNCTION_ATTR_MAX = 3,
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
};

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
};

typedef u64 devlink_resource_occ_get_t(void *);

struct devlink_resource {
	const char *name;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

struct devlink_flash_notify {
	const char *status_msg;
	const char *component;
	long unsigned int done;
	long unsigned int total;
	long unsigned int timeout;
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	long unsigned int supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
	bool published;
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH = 11,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA = 12,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET = 13,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 14,
	DEVLINK_PARAM_GENERIC_ID_MAX = 13,
};

struct devlink_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

struct devlink_port_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter;

struct devlink_fmsg;

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
};

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_port *devlink_port;
	struct devlink_fmsg *dump_fmsg;
	struct mutex dump_lock;
	u64 graceful_period;
	bool auto_recover;
	bool auto_dump;
	u8 health_state;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
	refcount_t refcount;
};

struct devlink_fmsg {
	struct list_head item_list;
	bool putting_binary;
};

struct devlink_trap_metadata {
	const char *trap_name;
	const char *trap_group_name;
	struct net_device *input_dev;
	const struct flow_action_cookie *fa_cookie;
	enum devlink_trap_type trap_type;
};

struct devlink_info_req {
	struct sk_buff *msg;
};

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	long unsigned int type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_raw_devlink_trap_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_trap_name;
	u32 __data_loc_trap_group_name;
	u32 __data_loc_input_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_trap_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 trap_name;
	u32 trap_group_name;
	u32 input_dev_name;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct devlink_region {
	struct devlink *devlink;
	struct devlink_port *port;
	struct list_head list;
	union {
		const struct devlink_region_ops *ops;
		const struct devlink_port_region_ops *port_ops;
	};
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	u64 size;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region *region;
	u8 *data;
	u32 id;
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_reload_combination {
	enum devlink_reload_action action;
	enum devlink_reload_limit limit;
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct devlink_stats {
	u64 rx_bytes;
	u64 rx_packets;
	struct u64_stats_sync syncp;
};

struct devlink_trap_policer_item {
	const struct devlink_trap_policer *policer;
	u64 rate;
	u64 burst;
	struct list_head list;
};

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	struct devlink_trap_policer_item *policer_item;
	struct list_head list;
	struct devlink_stats *stats;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats *stats;
	void *priv;
};

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
	SK_PSOCK_RX_STRP_ENABLED = 1,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	raw_spinlock_t lock;
	long: 64;
	long: 64;
};

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	raw_spinlock_t lock;
};

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
	long: 64;
};

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct nvmem_cell_mac_address_property {
	char *name;
	void * (*read)(struct nvmem_cell *);
};

struct llc_addr {
	unsigned char lsap;
	unsigned char mac[6];
};

struct llc_sap {
	unsigned char state;
	unsigned char p_bit;
	unsigned char f_bit;
	refcount_t refcnt;
	int (*rcv_func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	struct llc_addr laddr;
	struct list_head node;
	spinlock_t sk_lock;
	int sk_count;
	struct hlist_nulls_head sk_laddr_hash[64];
	struct hlist_head sk_dev_hash[64];
	struct callback_head rcu;
};

struct llc_pdu_sn {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
	u8 ctrl_2;
};

struct llc_pdu_un {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
};

struct datalink_proto {
	unsigned char type[8];
	struct llc_sap *sap;
	short unsigned int header_length;
	int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	int (*request)(struct datalink_proto *, struct sk_buff *, unsigned char *);
	struct list_head node;
};

struct stp_proto {
	unsigned char group_address[6];
	void (*rcv)(const struct stp_proto *, struct sk_buff *, struct net_device *);
	void *data;
};

struct garp_applicant;

struct garp_port {
	struct garp_applicant *applicants[1];
	struct callback_head rcu;
};

struct garp_pdu_hdr {
	__be16 protocol;
};

struct garp_msg_hdr {
	u8 attrtype;
};

enum garp_attr_event {
	GARP_LEAVE_ALL = 0,
	GARP_JOIN_EMPTY = 1,
	GARP_JOIN_IN = 2,
	GARP_LEAVE_EMPTY = 3,
	GARP_LEAVE_IN = 4,
	GARP_EMPTY = 5,
};

struct garp_attr_hdr {
	u8 len;
	u8 event;
	u8 data[0];
};

struct garp_skb_cb {
	u8 cur_type;
};

enum garp_applicant_state {
	GARP_APPLICANT_INVALID = 0,
	GARP_APPLICANT_VA = 1,
	GARP_APPLICANT_AA = 2,
	GARP_APPLICANT_QA = 3,
	GARP_APPLICANT_LA = 4,
	GARP_APPLICANT_VP = 5,
	GARP_APPLICANT_AP = 6,
	GARP_APPLICANT_QP = 7,
	GARP_APPLICANT_VO = 8,
	GARP_APPLICANT_AO = 9,
	GARP_APPLICANT_QO = 10,
	__GARP_APPLICANT_MAX = 11,
};

enum garp_event {
	GARP_EVENT_REQ_JOIN = 0,
	GARP_EVENT_REQ_LEAVE = 1,
	GARP_EVENT_R_JOIN_IN = 2,
	GARP_EVENT_R_JOIN_EMPTY = 3,
	GARP_EVENT_R_EMPTY = 4,
	GARP_EVENT_R_LEAVE_IN = 5,
	GARP_EVENT_R_LEAVE_EMPTY = 6,
	GARP_EVENT_TRANSMIT_PDU = 7,
	__GARP_EVENT_MAX = 8,
};

enum garp_action {
	GARP_ACTION_NONE = 0,
	GARP_ACTION_S_JOIN_IN = 1,
	GARP_ACTION_S_LEAVE_EMPTY = 2,
};

struct garp_attr {
	struct rb_node node;
	enum garp_applicant_state state;
	u8 type;
	u8 dlen;
	unsigned char data[0];
};

enum garp_applications {
	GARP_APPLICATION_GVRP = 0,
	__GARP_APPLICATION_MAX = 1,
};

struct garp_application {
	enum garp_applications type;
	unsigned int maxattr;
	struct stp_proto proto;
};

struct garp_applicant {
	struct garp_application *app;
	struct net_device *dev;
	struct timer_list join_timer;
	spinlock_t lock;
	struct sk_buff_head queue;
	struct sk_buff *pdu;
	struct rb_root gid;
	struct callback_head rcu;
};

struct garp_state_trans {
	u8 state;
	u8 action;
};

struct mrp_applicant;

struct mrp_port {
	struct mrp_applicant *applicants[1];
	struct callback_head rcu;
};

struct mrp_pdu_hdr {
	u8 version;
};

struct mrp_msg_hdr {
	u8 attrtype;
	u8 attrlen;
};

struct mrp_vecattr_hdr {
	__be16 lenflags;
	unsigned char firstattrvalue[0];
};

enum mrp_vecattr_event {
	MRP_VECATTR_EVENT_NEW = 0,
	MRP_VECATTR_EVENT_JOIN_IN = 1,
	MRP_VECATTR_EVENT_IN = 2,
	MRP_VECATTR_EVENT_JOIN_MT = 3,
	MRP_VECATTR_EVENT_MT = 4,
	MRP_VECATTR_EVENT_LV = 5,
	__MRP_VECATTR_EVENT_MAX = 6,
};

struct mrp_skb_cb {
	struct mrp_msg_hdr *mh;
	struct mrp_vecattr_hdr *vah;
	unsigned char attrvalue[0];
};

enum mrp_applicant_state {
	MRP_APPLICANT_INVALID = 0,
	MRP_APPLICANT_VO = 1,
	MRP_APPLICANT_VP = 2,
	MRP_APPLICANT_VN = 3,
	MRP_APPLICANT_AN = 4,
	MRP_APPLICANT_AA = 5,
	MRP_APPLICANT_QA = 6,
	MRP_APPLICANT_LA = 7,
	MRP_APPLICANT_AO = 8,
	MRP_APPLICANT_QO = 9,
	MRP_APPLICANT_AP = 10,
	MRP_APPLICANT_QP = 11,
	__MRP_APPLICANT_MAX = 12,
};

enum mrp_event {
	MRP_EVENT_NEW = 0,
	MRP_EVENT_JOIN = 1,
	MRP_EVENT_LV = 2,
	MRP_EVENT_TX = 3,
	MRP_EVENT_R_NEW = 4,
	MRP_EVENT_R_JOIN_IN = 5,
	MRP_EVENT_R_IN = 6,
	MRP_EVENT_R_JOIN_MT = 7,
	MRP_EVENT_R_MT = 8,
	MRP_EVENT_R_LV = 9,
	MRP_EVENT_R_LA = 10,
	MRP_EVENT_REDECLARE = 11,
	MRP_EVENT_PERIODIC = 12,
	__MRP_EVENT_MAX = 13,
};

enum mrp_tx_action {
	MRP_TX_ACTION_NONE = 0,
	MRP_TX_ACTION_S_NEW = 1,
	MRP_TX_ACTION_S_JOIN_IN = 2,
	MRP_TX_ACTION_S_JOIN_IN_OPTIONAL = 3,
	MRP_TX_ACTION_S_IN_OPTIONAL = 4,
	MRP_TX_ACTION_S_LV = 5,
};

struct mrp_attr {
	struct rb_node node;
	enum mrp_applicant_state state;
	u8 type;
	u8 len;
	unsigned char value[0];
};

enum mrp_applications {
	MRP_APPLICATION_MVRP = 0,
	__MRP_APPLICATION_MAX = 1,
};

struct mrp_application {
	enum mrp_applications type;
	unsigned int maxattr;
	struct packet_type pkttype;
	unsigned char group_address[6];
	u8 version;
};

struct mrp_applicant {
	struct mrp_application *app;
	struct net_device *dev;
	struct timer_list join_timer;
	struct timer_list periodic_timer;
	spinlock_t lock;
	struct sk_buff_head queue;
	struct sk_buff *pdu;
	struct rb_root mad;
	struct callback_head rcu;
	bool active;
};

enum macvlan_mode {
	MACVLAN_MODE_PRIVATE = 1,
	MACVLAN_MODE_VEPA = 2,
	MACVLAN_MODE_BRIDGE = 4,
	MACVLAN_MODE_PASSTHRU = 8,
	MACVLAN_MODE_SOURCE = 16,
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

struct vlan_pcpu_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_multicast;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
};

struct skb_array {
	struct ptr_ring ring;
};

struct macvlan_port;

struct macvlan_dev {
	struct net_device *dev;
	struct list_head list;
	struct hlist_node hlist;
	struct macvlan_port *port;
	struct net_device *lowerdev;
	void *accel_priv;
	struct vlan_pcpu_stats *pcpu_stats;
	long unsigned int mc_filter[4];
	netdev_features_t set_features;
	enum macvlan_mode mode;
	u16 flags;
	unsigned int macaddr_count;
	u32 bc_queue_len_req;
};

struct psched_pktrate {
	u64 rate_pkts_ps;
	u32 mult;
	u8 shift;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
	__u8 inner_ipproto;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct sch_frag_data {
	long unsigned int dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct Qdisc_class_common {
	u32 classid;
	struct hlist_node hnode;
};

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct qdisc_watchdog {
	u64 last_expires;
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	__TCA_ACT_MAX = 10,
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_packed tcfa_bstats;
	struct gnet_stats_basic_packed tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_basic_cpu *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
};

typedef void (*tc_action_priv_destructor)(void *);

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto *filter_chain;
};

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	int action;
	int police;
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit_parms {
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
	u32 tcfp_off_max_hint;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct callback_head rcu;
};

struct tcf_pedit {
	struct tc_action common;
	struct tcf_pedit_parms *parms;
};

struct tcf_mirred {
	struct tc_action common;
	int tcfm_eaction;
	bool tcfm_mac_header_xmit;
	struct net_device *tcfm_dev;
	struct list_head tcfm_list;
};

struct tcf_vlan_params {
	int tcfv_action;
	unsigned char tcfv_push_dst[6];
	unsigned char tcfv_push_src[6];
	u16 tcfv_push_vid;
	__be16 tcfv_push_proto;
	u8 tcfv_push_prio;
	bool tcfv_push_prio_exists;
	struct callback_head rcu;
};

struct tcf_vlan {
	struct tc_action common;
	struct tcf_vlan_params *vlan_p;
};

struct tcf_tunnel_key_params {
	struct callback_head rcu;
	int tcft_action;
	struct metadata_dst *tcft_enc_metadata;
};

struct tcf_tunnel_key {
	struct tc_action common;
	struct tcf_tunnel_key_params *params;
};

struct tcf_csum_params {
	u32 update_flags;
	struct callback_head rcu;
};

struct tcf_csum {
	struct tc_action common;
	struct tcf_csum_params *params;
};

struct tcf_gact {
	struct tc_action common;
	u16 tcfg_ptype;
	u16 tcfg_pval;
	int tcfg_paction;
	atomic_t packets;
};

struct tcf_police_params {
	int tcfp_result;
	u32 tcfp_ewma_rate;
	s64 tcfp_burst;
	u32 tcfp_mtu;
	s64 tcfp_mtu_ptoks;
	s64 tcfp_pkt_burst;
	struct psched_ratecfg rate;
	bool rate_present;
	struct psched_ratecfg peak;
	bool peak_present;
	struct psched_pktrate ppsrate;
	bool pps_present;
	struct callback_head rcu;
};

struct tcf_police {
	struct tc_action common;
	struct tcf_police_params *params;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t tcfp_lock;
	s64 tcfp_toks;
	s64 tcfp_ptoks;
	s64 tcfp_pkttoks;
	s64 tcfp_t_c;
	long: 64;
	long: 64;
	long: 64;
};

struct tcf_sample {
	struct tc_action common;
	u32 rate;
	bool truncate;
	u32 trunc_size;
	struct psample_group *psample_group;
	u32 psample_group_num;
	struct list_head tcfm_list;
};

struct tcf_skbedit_params {
	u32 flags;
	u32 priority;
	u32 mark;
	u32 mask;
	u16 queue_mapping;
	u16 ptype;
	struct callback_head rcu;
};

struct tcf_skbedit {
	struct tc_action common;
	struct tcf_skbedit_params *params;
};

struct nf_nat_range2 {
	unsigned int flags;
	union nf_inet_addr min_addr;
	union nf_inet_addr max_addr;
	union nf_conntrack_man_proto min_proto;
	union nf_conntrack_man_proto max_proto;
	union nf_conntrack_man_proto base_proto;
};

struct tcf_ct_flow_table;

struct tcf_ct_params {
	struct nf_conn *tmpl;
	u16 zone;
	u32 mark;
	u32 mark_mask;
	u32 labels[4];
	u32 labels_mask[4];
	struct nf_nat_range2 range;
	bool ipv4_range;
	u16 ct_action;
	struct callback_head rcu;
	struct tcf_ct_flow_table *ct_ft;
	struct nf_flowtable *nf_ft;
};

struct tcf_ct {
	struct tc_action common;
	struct tcf_ct_params *params;
};

struct tcf_mpls_params {
	int tcfm_action;
	u32 tcfm_label;
	u8 tcfm_tc;
	u8 tcfm_ttl;
	u8 tcfm_bos;
	__be16 tcfm_proto;
	struct callback_head rcu;
};

struct tcf_mpls {
	struct tc_action common;
	struct tcf_mpls_params *mpls_p;
};

struct tcfg_gate_entry {
	int index;
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
	struct list_head list;
};

struct tcf_gate_params {
	s32 tcfg_priority;
	u64 tcfg_basetime;
	u64 tcfg_cycletime;
	u64 tcfg_cycletime_ext;
	u32 tcfg_flags;
	s32 tcfg_clockid;
	size_t num_entries;
	struct list_head entries;
};

struct tcf_gate {
	struct tc_action common;
	struct tcf_gate_params param;
	u8 current_gate_status;
	ktime_t current_close_time;
	u32 current_entry_octets;
	s32 current_max_octets;
	struct tcfg_gate_entry *next_entry;
	struct hrtimer hitimer;
	enum tk_offsets tk_offset;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	__TCA_ROOT_MAX = 5,
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

struct tc_fifo_qopt {
	__u32 limit;
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

enum {
	TCA_FQ_CODEL_UNSPEC = 0,
	TCA_FQ_CODEL_TARGET = 1,
	TCA_FQ_CODEL_LIMIT = 2,
	TCA_FQ_CODEL_INTERVAL = 3,
	TCA_FQ_CODEL_ECN = 4,
	TCA_FQ_CODEL_FLOWS = 5,
	TCA_FQ_CODEL_QUANTUM = 6,
	TCA_FQ_CODEL_CE_THRESHOLD = 7,
	TCA_FQ_CODEL_DROP_BATCH_SIZE = 8,
	TCA_FQ_CODEL_MEMORY_LIMIT = 9,
	__TCA_FQ_CODEL_MAX = 10,
};

enum {
	TCA_FQ_CODEL_XSTATS_QDISC = 0,
	TCA_FQ_CODEL_XSTATS_CLASS = 1,
};

struct tc_fq_codel_qd_stats {
	__u32 maxpacket;
	__u32 drop_overlimit;
	__u32 ecn_mark;
	__u32 new_flow_count;
	__u32 new_flows_len;
	__u32 old_flows_len;
	__u32 ce_mark;
	__u32 memory_usage;
	__u32 drop_overmemory;
};

struct tc_fq_codel_cl_stats {
	__s32 deficit;
	__u32 ldelay;
	__u32 count;
	__u32 lastcount;
	__u32 dropping;
	__s32 drop_next;
};

struct tc_fq_codel_xstats {
	__u32 type;
	union {
		struct tc_fq_codel_qd_stats qdisc_stats;
		struct tc_fq_codel_cl_stats class_stats;
	};
};

typedef u32 codel_time_t;

typedef s32 codel_tdiff_t;

struct codel_params {
	codel_time_t target;
	codel_time_t ce_threshold;
	codel_time_t interval;
	u32 mtu;
	bool ecn;
};

struct codel_vars {
	u32 count;
	u32 lastcount;
	bool dropping;
	u16 rec_inv_sqrt;
	codel_time_t first_above_time;
	codel_time_t drop_next;
	codel_time_t ldelay;
};

struct codel_stats {
	u32 maxpacket;
	u32 drop_count;
	u32 drop_len;
	u32 ecn_mark;
	u32 ce_mark;
};

typedef u32 (*codel_skb_len_t)(const struct sk_buff *);

typedef codel_time_t (*codel_skb_time_t)(const struct sk_buff *);

typedef void (*codel_skb_drop_t)(struct sk_buff *, void *);

typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *, void *);

struct codel_skb_cb {
	codel_time_t enqueue_time;
	unsigned int mem_usage;
};

struct fq_codel_flow {
	struct sk_buff *head;
	struct sk_buff *tail;
	struct list_head flowchain;
	int deficit;
	struct codel_vars cvars;
};

struct fq_codel_sched_data {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct fq_codel_flow *flows;
	u32 *backlogs;
	u32 flows_cnt;
	u32 quantum;
	u32 drop_batch_size;
	u32 memory_limit;
	struct codel_params cparams;
	struct codel_stats cstats;
	u32 memory_usage;
	u32 drop_overmemory;
	u32 drop_overlimit;
	u32 new_flow_count;
	struct list_head new_flows;
	struct list_head old_flows;
};

struct tcf_ematch_tree_hdr {
	__u16 nmatches;
	__u16 progid;
};

enum {
	TCA_EMATCH_TREE_UNSPEC = 0,
	TCA_EMATCH_TREE_HDR = 1,
	TCA_EMATCH_TREE_LIST = 2,
	__TCA_EMATCH_TREE_MAX = 3,
};

struct tcf_ematch_hdr {
	__u16 matchid;
	__u16 kind;
	__u16 flags;
	__u16 pad;
};

struct tcf_pkt_info {
	unsigned char *ptr;
	int nexthdr;
};

struct tcf_ematch_ops;

struct tcf_ematch {
	struct tcf_ematch_ops *ops;
	long unsigned int data;
	unsigned int datalen;
	u16 matchid;
	u16 flags;
	struct net *net;
};

struct tcf_ematch_ops {
	int kind;
	int datalen;
	int (*change)(struct net *, void *, int, struct tcf_ematch *);
	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
	void (*destroy)(struct tcf_ematch *);
	int (*dump)(struct sk_buff *, struct tcf_ematch *);
	struct module *owner;
	struct list_head link;
};

struct tcf_ematch_tree {
	struct tcf_ematch_tree_hdr hdr;
	struct tcf_ematch *matches;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	__NLMSGERR_ATTR_MAX = 5,
	NLMSGERR_ATTR_MAX = 4,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct trace_event_raw_netlink_extack {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_netlink_extack {
	u32 msg;
};

typedef void (*btf_trace_netlink_extack)(void *, const char *);

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_ops *ops;
	int hdrlen;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	unsigned int opidx;
	u32 op;
	u16 fam_id;
	u8 policies: 1;
	u8 single_op: 1;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_test_timer {
	enum {
		NO_PREEMPT = 0,
		NO_MIGRATE = 1,
	} mode;
	u32 i;
	u64 time_start;
	u64 time_spent;
};

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	long: 0;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

struct link_mode_info {
	int speed;
	u8 lanes;
	u8 duplex;
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	ETHTOOL_MSG_FEC_GET = 29,
	ETHTOOL_MSG_FEC_SET = 30,
	ETHTOOL_MSG_MODULE_EEPROM_GET = 31,
	ETHTOOL_MSG_STATS_GET = 32,
	ETHTOOL_MSG_PHC_VCLOCKS_GET = 33,
	__ETHTOOL_MSG_USER_CNT = 34,
	ETHTOOL_MSG_USER_MAX = 33,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	ETHTOOL_A_LINKMODES_LANES = 9,
	__ETHTOOL_A_LINKMODES_CNT = 10,
	ETHTOOL_A_LINKMODES_MAX = 9,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	__ETHTOOL_A_LINKSTATE_CNT = 7,
	ETHTOOL_A_LINKSTATE_MAX = 6,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	__ETHTOOL_A_RINGS_CNT = 10,
	ETHTOOL_A_RINGS_MAX = 9,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_TX = 24,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_RX = 25,
	__ETHTOOL_A_COALESCE_CNT = 26,
	ETHTOOL_A_COALESCE_MAX = 25,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	__ETHTOOL_A_PAUSE_CNT = 6,
	ETHTOOL_A_PAUSE_MAX = 5,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

enum {
	ETHTOOL_A_PHC_VCLOCKS_UNSPEC = 0,
	ETHTOOL_A_PHC_VCLOCKS_HEADER = 1,
	ETHTOOL_A_PHC_VCLOCKS_NUM = 2,
	ETHTOOL_A_PHC_VCLOCKS_INDEX = 3,
	__ETHTOOL_A_PHC_VCLOCKS_CNT = 4,
	ETHTOOL_A_PHC_VCLOCKS_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum {
	ETHTOOL_A_FEC_UNSPEC = 0,
	ETHTOOL_A_FEC_HEADER = 1,
	ETHTOOL_A_FEC_MODES = 2,
	ETHTOOL_A_FEC_AUTO = 3,
	ETHTOOL_A_FEC_ACTIVE = 4,
	ETHTOOL_A_FEC_STATS = 5,
	__ETHTOOL_A_FEC_CNT = 6,
	ETHTOOL_A_FEC_MAX = 5,
};

enum {
	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
};

enum {
	ETHTOOL_A_STATS_UNSPEC = 0,
	ETHTOOL_A_STATS_PAD = 1,
	ETHTOOL_A_STATS_HEADER = 2,
	ETHTOOL_A_STATS_GROUPS = 3,
	ETHTOOL_A_STATS_GRP = 4,
	__ETHTOOL_A_STATS_CNT = 5,
	ETHTOOL_A_STATS_MAX = 4,
};

enum {
	ETHTOOL_STATS_ETH_PHY = 0,
	ETHTOOL_STATS_ETH_MAC = 1,
	ETHTOOL_STATS_ETH_CTRL = 2,
	ETHTOOL_STATS_RMON = 3,
	__ETHTOOL_STATS_CNT = 4,
};

enum {
	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
};

enum {
	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
};

enum {
	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
};

enum {
	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
	ETHTOOL_A_STATS_RMON_FRAG = 2,
	ETHTOOL_A_STATS_RMON_JABBER = 3,
	__ETHTOOL_A_STATS_RMON_CNT = 4,
	ETHTOOL_A_STATS_RMON_MAX = 3,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_req_info {
	struct net_device *dev;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	int pos_hash;
	int pos_idx;
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

typedef const char (* const ethnl_string_array_t)[32];

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[21];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	struct kernel_ethtool_coalesce kernel_coalesce;
	u32 supported_params;
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	int pos_hash;
	int pos_idx;
};

enum {
	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
	ETHTOOL_A_FEC_STAT_PAD = 1,
	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
	ETHTOOL_A_FEC_STAT_UNCORR = 3,
	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
	__ETHTOOL_A_FEC_STAT_CNT = 5,
	ETHTOOL_A_FEC_STAT_MAX = 4,
};

struct fec_stat_grp {
	u64 stats[9];
	u8 cnt;
};

struct fec_reply_data {
	struct ethnl_reply_data base;
	long unsigned int fec_link_modes[2];
	u32 active_fec;
	u8 fec_auto;
	struct fec_stat_grp corr;
	struct fec_stat_grp uncorr;
	struct fec_stat_grp corr_bits;
};

struct eeprom_req_info {
	struct ethnl_req_info base;
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
};

struct eeprom_reply_data {
	struct ethnl_reply_data base;
	u32 length;
	u8 *data;
};

enum {
	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
	ETHTOOL_A_STATS_GRP_PAD = 1,
	ETHTOOL_A_STATS_GRP_ID = 2,
	ETHTOOL_A_STATS_GRP_SS_ID = 3,
	ETHTOOL_A_STATS_GRP_STAT = 4,
	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
	__ETHTOOL_A_STATS_GRP_CNT = 10,
	ETHTOOL_A_STATS_GRP_MAX = 9,
};

struct stats_req_info {
	struct ethnl_req_info base;
	long unsigned int stat_mask[1];
};

struct stats_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eth_phy_stats phy_stats;
	struct ethtool_eth_mac_stats mac_stats;
	struct ethtool_eth_ctrl_stats ctrl_stats;
	struct ethtool_rmon_stats rmon_stats;
	const struct ethtool_rmon_hist_range *rmon_ranges;
};

struct phc_vclocks_reply_data {
	struct ethnl_reply_data base;
	int num;
	int *index;
};

enum nf_hook_ops_type {
	NF_HOOK_OP_UNDEFINED = 0,
	NF_HOOK_OP_NF_TABLES = 1,
};

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u8 pf;
	enum nf_hook_ops_type hook_ops_type: 8;
	unsigned int hooknum;
	int priority;
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

enum nf_nat_manip_type;

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	unsigned int (*manip_pkt)(struct sk_buff *, struct nf_conn *, enum nf_nat_manip_type, enum ip_conntrack_dir);
};

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
};

struct nfnl_ct_hook {
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nf_queue_entry;

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct nf_hook_state state;
	u16 size;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	struct module *owner;
};

enum nfnetlink_groups {
	NFNLGRP_NONE = 0,
	NFNLGRP_CONNTRACK_NEW = 1,
	NFNLGRP_CONNTRACK_UPDATE = 2,
	NFNLGRP_CONNTRACK_DESTROY = 3,
	NFNLGRP_CONNTRACK_EXP_NEW = 4,
	NFNLGRP_CONNTRACK_EXP_UPDATE = 5,
	NFNLGRP_CONNTRACK_EXP_DESTROY = 6,
	NFNLGRP_NFTABLES = 7,
	NFNLGRP_ACCT_QUOTA = 8,
	NFNLGRP_NFTRACE = 9,
	__NFNLGRP_MAX = 10,
};

struct nfgenmsg {
	__u8 nfgen_family;
	__u8 version;
	__be16 res_id;
};

enum nfnl_batch_attributes {
	NFNL_BATCH_UNSPEC = 0,
	NFNL_BATCH_GENID = 1,
	__NFNL_BATCH_MAX = 2,
};

struct nfnl_info {
	struct net *net;
	struct sock *sk;
	const struct nlmsghdr *nlh;
	const struct nfgenmsg *nfmsg;
	struct netlink_ext_ack *extack;
};

enum nfnl_callback_type {
	NFNL_CB_UNSPEC = 0,
	NFNL_CB_MUTEX = 1,
	NFNL_CB_RCU = 2,
	NFNL_CB_BATCH = 3,
};

struct nfnl_callback {
	int (*call)(struct sk_buff *, const struct nfnl_info *, const struct nlattr * const *);
	const struct nla_policy *policy;
	enum nfnl_callback_type type;
	__u16 attr_count;
};

enum nfnl_abort_action {
	NFNL_ABORT_NONE = 0,
	NFNL_ABORT_AUTOLOAD = 1,
	NFNL_ABORT_VALIDATE = 2,
};

struct nfnetlink_subsystem {
	const char *name;
	__u8 subsys_id;
	__u8 cb_count;
	const struct nfnl_callback *cb;
	struct module *owner;
	int (*commit)(struct net *, struct sk_buff *);
	int (*abort)(struct net *, struct sk_buff *, enum nfnl_abort_action);
	bool (*valid_genid)(struct net *, u32);
};

struct nfnl_net {
	struct sock *nfnl;
};

struct nfnl_err {
	struct list_head head;
	struct nlmsghdr *nlh;
	int err;
	struct netlink_ext_ack extack;
};

enum {
	NFNL_BATCH_FAILURE = 1,
	NFNL_BATCH_DONE = 2,
	NFNL_BATCH_REPLAY = 4,
};

enum nfnl_acct_msg_types {
	NFNL_MSG_ACCT_NEW = 0,
	NFNL_MSG_ACCT_GET = 1,
	NFNL_MSG_ACCT_GET_CTRZERO = 2,
	NFNL_MSG_ACCT_DEL = 3,
	NFNL_MSG_ACCT_OVERQUOTA = 4,
	NFNL_MSG_ACCT_MAX = 5,
};

enum nfnl_acct_flags {
	NFACCT_F_QUOTA_PKTS = 1,
	NFACCT_F_QUOTA_BYTES = 2,
	NFACCT_F_OVERQUOTA = 4,
};

enum nfnl_acct_type {
	NFACCT_UNSPEC = 0,
	NFACCT_NAME = 1,
	NFACCT_PKTS = 2,
	NFACCT_BYTES = 3,
	NFACCT_USE = 4,
	NFACCT_FLAGS = 5,
	NFACCT_QUOTA = 6,
	NFACCT_FILTER = 7,
	NFACCT_PAD = 8,
	__NFACCT_MAX = 9,
};

enum nfnl_attr_filter_type {
	NFACCT_FILTER_UNSPEC = 0,
	NFACCT_FILTER_MASK = 1,
	NFACCT_FILTER_VALUE = 2,
	__NFACCT_FILTER_MAX = 3,
};

enum {
	NFACCT_NO_QUOTA = 4294967295,
	NFACCT_UNDERQUOTA = 0,
	NFACCT_OVERQUOTA = 1,
};

struct nf_acct {
	atomic64_t pkts;
	atomic64_t bytes;
	long unsigned int flags;
	struct list_head head;
	refcount_t refcnt;
	char name[32];
	struct callback_head callback_head;
	char data[0];
};

struct nfacct_filter {
	u32 value;
	u32 mask;
};

struct nfnl_acct_net {
	struct list_head nfnl_acct_list;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	u8 tos;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct ip_rt_acct {
	__u32 o_bytes;
	__u32 o_packets;
	__u32 i_bytes;
	__u32 i_packets;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	u8 fa_tos;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct raw_hashinfo {
	rwlock_t lock;
	struct hlist_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_state_offload {
	struct net_device *dev;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	unsigned int num_exthdrs;
	u8 flags;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

enum xfrm_replay_mode {
	XFRM_REPLAY_MODE_LEGACY = 0,
	XFRM_REPLAY_MODE_BMP = 1,
	XFRM_REPLAY_MODE_ESN = 2,
};

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	struct hlist_node byseq;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	__be16 new_mapping_sport;
	u32 new_mapping;
	u32 mapping_maxage;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	enum xfrm_replay_mode repl_mode;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_state_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
};

struct xfrm_type {
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
};

struct xfrm_type_offload {
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct sec_path {
	int len;
	int olen;
	int verified_cnt;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 protocol;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	union {
		struct {
			__be32 imsf_multiaddr_aux;
			__be32 imsf_interface_aux;
			__u32 imsf_fmode_aux;
			__u32 imsf_numsrc_aux;
			__be32 imsf_slist[1];
		};
		struct {
			__be32 imsf_multiaddr;
			__be32 imsf_interface;
			__u32 imsf_fmode;
			__u32 imsf_numsrc;
			__be32 imsf_slist_flex[0];
		};
	};
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		};
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		};
	};
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		} __attribute__((packed));
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		} __attribute__((packed));
	};
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
	TCP_NLA_TTL = 26,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
	__u64 msg_control;
	__u64 msg_controllen;
	__u32 msg_flags;
	__u32 reserved;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

enum {
	TCP_CMSG_INQ = 1,
	TCP_CMSG_TS = 2,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

struct mptcp_out_options {};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	u8 flags;
	union tcp_md5_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_tcp_iter_state {
	struct tcp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	struct net *tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	long: 0;
	int bucket;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_NAT_CLASH_BIT = 12,
	IPS_NAT_CLASH = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_HW_OFFLOAD_BIT = 15,
	IPS_HW_OFFLOAD = 32768,
	IPS_UNCHANGEABLE_MASK = 56313,
	__IPS_MAX_BIT = 16,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_ext_echo_ctype3_hdr {
	__be16 afi;
	__u8 addrlen;
	__u8 reserved;
};

struct icmp_ext_echo_iio {
	struct icmp_extobj_hdr extobj_hdr;
	union {
		char name[16];
		__be32 ifindex;
		struct {
			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
			union {
				__be32 ipv4_addr;
				struct in6_addr ipv6_addr;
			} ip_addr;
		} addr;
	} ident;
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	bool (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	__IFA_MAX = 11,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct fib_config {
	u8 fc_dst_len;
	u8 fc_tos;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	u8 tos;
	u8 type;
	u32 tb_id;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct key_vector *tnode[0];
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	rwlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct vxlan_metadata {
	u32 gbp;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	NEXTHOP_GRP_TYPE_RES = 1,
	__NEXTHOP_GRP_TYPE_MAX = 2,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	NHA_RES_GROUP = 12,
	NHA_RES_BUCKET = 13,
	__NHA_MAX = 14,
};

enum {
	NHA_RES_GROUP_UNSPEC = 0,
	NHA_RES_GROUP_PAD = 0,
	NHA_RES_GROUP_BUCKETS = 1,
	NHA_RES_GROUP_IDLE_TIMER = 2,
	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
	NHA_RES_GROUP_UNBALANCED_TIME = 4,
	__NHA_RES_GROUP_MAX = 5,
};

enum {
	NHA_RES_BUCKET_UNSPEC = 0,
	NHA_RES_BUCKET_PAD = 0,
	NHA_RES_BUCKET_INDEX = 1,
	NHA_RES_BUCKET_IDLE_TIME = 2,
	NHA_RES_BUCKET_NH_ID = 3,
	__NHA_RES_BUCKET_MAX = 4,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	u16 nh_grp_res_num_buckets;
	long unsigned int nh_grp_res_idle_timer;
	long unsigned int nh_grp_res_unbalanced_timer;
	bool nh_grp_res_has_num_buckets;
	bool nh_grp_res_has_idle_timer;
	bool nh_grp_res_has_unbalanced_timer;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
};

enum nh_notifier_info_type {
	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
	NH_NOTIFIER_INFO_TYPE_GRP = 1,
	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u8 weight;
	u32 id;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_res_bucket_info {
	u16 bucket_index;
	unsigned int idle_timer_ms;
	bool force;
	struct nh_notifier_single_info old_nh;
	struct nh_notifier_single_info new_nh;
};

struct nh_notifier_res_table_info {
	u16 num_nh_buckets;
	struct nh_notifier_single_info nhs[0];
};

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	enum nh_notifier_info_type type;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
		struct nh_notifier_res_table_info *nh_res_table;
		struct nh_notifier_res_bucket_info *nh_res_bucket;
	};
};

struct nh_dump_filter {
	u32 nh_id;
	int dev_idx;
	int master_idx;
	bool group_filter;
	bool fdb_filter;
	u32 res_bucket_nh_id;
};

struct rtm_dump_nh_ctx {
	u32 idx;
};

struct rtm_dump_res_bucket_ctx {
	struct rtm_dump_nh_ctx nh;
	u16 bucket_index;
	u32 done_nh_idx;
};

struct rtm_dump_nexthop_bucket_data {
	struct rtm_dump_res_bucket_ctx *ctx;
	struct nh_dump_filter filter;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct fib4_rule {
	struct fib_rule common;
	u8 dst_len;
	u8 src_len;
	u8 tos;
	__be32 src;
	__be32 srcmask;
	__be32 dst;
	__be32 dstmask;
	u32 tclassid;
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

struct pimreghdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
	__be32 flags;
};

typedef short unsigned int vifi_t;

struct vifctl {
	vifi_t vifc_vifi;
	unsigned char vifc_flags;
	unsigned char vifc_threshold;
	unsigned int vifc_rate_limit;
	union {
		struct in_addr vifc_lcl_addr;
		int vifc_lcl_ifindex;
	};
	struct in_addr vifc_rmt_addr;
};

struct mfcctl {
	struct in_addr mfcc_origin;
	struct in_addr mfcc_mcastgrp;
	vifi_t mfcc_parent;
	unsigned char mfcc_ttls[32];
	unsigned int mfcc_pkt_cnt;
	unsigned int mfcc_byte_cnt;
	unsigned int mfcc_wrong_if;
	int mfcc_expire;
};

struct sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_vif_req {
	vifi_t vifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct igmpmsg {
	__u32 unused1;
	__u32 unused2;
	unsigned char im_msgtype;
	unsigned char im_mbz;
	unsigned char im_vif;
	unsigned char im_vif_hi;
	struct in_addr im_src;
	struct in_addr im_dst;
};

enum {
	IPMRA_TABLE_UNSPEC = 0,
	IPMRA_TABLE_ID = 1,
	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
	IPMRA_TABLE_MROUTE_DO_PIM = 5,
	IPMRA_TABLE_VIFS = 6,
	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
	__IPMRA_TABLE_MAX = 8,
};

enum {
	IPMRA_VIF_UNSPEC = 0,
	IPMRA_VIF = 1,
	__IPMRA_VIF_MAX = 2,
};

enum {
	IPMRA_VIFA_UNSPEC = 0,
	IPMRA_VIFA_IFINDEX = 1,
	IPMRA_VIFA_VIF_ID = 2,
	IPMRA_VIFA_FLAGS = 3,
	IPMRA_VIFA_BYTES_IN = 4,
	IPMRA_VIFA_BYTES_OUT = 5,
	IPMRA_VIFA_PACKETS_IN = 6,
	IPMRA_VIFA_PACKETS_OUT = 7,
	IPMRA_VIFA_LOCAL_ADDR = 8,
	IPMRA_VIFA_REMOTE_ADDR = 9,
	IPMRA_VIFA_PAD = 10,
	__IPMRA_VIFA_MAX = 11,
};

enum {
	IPMRA_CREPORT_UNSPEC = 0,
	IPMRA_CREPORT_MSGTYPE = 1,
	IPMRA_CREPORT_VIF_ID = 2,
	IPMRA_CREPORT_SRC_ADDR = 3,
	IPMRA_CREPORT_DST_ADDR = 4,
	IPMRA_CREPORT_PKT = 5,
	IPMRA_CREPORT_TABLE = 6,
	__IPMRA_CREPORT_MAX = 7,
};

struct vif_device {
	struct net_device *dev;
	long unsigned int bytes_in;
	long unsigned int bytes_out;
	long unsigned int pkt_in;
	long unsigned int pkt_out;
	long unsigned int rate_limit;
	unsigned char threshold;
	short unsigned int flags;
	int link;
	struct netdev_phys_item_id dev_parent_id;
	__be32 local;
	__be32 remote;
};

struct vif_entry_notifier_info {
	struct fib_notifier_info info;
	struct net_device *dev;
	short unsigned int vif_index;
	short unsigned int vif_flags;
	u32 tb_id;
};

enum {
	MFC_STATIC = 1,
	MFC_OFFLOAD = 2,
};

struct mr_mfc {
	struct rhlist_head mnode;
	short unsigned int mfc_parent;
	int mfc_flags;
	union {
		struct {
			long unsigned int expires;
			struct sk_buff_head unresolved;
		} unres;
		struct {
			long unsigned int last_assert;
			int minvif;
			int maxvif;
			long unsigned int bytes;
			long unsigned int pkt;
			long unsigned int wrong_if;
			long unsigned int lastuse;
			unsigned char ttls[32];
			refcount_t refcount;
		} res;
	} mfc_un;
	struct list_head list;
	struct callback_head rcu;
	void (*free)(struct callback_head *);
};

struct mfc_entry_notifier_info {
	struct fib_notifier_info info;
	struct mr_mfc *mfc;
	u32 tb_id;
};

struct mr_table_ops {
	const struct rhashtable_params *rht_params;
	void *cmparg_any;
};

struct mr_table {
	struct list_head list;
	possible_net_t net;
	struct mr_table_ops ops;
	u32 id;
	struct sock *mroute_sk;
	struct timer_list ipmr_expire_timer;
	struct list_head mfc_unres_queue;
	struct vif_device vif_table[32];
	struct rhltable mfc_hash;
	struct list_head mfc_cache_list;
	int maxvif;
	atomic_t cache_resolve_queue_len;
	bool mroute_do_assert;
	bool mroute_do_pim;
	bool mroute_do_wrvifwhole;
	int mroute_reg_vif_num;
};

struct mr_vif_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	int ct;
};

struct mr_mfc_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	struct list_head *cache;
	spinlock_t *lock;
};

struct mfc_cache_cmp_arg {
	__be32 mfc_mcastgrp;
	__be32 mfc_origin;
};

struct mfc_cache {
	struct mr_mfc _c;
	union {
		struct {
			__be32 mfc_mcastgrp;
			__be32 mfc_origin;
		};
		struct mfc_cache_cmp_arg cmparg;
	};
};

struct ipmr_result {
	struct mr_table *mrt;
};

struct rta_mfc_stats {
	__u64 mfcs_packets;
	__u64 mfcs_bytes;
	__u64 mfcs_wrong_if;
};

struct inet_diag_sockid {
	__be16 idiag_sport;
	__be16 idiag_dport;
	__be32 idiag_src[4];
	__be32 idiag_dst[4];
	__u32 idiag_if;
	__u32 idiag_cookie[2];
};

struct inet_diag_req {
	__u8 idiag_family;
	__u8 idiag_src_len;
	__u8 idiag_dst_len;
	__u8 idiag_ext;
	struct inet_diag_sockid id;
	__u32 idiag_states;
	__u32 idiag_dbs;
};

struct inet_diag_req_v2 {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 pad;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_bc_op {
	unsigned char code;
	unsigned char yes;
	short unsigned int no;
};

enum {
	INET_DIAG_BC_NOP = 0,
	INET_DIAG_BC_JMP = 1,
	INET_DIAG_BC_S_GE = 2,
	INET_DIAG_BC_S_LE = 3,
	INET_DIAG_BC_D_GE = 4,
	INET_DIAG_BC_D_LE = 5,
	INET_DIAG_BC_AUTO = 6,
	INET_DIAG_BC_S_COND = 7,
	INET_DIAG_BC_D_COND = 8,
	INET_DIAG_BC_DEV_COND = 9,
	INET_DIAG_BC_MARK_COND = 10,
	INET_DIAG_BC_S_EQ = 11,
	INET_DIAG_BC_D_EQ = 12,
	INET_DIAG_BC_CGROUP_COND = 13,
};

struct inet_diag_hostcond {
	__u8 family;
	__u8 prefix_len;
	int port;
	__be32 addr[0];
};

struct inet_diag_markcond {
	__u32 mark;
	__u32 mask;
};

struct inet_diag_msg {
	__u8 idiag_family;
	__u8 idiag_state;
	__u8 idiag_timer;
	__u8 idiag_retrans;
	struct inet_diag_sockid id;
	__u32 idiag_expires;
	__u32 idiag_rqueue;
	__u32 idiag_wqueue;
	__u32 idiag_uid;
	__u32 idiag_inode;
};

enum {
	INET_DIAG_NONE = 0,
	INET_DIAG_MEMINFO = 1,
	INET_DIAG_INFO = 2,
	INET_DIAG_VEGASINFO = 3,
	INET_DIAG_CONG = 4,
	INET_DIAG_TOS = 5,
	INET_DIAG_TCLASS = 6,
	INET_DIAG_SKMEMINFO = 7,
	INET_DIAG_SHUTDOWN = 8,
	INET_DIAG_DCTCPINFO = 9,
	INET_DIAG_PROTOCOL = 10,
	INET_DIAG_SKV6ONLY = 11,
	INET_DIAG_LOCALS = 12,
	INET_DIAG_PEERS = 13,
	INET_DIAG_PAD = 14,
	INET_DIAG_MARK = 15,
	INET_DIAG_BBRINFO = 16,
	INET_DIAG_CLASS_ID = 17,
	INET_DIAG_MD5SIG = 18,
	INET_DIAG_ULP_INFO = 19,
	INET_DIAG_SK_BPF_STORAGES = 20,
	INET_DIAG_CGROUP_ID = 21,
	INET_DIAG_SOCKOPT = 22,
	__INET_DIAG_MAX = 23,
};

struct inet_diag_meminfo {
	__u32 idiag_rmem;
	__u32 idiag_wmem;
	__u32 idiag_fmem;
	__u32 idiag_tmem;
};

struct inet_diag_sockopt {
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 unused: 5;
};

struct inet_diag_handler {
	void (*dump)(struct sk_buff *, struct netlink_callback *, const struct inet_diag_req_v2 *);
	int (*dump_one)(struct netlink_callback *, const struct inet_diag_req_v2 *);
	void (*idiag_get_info)(struct sock *, struct inet_diag_msg *, void *);
	int (*idiag_get_aux)(struct sock *, bool, struct sk_buff *);
	size_t (*idiag_get_aux_size)(struct sock *, bool);
	int (*destroy)(struct sk_buff *, const struct inet_diag_req_v2 *);
	__u16 idiag_type;
	__u16 idiag_info_size;
};

struct inet_diag_dump_data {
	struct nlattr *req_nlas[4];
	struct bpf_sk_storage_diag *bpf_stg_diag;
};

struct inet_diag_entry {
	const __be32 *saddr;
	const __be32 *daddr;
	u16 sport;
	u16 dport;
	u16 family;
	u16 userlocks;
	u32 ifindex;
	u32 mark;
	u64 cgroup_id;
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	char aad_space[13];
	u8 iv_data[16];
	long: 64;
	long: 64;
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_RX = 2,
	TCP_BPF_TXRX = 3,
	TCP_BPF_NUM_CFGS = 4,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	unsigned int hash;
	struct sockaddr_un name[0];
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	struct sk_buff *oob_skb;
	long: 64;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct bpf_iter__unix {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct unix_sock *unix_sk;
	};
	uid_t uid;
};

struct unix_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 udiag_states;
	__u32 udiag_ino;
	__u32 udiag_show;
	__u32 udiag_cookie[2];
};

struct unix_diag_msg {
	__u8 udiag_family;
	__u8 udiag_type;
	__u8 udiag_state;
	__u8 pad;
	__u32 udiag_ino;
	__u32 udiag_cookie[2];
};

enum {
	UNIX_DIAG_NAME = 0,
	UNIX_DIAG_VFS = 1,
	UNIX_DIAG_PEER = 2,
	UNIX_DIAG_ICONS = 3,
	UNIX_DIAG_RQLEN = 4,
	UNIX_DIAG_MEMINFO = 5,
	UNIX_DIAG_SHUTDOWN = 6,
	UNIX_DIAG_UID = 7,
	__UNIX_DIAG_MAX = 8,
};

struct unix_diag_vfs {
	__u32 udiag_vfs_ino;
	__u32 udiag_vfs_dev;
};

struct unix_diag_rqlen {
	__u32 udiag_rqueue;
	__u32 udiag_wqueue;
};

struct ioam6_pernet_data {
	struct mutex lock;
	struct rhashtable namespaces;
	struct rhashtable schemas;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	__u16 gso_size;
};

struct inet6_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	IFLA_INET6_RA_MTU = 9,
	__IFLA_INET6_MAX = 10,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool promiscuous_mode;
	bool ackreq;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_RA_DEFRTR_METRIC = 52,
	DEVCONF_IOAM6_ENABLED = 53,
	DEVCONF_IOAM6_ID = 54,
	DEVCONF_IOAM6_ID_WIDE = 55,
	DEVCONF_MAX = 56,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head if_list_aux;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	u32 flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u8 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	struct device dev;
	possible_net_t _net;
	char priv[0];
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		__be16 fifo_hi;
		__be32 fifo_lo;
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_MAX = 9,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	u32 __data_loc_name;
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_S = 0,
	FWS_L = 1,
	FWS_R = 2,
	FWS_C = 3,
	FWS_U = 4,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct static_key_false_deferred {
	struct static_key_false key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct in6_addr addr[0];
		__u8 data[0];
	} segments;
};

struct ioam6_hdr {
	__u8 opt_type;
	__u8 opt_len;
	char: 8;
	__u8 type;
};

struct ioam6_trace_hdr {
	__be16 namespace_id;
	char: 2;
	__u8 overflow: 1;
	__u8 nodelen: 5;
	__u8 remlen: 7;
	union {
		__be32 type_be32;
		struct {
			__u32 bit7: 1;
			__u32 bit6: 1;
			__u32 bit5: 1;
			__u32 bit4: 1;
			__u32 bit3: 1;
			__u32 bit2: 1;
			__u32 bit1: 1;
			__u32 bit0: 1;
			__u32 bit15: 1;
			__u32 bit14: 1;
			__u32 bit13: 1;
			__u32 bit12: 1;
			__u32 bit11: 1;
			__u32 bit10: 1;
			__u32 bit9: 1;
			__u32 bit8: 1;
			__u32 bit23: 1;
			__u32 bit22: 1;
			__u32 bit21: 1;
			__u32 bit20: 1;
			__u32 bit19: 1;
			__u32 bit18: 1;
			__u32 bit17: 1;
			__u32 bit16: 1;
		} type;
	};
	__u8 data[0];
};

struct ioam6_schema;

struct ioam6_namespace {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_schema *schema;
	__be16 id;
	__be32 data;
	__be64 data_wide;
};

struct ioam6_schema {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_namespace *ns;
	u32 id;
	int len;
	__be32 hdr;
	u8 data[0];
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

enum {
	IOAM6_ATTR_UNSPEC = 0,
	IOAM6_ATTR_NS_ID = 1,
	IOAM6_ATTR_NS_DATA = 2,
	IOAM6_ATTR_NS_DATA_WIDE = 3,
	IOAM6_ATTR_SC_ID = 4,
	IOAM6_ATTR_SC_DATA = 5,
	IOAM6_ATTR_SC_NONE = 6,
	IOAM6_ATTR_PAD = 7,
	__IOAM6_ATTR_MAX = 8,
};

enum {
	IOAM6_CMD_UNSPEC = 0,
	IOAM6_CMD_ADD_NAMESPACE = 1,
	IOAM6_CMD_DEL_NAMESPACE = 2,
	IOAM6_CMD_DUMP_NAMESPACES = 3,
	IOAM6_CMD_ADD_SCHEMA = 4,
	IOAM6_CMD_DEL_SCHEMA = 5,
	IOAM6_CMD_DUMP_SCHEMAS = 6,
	IOAM6_CMD_NS_SET_SCHEMA = 7,
	__IOAM6_CMD_MAX = 8,
};

typedef short unsigned int mifi_t;

typedef __u32 if_mask;

struct if_set {
	if_mask ifs_bits[8];
};

struct mif6ctl {
	mifi_t mif6c_mifi;
	unsigned char mif6c_flags;
	unsigned char vifc_threshold;
	__u16 mif6c_pifi;
	unsigned int vifc_rate_limit;
};

struct mf6cctl {
	struct sockaddr_in6 mf6cc_origin;
	struct sockaddr_in6 mf6cc_mcastgrp;
	mifi_t mf6cc_parent;
	struct if_set mf6cc_ifset;
};

struct sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_mif_req6 {
	mifi_t mifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct mrt6msg {
	__u8 im6_mbz;
	__u8 im6_msgtype;
	__u16 im6_mif;
	__u32 im6_pad;
	struct in6_addr im6_src;
	struct in6_addr im6_dst;
};

enum {
	IP6MRA_CREPORT_UNSPEC = 0,
	IP6MRA_CREPORT_MSGTYPE = 1,
	IP6MRA_CREPORT_MIF_ID = 2,
	IP6MRA_CREPORT_SRC_ADDR = 3,
	IP6MRA_CREPORT_DST_ADDR = 4,
	IP6MRA_CREPORT_PKT = 5,
	__IP6MRA_CREPORT_MAX = 6,
};

struct mfc6_cache_cmp_arg {
	struct in6_addr mf6c_mcastgrp;
	struct in6_addr mf6c_origin;
};

struct mfc6_cache {
	struct mr_mfc _c;
	union {
		struct {
			struct in6_addr mf6c_mcastgrp;
			struct in6_addr mf6c_origin;
		};
		struct mfc6_cache_cmp_arg cmparg;
	};
};

struct ip6mr_result {
	struct mr_table *mrt;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 vlan_filtered: 1;
	u8 br_netfilter_broute: 1;
	u8 tx_fwd_offload: 1;
	int src_hwdom;
	long unsigned int fwd_hwdoms;
};

struct nf_bridge_frag_data;

struct fib6_rule {
	struct fib_rule common;
	struct rt6key src;
	struct rt6key dst;
	u8 tclass;
};

enum {
	SEG6_IPTUNNEL_UNSPEC = 0,
	SEG6_IPTUNNEL_SRH = 1,
	__SEG6_IPTUNNEL_MAX = 2,
};

struct seg6_iptunnel_encap {
	int mode;
	struct ipv6_sr_hdr srh[0];
};

enum {
	SEG6_IPTUN_MODE_INLINE = 0,
	SEG6_IPTUN_MODE_ENCAP = 1,
	SEG6_IPTUN_MODE_L2ENCAP = 2,
};

struct seg6_lwt {
	struct dst_cache cache;
	struct seg6_iptunnel_encap tuninfo[0];
};

enum l3mdev_type {
	L3MDEV_TYPE_UNSPEC = 0,
	L3MDEV_TYPE_VRF = 1,
	__L3MDEV_TYPE_MAX = 2,
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

enum {
	SEG6_LOCAL_UNSPEC = 0,
	SEG6_LOCAL_ACTION = 1,
	SEG6_LOCAL_SRH = 2,
	SEG6_LOCAL_TABLE = 3,
	SEG6_LOCAL_NH4 = 4,
	SEG6_LOCAL_NH6 = 5,
	SEG6_LOCAL_IIF = 6,
	SEG6_LOCAL_OIF = 7,
	SEG6_LOCAL_BPF = 8,
	SEG6_LOCAL_VRFTABLE = 9,
	SEG6_LOCAL_COUNTERS = 10,
	__SEG6_LOCAL_MAX = 11,
};

enum {
	SEG6_LOCAL_BPF_PROG_UNSPEC = 0,
	SEG6_LOCAL_BPF_PROG = 1,
	SEG6_LOCAL_BPF_PROG_NAME = 2,
	__SEG6_LOCAL_BPF_PROG_MAX = 3,
};

enum {
	SEG6_LOCAL_CNT_UNSPEC = 0,
	SEG6_LOCAL_CNT_PAD = 1,
	SEG6_LOCAL_CNT_PACKETS = 2,
	SEG6_LOCAL_CNT_BYTES = 3,
	SEG6_LOCAL_CNT_ERRORS = 4,
	__SEG6_LOCAL_CNT_MAX = 5,
};

struct seg6_local_lwt;

struct seg6_local_lwtunnel_ops {
	int (*build_state)(struct seg6_local_lwt *, const void *, struct netlink_ext_ack *);
	void (*destroy_state)(struct seg6_local_lwt *);
};

struct bpf_lwt_prog {
	struct bpf_prog *prog;
	char *name;
};

enum seg6_end_dt_mode {
	DT_INVALID_MODE = 4294967274,
	DT_LEGACY_MODE = 0,
	DT_VRF_MODE = 1,
};

struct seg6_end_dt_info {
	enum seg6_end_dt_mode mode;
	struct net *net;
	int vrf_ifindex;
	int vrf_table;
	u16 family;
};

struct pcpu_seg6_local_counters;

struct seg6_action_desc;

struct seg6_local_lwt {
	int action;
	struct ipv6_sr_hdr *srh;
	int table;
	struct in_addr nh4;
	struct in6_addr nh6;
	int iif;
	int oif;
	struct bpf_lwt_prog bpf;
	struct seg6_end_dt_info dt_info;
	struct pcpu_seg6_local_counters *pcpu_counters;
	int headroom;
	struct seg6_action_desc *desc;
	long unsigned int parsed_optattrs;
};

struct seg6_action_desc {
	int action;
	long unsigned int attrs;
	long unsigned int optattrs;
	int (*input)(struct sk_buff *, struct seg6_local_lwt *);
	int static_headroom;
	struct seg6_local_lwtunnel_ops slwt_ops;
};

struct pcpu_seg6_local_counters {
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t errors;
	struct u64_stats_sync syncp;
};

struct seg6_local_counters {
	__u64 packets;
	__u64 bytes;
	__u64 errors;
};

struct seg6_action_param {
	int (*parse)(struct nlattr **, struct seg6_local_lwt *);
	int (*put)(struct sk_buff *, struct seg6_local_lwt *);
	int (*cmp)(struct seg6_local_lwt *, struct seg6_local_lwt *);
	void (*destroy)(struct seg6_local_lwt *);
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	struct packet_type prot_hook;
	struct sock *arr[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	long unsigned int flags;
	unsigned int running;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	unsigned int pkt_type;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum packet_sock_flags {
	PACKET_SOCK_ORIGDEV = 0,
	PACKET_SOCK_AUXDATA = 1,
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct packet_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 pdiag_ino;
	__u32 pdiag_show;
	__u32 pdiag_cookie[2];
};

struct packet_diag_msg {
	__u8 pdiag_family;
	__u8 pdiag_type;
	__u16 pdiag_num;
	__u32 pdiag_ino;
	__u32 pdiag_cookie[2];
};

enum {
	PACKET_DIAG_INFO = 0,
	PACKET_DIAG_MCLIST = 1,
	PACKET_DIAG_RX_RING = 2,
	PACKET_DIAG_TX_RING = 3,
	PACKET_DIAG_FANOUT = 4,
	PACKET_DIAG_UID = 5,
	PACKET_DIAG_MEMINFO = 6,
	PACKET_DIAG_FILTER = 7,
	__PACKET_DIAG_MAX = 8,
};

struct packet_diag_info {
	__u32 pdi_index;
	__u32 pdi_version;
	__u32 pdi_reserve;
	__u32 pdi_copy_thresh;
	__u32 pdi_tstamp;
	__u32 pdi_flags;
};

struct packet_diag_mclist {
	__u32 pdmc_index;
	__u32 pdmc_count;
	__u16 pdmc_type;
	__u16 pdmc_alen;
	__u8 pdmc_addr[32];
};

struct packet_diag_ring {
	__u32 pdr_block_size;
	__u32 pdr_block_nr;
	__u32 pdr_frame_size;
	__u32 pdr_frame_nr;
	__u32 pdr_retire_tmo;
	__u32 pdr_sizeof_priv;
	__u32 pdr_features;
};

struct switchdev_brport {
	struct net_device *dev;
	const void *ctx;
	struct notifier_block *atomic_nb;
	struct notifier_block *blocking_nb;
	bool tx_fwd_offload;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
	SWITCHDEV_BRPORT_OFFLOADED = 15,
	SWITCHDEV_BRPORT_UNOFFLOADED = 16,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
	const void *ctx;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 is_local: 1;
	u8 offloaded: 1;
};

struct switchdev_notifier_brport_info {
	struct switchdev_notifier_info info;
	const struct switchdev_brport brport;
};

enum br_boolopt_id {
	BR_BOOLOPT_NO_LL_LEARN = 0,
	BR_BOOLOPT_MCAST_VLAN_SNOOPING = 1,
	BR_BOOLOPT_MAX = 2,
};

struct br_boolopt_multi {
	__u32 optval;
	__u32 optmask;
};

enum net_bridge_opts {
	BROPT_VLAN_ENABLED = 0,
	BROPT_VLAN_STATS_ENABLED = 1,
	BROPT_NF_CALL_IPTABLES = 2,
	BROPT_NF_CALL_IP6TABLES = 3,
	BROPT_NF_CALL_ARPTABLES = 4,
	BROPT_GROUP_ADDR_SET = 5,
	BROPT_MULTICAST_ENABLED = 6,
	BROPT_MULTICAST_QUERY_USE_IFADDR = 7,
	BROPT_MULTICAST_STATS_ENABLED = 8,
	BROPT_HAS_IPV6_ADDR = 9,
	BROPT_NEIGH_SUPPRESS_ENABLED = 10,
	BROPT_MTU_SET_BY_USER = 11,
	BROPT_VLAN_STATS_PER_PORT = 12,
	BROPT_NO_LL_LEARN = 13,
	BROPT_VLAN_BRIDGE_BINDING = 14,
	BROPT_MCAST_VLAN_SNOOPING_ENABLED = 15,
};

struct net_bridge_mcast_gc {
	struct hlist_node gc_node;
	void (*destroy)(struct net_bridge_mcast_gc *);
};

struct net_bridge_port_group_sg_key {
	struct net_bridge_port *port;
	struct br_ip addr;
};

struct net_bridge_port_group {
	struct net_bridge_port_group *next;
	struct net_bridge_port_group_sg_key key;
	unsigned char eth_addr[6];
	unsigned char flags;
	unsigned char filter_mode;
	unsigned char grp_query_rexmit_cnt;
	unsigned char rt_protocol;
	struct hlist_head src_list;
	unsigned int src_ents;
	struct timer_list timer;
	struct timer_list rexmit_timer;
	struct hlist_node mglist;
	struct rb_root eht_set_tree;
	struct rb_root eht_host_tree;
	struct rhash_head rhnode;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct net_bridge_mdb_entry {
	struct rhash_head rhnode;
	struct net_bridge *br;
	struct net_bridge_port_group *ports;
	struct br_ip addr;
	bool host_joined;
	struct timer_list timer;
	struct hlist_node mdb_node;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

enum br_pkt_type {
	BR_PKT_UNICAST = 0,
	BR_PKT_MULTICAST = 1,
	BR_PKT_BROADCAST = 2,
};

struct nf_br_ops {
	int (*br_dev_xmit_hook)(struct sk_buff *);
};

enum {
	FDB_NOTIFY_BIT = 1,
	FDB_NOTIFY_INACTIVE_BIT = 2,
};

enum {
	NFEA_UNSPEC = 0,
	NFEA_ACTIVITY_NOTIFY = 1,
	NFEA_DONT_REFRESH = 2,
	__NFEA_MAX = 3,
};

struct __fdb_entry {
	__u8 mac_addr[6];
	__u8 port_no;
	__u8 is_local;
	__u32 ageing_timer_value;
	__u8 port_hi;
	__u8 pad0;
	__u16 unused;
};

enum {
	BR_FDB_LOCAL = 0,
	BR_FDB_STATIC = 1,
	BR_FDB_STICKY = 2,
	BR_FDB_ADDED_BY_USER = 3,
	BR_FDB_ADDED_BY_EXT_LEARN = 4,
	BR_FDB_OFFLOADED = 5,
	BR_FDB_NOTIFY = 6,
	BR_FDB_NOTIFY_INACTIVE = 7,
};

enum {
	MDB_RTR_TYPE_DISABLED = 0,
	MDB_RTR_TYPE_TEMP_QUERY = 1,
	MDB_RTR_TYPE_PERM = 2,
	MDB_RTR_TYPE_TEMP = 3,
};

struct br_frame_type {
	__be16 type;
	int (*frame_handler)(struct net_bridge_port *, struct sk_buff *);
	struct hlist_node list;
};

struct __bridge_info {
	__u64 designated_root;
	__u64 bridge_id;
	__u32 root_path_cost;
	__u32 max_age;
	__u32 hello_time;
	__u32 forward_delay;
	__u32 bridge_max_age;
	__u32 bridge_hello_time;
	__u32 bridge_forward_delay;
	__u8 topology_change;
	__u8 topology_change_detected;
	__u8 root_port;
	__u8 stp_enabled;
	__u32 ageing_time;
	__u32 gc_interval;
	__u32 hello_timer_value;
	__u32 tcn_timer_value;
	__u32 topology_change_timer_value;
	__u32 gc_timer_value;
};

struct __port_info {
	__u64 designated_root;
	__u64 designated_bridge;
	__u16 port_id;
	__u16 designated_port;
	__u32 path_cost;
	__u32 designated_cost;
	__u8 state;
	__u8 top_change_ack;
	__u8 config_pending;
	__u8 unused0;
	__u32 message_age_timer_value;
	__u32 forward_delay_timer_value;
	__u32 hold_timer_value;
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 2,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 4,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 8,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 9,
	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE = 10,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		struct switchdev_brport_flags brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		u16 vlan_protocol;
		bool mc_disabled;
		u8 mrp_port_role;
	} u;
};

struct br_config_bpdu {
	unsigned int topology_change: 1;
	unsigned int topology_change_ack: 1;
	bridge_id root;
	int root_path_cost;
	bridge_id bridge_id;
	port_id port_id;
	int message_age;
	int max_age;
	int hello_time;
	int forward_delay;
};

enum {
	IFLA_BR_UNSPEC = 0,
	IFLA_BR_FORWARD_DELAY = 1,
	IFLA_BR_HELLO_TIME = 2,
	IFLA_BR_MAX_AGE = 3,
	IFLA_BR_AGEING_TIME = 4,
	IFLA_BR_STP_STATE = 5,
	IFLA_BR_PRIORITY = 6,
	IFLA_BR_VLAN_FILTERING = 7,
	IFLA_BR_VLAN_PROTOCOL = 8,
	IFLA_BR_GROUP_FWD_MASK = 9,
	IFLA_BR_ROOT_ID = 10,
	IFLA_BR_BRIDGE_ID = 11,
	IFLA_BR_ROOT_PORT = 12,
	IFLA_BR_ROOT_PATH_COST = 13,
	IFLA_BR_TOPOLOGY_CHANGE = 14,
	IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
	IFLA_BR_HELLO_TIMER = 16,
	IFLA_BR_TCN_TIMER = 17,
	IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
	IFLA_BR_GC_TIMER = 19,
	IFLA_BR_GROUP_ADDR = 20,
	IFLA_BR_FDB_FLUSH = 21,
	IFLA_BR_MCAST_ROUTER = 22,
	IFLA_BR_MCAST_SNOOPING = 23,
	IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
	IFLA_BR_MCAST_QUERIER = 25,
	IFLA_BR_MCAST_HASH_ELASTICITY = 26,
	IFLA_BR_MCAST_HASH_MAX = 27,
	IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
	IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
	IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
	IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
	IFLA_BR_MCAST_QUERIER_INTVL = 32,
	IFLA_BR_MCAST_QUERY_INTVL = 33,
	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
	IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
	IFLA_BR_NF_CALL_IPTABLES = 36,
	IFLA_BR_NF_CALL_IP6TABLES = 37,
	IFLA_BR_NF_CALL_ARPTABLES = 38,
	IFLA_BR_VLAN_DEFAULT_PVID = 39,
	IFLA_BR_PAD = 40,
	IFLA_BR_VLAN_STATS_ENABLED = 41,
	IFLA_BR_MCAST_STATS_ENABLED = 42,
	IFLA_BR_MCAST_IGMP_VERSION = 43,
	IFLA_BR_MCAST_MLD_VERSION = 44,
	IFLA_BR_VLAN_STATS_PER_PORT = 45,
	IFLA_BR_MULTI_BOOLOPT = 46,
	IFLA_BR_MCAST_QUERIER_STATE = 47,
	__IFLA_BR_MAX = 48,
};

enum {
	LINK_XSTATS_TYPE_UNSPEC = 0,
	LINK_XSTATS_TYPE_BRIDGE = 1,
	LINK_XSTATS_TYPE_BOND = 2,
	__LINK_XSTATS_TYPE_MAX = 3,
};

struct bridge_vlan_info {
	__u16 flags;
	__u16 vid;
};

struct bridge_vlan_xstats {
	__u64 rx_bytes;
	__u64 rx_packets;
	__u64 tx_bytes;
	__u64 tx_packets;
	__u16 vid;
	__u16 flags;
	__u32 pad2;
};

enum {
	BRIDGE_XSTATS_UNSPEC = 0,
	BRIDGE_XSTATS_VLAN = 1,
	BRIDGE_XSTATS_MCAST = 2,
	BRIDGE_XSTATS_PAD = 3,
	BRIDGE_XSTATS_STP = 4,
	__BRIDGE_XSTATS_MAX = 5,
};

enum {
	BR_GROUPFWD_STP = 1,
	BR_GROUPFWD_MACPAUSE = 2,
	BR_GROUPFWD_LACP = 4,
};

struct vtunnel_info {
	u32 tunid;
	u16 vid;
	u16 flags;
};

enum {
	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC = 0,
	IFLA_BRIDGE_VLAN_TUNNEL_ID = 1,
	IFLA_BRIDGE_VLAN_TUNNEL_VID = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS = 3,
	__IFLA_BRIDGE_VLAN_TUNNEL_MAX = 4,
};

struct brport_attribute {
	struct attribute attr;
	ssize_t (*show)(struct net_bridge_port *, char *);
	int (*store)(struct net_bridge_port *, long unsigned int);
	int (*store_raw)(struct net_bridge_port *, char *);
};

struct pimhdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
};

enum {
	BRIDGE_QUERIER_UNSPEC = 0,
	BRIDGE_QUERIER_IP_ADDRESS = 1,
	BRIDGE_QUERIER_IP_PORT = 2,
	BRIDGE_QUERIER_IP_OTHER_TIMER = 3,
	BRIDGE_QUERIER_PAD = 4,
	BRIDGE_QUERIER_IPV6_ADDRESS = 5,
	BRIDGE_QUERIER_IPV6_PORT = 6,
	BRIDGE_QUERIER_IPV6_OTHER_TIMER = 7,
	__BRIDGE_QUERIER_MAX = 8,
};

struct br_ip_list {
	struct list_head list;
	struct br_ip addr;
};

enum {
	BR_VLFLAG_PER_PORT_STATS = 1,
	BR_VLFLAG_ADDED_BY_SWITCHDEV = 2,
	BR_VLFLAG_MCAST_ENABLED = 4,
	BR_VLFLAG_GLOBAL_MCAST_ENABLED = 8,
};

struct net_bridge_group_src {
	struct hlist_node node;
	struct br_ip addr;
	struct net_bridge_port_group *pg;
	u8 flags;
	u8 src_query_rexmit_cnt;
	struct timer_list timer;
	struct net_bridge *br;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct switchdev_notifier_port_obj_info {
	struct switchdev_notifier_info info;
	const struct switchdev_obj *obj;
	bool handled;
};

enum {
	MDBA_UNSPEC = 0,
	MDBA_MDB = 1,
	MDBA_ROUTER = 2,
	__MDBA_MAX = 3,
};

enum {
	MDBA_MDB_UNSPEC = 0,
	MDBA_MDB_ENTRY = 1,
	__MDBA_MDB_MAX = 2,
};

enum {
	MDBA_MDB_ENTRY_UNSPEC = 0,
	MDBA_MDB_ENTRY_INFO = 1,
	__MDBA_MDB_ENTRY_MAX = 2,
};

enum {
	MDBA_MDB_EATTR_UNSPEC = 0,
	MDBA_MDB_EATTR_TIMER = 1,
	MDBA_MDB_EATTR_SRC_LIST = 2,
	MDBA_MDB_EATTR_GROUP_MODE = 3,
	MDBA_MDB_EATTR_SOURCE = 4,
	MDBA_MDB_EATTR_RTPROT = 5,
	__MDBA_MDB_EATTR_MAX = 6,
};

enum {
	MDBA_MDB_SRCLIST_UNSPEC = 0,
	MDBA_MDB_SRCLIST_ENTRY = 1,
	__MDBA_MDB_SRCLIST_MAX = 2,
};

enum {
	MDBA_MDB_SRCATTR_UNSPEC = 0,
	MDBA_MDB_SRCATTR_ADDRESS = 1,
	MDBA_MDB_SRCATTR_TIMER = 2,
	__MDBA_MDB_SRCATTR_MAX = 3,
};

enum {
	MDBA_ROUTER_UNSPEC = 0,
	MDBA_ROUTER_PORT = 1,
	__MDBA_ROUTER_MAX = 2,
};

enum {
	MDBA_ROUTER_PATTR_UNSPEC = 0,
	MDBA_ROUTER_PATTR_TIMER = 1,
	MDBA_ROUTER_PATTR_TYPE = 2,
	MDBA_ROUTER_PATTR_INET_TIMER = 3,
	MDBA_ROUTER_PATTR_INET6_TIMER = 4,
	MDBA_ROUTER_PATTR_VID = 5,
	__MDBA_ROUTER_PATTR_MAX = 6,
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
			unsigned char mac_addr[6];
		} u;
		__be16 proto;
	} addr;
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	MDBA_SET_ENTRY_ATTRS = 2,
	__MDBA_SET_ENTRY_MAX = 3,
};

enum {
	MDBE_ATTR_UNSPEC = 0,
	MDBE_ATTR_SOURCE = 1,
	__MDBE_ATTR_MAX = 2,
};

struct br_mdb_complete_info {
	struct net_bridge_port *port;
	struct br_ip ip;
};

union net_bridge_eht_addr {
	__be32 ip4;
	struct in6_addr ip6;
};

struct net_bridge_group_eht_host {
	struct rb_node rb_node;
	union net_bridge_eht_addr h_addr;
	struct hlist_head set_entries;
	unsigned int num_entries;
	unsigned char filter_mode;
	struct net_bridge_port_group *pg;
};

struct net_bridge_group_eht_set;

struct net_bridge_group_eht_set_entry {
	struct rb_node rb_node;
	struct hlist_node host_list;
	union net_bridge_eht_addr h_addr;
	struct timer_list timer;
	struct net_bridge *br;
	struct net_bridge_group_eht_set *eht_set;
	struct net_bridge_group_eht_host *h_parent;
	struct net_bridge_mcast_gc mcast_gc;
};

struct net_bridge_group_eht_set {
	struct rb_node rb_node;
	union net_bridge_eht_addr src_addr;
	struct rb_root entry_tree;
	struct timer_list timer;
	struct net_bridge_port_group *pg;
	struct net_bridge *br;
	struct net_bridge_mcast_gc mcast_gc;
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats *vlan_pcpu_stats;
};

struct br_vlan_msg {
	__u8 family;
	__u8 reserved1;
	__u16 reserved2;
	__u32 ifindex;
};

enum {
	BRIDGE_VLANDB_DUMP_UNSPEC = 0,
	BRIDGE_VLANDB_DUMP_FLAGS = 1,
	__BRIDGE_VLANDB_DUMP_MAX = 2,
};

enum {
	BRIDGE_VLANDB_UNSPEC = 0,
	BRIDGE_VLANDB_ENTRY = 1,
	BRIDGE_VLANDB_GLOBAL_OPTIONS = 2,
	__BRIDGE_VLANDB_MAX = 3,
};

enum {
	BRIDGE_VLANDB_ENTRY_UNSPEC = 0,
	BRIDGE_VLANDB_ENTRY_INFO = 1,
	BRIDGE_VLANDB_ENTRY_RANGE = 2,
	BRIDGE_VLANDB_ENTRY_STATE = 3,
	BRIDGE_VLANDB_ENTRY_TUNNEL_INFO = 4,
	BRIDGE_VLANDB_ENTRY_STATS = 5,
	BRIDGE_VLANDB_ENTRY_MCAST_ROUTER = 6,
	__BRIDGE_VLANDB_ENTRY_MAX = 7,
};

enum {
	BRIDGE_VLANDB_STATS_UNSPEC = 0,
	BRIDGE_VLANDB_STATS_RX_BYTES = 1,
	BRIDGE_VLANDB_STATS_RX_PACKETS = 2,
	BRIDGE_VLANDB_STATS_TX_BYTES = 3,
	BRIDGE_VLANDB_STATS_TX_PACKETS = 4,
	BRIDGE_VLANDB_STATS_PAD = 5,
	__BRIDGE_VLANDB_STATS_MAX = 6,
};

struct br_vlan_bind_walk_data {
	u16 vid;
	struct net_device *result;
};

struct br_vlan_link_state_walk_data {
	struct net_bridge *br;
};

enum {
	BRIDGE_VLANDB_TINFO_UNSPEC = 0,
	BRIDGE_VLANDB_TINFO_ID = 1,
	BRIDGE_VLANDB_TINFO_CMD = 2,
	__BRIDGE_VLANDB_TINFO_MAX = 3,
};

enum {
	BRIDGE_VLANDB_GOPTS_UNSPEC = 0,
	BRIDGE_VLANDB_GOPTS_ID = 1,
	BRIDGE_VLANDB_GOPTS_RANGE = 2,
	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING = 3,
	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION = 4,
	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION = 5,
	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT = 6,
	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT = 7,
	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL = 8,
	BRIDGE_VLANDB_GOPTS_PAD = 9,
	BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL = 10,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL = 11,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL = 12,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL = 13,
	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL = 14,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER = 15,
	BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS = 16,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE = 17,
	__BRIDGE_VLANDB_GOPTS_MAX = 18,
};

struct switchdev_notifier_port_attr_info {
	struct switchdev_notifier_info info;
	const struct switchdev_attr *attr;
	bool handled;
};

struct dsa_devlink_priv {
	struct dsa_switch *ds;
};

struct dsa_tag_driver {
	const struct dsa_device_ops *ops;
	struct list_head list;
	struct module *owner;
};

struct dsa_slave_priv {
	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
	struct gro_cells gcells;
	struct dsa_port *dp;
	struct list_head mall_tc_list;
};

struct dsa_mac_addr {
	unsigned char addr[6];
	u16 vid;
	refcount_t refcount;
	struct list_head list;
};

enum {
	DSA_NOTIFIER_AGEING_TIME = 0,
	DSA_NOTIFIER_BRIDGE_JOIN = 1,
	DSA_NOTIFIER_BRIDGE_LEAVE = 2,
	DSA_NOTIFIER_FDB_ADD = 3,
	DSA_NOTIFIER_FDB_DEL = 4,
	DSA_NOTIFIER_HOST_FDB_ADD = 5,
	DSA_NOTIFIER_HOST_FDB_DEL = 6,
	DSA_NOTIFIER_HSR_JOIN = 7,
	DSA_NOTIFIER_HSR_LEAVE = 8,
	DSA_NOTIFIER_LAG_CHANGE = 9,
	DSA_NOTIFIER_LAG_JOIN = 10,
	DSA_NOTIFIER_LAG_LEAVE = 11,
	DSA_NOTIFIER_MDB_ADD = 12,
	DSA_NOTIFIER_MDB_DEL = 13,
	DSA_NOTIFIER_HOST_MDB_ADD = 14,
	DSA_NOTIFIER_HOST_MDB_DEL = 15,
	DSA_NOTIFIER_VLAN_ADD = 16,
	DSA_NOTIFIER_VLAN_DEL = 17,
	DSA_NOTIFIER_MTU = 18,
	DSA_NOTIFIER_TAG_PROTO = 19,
	DSA_NOTIFIER_TAG_PROTO_CONNECT = 20,
	DSA_NOTIFIER_TAG_PROTO_DISCONNECT = 21,
	DSA_NOTIFIER_MRP_ADD = 22,
	DSA_NOTIFIER_MRP_DEL = 23,
	DSA_NOTIFIER_MRP_ADD_RING_ROLE = 24,
	DSA_NOTIFIER_MRP_DEL_RING_ROLE = 25,
	DSA_NOTIFIER_TAG_8021Q_VLAN_ADD = 26,
	DSA_NOTIFIER_TAG_8021Q_VLAN_DEL = 27,
	DSA_NOTIFIER_MASTER_STATE_CHANGE = 28,
};

struct dsa_notifier_tag_proto_info {
	const struct dsa_device_ops *tag_ops;
};

struct dsa_notifier_master_state_info {
	const struct net_device *master;
	bool operational;
};

struct dsa_notifier_ageing_time_info {
	unsigned int ageing_time;
};

struct dsa_notifier_bridge_info {
	struct net_device *br;
	int tree_index;
	int sw_index;
	int port;
};

struct dsa_notifier_fdb_info {
	int sw_index;
	int port;
	const unsigned char *addr;
	u16 vid;
};

struct dsa_notifier_mdb_info {
	const struct switchdev_obj_port_mdb *mdb;
	int sw_index;
	int port;
};

struct dsa_notifier_lag_info {
	struct net_device *lag;
	int sw_index;
	int port;
	struct netdev_lag_upper_info *info;
};

struct dsa_notifier_vlan_info {
	const struct switchdev_obj_port_vlan *vlan;
	int sw_index;
	int port;
	struct netlink_ext_ack *extack;
};

struct dsa_notifier_mtu_info {
	bool targeted_match;
	int sw_index;
	int port;
	int mtu;
};

struct dsa_notifier_mrp_info {
	const struct switchdev_obj_mrp *mrp;
	int sw_index;
	int port;
};

struct dsa_notifier_mrp_ring_role_info {
	const struct switchdev_obj_ring_role_mrp *mrp;
	int sw_index;
	int port;
};

struct dsa_notifier_tag_8021q_vlan_info {
	int tree_index;
	int sw_index;
	int port;
	u16 vid;
};

struct dsa_notifier_hsr_info {
	struct net_device *hsr;
	int sw_index;
	int port;
};

enum tc_matchall_command {
	TC_CLSMATCHALL_REPLACE = 0,
	TC_CLSMATCHALL_DESTROY = 1,
	TC_CLSMATCHALL_STATS = 2,
};

struct tc_cls_matchall_offload {
	struct flow_cls_common_offload common;
	enum tc_matchall_command command;
	struct flow_rule *rule;
	struct flow_stats stats;
	long unsigned int cookie;
};

enum dsa_port_mall_action_type {
	DSA_PORT_MALL_MIRROR = 0,
	DSA_PORT_MALL_POLICER = 1,
};

struct dsa_mall_tc_entry {
	struct list_head list;
	long unsigned int cookie;
	enum dsa_port_mall_action_type type;
	union {
		struct dsa_mall_mirror_tc_entry mirror;
		struct dsa_mall_policer_tc_entry policer;
	};
};

struct dsa_switchdev_event_work {
	struct dsa_switch *ds;
	int port;
	struct net_device *dev;
	struct work_struct work;
	long unsigned int event;
	unsigned char addr[6];
	u16 vid;
	bool host_addr;
};

struct dsa_slave_dump_ctx {
	struct net_device *dev;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	int idx;
};

struct dsa_hw_port {
	struct list_head list;
	struct net_device *dev;
	int old_mtu;
};

struct dsa_tag_8021q_vlan {
	struct list_head list;
	int port;
	u16 vid;
	refcount_t refcount;
};

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device **vlan_devices_arrays[16];
};

struct vlan_info {
	struct net_device *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

enum vlan_ioctl_cmds {
	ADD_VLAN_CMD = 0,
	DEL_VLAN_CMD = 1,
	SET_VLAN_INGRESS_PRIORITY_CMD = 2,
	SET_VLAN_EGRESS_PRIORITY_CMD = 3,
	GET_VLAN_INGRESS_PRIORITY_CMD = 4,
	GET_VLAN_EGRESS_PRIORITY_CMD = 5,
	SET_VLAN_NAME_TYPE_CMD = 6,
	SET_VLAN_FLAG_CMD = 7,
	GET_VLAN_REALDEV_NAME_CMD = 8,
	GET_VLAN_VID_CMD = 9,
};

enum vlan_name_types {
	VLAN_NAME_TYPE_PLUS_VID = 0,
	VLAN_NAME_TYPE_RAW_PLUS_VID = 1,
	VLAN_NAME_TYPE_PLUS_VID_NO_PAD = 2,
	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD = 3,
	VLAN_NAME_TYPE_HIGHEST = 4,
};

struct vlan_ioctl_args {
	int cmd;
	char device1[24];
	union {
		char device2[24];
		int VID;
		unsigned int skb_priority;
		unsigned int name_type;
		unsigned int bind_type;
		unsigned int flag;
	} u;
	short int vlan_qos;
};

struct vlan_net {
	struct proc_dir_entry *proc_vlan_dir;
	struct proc_dir_entry *proc_vlan_conf;
	short unsigned int name_type;
};

enum {
	IFLA_VLAN_UNSPEC = 0,
	IFLA_VLAN_ID = 1,
	IFLA_VLAN_FLAGS = 2,
	IFLA_VLAN_EGRESS_QOS = 3,
	IFLA_VLAN_INGRESS_QOS = 4,
	IFLA_VLAN_PROTOCOL = 5,
	__IFLA_VLAN_MAX = 6,
};

struct ifla_vlan_flags {
	__u32 flags;
	__u32 mask;
};

enum {
	IFLA_VLAN_QOS_UNSPEC = 0,
	IFLA_VLAN_QOS_MAPPING = 1,
	__IFLA_VLAN_QOS_MAX = 2,
};

struct ifla_vlan_qos_mapping {
	__u32 from;
	__u32 to;
};

enum gvrp_attributes {
	GVRP_ATTR_INVALID = 0,
	GVRP_ATTR_VID = 1,
	__GVRP_ATTR_MAX = 2,
};

enum mvrp_attributes {
	MVRP_ATTR_INVALID = 0,
	MVRP_ATTR_VID = 1,
	__MVRP_ATTR_MAX = 2,
};

typedef void switchdev_deferred_func_t(struct net_device *, const void *);

struct switchdev_deferred_item {
	struct list_head list;
	struct net_device *dev;
	switchdev_deferred_func_t *func;
	long unsigned int data[0];
};

struct switchdev_nested_priv {
	bool (*check_cb)(const struct net_device *);
	bool (*foreign_dev_check_cb)(const struct net_device *, const struct net_device *);
	const struct net_device *dev;
	struct net_device *lower_dev;
};

typedef int (*lookup_by_table_id_t)(struct net *, u32);

struct l3mdev_handler {
	lookup_by_table_id_t dev_lookup;
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
